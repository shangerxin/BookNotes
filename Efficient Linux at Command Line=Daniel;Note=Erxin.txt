Efficient Linux at Command Line=Daniel;Note=Erxin

# Preface 
- The six commands—wc, head, cut, grep, sort, and uniq


    + The wc command prints the number of lines, words, and characters in a file
```   
$ wc --help
Usage: wc [OPTION]... [FILE]...
  or:  wc [OPTION]... --files0-from=F
Print newline, word, and byte counts for each FILE, and a total line if
more than one FILE is specified.  A word is a non-zero-length sequence of
characters delimited by white space.

With no FILE, or when FILE is -, read standard input.

The options below may be used to select which counts are printed, always in
the following order: newline, word, character, byte, maximum line length.
  -c, --bytes            print the byte counts
  -m, --chars            print the character counts
  -l, --lines            print the newline counts
      --files0-from=F    read input from the files specified by
                           NUL-terminated names in file F;
                           If F is - then read names from standard input
  -L, --max-line-length  print the maximum display width
  -w, --words            print the word counts
      --help     display this help and exit
      --version  output version information and exit
```
    

    + The head command prints the first lines of a file.
```
$ head --help
Usage: head [OPTION]... [FILE]...
Print the first 10 lines of each FILE to standard output.
With more than one FILE, precede each with a header giving the file name.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -c, --bytes=[-]NUM       print the first NUM bytes of each file;
                             with the leading '-', print all but the last
                             NUM bytes of each file
  -n, --lines=[-]NUM       print the first NUM lines instead of the first 10;
                             with the leading '-', print all but the last
                             NUM lines of each file
  -q, --quiet, --silent    never print headers giving file names
  -v, --verbose            always print headers giving file names
  -z, --zero-terminated    line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit
```

    + The cut command prints one or more columns from a file.
```
$ cut --help
Usage: cut OPTION... [FILE]...
Print selected parts of lines from each FILE to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --bytes=LIST        select only these bytes
  -c, --characters=LIST   select only these characters
  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter
  -f, --fields=LIST       select only these fields;  also print any line
                            that contains no delimiter character, unless
                            the -s option is specified
  -n                      (ignored)
      --complement        complement the set of selected bytes, characters
                            or fields
  -s, --only-delimited    do not print lines not containing delimiters
      --output-delimiter=STRING  use STRING as the output delimiter
                            the default is to use the input delimiter
  -z, --zero-terminated    line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit

Use one, and only one of -b, -c or -f.  Each LIST is made up of one
range, or many ranges separated by commas.  Selected input is written
in the same order that it is read, and is written exactly once.
Each range is one of:

  N     N'th byte, character or field, counted from 1
  N-    from N'th byte, character or field, to end of line
  N-M   from N'th to M'th (included) byte, character or field
  -M    from first to M'th (included) byte, character or field
  
c option. Print the first three characters from each line of the file, which you can specify either with commas (1,2,3) or as a range (1-3):
```

```
$ cut -c1-3 animals.txt
pyt
sna
alp
```

```
$ grep --help
Usage: grep [OPTION]... PATTERN [FILE]...
Search for PATTERN in each FILE or standard input.
PATTERN is, by default, a basic regular expression (BRE).
Example: grep -i 'hello world' menu.h main.c

Regexp selection and interpretation:
  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)
  -F, --fixed-strings       PATTERN is a set of newline-separated strings
  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)
  -P, --perl-regexp         PATTERN is a Perl regular expression
  -e, --regexp=PATTERN      use PATTERN for matching
  -f, --file=FILE           obtain PATTERN from FILE
  -i, --ignore-case         ignore case distinctions
  -w, --word-regexp         force PATTERN to match only whole words
  -x, --line-regexp         force PATTERN to match only whole lines
  -z, --null-data           a data line ends in 0 byte, not newline

Miscellaneous:
  -s, --no-messages         suppress error messages
  -v, --invert-match        select non-matching lines
  -V, --version             display version information and exit
      --help                display this help text and exit

Output control:
  -m, --max-count=NUM       stop after NUM matches
  -b, --byte-offset         print the byte offset with output lines
  -n, --line-number         print line number with output lines
      --line-buffered       flush output on every line
  -H, --with-filename       print the file name for each match
  -h, --no-filename         suppress the file name prefix on output
      --label=LABEL         use LABEL as the standard input file name prefix
  -o, --only-matching       show only the part of a line matching PATTERN
  -q, --quiet, --silent     suppress all normal output
      --binary-files=TYPE   assume that binary files are TYPE;
                            TYPE is 'binary', 'text', or 'without-match'
  -a, --text                equivalent to --binary-files=text
  -I                        equivalent to --binary-files=without-match
  -d, --directories=ACTION  how to handle directories;
                            ACTION is 'read', 'recurse', or 'skip'
  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;
                            ACTION is 'read' or 'skip'
  -r, --recursive           like --directories=recurse
  -R, --dereference-recursive  likewise, but follow all symlinks
      --include=FILE_PATTERN  search only files that match FILE_PATTERN
      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN
      --exclude-from=FILE   skip files matching any file pattern from FILE
      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.
  -L, --files-without-match  print only names of FILEs containing no match
  -l, --files-with-matches  print only names of FILEs containing matches
  -c, --count               print only a count of matching lines per FILE
  -T, --initial-tab         make tabs line up (if needed)
  -Z, --null                print 0 byte after FILE name

Context control:
  -B, --before-context=NUM  print NUM lines of leading context
  -A, --after-context=NUM   print NUM lines of trailing context
  -C, --context=NUM         print NUM lines of output context
  -NUM                      same as --context=NUM
      --color[=WHEN],
      --colour[=WHEN]       use markers to highlight the matching strings;
                            WHEN is 'always', 'never', or 'auto'
  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)
  -u, --unix-byte-offsets   report offsets as if CRs were not there
                            (MSDOS/Windows)

'egrep' means 'grep -E'.  'fgrep' means 'grep -F'.
Direct invocation as either 'egrep' or 'fgrep' is deprecated.
```


# Introducing the shell 
- evaluating variables 

Variables like USER and HOME are predefined by the shell. Their values are set automatically when you log in

assign its name to a variable:

$ work=$HOME/Projects

$ cd $work
$ pwd
/home/smith/Projects

define an alias called “less” that runs less -c:2

$ alias less="less -c"

- The shell can redirect input and output in the same command:

$ wc < animals.txt > count

- Any changes you make to $HOME/.bashrc do not affect any running shells. You can force a running shell to reread and execute $HOME/.bashrc with either of the following commands:

.bashrc 
```
# Set the search path
PATH=$HOME/bin:/usr/local/bin:/usr/bin:/bin
# Set the shell prompt
PS1='$ '
# Set your preferred text editor
EDITOR=emacs
# Start in my work directory
cd $HOME/Work/Projects
# Define an alias
alias g=grep
# Offer a hearty greeting
echo "Welcome to Linux, friend!"
```


$ source $HOME/.bashrc                 Uses the builtin "source" command
$ . $HOME/.bashrc                      Uses a dot



# Rerunning commands 
-  “Detecting Duplicate Files”:

$ md5sum *.jpg | cut -c1-32 | sort | uniq -c | sort -nr

- history command, which is a shell builtin.

$ history 


maximum is five hundred or whatever number is stored in the shell variable HISTSIZE, which you can change:

$ echo $HISTSIZE
500
$ HISTSIZE=10000

rerun the most recent grep command, run “bang grep”:
$ !grep


surround the string with question marks as well
$ !?grep?
history | grep -w cd


To mitigate this risk, append the modifier :p to print the command from your history but not execute it:
$ !-3:p

before each deletion:
$ alias rm='rm -i'                  Often found in a shell configuration file
$ rm *.txt
/bin/rm: remove regular file 'a.txt'? y

The prompt changes to indicate an incremental search:
(reverse-i-search)`':

desired command. For example, type c:
(reverse-i-search)`': c

- history expansion with carets 

Suppose you’ve mistakenly run the following command by typing jg instead of jpg:

$ md5sum *.jg | cut -c1-32 | sort | uniq -c | sort -nr

just type the old (wrong) text, the new (corrected) text, and a pair of carets (^), like this:

$ ^jg^jpg

- sed or ed to change a source string into a target string:

s/source/target/

recall a command, such as !!. Then add a colon, and end with a sed-style substitution.

replace jg by jpg (first occurrence only), just as caret notation does, run:

$ !!:s/jg/jpg/


most recent command beginning with md5sum, and perform the same replacement of jg by jpg:

$ !md5sum:s/jg/jpg/

- emacs or vim style command line editing 

If you prefer Vim-style editing, run the following command (or add it to your $HOME/.bashrc file and source it):

$ set -o vi

back to Emacs-style editing, run:

$ set -o emacs

Keystrokes for Emacs- or Vim-style editinga
Action	                                                                Emacs	                        Vim
Move forward by one character                                           Ctrl-f                          l
Move backward by one character                                          Ctrl-b                          h
Move forward by one word                                                Meta-f                          w
Move backward by one word                                               Meta-b                          b
Move to beginning of line                                               Ctrl-a                          0
Move to end of line                                                     Ctrl-e                          $
Transpose (swap) two characters                                         Ctrl-t                          xp
Transpose (swap) two words                                              Meta-t                          n/a
Capitalize word (uppercase first letter)                                Meta-c                         n/a
Uppercase to end of word                                                Meta-u                          n/a
Lowercase to end of word                                                Meta-l                          n/a
Change case of the current character                                    n/a                             ~
Insert the next character verbatim, including control characters        Ctrl-v                          Ctrl-v
Delete forward by one character                                         Ctrl-d                          x
Delete backward by one character                                        Backspace or Ctrl-h             X
Cut forward by one word                                                 Meta-d                          dw
Cut backward by one word                                                Meta-Backspace or Ctrl-w        db
Cut from cursor to beginning of line                                    Ctrl-u                          d^
Cut from cursor to end of line                                          Ctrl-k                          D
Delete the entire line                                                  Ctrl-e Ctrl-u                   dd
Paste (yank) the most recently deleted text                             Ctrl-y                          p
Paste (yank) the next deleted text (after a previous yank)              Meta-y                          n/a
Undo the previous editing operation                                     Ctrl-_                          u
Undo all edits made so far                                              Meta-r                          U
Switch from insertion mode to command mode                              n/a                             Escape
Switch from command mode to insertion mode                              n/a                             i
Abort an edit operation in progress                                     Ctrl-g                          n/a
Clear the display                                                       Ctrl-l                        Ctrl-l



# Crusing the filesystem 
- frequently visited directories using aliases or variables 

$ alias work="cd $HOME/Work/Projects/Web/src/include"

$ work=$HOME/Work/Projects/Web/src/include
$ cd $work
$ pwd

- define a quick cd function 
```
# Define the qcd function
qcd () {
  # Accept 1 argument that's a string key, and perform a different
  # "cd" operation for each key.
  case "$1" in
    work)
      cd $HOME/Work/Projects/Web/src/include
      ;;
    recipes)
      cd $HOME/Family/Cooking/Recipes
      ;;
    video)
      cd /data/Arts/Video/Collection
      ;;
    beatles)
      cd $HOME/Music/mp3/Artists/B/Beatles
      ;;
    *)
      # The supplied argument was not one of the supported keys
      echo "qcd: unknown key '$1'"
      return 1
      ;;
  esac
  # Helpfully print the current directory name to indicate where you are
  pwd
}
# Set up tab completion
complete -W "work recipes video beatles" qcd

$ qcd beatles
```

- configure cd search path 

A cd search path works like your command search path, $PATH, but instead of finding commands, it finds subdirectories. Configure it with the shell variable CDPATH, which has the same format as PATH: a list of directories separated by colons. If your CDPATH consists of these four directories

$HOME:$HOME/Projects:$HOME/Family/Memories:/usr/local

$ CDPATH=/usr     Set a CDPATH
$ cd /tmp         No output: CDPATH wasn't consulted
$ cd bin          cd consults CDPATH...
/usr/bin          ...and prints the new working directory

- Returning to Directories Efficiently

Toggle Between Two Directories with “cd -” 

$ pwd
/home/smith/Finances/Bank/Checking/Statements
$ cd /etc
$ cd -
/home/smith/Finances/Bank/Checking/Statements

Toggle Among Many Directories with pushd and popd

    + view dir stacks 
    
dirs command. It does not modify the stack:

$ dirs
/etc/ssl/certs /etc/apache2 /var/www/html ~/Work/Projects/Web/src

print the stack from top to bottom, use the -p option
$ dirs -p
/etc/ssl/certs
/etc/apache2
/var/www/html
~/Work/Projects/Web/src

Just run pushd twice, once with a dash argument and once without:

$ pushd -
~/Work/Projects/Web/src /etc/ssl/certs /var/www/html /etc/apache2
$ pushd
/etc/ssl/certs ~/Work/Projects/Web/src /var/www/html /etc/apache2

Go deeper into the stack
$ pushd +N


# Next level skills 