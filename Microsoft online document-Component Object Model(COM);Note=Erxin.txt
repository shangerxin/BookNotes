Microsoft online document-Component Object Model(COM);Note=Erxin


# The component object model 
- C, Java, and VBScript can be used to create and use COM objects.

- caller can access only the interface member functions. Internal state is unavailable to a caller unless it is exposed in the interface.

- Interfaces are strongly typed. Every interface has its own unique interface identifier, named an IID, globally unique identifier (GUID),

- define a new interface with using the interface definition language (IDL)

- The IDL supplied by Microsoft is based on simple extensions to DCE IDL, an industry standard for Remote Procedure Call (RPC)-based distributed computing

- In addition, interfaces use only single inheritance

- interface implementation In C++, a COM interface is modeled as an abstract base class, a C++ class that contains only pure virtual member functions

- any programming language that supports the concept of function pointers to implement a COM interface

- A COM class is identified by using a unique 128-bit Class ID (CLSID) that associates a class with a particular deployment in the file system, which for Windows is a DLL or EXE. A CLSID is a GUID

- You obtain a new CLSID by using the CoCreateGuid function or by using a COM authoring tool

- The lifetime of a COM object instance is controlled by its reference count

The IUnknown member functions AddRef and Release control the count. 

When the reference count reaches zero, the Release member function may free the instance

- client/server model 

    + client 
The client is responsible for managing the lifetime of the instance by calling its Release function when the client has finished using it.

A COM client is any caller that passes a CLSID to the system to request an instance of a COM object. create an instance is to call the COM function, CoCreateInstance

To create multiple objects based on a single CLSID, call the CoGetClassObject function. 

To connect to an object that is already created and running, call the GetActiveObject function.

    + server 
A server associates a CLSID with a COM class, houses the implementation of the class, implements a class factory for creating instances of the class, and provides for unloading the server.

A COM server is not the same as the COM object that it provides to the system. implementation of the IClassFactory interface. 

Clients can call the CreateInstance method to request a new instance of a COM object, but normally the CreateInstance is encapsulated in the CoCreateInstance

- Service Control Manager, SCM ahndles the client request for an instance of a COM object 

    1. A client requests an interface pointer to a COM object from the COM Library by calling a function such as CoCreateInstance with the CLSID of the COM object
    
    2. The COM Library queries the SCM to find the server that corresponds with the requested CLSID.

    3. The SCM locates the server and requests the creation of the COM object from the class factory that is provided by the server.
    
    4. If successful, the COM Library returns an interface pointer to the client.
    
COM system connects a server object to a client, the client and object communicate directly.

register a COM server with the host system, you can specify different ways for the server to be activated. 

    + In-process: The SCM returns the file path of the DLL that contains the object server implementation. The COM Library loads the DLL and queries it for its class factory interface pointer

    + Local: The SCM starts the local executable which registers a class factory on startup, and its interface pointer is available to the system and clients.

    + Remote: The local SCM acquires a class factory interface pointer from the SCM that is running on a remote computer.

- storage and stream objects, Storage and stream objects are sharable among processes 

    + storage
A storage object is conceptually similar to a directory in a file system. Each storage can contain any number of sub-storage objects and any number of streams. 

Each storage has its own access rights. Through the IStorage interface, you can perform operations such as enumerating, moving, copying, renaming, creating, and deleting elements

https://docs.microsoft.com/en-us/windows/desktop/Stg/storage-object-naming-conventions

    + stream 
    
A stream object contains data and is conceptually similar to a single file in a file system. 
Each stream has access rights and a single seek pointer. Through the IStream interface, you can read, write, seek, and perform other operations on the stream's underlying data

- COM object can read and write itself to persistent storage 

IPersistStorage: The COM object reads and writes its persistent state to a storage object. 

IPersistStream: The COM object reads and writes its persistent state to a stream object.

IPersistFile: The COM object reads and writes its persistent state directly to a file on the underlying system. no semantics for storages and streams 

Streams can remain open for long periods of time without consuming file-system resources. 

- data transfer, Uniform data transfer represents all data transfers by using the IDataObject interface. COM defines two data structures

    + The FORMATETC structure represents a generalized clipboard format
    
    + STGMEDIUM structure represents the transfer medium as a memory handle

The client creates a STGMEDIUM structure and passes it to the GetData method, and the data object returns the data in the provided STGMEDIUM structure

COM handles data-change notifications by using an advise sink object, which implements the IAdviseSink interface.

- remoting, COM enables remote and distributed computation. Interface remoting enables a member function to return an interface pointer to a COM object that is in a different process or on a different host computer. 

client always call an in-process implement. if the COM is in-process the call is direct. if COM is out-of-process or remote, COM provides a proxy to forward the call using remote procedure call(RPC)

a COM object always receives calls from a client through an in-process. if caller is out-of-process or remote. COM provides a stub implementation that receives the remote procedure call from the proxy in the client process.

Marshaling is the procedure for packaging the call stack for transmission from proxy to stub. Unmarshaling is the unpackaging that occurs at the receiving end. 

https://docs.microsoft.com/en-us/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface

customize marshaling 
https://docs.microsoft.com/en-us/windows/win32/com/inter-object-communication

- security, two forms of application security 
    + activation security, specifies how new objects are created, how clients connect to new and existing objects, how certain public services, such as class table and running object table are secured 
    
    applied automatically by the Service Control Manager (SCM). will check against with registry 
    
    https://docs.microsoft.com/en-us/windows/win32/com/activation-security
    + call security, specifies how security operates in an established connection between a client to a COM object 
    
    applied automatically or is enforced by the application.

        * general functions 
        
        https://docs.microsoft.com/en-us/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity
        
        * interfaces on client proxies 
        
        https://docs.microsoft.com/en-us/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity
        
        * server-side functions
        https://docs.microsoft.com/en-us/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity


the client queries the COM object for the IClientSecurity interface, which is implemented locally by the remoting layer

the server may call the CoGetCallContext function to retrieve an IServerSecurity interface, which allows the server to check the client's authentication and to impersonate the client. 

CoInitializeSecurity function to initialize the security layer and set the specified values as the security default. if process does not call, it will be called automatically during marshaled or unmarshaled.

https://docs.microsoft.com/en-us/windows/win32/com/setting-processwide-security-with-coinitializesecurity


## COM objects and interfaces 
### interfaces and interface implementations 
### interface pointers and interfaces 
- An instance of an interface implementation is actually a pointer to an array of pointers to methods 

- a client can call an interface method through its name, not its position in the array. 

- A COM interface is not the same as a C++ class. The pure virtual definition carries no implementation.

- A COM interface is not an object. It is simply a related group of functions and is the binary standard through which clients and objects communicate

- COM interfaces are strongly typed. Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication

- COM interfaces are immutable. You cannot define a new version of an old interface and give it the same identifier. Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.


### IUnknown and interface inheritance 
- Inheritance in COM does not mean code reuse. Because no implementations are associated with interfaces

- a C++ pure-virtual base-class fashion and modified â€” either by adding new methods or by further qualifying the allowed usage of methods. There is no selective inheritance in COM.

- important interface IUnknown, which contains three vital methods: QueryInterface, AddRef, and Release. All COM objects must implement the IUnknown interface

- an object that supports aggregation, you would need to implement one set of IUnknown functions for all interfaces as well as a stand-alone IUnknown interface

- a few interfaces that inherit their definitions from a second interface in addition to IUnknown, the majority simply inherit the IUnknown interface methods. 

- aggregation requires an explicit implementation of IUnknown on the inner object and delegation of the IUnknown methods of any other interface to the outer object's IUnknown methods

    + creating aggregable Objects
    
    The aggregable (or inner) object's implementation of QueryInterface, AddRef, and Release for its IUnknown interface controls the inner object's reference count, and this implementation must not delegate to the outer object's unknown (the controlling IUnknown).
    
    The aggregable (or inner) object's implementation of QueryInterface, AddRef, and Release for its other interfaces must delegate to the controlling IUnknown and must not directly affect the inner object's reference count.
    
    The inner IUnknown must implement QueryInterface only for the inner object
    
    The aggregable object must not call AddRef when holding a reference to the controlling IUnknown pointer

```
// CSomeObject is an aggregable object that implements 
// IUnknown and ISomeInterface 
class CSomeObject : public IUnknown 
{ 
    private: 
        DWORD        m_cRef;         // Object reference count 
        IUnknown*    m_pUnkOuter;    // Controlling IUnknown, no AddRef 
 
        // Nested class to implement the ISomeInterface interface 
        class CImpSomeInterface : public ISomeInterface 
        { 
            friend class CSomeObject ; 
            private: 
                DWORD    m_cRef;    // Interface ref-count, for debugging 
                IUnknown*    m_pUnkOuter;    // Controlling IUnknown 
            public: 
                CImpSomeInterface() { m_cRef = 0;   }; 
                ~ CImpSomeInterface(void) {}; 
 
                // IUnknown members delegate to the outer unknown 
                // IUnknown members do not control lifetime of object 
                STDMETHODIMP     QueryInterface(REFIID riid, void** ppv) 
                {    return m_pUnkOuter->QueryInterface(riid,ppv);   }; 
 
                STDMETHODIMP_(DWORD) AddRef(void) 
                {    return m_pUnkOuter->AddRef();   }; 
 
                STDMETHODIMP_(DWORD) Release(void) 
                {    return m_pUnkOuter->Release();   }; 
 
                // ISomeInterface members 
                STDMETHODIMP SomeMethod(void) 
                {    return S_OK;   }; 
        } ; 
        
        CImpSomeInterface m_ImpSomeInterface ; 
        
    public: 
        CSomeObject(IUnknown * pUnkOuter) 
        { 
            m_cRef=0; 
            // No AddRef necessary if non-NULL as we're aggregated. 
            m_pUnkOuter=pUnkOuter; 
            m_ImpSomeInterface.m_pUnkOuter=pUnkOuter; 
        } ; 
        
        ~CSomeObject(void) {} ; 
 
        // Static member function for creating new instances (don't use 
        // new directly). Protects against outer objects asking for 
        // interfaces other than IUnknown. 
        static HRESULT Create(IUnknown* pUnkOuter, REFIID riid, void **ppv) 
        { 
            CSomeObject*        pObj; 
            if (pUnkOuter != NULL && riid != IID_IUnknown) 
                return CLASS_E_NOAGGREGATION; 
                
            pObj = new CSomeObject(pUnkOuter); 
            if (pObj == NULL) 
                return E_OUTOFMEMORY; 
                
            // Set up the right unknown for delegation (the non-
            // aggregation case) 
            if (pUnkOuter == NULL) 
            {
                pObj->m_pUnkOuter = (IUnknown*)pObj ; 
                pObj->m_ImpSomeInterface.m_pUnkOuter = (IUnknown*)pObj;
            }
            
            HRESULT hr; 
            if (FAILED(hr = pObj->QueryInterface(riid, (void**)ppv))) 
                delete pObj ; 
                
            return hr; 
        } 
 
        // Inner IUnknown members, non-delegating 
        // Inner QueryInterface only controls inner object 
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv) 
        { 
            *ppv=NULL; 
            if (riid == IID_IUnknown) 
                *ppv=this; 
            if (riid == IID_ISomeInterface) 
                *ppv=&m_ImpSomeInterface; 
            if (NULL==*ppv) 
                return ResultFromScode(E_NOINTERFACE); 
            ((IUnknown*)*ppv)->AddRef(); 
            return NOERROR; 
        } ; 
        
        STDMETHODIMP_(DWORD) AddRef(void) 
        {    return ++m_cRef; }; 
        
        STDMETHODIMP_(DWORD) Release(void) 
        { 
            if (--m_cRef != 0) 
                return m_cRef; 
            delete this; 
            return 0; 
        }; 
}; 
```

    + aggregating objects 
    
    creating inner object, the outer object must explicitly ask for its IUnknown
    
    the outer object must protect its implementation of Release from reentrancy with an artificial reference count around its destruction code 
    
    the outer object must call its controlling IUnknown Release method if it queries for a pointer to any of the inner object's interfaces. To free this pointer the outer object calls its controlling IUnknown AddRef method, followed by Release on the inner object's pointer 
    
    The outer object must not blindly delegate a query for any unrecognized interface to the inner object, unless that behavior is specifically the intention of the outer object.
    
```
// Obtaining inner object interface pointer 
pUnkInner->QueryInterface(IID_ISomeInterface, &pISomeInterface); 
pUnkOuter->Release(); 

// Releasing inner object interface pointer 
pUnkOuter->AddRef(); 
pISomeInterface->Release(); 
```

- The most common mechanism for object reuse in COM is containment/delegation. This type of reuse is a familiar concept found in most object-oriented languages and systems


## Using and implementing IUnknown
- client and server

https://docs.microsoft.com/en-us/windows/win32/com/com-clients-and-servers

- processes, threads and apartments 
https://docs.microsoft.com/en-us/windows/win32/com/processes--threads--and-apartments

- QueryInterface, navigating in an object 

QueryInterface to ask an object for an interface through which the client may invoke the desired operations

QueryInterface returns a null pointerâ€”an errorâ€”and the client has no pointer through which to call the desired functions

The technology that supports this is the algorithm by which IIDs are allocated

- rules for implementing QueryInterface 

objects must have identity, a call to QueryInterface with IID_IUnknown must always return the same physical pointer value. 
```
IA * pA = (some function returning an IA *); 
IB * pB = NULL; 
HRESULT   hr; 
hr = pA->QueryInterface(IID_IB, &pB); 

pA->QueryInterface(IID_IA, ...);
pB->QueryInterface(IID_IA, ...);

IC * pC = NULL; 
hr = pB->QueryInterface(IID_IC, &pC); 
pA->QueryInterface(IID_IC, ...) 
```

the set of interfaces on an object instance must be static 

it must be possible to query successful for any interface on an object from any other interface 

the counter should be unsigned integer 


### Managing object lifetimes through reference counting 
- One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared. 

- AddRef increments the object's internal reference count.

- Release first decrements the object's internal reference count, and then it checks whether the reference count has fallen to zero.

-  COM does not require that an object return the same pointer when asked for the same interface multiple times. (The only exception to this is a query to IUnknown, which identifies an object to COM.)

- rules for managing reference counts 

From a COM client's perspective, reference counting is always done for each interface. Client should never assume an object uses the same counter for all interfaces

default case is that AddRef must be called for every new copy of an interface pointer and Release must be called for every destruction of an interface pointer except
    1. In-out parameters to functions. The caller must call AddRef on the parameter because it will be released when the out value is stored on top of it.
    
    2. Fetching a global variable.

    3. A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call AddRef initially on the newly synthesized pointer.

    4. Retrieving a copy of an internally stored pointer. When a function retrieves a copy of a pointer that is stored internally by the object called
    
    5. In parameters to functions. The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value

    6. Out parameters from functions, including return values. the out parameter does not need a separate reference count.

    7. Local variables. A method implementation has control of the lifetimes of each of the pointer . can omit redundant AddRef/Release pairs 


### Reusing objects 
- containment/delegation 
- aggregation 


### The COM library 
- Any process that uses COM must both initialize and uninitialize the COM library.

a set of DLLs and EXEs (primarily Ole32.dll and Rpcss.exe) in Microsoft Windows, the COM library includes

A small number of fundamental functions that facilitate the creation of COM applications, both client and server. 

Implementation-locator services through which COM determines, from a unique class identifier (CLSID)

Transparent remote procedure calls when an object is running in a local or remote server.

A standard mechanism to allow an application to control how memory is allocated within its process, particularly memory that needs to be passed between cooperating objects

- all COM threads of execution in clients and out-of-process servers must call either the CoInitialize or the CoInitializeEx function before calling any other COM function except memory allocation calls

CoInitializeEx replaces the other function, adding a parameter that allows you to specify the threading model of the thread. either apartment-threaded or free-threaded

CoInitialize simply sets the threading model to apartment-threaded.

OLE compound document applications call the OleInitialize function, which calls CoInitializeEx. cannot be free-threaded

In-process servers do not call the initialization functions because they are being loaded into a process. either InprocServer32 
```
Registers a 32-bit in-process server and specifies the threading model of the apartment the server can run in.

HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
   {CLSID}
      InprocServer32
         (Default) = path
         ThreadingModel = value
         
ThreadingModel:
Apartment, single threaded 
Both, single threaded or multithreaded 
Free, multithreaded apartment
Neutral, Neutral apartment
not set to a value, the server is loaded into the first apartment that was initialized in the process. referred to as the main single-threaded apartment (STA)

The InprocServer entry is needed only for backward compatibility. missing then cannot loaded in 16-bit app 
```

client must be a corresponding call to CoUninitialize or OLE client a corresponding call to OleUninitialize.

In-process servers can assume the process already performed these steps 


### Manage memory allocation 
- both caller and called to have a compatible allocation and de-allocation policy. COM defines a universal convention for memory allocation

- OLE memory allocator 

Whenever ownership of an allocated chunk of memory is passed through a COM interface or between a client and the COM library, you must use this COM allocator to allocate the memory, thread-safe allocator

CoGetMalloc provides a pointer to the OLE allocator, which is an implementation of the IMalloc interface

helper functions CoTaskMemAlloc, CoTaskMemRealloc, and CoTaskMemFree, which wrap getting a pointer to the task memory allocator, calling the corresponding IMalloc method 

- memory management rules 

In-parameters must be allocated and freed by the caller

Out-parameters must be allocated by the one called. freed by the caller using the standard COM task memory allocator.

In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called

All out pointer parameters must explicitly be set to NULL. These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.

Under error conditions, all in-out parameters must either be left alone by the code called or explicitly set 

COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers. 
https://docs.microsoft.com/en-us/windows/win32/rpc/server-stub-memory-management

- debugging memory allocations 

COM provides the IMallocSpy interface for developers to use to debug their memory allocations


## Processes, threads, and apartments 
- RPC, There is no difference to the caller between a call coming from a process on a remote machine

- set a process's priority class attribute by calling the SetPriorityClass function

set a thread's base priority with a call to SetThreadPriority.

- the apartment and the COM threading architecture 

multiple threads often causes performance problems. The key is to use multiple threads only if you are very sure of what you are doing

all the COM objects in the process as divided into groups called apartments. 

its methods can legally be directly called only by a thread that belongs to that apartment. other thread need to call must through a proxy 

    + Single-threaded apartments consist of exactly one thread
    
    All method calls to a COM object in a single-threaded apartment are synchronized with the windows message queue for the single-threaded apartment's thread. 
    
    + Multithreaded apartments consist of one or more threads

    an multithreaded apartment can receive method calls directly from any of the threads that belong to the multithreaded apartment. 

    use a model called free-threading, the call is synchronized by the objects themselves.

- A process can have zero or more single-threaded apartments

zero or one multithreaded apartment.

- Call parameters are marshaled between apartments, and COM handles the synchronization through messaging

- multiple threads in a process to be free-threaded, all free threads reside in a single apartment

all other apartments are single-threaded apartments

- all calls to objects outside a process behave identically, arriving calls behave identically too

- single-threaded object is called simultaneously by multiple free-threaded clients, the calls will be synchronized by COM by placing corresponding window messages in the server's message queue


### Choosing the threading model 
- An object that does extensive I/O might support free-threading to provide maximum response to clients by allowing interface calls during I/O latency.

- an object that interacts with the user might support apartment threading to synchronize incoming COM calls with its window operations



### Single threaded apartments 
- Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently

- Calls to objects in other threads must be made within the context of the owning thread

- objects in different processes use to pass pointers across process boundaries. 

The interprocess and interthread models are similar. 

- rules 

Every object should live on only one thread (within a single-threaded apartment).

Initialize the COM library for each thread.

Marshal all pointers to objects when passing them between apartments.

must have a message loop

DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the ThreadingModel named-value under the InprocServer32 key in the registry. 

- multiple objects can live on a single thread, no apartment model object can live on more than one thread.

- a client process or out-of-process server must call CoInitialize, or call CoInitializeEx and specify COINIT_APARTMENTTHREADED for the dwCoInit parameter. 

The main apartment is the thread that calls CoInitializeEx first

- All calls to an object must be made on its thread (within its apartment). It is forbidden to call an object directly from another thread

- The implication of this rule is that all pointers to objects must be marshaled when passed between apartments. 

    + CoMarshalInterThreadInterfaceInStream marshals an interface into a stream object that is returned to the caller.

    + CoGetInterfaceAndReleaseStream unmarshals an interface pointer from a stream object and releases it.
    
these functions wrap calls to CoMarshalInterface and CoUnmarshalInterface functions, which require the use of the MSHCTX_INPROC flag
    
- marshaling is accomplished automatically by COM.

- where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually

- If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call CoMarshalInterThreadInterfaceInStream to marshal the interface. The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2. Apartment 2 must pass this stream to CoGetInterfaceAndReleaseStream to unmarshal the interface and will get back a pointer to a proxy 

- the MsgWaitForMultipleObjects function can be used to wait both for messages and for thread synchronization events.

- COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment. A call to an object is received as a window message to this hidden window. 

- Single-threaded apartments can implement IMessageFilter to permit them to cancel calls or receive window messages when necessary or makes an ORPC call to another thread

- The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread

OLE does not prevent reentrancy on the same thread, but it can help provide thread safety. This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.

calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered. <- DOES THIS WILL CAUSE MESSAGE JAM?


## Multithreaded apartments 
- all the threads in the process that have been initialized as free-threaded reside in a single apartment.

no need to marshal between threads

need not retrieve and dispatch messages because COM does not use window messages

- Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment. 

- best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling

use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores

the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage)

- synchronization for multithreaded apartments 

COM provides call synchronization for single-threaded apartments only

Multithreaded apartments do not receive calls while making calls on the same thread 

Multithreaded apartments cannot make input-synchronized calls

Asynchronous calls are converted to synchronous calls in multithreaded apartments

The message filter is not called for any thread in a multithreaded apartment.

- To initialize a thread as free-threaded, call CoInitializeEx, specifying COINIT_MULTITHREADED

- COM, through the RPC subsystem, creates a pool of threads in the server process and a client call can arraived at any time 

- An out-of-process server must also implement synchronization in its class factory.

- All threads belong to the same multithreaded apartment. Interface pointers are passed directly from thread to thread within a multithreaded apartment

- The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns. 

- Calls between processes are still handled by RPC 

- Window synchronization primitives 

    + Event objects provide a way of signaling one or more threads that an event has occurred. CreateEvent 
    
    https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-createeventa
    
    + Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed. Only used by the threads within a single process. 

    To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL_SECTION data structure and initializes its members

    EnterCriticalSection

    A thread attempting to enter a critical section calls EnterCriticalSection which checks to see whether the CRITICAL_SECTION data structure has been modified.
    
    A thread leaving a critical section calls LeaveCriticalSection, which resets the data structure. the system wakes one of the sleeping threads
    
    + Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes. CreateMutex, ownership passes to other threads on a first-come, first-served basis.
    
    + Semaphores are used to maintain a reference count on some available resource. CreateSemaphore,  an initial resource count, and the maximum resource count. 
    
    A thread requesting a resource passes its semaphore handle in a call to the WaitForSingleObject function.
    
    The semaphore object polls the resource to determine whether it is available. If so, the semaphore decrements the resource count and wakes the waiting thread. zero, the thread remains asleep until another thread releases a resource
    
    
## Single threaded and multithreaded communication 
- one multithreaded apartment, containing all threads initialized as free-threaded, and one or more single-threaded apartments.
    
- Interface pointers must be marshaled between apartments but can be used without marshaling within an apartment. 
    
- Calls to objects in a single-threaded apartment will be synchronized by COM
    
- inter-apartment communication requires  CoMarshalInterThreadInterfaceInStream and CoGetInterfaceAndReleaseStream
    
    
## In-Process Server Threading Issues 
- an in-process server does not call CoInitialize, CoInitializeEx, or OleInitialize to mark its threading model
    
thread-aware DLL-based or in-process objects, you need to set the threading model in the registry
    
add the ThreadingModel value to the InprocServer32 key in the registry. The default value is single-threaded-per-process 

- a client and an in-process object that use different threading models is exactly like the interaction between clients and out-of-process servers. 

- an in-process object that supports the single-threaded model is called simultaneously by multiple threads of a client,
    
COM creates the object in the client's main apartment and requires all the other client apartments to access the object by using proxies
    
- if you design a custom interface on an in-process server, you should also provide the marshaling code for it 
    
- all of the DLL entry points (like DllGetClassObject and DllCanUnloadNow) and global data should always be accessed by the same apartment. such objects in the main apartment of the client, giving the main apartment direct access to the object's pointers.
    
Calls from the other apartments use interthread marshaling to go from the proxy to the stub in the main apartment
    
- a single-threaded in-process server, an object provided by an apartment model DLL must be accessed by the same client apartment from which it was created.
    
objects provided by this server can be created in multiple apartments of the client, so the server must implement its entry points (like DllGetClassObject and DllCanUnloadNow) for multithreaded use
    
- If the DLL provides only one instance of the class factory to create all the objects, the class factory implementation must also be designed for multithreaded use
    
If the DLL creates a new instance of the class factory each time DllGetClassObject is called, the class factory need not be thread-safe.
    
- Objects created by the class factory need not be thread-safe. Once created by a thread, the object is always accessed through that thread. calls to the object will be synchronized by COM 

- in-process DLL ThreadingModel value is set to "Both", an object provided by this DLL can be created and used directly (without a proxy) in single-threaded or multithreaded client apartments. 
    
- CoCreateFreeThreadedMarshaler function. This function creates a free-threaded marshaling object that can be aggregated with an in-process server object. 
    
when the client marshals the object's interface to a different apartment in the same process. The client does not need to do any synchronization. 

- An object provided by an in-process DLL that supports only free threading is a free-threaded object. It implements its own synchronization and can be accessed by multiple client threads at the same time. server does not marshal interfaces between threads. 

single threaded apartments that create it will access it through a proxy 


# Accessing interfaces across apartments 
- any apartment in a process get access to an interface implemented on an object in any other apartment in the process. This is done through the IGlobalInterfaceTable interface. 

    + register an interface as a global processwide interface 
    + get a pointer to that interface from any other aparment through a cookie 
    + revoke the global registration of an interface 

- agile objects (free-threaded, marshaled objects) containing interface pointers to other objects.

- global interface table is good for save process-wide variables and agile objects (free-threaded, marshaled objects). It guaranteeing that a valid proxy or directr pointer to the agile objects. 

- The global interface table is not portable across process or machine boundaries. cannot be used in place of parameter-passing mechanism 



# Greating the global interface table 
- There is a single instance of the global interface table per process
- create the global interface table object 

```
HRESULT hr;
hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_IGlobalInterfaceTable,
                 (void **)&gpGIT);
if (hr != S_OK) {
  exit(0); // Handle errors here.
}
```

- all to the CoCreateInstance function, register the interface from the apartment in which it resides with a call to the RegisterInterfaceInGlobal method

revoke the interface's global registration, any apartment can call the RevokeInterfaceFromGlobal method

- using IGlobalInterfaceTable would be when you want to pass an interface pointer on an object in a single-threaded apartment (STA) to a worker thread in another apartment. Instead of marshal between threads.

IGlobalInterfaceTable allows you simply to pass a cookie. register the interface in the global interface table, you get a cookie that you can use instead of passing the actual pointer. 

- IGlobalInterfaceTable provides complete thread-safe functionality 


# When to use the global interface table 
- CoMarshalInterThreadInterfaceInStream function. It can also be used to pass an interface pointer from one thread to another thread in the same process.

- Simplified the problems 
    + An in-process agile object aggregates the free-threaded marshaler.
    + This same agile object also holds (as member variables) interface pointers to other objects not agile or aggregate the free-threaded marshaler 

if the outer object gets marshaled to another apartment and the application calls on it,. RPC_E_WRONG_THREAD. This error occurs because the inner interface is designed to be callable only from the apartment

the outer object should call IGlobalInterfaceTable::RegisterInterfaceInGlobal on the inner interface and store the resulting cookie in its member instead of pointer

call IGlobalInterfaceTable::GetInterfaceFromGlobal, use the returned interface pointer, and then release it. 

outer object goes away, it should call IGlobalInterfaceTable::RevokeInterfaceFromGlobal to remove itself



## COM clients and servers 
- A COM client is whatever code or object gets a pointer to a COM server and uses its services by calling the methods

- A COM server is any object that provides services to clients; these services are in the form of COM interface implementations

- In-process servers are implemented in a dynamic linked library (DLL)

- out-of-process servers are implemented in an executable file (EXE)

- Distributed COM further allows objects to be packaged as service applications, synchronizing COM with the rich administrative and system-integration of windows 

- DCOM is not separate;it is just COM with a longer wire. I


## Getting a pointer to an object 
- COM does not have a strict class model. four ways that a client can instantiate an interface on an object 

Call a COM library function that creates an object of a predetermined type; return a pointer only one specific interface for a specific object class.

Call a COM library function that can create an object based on a class identifier (CLSID) 

Call a method of some interface that creates another object 

Implement an object with an interface through which other objects pass their interface pointer to the client directly.

- Creating an object of a predetermined type 

 are numerous COM functions, such as CoGetMalloc, that return pointers to specific interface implementations. helper functions 
 
- the function CoGetClassObject, which creates a class object and supplies a pointer to an interface that allows you to create instances of that class

- typical way to create an enumerator instance and get a pointer to its interface is to call a method from another interface



# Creating an object through a class object 
- COM class is identified by a CLSID, a unique 128-bit GUID, which the server must register. 

- all the CLSIDs for the servers installed on the system. This is a mapping between each CLSID and the location of the DLL or EXE that houses the code for that CLSID

- distributed systems, COM provides registry entries that allow a remote server to register itself for use by a client. COM allows clients to override registry entries and to specify server locations

- calls to activation functions other than CoGetClassObject (such as CoCreateInstanceEx) require that the server support IClassFactory.

- create an instance of the server's object, it uses the desired object's CLSID in a call to CoGetClassObject. 

- activating object instances is through the class moniker.  



## Locating a remote object 
- COM has added registry keys that permit a server to register the name of the machine on which it resides or the machine where an existing storage is located.

- COM has replaced a previously reserved parameter of CoGetClassObject with a COSERVERINFO structure, which allows a client to specify the location of a server. 

-  CoGetClassObject function is the CLSCTX enumeration



## Instance creation helper functions 
- the CoCreateInstance function. This function encapsulates the process of creating a class object

- more specific OleCreate, the OLE compound document helper that creates a class object

- four important new instance creation mechanisms 

class monikers and IClassActivator 

CoCreateInstanceEx 

CoGetInstanceFromFile 

CoGetInstanceFromIStorage

-  A class moniker permits you to identify the class of an object

 a file moniker, to indicate the location of the object



## COM server responsibilities 
- server must implementation of either the IClassFactory or IClassFactory2 interface

- must register its CLSID in the system registry on the machine 

- publishing its machine location to other systems on a network to allow clients to call it 

- In-process servers should implement and export certain functions 


### Implementing IClassFactory
- IClassFactory contains two methods 

CreateInstance. This method must create an uninitialized instance of the object and return a pointer to a requested interface on the object

LockServer. This method just increments the reference count on the class object to ensure that the server stays in memory and does not shut down

- responsible for its own licensing, COM defines IClassFactory2, which inherits its definition from IClassFactory. 


### Licensing and IClassFactory2
- The IClassFactory interface on a class object provides the basic object creation mechanism of COM. 

- IClassFactory::CreateInstance method can allow or disallow object creation based on the existence of a machine license

The GetLicInfo method fills a LICINFO structure with information describing the licensing behavior of the class factory

The RequestLicKey method provides a license key for the component

The CreateInstanceLic method creates an instance of the licensed component if the license key parameter (BSTRÃ‚ bstrKey) is valid.

the development tool could create a header (.h) file containing the BSTR license key, and then you would include that .h file in your client application.

create the component with IClassFactory::CreateInstance or pass the run-time key to the CreateInstanceLic method



### Registering COM servers 
-  registering a class at installation 

This information must be registered for all CLSIDs. Other information is optional. Tools such as Regsvr32 make it simple to write a setup program that registers servers at installation.


run at a particular computer whenever an activation function is called for which a COSERVERINFO structure is not specified.

The ActivateAtStorage capability provides a transparent way to allow clients to locate running objects
```
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
   {AppID_GUID}
      RemoteServerName = name
      
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
   {AppID_GUID}
      ActivateAtStorage = value
```

    + two important keys in the registry: the CLSID and the AppID. 

    + can also be installed as a service or run under a specific user account. For more information, see Installing as a Service Application.

https://docs.microsoft.com/en-us/windows/win32/com/installing-as-a-service-application

a server or ROT object that is not a service or running under a specific user account can be referred to as an "activate as activator" server 

    + the security context and the window station/desktop of the client must match the server's. COM clients and servers should not change their window station or thread desktops after calling CoInitialize or CoInitializeEx
    
    +  in-process, a call to CoGetClassObject to create its class object is automatically passed by COM to the DllGetClassObject function
    
    + Classes in executables can specify that COM should execute their process and wait for the process to register their class object's IClassFactory interface through CoRegisterClassObject

- registering a running EXE server 

    + an executable (EXE) server is launched, it should call CoRegisterClassObject, which registers the CLSID for the server in what is called the class table
































