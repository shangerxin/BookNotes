Microsoft online document, overview of window programming in C++;Note=Erxin

# Reference 
https://docs.microsoft.com/en-us/cpp/windows/overview-of-windows-programming-in-cpp?view=msvc-160



# Overview of windows programming in C++ 
- how to use Visual Studio and the MFC/ATL wrapper libraries to create Windows programs.

    + native desktop 
    
    Windows C APIs or Component Object Model (COM) APIs to access the operating system. 

    + C# is less complex, less error-prone, and has a more modern object-oriented API than Win32 or MFC. 
    
    + why to choose c++, we recommend using C++ for desktop applications when you require:

    precise control over memory usage
    the utmost economy in power consumption
    usage of the GPU for general computing
    access to DirectX
    heavy usage of standard C++ libraries
    
    use C++/CLI to enable the application to consume native C++ libraries

    + The Component Object Model (COM) is a specification that enables programs written in different languages to communicate with one another.

    +  Universal Windows Platform (UWP) is the modern Windows API. UWP apps run on any Windows 10 device, use XAML for the user-interface

    + Desktop Bridge

    In Windows 10, you can package your existing desktop application or COM object as a UWP app
    
    + games 
    
    DirectX games can run on the PC or Xbox
    
    https://docs.microsoft.com/en-us/windows/win32/directx
    
    + sql server native client 
    
    + window device drivers 
    
    https://docs.microsoft.com/en-us/windows-hardware/drivers/index
    
    + window services 
    
    A Windows service is a program that can run in the background with little or no user interaction. 
    
    + sdks, libraries and header files 
    
    Visual Studio includes the C Runtime Library (CRT), the C++ Standard Library
    
    these libraries are located in the Visual Studio installation directory under the \VC\ folder

    CRT header files are found in the Windows SDK installation folder.
    
    + vcpkg package manager lets you conveniently install hundreds of third-party open-source libraries 
    
    https://vcpkg.io/

    + microsoft libraries include 
    
    MFC 
    
    ATL 
    
    C++ AMP, accelerated massive paralelism 
    
    concurrency runtime 

    + windows 10 sdk, https://dev.windows.com/downloads/windows-10-sdk
    
    location, Program Files (x86)\Windows Kits is the default location for all versions of the Windows SDK
    
- hilo development introduction 

https://docs.microsoft.com/en-us/previous-versions/msdn10/ff708696(v=msdn.10)
    

# Desktop applications 
- desktop bridge 

Any desktop application in C++ can use C Runtime (CRT) and Standard Library classes and functions, COM objects, and the public Windows functions


# ATL 


# MFC 


# Text and strings in MSVC 
- reference 
https://docs.microsoft.com/en-us/cpp/text/text-and-strings-in-visual-cpp?view=msvc-160

todo

- multibyte character set (MBCS) called double-byte character set (DBCS) on all platforms

MBCS is used to describe all non-Unicode support for multibyte characters. In Visual C++, MBCS always means DBCS. Character sets wider than 2 bytes are not supported.

defines the symbol _UNICODE or the symbol _MBCS (which means DBCS). 

- handle certain kinds of internationalization tasks

Use the same portable run-time functions that make MFC portable

Make literal strings and characters portable under either environment, using the _T macro.

Take care if you mix ANSI (8-bit) and Unicode (16-bit) characters in your application. 

Do not hard-code strings in your application. Instead, make them STRINGTABLE resources by adding them to the application's .rc file.

- internationalization strategies 

Your application uses Unicode. 16 bits wide 

Your application uses MBCS and can be run on any Win32 platform, Strings can contain single-byte characters, double-byte characters, or both. The C run-time library provides functions, macros, and data types for MBCS-only programming. MFC is fully MBCS-enabled.

The source code for your application is written for complete portability by recompiling with the symbol _UNICODE or the symbol _MBCS defined

- locales and code pages 

change the internal multibyte code page by calling the _setmbcp function.

System-default ANSI code page. By default, at startup the runtime system automatically sets the multibyte code page to the system-default ANSI

setlocale ( LC_ALL, "" );

By default, all locale-dependent routines in the Microsoft run-time library use the code page that corresponds to the "C" locale. At run time, you can change or query the locale code page in use with a call to setlocale.

At run-time you can query and change the multibyte code page with _getmbcp and _setmbcp, respectively.

For example, in the "C" locale, islower returns true for the values 0x61 - 0x7A only. In another locale, islower may return true for these and other values, as defined by that locale.

- interpretation of multibyte character sequences 

The output value is affected by the setting of the LC_CTYPE category setting of the locale. For more information, see setlocale. The versions of these functions without the _l suffix use the current locale for this locale-dependent behavior

_mbclen, mblen, _mblen_l 	Validate and return number of bytes in multibyte character

strlen, wcslen, _mbslen, _mbslen_l, _mbstrlen, _mbstrlen_l 	For multibyte character strings: validate each character in string; return string length.

mbstowcs, _mbstowcs_l, mbstowcs_s, _mbstowcs_s_l 	Convert sequence of multibyte characters to corresponding sequence of wide characters

mbtowc, _mbtowc_l 	Convert multibyte character to corresponding wide character

wcstombs, _wcstombs_l, wcstombs_s, _wcstombs_s_l 	Convert sequence of wide characters to corresponding sequence of multibyte characters

wctomb, _wctomb_l, wctomb_s, _wctomb_s_l 	Convert wide character to corresponding multibyte character

mbrtoc16, mbrtoc32 	Convert multibyte UTF-8 character to equivalent UTF-16 or UTF-32 character

c16rtomb, c32rtomb 	Convert UTF-16 or UTF-32 character to equivalent UTF-8 multibyte character

- ISO646 operators 

he standard header <iso646.h> is available even in a freestanding implementation.


and 	An alternative to the && operator.
and_eq 	An alternative to the &= operator.
bitand 	An alternative to the & operator.
bitor 	An alternative to the | operator.
compl 	An alternative to the ~ operator.
not 	An alternative to the ! operator.
not_eq 	An alternative to the != operator.
or 	An alternative to the || operator.
or_eq 	An alternative to the |= operator.
xor 	An alternative to the ^ operator.
xor_eq 	An alternative to the ^= operator.

```
// iso646_and.cpp
// compile with: /EHsc
#include <iostream>
#include <iso646.h>

int main( )
{
   using namespace std;
   bool a = true, b = false, result;

   boolalpha(cout);

   result= a && b;
   cout << result << endl;

   result= a and b;
   cout << result << endl;
}
```

- unicode the wide cahracter set 

A wide character is of type wchar_t. A wide-character string is represented as a wchar_t[] array. You point to the array with a wchar_t* pointer.

prefixing the letter L. For example, L"Hello".

- generic-text function _tcsrev, defined in TCHAR.H, maps to mbsrev if MBCS has been defined in your program, or to _wcsrev if _UNICODE has been defined. Otherwise _tcsrev maps to strrev

Generic-text 	SBCS (_UNICODE, _MBCS not defined) 	_MBCS defined 	_UNICODE defined
_TCHAR          char 	                            char 	        wchar_t
_TINT 	        int 	                            int 	        wint_t
_TSCHAR 	    signed char 	                    signed char 	wchar_t
_TUCHAR 	    unsigned char 	                    unsigned char 	wchar_t
_TXCHAR 	    char 	                            unsigned char 	wchar_t
_T or _TEXT 	No effect (removed by preprocessor) 	No effect (removed by preprocessor) 	L (converts following character or string to its Unicode counterpart)

use of _TCHAR and _tcsrev for mapping to the MBCS

write generic code that can be compiled for any of the three kinds of character sets: ASCII (SBCS), MBCS, or Unicode, depending on a manifest constant you define using a #define statement

_UNICODE 	Unicode (wide-character)        _tcsrev maps to _wcsrev 
_MBCS 	    Multibyte-character             _tcsrev maps to _mbsrev 
None (the default: neither _UNICODE nor _MBCS defined) 	SBCS (ASCII) 	_tcsrev maps to strrev

- using TCHAR.H data types with _MBCS 

constant _MBCS is defined, a given generic-text routine maps to one of the following kinds of routines

An SBCS routine that handles multibyte bytes, characters, and strings appropriately. the formal and actual parameter types for printf match because _TCHAR* maps to char*.

An MBCS-specific routine. In this case, the string arguments are expected to be of type unsigned char*. 

inline by preprocessors statement , provided in TCHAR.H, to map the generic-text routine directly to the appropriate MBCS routine. 

```
#define _USE_INLINING

__inline char *_tcsrev(char *_s1)
{return (char *)_mbsrev((unsigned char *)_s1);}


#define _MB_MAP_DIRECT
#define _tcschr _mbschr
```

You can use type casting to ensure proper type matching or you can use the _TXCHAR generic-text data type. _TXCHAR maps to type char in SBCS code but maps to type unsigned char in MBCS code.



# Resource for creating a game using directx 
- DirectX SDK is included in the Windows SDK. You don't have to download anything extra.


# How to use windows 10 sdk 
- see Using the Windows Headers and Update WINVER and _WIN32_WINNT.

```
#define WINVER 0x0A00
#define _WIN32_WINNT 0x0A00
...
```

https://docs.microsoft.com/en-us/cpp/porting/modifying-winver-and-win32-winnt?view=msvc-160

- VS, shortcut menu for the project node, and choose Retarget projects. 
- Configuration Properties > General section, notice the values of Windows Target Platform Version. 
- open the Visual C++ Directories section of the Project Properties dialog. Select one of the properties, such as Include Directories. <Edit> 

- Macros >> button, and scroll down the list of macros to the Windows SDK macros to see all the new values.



# using window hearders
- Macros for Conditional Declarations

define NTDDI_VERSION, you must also define _WIN32_WINNT.

Windows 10 1903 "19H1" 	NTDDI_WIN10_19H1 (0x0A000007)
Windows 10 1809 "Redstone 5" 	NTDDI_WIN10_RS5 (0x0A000006)
Windows 10 1803 "Redstone 4" 	NTDDI_WIN10_RS4 (0x0A000005)
...

Internet Explorer 11.0 	_WIN32_IE_IE110 (0x0A00)
Internet Explorer 10.0 	_WIN32_IE_IE100 (0x0A00)
...

- controlling structure packing 

see /Zp (struct member alignment) or pack

- Define WIN32_LEAN_AND_MEAN to exclude APIs such as Cryptography, DDE, RPC, Shell, and Windows Sockets.

```
#define WIN32_LEAN_AND_MEAN
```


- Define one or more of the NOapi symbols to exclude the API. NOCOMM excludes the serial communication API. For a list of support NOapi symbols, see Windows.h.

```
#define NOCOMM
````

- header annotations 

Header annotations describe how a function uses its parameters and return value. 

to help you ensure that you are calling the Windows API correctly. 

in Specstrings.h. They are built on primitives that are part of the Standard Annotation Language (SAL) and implemented using _declspec("SAL_*").

    + buffer annotations 

(size) Specifies the total size of the buffer.

(size,length) Specifies the total size and initialized length of the buffer.

_bcount The buffer size is in bytes.

_ecount The buffer size is in elements.

_in The function reads from the buffer.

_inout The function both reads from and writes to buffer.

_out The function writes to the buffer. 

_deref Dereference the parameter to obtain the buffer pointer. 

_deref_opt Dereference the parameter to obtain the buffer pointer. 

_full The function initializes the entire buffer., only with output buffers 

_part The function initializes part of the buffe, only with output buffers 

_opt This parameter can be NULL.

```
DWORD
WINAPI
GetModuleFileName(
    __in_opt HMODULE hModule,
    __out_ecount_part(nSize, return + 1) LPTSTR lpFilename,
    __in DWORD nSize
    );
```

the annnotations can be combined together 

    + advance annotations, additional information about the parameter or return value
    
__blocksOn(resource)    The functions blocks on the specified resource.
__callback              The function can be used as a function pointer.
__checkReturn           Callers must check the return value
__format_string         The parameter is a string that contains printf-style % markers.
__in_awcount(expr,size) If the expression is true at exit, the size of the input buffer is specified in bytes. If the expression is false, the size is specified in elements.
__nullnullterminated    The buffer may be accessed up to and including the first sequence of two null characters or pointers.
__nullterminated        The buffer may be accessed up to and including the first null character or pointer.
__out_awcount(expr,size)    If the expression is true at exit, the size of the output buffer is specified in bytes. If the expression is false, the size is specified in elements. 

__override              Specifies C#-style override behavior for virtual methods.
__reserved              The parameter is reserved for future use and must be zero or NULL.
__success(expr)         If the expression is true at exit, the caller can rely on all guarantees specified by other annotations. 

__typefix(ctype)        Treat the parameter as the specified type rather than its declared type.

        * example 
```
__checkReturn
BOOL
WINAPI
DeleteTimerQueueTimer(
    __in_opt HANDLE TimerQueue,
    __in     HANDLE Timer,
    __in_opt HANDLE CompletionEvent
    );

BOOL
WINAPI
FreeEnvironmentStrings(
    __in __nullnullterminated LPTCH
    );

__callback
LONG
WINAPI
UnhandledExceptionFilter(
    __in struct _EXCEPTION_POINTERS *ExceptionInfo
    );
```

- strict type checking 

    + Windows.h header file contains definitions, macros, and structures to help you write source code that is portable between versions of Windows. 
    
    + enabling STRICT, Enabling STRICT redefines certain data types so that the compiler does not permit assignment from one type to another without an explicit cast.
    
```
#define STRICT
#include <windows.h>

```

        * Specific handle types are defined to be mutually exclusive; for example, you will not be able to pass an HWND where an HDC type argument is required.
        
        * All callback function types (such as dialog procedures, window procedures, and hook procedures) are defined with full prototypes. 
        
        * Parameter and return value types that should use a generic pointer are declared correctly as LPVOID instead of as LPSTR or another pointer type.
        
        * The COMSTAT structure is declared according to the ANSI standard.
        
    + disable STRICT 
    
```
#define NO_STRICT
#include <windows.h>
```
    + strict compiliance 
    
    the generic HANDLE type should be used only when necessary.
    
    + declaring functions within your application 
    
    If you use the /Zg compiler option to create header files for your functions, remember that you will get different results depending on whether you have enabled STRICT type checking. With STRICT disabled, all handle types generate the same base type. With STRICT enabled, they generate different base types
    
    + types that require casts 
    
        * use correct type casts these functions.

    LocalLock
    GlobalLock
    GetWindowLong
    SetWindowLong
    SendMessage
    DefWindowProc
    SendDlgItemMessage

    call SendMessage, DefWindowProc, or SendDlgItemMessage, you should first cast the result to type UINT_PTR. You need to take similar steps for any function that returns an LRESULT or LONG_PTR value, where the result contains a handle. 
    
    The (UINT_PTR) cast ensures proper conversion. 
        * example convert from SendMessage to HBRUSH
    ```
HBRUSH hbr;

hbr = (HBRUSH)(UINT_PTR)SendMessage(hwnd, WM_CTLCOLOR, ..., ...);
    ```
    
        * The CreateWindow and CreateWindowEx parameter hmenu is sometimes used to pass an integer control identifier (ID).
        
```
HWND hwnd;
int id;

hwnd = CreateWindow(
        TEXT("Button"), TEXT("OK"), BS_PUSHBUTTON,
        x, y, cx, cy, hwndParent,
        (HMENU)id,    // Cast required here
        hinst,
        NULL);
```

        * The types WPARAM, LPARAM, LRESULT, and LPVOID are polymorphic data types. They hold different kinds of data at different times, even when STRICT type checking is enabled.
        
        * Take special care to distinguish HMODULE and HINSTANCE types. Even with STRICT enabled, they are defined as the same base type.
    
- windnows data types 
    + reference 
    https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types
    
    + type lists 

APIENTRY 	The calling convention for system functions. #define APIENTRY WINAPI 

ATOM 	An atom. For more information, see About Atom Tables. typedef WORD ATOM

BOOL 	A Boolean variable (should be TRUE or FALSE). typedef int BOOL

BOOLEAN 	A Boolean variable (should be TRUE or FALSE). typedef BYTE BOOLEAN 

BYTE 	A byte (8 bits). typedef unsigned char BYTE;

CALLBACK 	The calling convention for callback functions. WinDef.h as follows:
#define CALLBACK __stdcall

CCHAR 	An 8-bit Windows (ANSI) character. typedef char CCHAR 

CHAR 	An 8-bit Windows (ANSI) character. typedef char CHAR;

COLORREF 	The red, green, blue (RGB) color value (32 bits).  typedef DWORD COLORREF;

CONST 	A variable whose value is to remain constant during execution. #define CONST const

DWORD 	A 32-bit unsigned integer. typedef unsigned long DWORD;

DWORDLONG 	A 64-bit unsigned integer. typedef unsigned __int64 DWORDLONG;

DWORD_PTR 	An unsigned long type for pointer precision. typedef ULONG_PTR DWORD_PTR;

DWORD32 	A 32-bit unsigned integer. typedef unsigned int DWORD32;

DWORD64 	A 64-bit unsigned integer. typedef unsigned __int64 DWORD64;

DWORD64 	A 64-bit unsigned integer. typedef unsigned __int64 DWORD64;

FLOAT 	A floating-point variable. typedef float FLOAT;

HACCEL 	A handle to an accelerator table. typedef HANDLE HACCEL;

HALF_PTR 	Half the size of a pointer. BaseTsd.h as follows

```
#ifdef _WIN64
 typedef int HALF_PTR;
#else
 typedef short HALF_PTR;
#endif
```

HANDLE 	    A handle to an object. typedef PVOID HANDLE; WinNT.h 

HBITMAP 	A handle to a bitmap. typedef HANDLE HBITMAP;

HBRUSH 	    A handle to a brush. typedef HANDLE HBRUSH;

HCOLORSPACE A handle to a color space, typedef HANDLE HCOLORSPACE;

HCONV 	    A handle to a dynamic data exchangetypedef HANDLE HCONV;

HCONVLIST 	A handle to a DDE conversation list. typedef HANDLE HCONVLIST;

HCURSOR 	A handle to a cursor typedef HICON HCURSOR;

HDC 	    A handle to a device context (DC).  typedef HANDLE HDC;

HDDEDATA 	A handle to DDE data. typedef HANDLE HDDEDATA;

HDESK 	    A handle to a desktop. typedef HANDLE HDESK;

HDROP 	    A handle to an internal drop structure. typedef HANDLE HDROP;

HDWP 	    A handle to a deferred window position structure. typedef HANDLE HDWP;

HENHMETAFILE 	A handle to an enhanced metafile. typedef HANDLE HENHMETAFILE;

HFILE 	    A handle to a file opened by OpenFile, not CreateFile. typedef int HFILE;

HFONT 	    A handle to a font. typedef HANDLE HFONT;

HGDIOBJ 	A handle to a GDI object. typedef HANDLE HGDIOBJ;

HGLOBAL 	A handle to a global memory block.

HHOOK 	    A handle to a hook. typedef HANDLE HHOOK;

HICON 	    A handle to an icon. typedef HANDLE HICON;

HINSTANCE 	A handle to an instance. This is the base address of the module in memory. HMODULE and HINSTANCE are the same today, 16-bit windows are different. typedef HANDLE HINSTANCE;

HKEY 	    A handle to a registry key. typedef HANDLE HKEY;

HKL 	    An input locale identifier.  typedef HANDLE HKL;

HLOCAL      A handle to a local memory block.  typedef HANDLE HLOCAL;

HMENU 	    A handle to a menu.  typedef HANDLE HMENU;

HMETAFILE 	A handle to a metafile.   typedef HANDLE HMETAFILE;

HMODULE 	A handle to a module. The is the base address of the module in memory. typedef HINSTANCE HMODULE;

HMONITOR 	A handle to a display monitor. if(WINVER >= 0x0500) typedef HANDLE HMONITOR;

HPALETTE 	A handle to a palette.

HPEN 	    A handle to a pen.  typedef HANDLE HPEN;

HRESULT 	The return codes used by COM interfaces.   typedef LONG HRESULT;

HRGN 	    A handle to a region.   typedef HANDLE HRGN;

HRSRC 	    A handle to a resource.   typedef HANDLE HRSRC;

HSZ 	    A handle to a DDE string.   typedef HANDLE HSZ;

HWINSTA 	A handle to a window station.  typedef HANDLE WINSTA;

HWND 	    A handle to a window.   typedef HANDLE HWND;

INT 	    A 32-bit signed integer.  typedef int INT 

INT_PTR 	A signed integer type for pointer precision. Use when casting a pointer to an integer to perform pointer arithmetic.

```
#if defined(_WIN64) 
 typedef __int64 INT_PTR; 
#else 
 typedef int INT_PTR;
#endif
```

INT8 	    An 8-bit signed integer. in BaseTsd.h as follows: typedef signed char INT8;

INT16 	    A 16-bit signed integer.  typedef signed short INT16;

INT32 	    A 32-bit signed integer.  typedef signed int INT32;

INT64 	    A 64-bit signed integer.  typedef signed __int64 INT64;

LANGID 	    A language identifier.  typedef WORD LANGID;

LCID 	    A locale identifier.  typedef DWORD LCID;

LCTYPE 	    A locale information type.  Locale Information Constants. typedef DWORD LCTYPE;

LGRPID 	    A language group identifier.  see EnumLanguageGroupLocales.  typedef DWORD LGRPID;

LONG 	    A 32-bit signed integer.  typedef long LONG;

LONGLONG 	A 64-bit signed integer.  
```
#if !defined(_M_IX86)
 typedef __int64 LONGLONG; 
#else
 typedef double LONGLONG;
#endif
```

LONG_PTR 	A signed long type for pointer precision. use when casting a pointer to a long 
```
#if defined(_WIN64)
 typedef __int64 LONG_PTR; 
#else
 typedef long LONG_PTR;
#endif
```

LONG32 	    A 32-bit signed integer.  typedef signed int LONG32;

LONG64 	    A 64-bit signed integer. typedef __int64 LONG64;

LPARAM 	    A message parameter.  typedef LONG_PTR LPARAM;

LPBOOL 	    A pointer to a BOOL.  typedef BOOL far *LPBOOL;

LPBYTE 	    A pointer to a BYTE.  typedef BYTE far *LPBYTE;

```
Near pointer is used to store 16 bit addresses means within current segment on a 16 bit 

A far pointer is typically 32 bit that can access memory outside current segment.  

huge pointer is also typically 32 bit and can access outside segment.  In far pointer, the segment part cannot be modified, but in Huge it can be

Intel had before. The near pointers were much faster than far pointers so therefore in some contexts it paid off to use them.

Nowadays with virtual memory near and far pointers have no use.
```

LPCOLORREF 	A pointer to a COLORREF value.   typedef DWORD *LPCOLORREF;

LPCSTR 	    A pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters.  typedef __nullterminated CONST CHAR *LPCSTR;

LPCTSTR 	An LPCWSTR if UNICODE is defined, an LPCSTR otherwise.
```
#ifdef UNICODE
 typedef LPCWSTR LPCTSTR; 
#else
 typedef LPCSTR LPCTSTR;
#endif
```

LPCVOID 	A pointer to a constant of any type.  typedef CONST void *LPCVOID;

LPCWSTR 	A pointer to a constant null-terminated string of 16-bit Unicode characters  typedef CONST WCHAR *LPCWSTR;

LPDWORD 	A pointer to a DWORD.  typedef DWORD *LPDWORD;

LPHANDLE 	A pointer to a HANDLE.   typedef HANDLE *LPHANDLE;

LPINT 	    A pointer to an INT.  typedef int *LPINT;

LPLONG 	    A pointer to a LONG.   typedef long *LPLONG;

LPSTR 	    A pointer to a null-terminated string of 8-bit Windows (ANSI) characters.  typedef CHAR *LPSTR;

LPTSTR 	    An LPWSTR if UNICODE is defined, an LPSTR otherwise. 
```
#ifdef UNICODE
 typedef LPWSTR LPTSTR;
#else
 typedef LPSTR LPTSTR;
#endif
```

LPVOID 	    A pointer to any type.  typedef void *LPVOID;

LPWORD 	    A pointer to a WORD.  typedef WORD *LPWORD;

LPWSTR 	    A pointer to a null-terminated string of 16-bit Unicode characters.  typedef WCHAR *LPWSTR;

LRESULT 	Signed result of message processing.   typedef LONG_PTR LRESULT;

PBOOL 	    A pointer to a BOOL.    typedef BOOL *PBOOL;

PBOOLEAN 	A pointer to a BOOLEAN.     typedef BOOLEAN *PBOOLEAN;

PBYTE 	    A pointer to a BYTE.    typedef BYTE *PBYTE;

PCHAR 	    A pointer to a CHAR.    typedef CHAR *PCHAR;

PCSTR 	    A pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters.  typedef CONST CHAR *PCSTR;

PCTSTR 	    A PCWSTR if UNICODE is defined, a PCSTR otherwise. 
```
#ifdef UNICODE
 typedef LPCWSTR PCTSTR;
#else
 typedef LPCSTR PCTSTR;
#endif
```

PCWSTR 	    A pointer to a constant null-terminated string of 16-bit Unicode characters.

PDWORD 	    A pointer to a DWORD.   typedef DWORD *PDWORD;

PDWORDLONG 	A pointer to a DWORDLONG.   typedef DWORDLONG *PDWORDLONG;

PDWORD_PTR 	A pointer to a DWORD_PTR.  typedef DWORD_PTR *PDWORD_PTR;

PDWORD32 	A pointer to a DWORD32.  typedef DWORD32 *PDWORD32;

PDWORD64 	A pointer to a DWORD64.  typedef DWORD64 *PDWORD64;

PFLOAT 	    A pointer to a FLOAT.   typedef FLOAT *PFLOAT;

PHALF_PTR 	A pointer to a HALF_PTR.
```
#ifdef _WIN64
 typedef HALF_PTR *PHALF_PTR;
#else
 typedef HALF_PTR *PHALF_PTR;
#endif
```

PHANDLE 	A pointer to a HANDLE.  typedef HANDLE *PHANDLE;

PHKEY 	    A pointer to an HKEY. typedef HKEY *PHKEY;

PINT 	    A pointer to an INT.    typedef int *PINT;

PINT_PTR 	A pointer to an INT_PTR.  typedef INT_PTR *PINT_PTR;

PINT8 	    A pointer to an INT8.   typedef INT8 *PINT8;

PINT16 	    A pointer to an INT16.  typedef INT16 *PINT16;

PINT32 	    A pointer to an INT32.  typedef INT32 *PINT32;

PINT64 	    A pointer to an INT64.  typedef INT64 *PINT64;

PLCID 	    A pointer to an LCID.   typedef PDWORD PLCID;

PLONG 	    A pointer to a LONG.    typedef LONG *PLONG;

PLONGLONG 	A pointer to a LONGLONG.   typedef LONGLONG *PLONGLONG;

PLONG_PTR 	A pointer to a LONG_PTR.   typedef LONG_PTR *PLONG_PTR;

PLONG32 	A pointer to a LONG32.     typedef LONG32 *PLONG32;

PLONG64 	A pointer to a LONG64.      typedef LONG64 *PLONG64;

POINTER_32 	A 32-bit pointer. On a 32-bit system, this is a native pointer. On a 64-bit system, this is a truncated 64-bit pointer.

```
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
```

POINTER_64 	A 64-bit pointer. On a 64-bit system, this is a native pointer. On a 32-bit system, this is a sign-extended 32-bit pointer.
```
#if (_MSC_VER >= 1300)
#define POINTER_64 __ptr64
#else
#define POINTER_64
#endif
```

POINTER_SIGNED 	A signed pointer.       #define POINTER_SIGNED __sptr

POINTER_UNSIGNED 	An unsigned pointer.    #define POINTER_UNSIGNED __uptr

PSHORT 	        A pointer to a SHORT.       typedef SHORT *PSHORT;    

PSIZE_T 	    A pointer to a SIZE_T.      typedef SIZE_T *PSIZE_T;

PSSIZE_T 	    A pointer to a SSIZE_T.     typedef SSIZE_T *PSSIZE_T;

PSTR 	        A pointer to a null-terminated string of 8-bit Windows (ANSI) characters. typedef CHAR *PSTR;

PUCHAR 	        A pointer to a UCHAR.       typedef UCHAR *PUCHAR;

PUHALF_PTR 	    A pointer to a UHALF_PTR.
```
#ifdef _WIN64
 typedef UHALF_PTR *PUHALF_PTR;
#else
 typedef UHALF_PTR *PUHALF_PTR;
#endif
```

PUINT 	        A pointer to a UINT.        typedef UINT *PUINT;

PUINT_PTR 	    A pointer to a UINT_PTR.    typedef UINT_PTR *PUINT_PTR;

PUINT8 	        A pointer to a UINT8.       typedef UINT8 *PUINT8;

PUINT16 	    A pointer to a UINT16.      typedef UINT16 *PUINT16;

PUINT32 	    A pointer to a UINT32.      typedef UINT32 *PUINT32;

PUINT64 	    A pointer to a UINT64.      typedef UINT64 *PUINT64;    

PULONG 	        A pointer to a ULONG.       typedef ULONG *PULONG;

PULONGLONG 	    A pointer to a ULONGLONG.   typedef ULONGLONG *PULONGLONG;

PULONG_PTR 	    A pointer to a ULONG_PTR.   typedef ULONG_PTR *PULONG_PTR;

PULONG32 	    A pointer to a ULONG32.     typedef ULONG32 *PULONG32;

PUSHORT 	    A pointer to a USHORT.      typedef USHORT *PUSHORT;

PVOID 	        A pointer to any type.      typedef void *PVOID;

PWCHAR 	        A pointer to a WCHAR.       typedef WCHAR *PWCHAR;

PWORD 	        A pointer to a WORD.        typedef WORD *PWORD;    

PWSTR 	        A pointer to a null-terminated string of 16-bit Unicode characters.     typedef WCHAR *PWSTR;

QWORD 	        A 64-bit unsigned integer.      typedef unsigned __int64 QWORD;

SC_HANDLE 	    A handle to a service control manager database.     typedef HANDLE SC_HANDLE;

SC_LOCK 	    A lock to a service control manager database.       typedef LPVOID SC_LOCK;

SERVICE_STATUS_HANDLE 	    A handle to a service status value.      typedef HANDLE SERVICE_STATUS_HANDLE;   

SHORT 	        A 16-bit integer.       typedef short SHORT;

SIZE_T 	        The maximum number of bytes to which a pointer can point.   typedef ULONG_PTR SIZE_T;

SSIZE_T 	    A signed version of SIZE_T.         typedef LONG_PTR SSIZE_T;

TBYTE 	        A WCHAR if UNICODE is defined, a CHAR otherwise. 
```
#ifdef UNICODE
 typedef WCHAR TBYTE;
#else
 typedef unsigned char TBYTE;
#endif
```

TCHAR 	        A WCHAR if UNICODE is defined, a CHAR otherwise.
```
#ifdef UNICODE
 typedef WCHAR TCHAR;
#else
 typedef char TCHAR;
#endif
```

UCHAR 	        An unsigned CHAR.       typedef unsigned char UCHAR;

UHALF_PTR 	    An unsigned HALF_PTR. Use within a structure that contains a pointer and two small fields.
```
#ifdef _WIN64
 typedef unsigned int UHALF_PTR;
#else
 typedef unsigned short UHALF_PTR;
#endif
```

UINT 	        An unsigned INT.        typedef unsigned int UINT;

UINT_PTR 	    An unsigned INT_PTR.        
```
#if defined(_WIN64)
 typedef unsigned __int64 UINT_PTR;
#else
 typedef unsigned int UINT_PTR;
#endif
```

UINT8 	        An unsigned INT8.       typedef unsigned char UINT8;

UINT16 	        An unsigned INT16.      typedef unsigned short UINT16;

UINT32 	        An unsigned INT32.      typedef unsigned int UINT32;

UINT64 	        An unsigned INT64.      typedef usigned __int 64 UINT64;

ULONG 	        An unsigned LONG.       typedef unsigned long ULONG;    

ULONGLONG 	    A 64-bit unsigned integer.      
```
#if !defined(_M_IX86)
 typedef unsigned __int64 ULONGLONG;
#else
 typedef double ULONGLONG;
#endif
```

ULONG_PTR 	    An unsigned LONG_PTR.   
```
#if defined(_WIN64)
 typedef unsigned __int64 ULONG_PTR;
#else
 typedef unsigned long ULONG_PTR;
#endif
```

ULONG32 	    An unsigned LONG32.         typedef unsigned int ULONG32;

UNICODE_STRING 	A Unicode string.           
```
typedef struct _UNICODE_STRING {
  USHORT  Length;
  USHORT  MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
```

USHORT 	        An unsigned SHORT.          typedef unsigned short USHORT;

USN 	        An update sequence number (USN).        typedef LONGLONG USN;

VOID 	        Any type.                           #define VOID void

WCHAR 	        A 16-bit Unicode character.         typedef wchar_t WCHAR;

WINAPI 	        The calling convention for system functions.        #define WINAPI __stdcall

WORD 	        A 16-bit unsigned integer.          typedef unsigned short WORD;

WPARAM 	        A message parameter.                typedef UINT_PTR WPARAM;

- 64-bit integers, see Large Integers

Microsoft Visual C++ supports the __int64 sized integer type

Applications can multiply signed or unsigned 32-bit integers, generating 64-bit results, by using the Int32x32To64 and UInt32x32To64 functions.

shift bits in 64-bit values to the left or right by using the Int64ShllMod32, Int64ShraMod32, and Int64ShrlMod32 functions

- large integer functions 

Int32x32To64 
Int64ShllMod32 
Int64ShraMod32 
Int64ShrlMod32 
MulDiv 
Multiply128
MultiplyExtract128
MultiplyHigh 
PopulationCount64 
ShiftLeft128
ShiftRight128 
UInt32x32To64 
UnsignedMultiply128 
UnsignedMultiplyExtract128
UnsignedMulitplyHigh 

- large integer structures 

LARGE_INTEGER 
ULARGE_INTEGER 




# Work with resource files 
- can compose of 

Interface elements that provide information to the user such as a bitmap, icon, or cursor.
Custom resources that contain data and application needs.
Version resources that are used by setup APIs.
Menu and dialog box resources.


- resource files 
*.rc file , bitmap, icon, cursor, resource script
*.rct file, resource template 

the Resource.h is reference to the RC file 
- Include resources in your executable (.exe) file that don't need editing

- import or export graphic resources to current resource file 

- include shared or read-only identifiers symbols 

- include resources in your executable file 

- editable resources 
.rc, resource script file 
.rct, resource template 
.res, resource file 
.resx, maanged resource file 
.exe, executable files 
.dll, dynamic link libraries files 
.bmp, .ico,, .dib, .cur, bitmap, icon, toolbar, cursor 

- edit resource will affects 
Resource.h, generated by the development environment contains the symbols 
Filename.aps, binary version of the current resource script used for quick loading, should not include .aps in source control 
.rc, resource script file that contains script 

- manifest resources 








# Deploy native desktop applications 


# C++ attributes for COM and .net 


# Attribute group 



# Programming guide for 64-bit windows 
- reference 
https://docs.microsoft.com/en-us/windows/win32/winprog64/the-new-data-types





































