Software architecture with c# 12 and .net 8 - fourth edition=Gabriel;Note=Erxin

# Understand the importance 
- a professional development project, you must do the following things

Define the customer requirements for the solution.
Design a great solution to meet those requirements.
Implement the designed solution.
Test the solution implementation.
Validate the solution with your customer.
Deliver the solution in the working environment.
Maintain the solution afterward.

- azure account 

Azure’s current state, structure, and updates in a compact, digestible way, just go to https://azurecharts.com/

- agile an the approach 

Eliminate waste: You may consider waste to be anything that will interfere with the delivery of the real need of the customer.
Build quality in: An organization that wants to guarantee quality needs to promote it in processes from the very beginning, instead of only considering it when code is being tested.
Create knowledge: All companies that have achieved excellence have a common pattern of generating new knowledge by disciplined experimentation, documenting that knowledge, and guaranteeing that it is spread all over the organization.
Defer commitment: Plan decisions at the latest possible moment without causing damage to the project.
Deliver fast: The faster you deliver software, the more elimination of waste you have. Companies that compete using time frequency have significant advantages over their competitors.
Respect people: Giving reasonable objectives to the team, together with plans that will guide them to self-organize their routine, is a matter of respecting the people that you work with.
Optimize the whole: A lean company improves the cycle of value; from the moment it receives a new requirement to the point at which it delivers the software.

- good practices 
write user stories

divide software into iterations 

avoid working overtime and guarantee a substainable velocity 

keep things simple 

refactoring 

keep the customer always available 

continue integration 

code the unit test first 


code must be written to agree standards 

pair programming 

acceptance tests 

- Scrum framework: https://www.scrum.org/. 

Sprint goal (Sprint Backlog) is determined by the Scrum Team, composed of the Product Owner, the Scrum Master, and the Development Team.

- gather requirements 

detecting exact user needs 
the power of imagination 
questinhnairs 
interviewws 
observation 


# Non functional requirements
- items  
Enabling scalability, availability, and resiliency with Azure and .NET 8
Performance issues that need to be considered when programming in C#
Software usability: how to design effective user interfaces
Interoperability with .NET 8
Achieving security by design

- Vertical scaling (scaling up)
Scaling up means changing the specification of the hardware that will host your application. 

- Horizontal scaling (scaling out)
Scaling out means splitting requests between more servers and using the same capacity instead of using more powerful machines. 

- asp.net 

- performance consideration in c#

string concatenation  help of the StringBuilder class (the code is available in this book’s GitHub repository):

exceptions try-catch needs to be concise and essential; otherwise, you will have big performance issues.

Do use concurrent collections (System.Collections.Concurrent): As soon as you start a multithreading application

- Interoperability with .NET 8

    + platform check 
    
OS by using the runtime checks provided by .NET 8, as follows:

using System.Runtime.InteropServices;
if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
	Console.WriteLine("Here you have Windows World!");
else if(RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
	Console.WriteLine("Here you have Linux World!");
else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
	Console.WriteLine("Here you have macOS World!");
    
    + create a linux service 
 Using a Linux terminal, you can type this:
 ```
$ cat >sample.service<<EOF
[Unit]
Description=Your Linux Service
After=network.target
[Service]
ExecStart=/usr/bin/dotnet $(pwd)/appfolder/app.dll 5000
Restart=on-failure
[Install]
WantedBy=multi-user.target
EOF


sudo cp sample.service /lib/systemd/system
sudo systemctl daemon-reload
sudo systemctl enable sample

# Start the service
sudo systemctl start sample
# View service status
sudo systemctl status sample
# Stop the service
sudo systemctl stop sample

```

- achieving security by design 




# Best practices in coding 
- items 

 SOLID principles (Single Responsibility, 
 Open/Close, 
 Liskov Substitution, 
 Interface Segregation, and Dependency Inversion), 
 
 you will turn complexity into simple code.
  software you are delivering. The metrics that the tool provides can be found at this link: https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values\
  
- Cyclomatic complexity
The creator of the cyclomatic complexity metric is Thomas J. McCabe. He defines the complexity of a software function according  

Loops inside loops
Lots of consecutive if-else statements
switch with code processing for each case inside the same method
  
- Maintainability index
The maintainability index represents a number from 0 to 100, which indicates how easy it is to maintain code

- Depth of inheritance
This metric represents the number of classes inherited by the one that is being analyzed. The more classes you have inherited

- Class coupling
When you connect too many classes in a single class, obviously you will get tight coupling

- Number of lines of code
This metric is useful in terms of making you understand the size of the code you are dealing with

- writing safe code in c# 

try-catch 

try-finally 

- The IDisposable interface
In the same way that you will have trouble if you do not manage objects created inside a method with try-finally/using statements, objects created in a class that does not properly implement the IDisposable interface may cause memory leaks

- Visual Studio 2022 certainly has more tools for this purpose than Visual Studio 2019, and so on.

You can find an overview of source code analysis at https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview.

SonarAnalyzer is an open-source initiative from the Sonar Source community to detect bugs and quality issues 



# Implementing code reusuability in c# 12 
- .net 8 for code reuse 

.NET. You can find a full .NET Standard overview at https://docs.microsoft.com/en-us/dotnet/standard/net-standard.

.NET implementation

Version support

.NET and .NET Core

2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0, 7.0, 8.0

.NET Framework 1

4.6.1 2, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1

Mono

5.4, 6.4

Xamarin.iOS

10.14, 12.16

Xamarin.Mac

3.8, 5.16

Xamarin.Android

8.0, 10.0

Universal Windows Platform

10.0.16299, TBD

Unity

2018.1

- create c# class library 

find a list of the available TFMs at https://docs.microsoft.com/en-us/dotnet/standard/frameworks:

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>


- Generics were introduced in C# in version 2.0 and are considered an approach that increases code reuse.
public class EvaluationService<T> where T: IContentEvaluated, new()

- Documenting .NET libraries using DocFX
DocFX is a good option for documenting a library using comments made in its code. By simply adding the docfx.console NuGet package, the tool allows you to create a task that will run once your library has been built

- Documenting a web API using Swagger
There is no doubt that a web API is one of the technologies that facilitates and promotes code reuse. For this reason, ensuring good documentation and, more than that, respecting a standard is good practice



# Design patterns and .net 8 implementation 
- GoF, the SOLID principles do not deliver code recipes.

Single Responsibility: A module or function should be responsible for a single purpose.
Open-Closed: A software artifact should be open for extension but closed for modification.
Liskov Substitution: The behavior of a program needs to remain unchanged when you substitute one of its components for another component that has been defined by a supertype of the primer object.
Interface Segregation: Depending on the way you create interfaces, you will promote dependencies that do not necessarily occur when you build their concrete objects, causing harm to the system architecture.
Dependency Inversion: The most flexible systems are the ones where object dependencies only refer to abstractions.

- builder you will have a complex object with different behaviors due to its configuration. Instead of setting this object up while using it, you may want to decouple its configuration from its usage, using a customized configuration that is already built 

one complex object <-> multiple builders 


- The Factory pattern is useful in situations where you have multiple objects from the same abstraction, and you only know which one needs to be created at runtime. 

multiple kinds of objects <-> one factory


- Singleton pattern When you implement Singleton in your application, you will have a single instance of the object implemented in the entire solution. 

- Proxy pattern The Proxy pattern is used when you need to provide an object that controls access to another object. 

- Publisher/Subscriber pattern
Providing information from an object to a group of other objects is common in all applications. The Publisher/Subscriber pattern is almost mandatory

- Dependency Injection pattern

    + There are three ways to perform dependency injection:

Use the constructor of the class to receive the objects
Tag some class properties to receive the objects
Define an interface with a method to inject all the necessary components

    + use third-party software since it contains a set of libraries to solve this in the Microsoft.Extensions.DependencyInjection namespace.


- Command pattern  There are many cases where you need to execute a command that will affect the behavior of an object. The Command pattern can help you with this by encapsulating this kind of request in an object. 
- Command pattern  There are many cases where you need to execute a command that will affect the behavior of an object. The Command pattern can help you with this by encapsulating this kind of request in an object. 



# Understanding the Different Domains in Software Solutions
- a modern software development technique called domain-driven design (DDD), which was first proposed by Eric Evans (see Domain-Driven Design:



use a different vocabulary for each domain of expertise. Consequently, the application must be split into modules that reflect the different domains of knowledge

- Entities
DDD entities represent domain objects that have a well-defined identity, as well as all the operations that are defined on them.

```
public abstract class Entity<K>: IEntity<K>
{
       
    public virtual K Id { get; protected set; }
    public bool IsTransient()
    {
        return Object.Equals(Id, default(K));
    }
    public override bool Equals(object obj)
    {
        return obj is Entity<K> entity &&
          Equals(entity);
    }
    public bool Equals(IEntity<K>? other)
    {
        if (other == null ||
            other.IsTransient() || this.IsTransient())
            return false;
        return Object.Equals(Id, other.Id);
    }
    int? _requestedHashCode;
    public override int GetHashCode()
    {
        if (!IsTransient())
        {
            if (!_requestedHashCode.HasValue)
                _requestedHashCode = HashCode.Combine(Id);
            return _requestedHashCode.Value;
        }
        else
            return base.GetHashCode();
    }
    public static bool operator ==(Entity<K> left, Entity<K> right)
    {
        if (Object.Equals(left, null))
            return Object.Equals(right, null);
        return left.Equals(right);
    }
    public static bool operator !=(Entity<K> left, Entity<K> right)
    {
        return !(left == right);
    }
}
```

- Value objects
Value objects, in contrast to entities, represent complex types that can’t be encoded with numbers or strings. Therefore, they have no identity and no principal keys. They have no operations defined on them and are immutable;


```
public record Address
{
   public string Country {get; init;}
   public string Town {get; init;}
   public string Street {get; init;}
}
```

- A purchase order, along with all its subparts (its order items), is called an aggregate, while the order entity is called the root of the aggregate. 
- classic layers architecture 


upled sets of classes/interfaces called layers, put one after the other:

The first layer in the sequence is the one that takes care of user interaction and is called the presentation layer.
The second layer in the sequence is the one that performs business-related processing and is called the business layer.
The third layer is the one dedicated to database interaction and is called the data layer.


- Onion architecture
In the onion architecture, layers obey different rules and are defined in a slightly different way. There is:

An outermost layer that takes care of all interactions with the application environment—that is, user interface, test software, and interaction with operating system and data storage
An application layer
A domain layer


domain layer is an abstraction of the classical data layer based on the Ubiquitous Language. It is where DDD entities and value objects are defined, together with abstractions of the operations that retrieve and save them.


The application layer, instead, defines operations that use the domain layer public interface (public interfaces and public classes) to get DDD entities and value objects 


Both the application services and the domain layer can be split into sublayers, and all layers/sublayers must conform to the following rule: Each layer may depend only on the inner layers.

 domain layer may be split into Domain Model and Domain Services
 
- Repository pattern
The repository pattern is an entity-centric approach to the definition of the domain layer interfaces: each entity—or better, each aggregate—has its own repository interface that defines how to retrieve and create it, and defines all queries that involve entities in the aggregate. 