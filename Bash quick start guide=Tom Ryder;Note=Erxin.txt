Bash quick start guide=Tom Ryder;Note=Erxin

# Introduction 
- reference 
https://learning.oreilly.com/library/view/bash-quick-start/9781789538830/

- example code 
 https://github.com/PacktPublishing/Bash-Quick-Start-Guide
 
 
- what is bash 

Bash is not (necessarily) part of Linux. They are separate pieces of software

Bash is not the same thing as SSH. SSH is a service and network protocol for running commands on remote computer

Bash is also not your terminal or TTY. Your terminal is a device for sending information to, and receiving information from, a computer.

Bash is not the same thing as PuTTY, iTerm, or xterm. These are terminal emulators

Bash is not the command line, in the strictest sense. Bash has an interactive mode

- getting bash 

The Bash source code is available at https://www.gnu.org/software/bash/.

- check bash is running 

$ declare -p BASH

printing the value of the SHELL variable:

$ echo "$SHELL"

- swtiching the login shell to bash 

$ bash 

find the location of the bash program:
```
bash$ declare -p BASH
BASH="/usr/local/bin/bash"
```

change Bash to your login shell to that path with the chsh tool:

$ chsh -s /usr/local/bin/bash

    + if get error "/usr/local/bin/bash is an invalid shell"
    
In this case, the invalid shell part likely means that the path given needs to be added to the /etc/shells file

$ cat /etc/shells

- identifyinng the bash version number 

printing the value of the BASH_VERSION variable:

```
bash$ declare -p BASH_VERSION
declare -- BASH_VERSION="4.4.12(1)-release"
```

$ bash --version

- upgrading bash on macOS 

$ brew install bash

- posix shell script features 

http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html

running command 

variables 

arithmetic expansion 

control structure 

aliases 

functions 

input and output redirection 

pipes 

argument list 

parameter expansion 

pattern matching 

process management 

compound commands 

reading lines of input data 

formatted strings 

command substitution 

    + calling the grep program, for example, you can select input lines using regular expressions
    
- bash specific features 

named array variables 

performing conditional tests 

extended globs 

regular expression 

local varaibles 

c-style loop 

parameter expansion 

arithmetic expression 

irregular filenames and unusual line separators 

- when to apply bash 

prototyping 

interactive system administration 

automation 

connecting programs together 

filtering and transforming text input 

navigating the unix file system 

basic pattern matching on strings 

portability to unix like systems 

- when to avoid bash 

speed requiring 

fixed or floating point math 

long or complex program 

serialization 

networking programming 

object oriented programming 

functional programming 

concurrent programming 

- getting help 

$ help printf 

$ man printf 

    +  the same command can have more than one implementation. In Bash, see a list with type command 
    
$ type -a printf

    + try help first, example ubuntu output 
```
$ help 
GNU bash, version 5.0.17(1)-release (x86_64-pc-linux-gnu)
These shell commands are defined internally.  Type `help' to see this list.
Type `help name' to find out more about the function `name'.
Use `info bash' to find out more about the shell in general.
Use `man -k' or `info' to find out more about commands not in this list.

A star (*) next to a name means that the command is disabled.

 job_spec [&]                                                            history [-c] [-d offset] [n] or history -anrw [filename] or history >
 (( expression ))                                                        if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ e>
 . filename [arguments]                                                  jobs [-lnprs] [jobspec ...] or jobs -x command [args]
 :                                                                       kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill ->
 [ arg... ]                                                              let arg [arg ...]
 [[ expression ]]                                                        local [option] name[=value] ...
 alias [-p] [name[=value] ... ]                                          logout [n]
 bg [job_spec ...]                                                       mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [->
 bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r ke>  popd [-n] [+N | -N]
 break [n]                                                               printf [-v var] format [arguments]
 builtin [shell-builtin [arg ...]]                                       pushd [-n] [+N | -N | dir]
 caller [expr]                                                           pwd [-LP]
 case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac              read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] >
 cd [-L|[-P [-e]] [-@]] [dir]                                            readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] >
 command [-pVv] command [arg ...]                                        readonly [-aAf] [name[=value] ...] or readonly -p
 compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W word>  return [n]
 complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G glo>  select NAME [in WORDS ... ;] do COMMANDS; done
 compopt [-o|+o option] [-DEI] [name ...]                                set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]
 continue [n]                                                            shift [n]
 coproc [NAME] command [redirections]                                    shopt [-pqsu] [-o] [optname ...]
 declare [-aAfFgilnrtux] [-p] [name[=value] ...]                         source filename [arguments]
 dirs [-clpv] [+N] [-N]                                                  suspend [-f]
 disown [-h] [-ar] [jobspec ... | pid ...]                               test [expr]
 echo [-neE] [arg ...]                                                   time [-p] pipeline
 enable [-a] [-dnps] [-f filename] [name ...]                            times
 eval [arg ...]                                                          trap [-lp] [[arg] signal_spec ...]
 exec [-cl] [-a name] [command [arguments ...]] [redirection ...]        true
 exit [n]                                                                type [-afptP] name [name ...]
 export [-fn] [name[=value] ...] or export -p                            typeset [-aAfFgilnrtux] [-p] name[=value] ...
 false                                                                   ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]
 fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]        umask [-p] [-S] [mode]
 fg [job_spec]                                                           unalias [-a] name [name ...]
 for NAME [in WORDS ... ] ; do COMMANDS; done                            unset [-f] [-v] [-n] [name ...]
 for (( exp1; exp2; exp3 )); do COMMANDS; done                           until COMMANDS; do COMMANDS; done
 function name { COMMANDS ; } or name () { COMMANDS ; }                  variables - Names and meanings of some shell variables
 getopts optstring name [arg]                                            wait [-fn] [id ...]
 hash [-lr] [-p pathname] [-dt] [name ...]                               while COMMANDS; do COMMANDS; done
 help [-dms] [pattern ...]                                               { COMMANDS ; }
```


# Using bash interactively 
- bash manual and gnu readline manual 

```
$ man bash
$ man 3 readline
```

- simple command example 

$ mkdir -p New/bash

- shell metacaracters have special meeting to bash  

many other characters interpreted specially by Bash in some contexts, including {, [, *, and $ etc. 

- quoting, Quoting special characters makes Bash ignore any special meaning they may otherwise have to the shell

- escaping, Using escaping with backslashes, the examples from the previous section

```
$ touch important\ files
$ touch Testfile\<Tom\>.doc
$ touch Review\;Final.doc
$ touch \$\$\$Money.doc
$ echo \\backslash\\
\backslash\

//can't escape newline within a word 
$ echo backslash\
> foo\
> bar
backslashfoobar
```

- single quotes, single quotes can escape a newline in a word

$ echo 'quotes
> foo
> bar'
quotes
foo
bar

two single-quoted strings, It and s today, and pushes them together as one word. The way to do it is to use a backslash outside of the single quote
```
$ echo 'It'\''s today'
It's today
```

- double quote, they perform certain kinds of expansion within them, for shell variables and substitutions

```
$ echo "This is my login shell: $SHELL"
This is my login shell: /bin/bash
```

```
$ echo 'This is my login shell: $SHELL'
This is my login shell: $SHELL
```

    + include a literal dollar sign or backslash in a string by escaping it
    
```
$ echo "Not a variable: \$total"
Not a variable: $total
$ echo "Back\\to\\back\\slashes"
Back\to\back\slashes
```

backtick character is requried to be escaped 
```
$ echo "Backticks: \`\`\`"
Backticks: ```
```

- quote concatenation, put different types of quoting together in the same word, as long as they can never separated by an unquoted space

```
$ echo Hello,\ "$USER"'! Welcome to '"$HOSTNAME"'!'
Hello, bashuser! Welcome to bashdemo!
```

- running commands in sequence 

$ cd ; ls -a ; mkdir New

if one of the commands fails, Bash will still keep running the next command.

- exit values 

$ rmdir ~/nonexistent

check the exist value $? 

$ echo $? 

- stopping a command list on error 

$ cd && rmdir ~/nonexistent && ls

- running command in background with trail &  

$ sleep 10 &



# Essential commands 
- distinguishing command types 

shell builtin commands, they are implemented in the bash binary itself like echo, type and source  

runtime commands, defined at runtime during a Bash session, often by reading startup files 

system commands, commands that can also be run outside of Bash. Examples are grep, ping, and rm.

- builtin commands:

type: Finding what a command is
echo: Printing arguments
printf: Printing formatted arguments
pwd: Printing the current directory
cd: Changing the current directory
set: Viewing and setting shell properties
declare: Managing variables and functions
test, [, [[: Evaluating expressions

- system commands, which are not part of Bash itself:

ls: Listing files for users
mv: Moving and renaming files
cp: Copying files
rm and rmdir: Deleting files and directories
grep: Matching patterns
cut: Extracting columns from data
wc: Counting lines, words, and characters
find: Iterating through a file tree
sort and uniq: Sorting and de-duplicating input

- get help for a command 

$ help type 

The type command, given the name of any command or commands

$ help type 
/bin/true path was returned, even though true is also the name of a shell builtin.

- echo command, emit content to the terminal including variables 

$ echo 'Hello, '"$USER"\!
Hello, bashuser!

-  printf, where echo might struggle, the first argument you provide to it is a format string:

$ printf '%s\n' -n
-n
$ string=-n
$ printf '%s\n' "$string"
-n

- pwd, The pwd Bash builtin prints the current working directory

- tilde paths ~, reference the user home 
$ echo ~

$ echo~root/.ssh 
/root/.ssh 

escape, single-quoting, and double-quoting all work to display ~ instead of reference the home path 
$ echo \~bashuser 
~bashuser 

- cd command, ch to sets the working directory 
$ cd <path> 

- set command, set shell options, and set shell positional parameters.

set prints a list of all of the variables and any functions for the running shell, in alphabetical order. We suggest you use declare instead

set options 
```
$ help set 

-e: Exit immediately if a command exits with a non-zero status. 

-n: Read commands but don't execute them. This is a useful way to check that your Bash script is syntactically correct

-v: Print shell input lines as they are read. This can be good for debugging

-x: Print commands and their arguments as they are executed. 
```

set -x in the shell has the same effect as starting the shell as bash -x, or having a script's shebang line include the option, such as #!/bin/bash -x.

set followed by the option terminator string, --, can be used to set the positional parameters for the shell.

- declare command, only the -p option, declare prints the values of all of the variables in the current shell environment

```
bash$ declare -p
declare -- BASH="/bin/bash"
declare -r BASHOPTS="cdspell:checkhash:checkjobs:checkwinsize:...
declare -ir BASHPID

bash$ declare -p BASH PWD
declare -- BASH="/bin/bash"
declare -x PWD="/home/bashuser"
```

- test, [, and [[ commands 

test file exist 
$ test -e /etc/passwd && echo 'Password file exists!'

alternative way to write this command, called [
$ type -a [

$ [ -e /etc/passwd ] && echo 'Password file exists!'

Bash implements a new version of [ called [[. It's actually not really a command;
$ type [[

[[ keyword that in turn derives its syntax from the [ command.

- system commands 

    + ls command 
    
    $ ls -al 
    
    + getting filenames lists 
    
     use globs or find in this situation. If you only have to deal with one directory, use globs, as the commands tend to be simpler:

$ grep pattern -- *
$ find . -type f -exec grep pattern -- {} \;

- mv command, The mv command moves files or directories to a new directory

last argument is a directory, all of the arguments before it are moved into it

$ mv file1 file2 dir1 path/to/directory

- cp command, used to copy a file or set of files 

$ cp file1 file2 file3 dir

copy a directory and all of the files beneath it:

$ cp -R olddir newdir

- rm and rmdir commands 

You can force this with the standard -R or -r option, but it's safer to use rmdir. This is because rmdir will refuse to delete a directory if it still has files in it;

```
$ mkdir test1 test2
$ touch test1/file test2/file
$ rm -r test1
$ rmdir test2
rmdir: failed to remove 'test2': Directory not empty
```

- grep command match regular expression 

$ grep 'telnet' /etc/services

$ grep '^telnet' /etc/services


$ grep -c telnet /etc/services

```
Usage: grep [OPTION]... PATTERNS [FILE]...
Search for PATTERNS in each FILE.
Example: grep -i 'hello world' menu.h main.c
PATTERNS can contain multiple patterns separated by newlines.

Pattern selection and interpretation:
  -E, --extended-regexp     PATTERNS are extended regular expressions
  -F, --fixed-strings       PATTERNS are strings
  -G, --basic-regexp        PATTERNS are basic regular expressions
  -P, --perl-regexp         PATTERNS are Perl regular expressions
  -e, --regexp=PATTERNS     use PATTERNS for matching
  -f, --file=FILE           take PATTERNS from FILE
  -i, --ignore-case         ignore case distinctions in patterns and data
      --no-ignore-case      do not ignore case distinctions (default)
  -w, --word-regexp         match only whole words
  -x, --line-regexp         match only whole lines
  -z, --null-data           a data line ends in 0 byte, not newline

Miscellaneous:
  -s, --no-messages         suppress error messages
  -v, --invert-match        select non-matching lines
  -V, --version             display version information and exit
      --help                display this help text and exit

Output control:
  -m, --max-count=NUM       stop after NUM selected lines
  -b, --byte-offset         print the byte offset with output lines
  -n, --line-number         print line number with output lines
      --line-buffered       flush output on every line
  -H, --with-filename       print file name with output lines
  -h, --no-filename         suppress the file name prefix on output
      --label=LABEL         use LABEL as the standard input file name prefix
  -o, --only-matching       show only nonempty parts of lines that match
  -q, --quiet, --silent     suppress all normal output
      --binary-files=TYPE   assume that binary files are TYPE;
                            TYPE is 'binary', 'text', or 'without-match'
  -a, --text                equivalent to --binary-files=text
  -I                        equivalent to --binary-files=without-match
  -d, --directories=ACTION  how to handle directories;
                            ACTION is 'read', 'recurse', or 'skip'
  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;
                            ACTION is 'read' or 'skip'
  -r, --recursive           like --directories=recurse
  -R, --dereference-recursive  likewise, but follow all symlinks
      --include=GLOB        search only files that match GLOB (a file pattern)
      --exclude=GLOB        skip files that match GLOB
      --exclude-from=FILE   skip files that match any file pattern from FILE
      --exclude-dir=GLOB    skip directories that match GLOB
  -L, --files-without-match  print only names of FILEs with no selected lines
  -l, --files-with-matches  print only names of FILEs with selected lines
  -c, --count               print only a count of selected lines per FILE
  -T, --initial-tab         make tabs line up (if needed)
  -Z, --null                print 0 byte after FILE name

Context control:
  -B, --before-context=NUM  print NUM lines of leading context
  -A, --after-context=NUM   print NUM lines of trailing context
  -C, --context=NUM         print NUM lines of output context
  -NUM                      same as --context=NUM
      --color[=WHEN],
      --colour[=WHEN]       use markers to highlight the matching strings;
                            WHEN is 'always', 'never', or 'auto'
  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)

When FILE is '-', read standard input.  With no FILE, read '.' if
recursive, '-' otherwise.  With fewer than two FILEs, assume -h.
Exit status is 0 if any line (or file if -L) is selected, 1 otherwise;
if any error occurs and -q is not given, the exit status is 2.

```

- cut command, select single columns of data from input separated by a single character

the -d specifies the delimiter or separator variable, in this case a colon, and -f specifies the number of the field (or column), starting from 1

$ cut -d: -f1,6 /etc/passwd

- wc, word count command, counts lines, words, and bytes of its input 

$ wc .bashrc

more than one files 
$ wc -c .bashrc .bash_profile

unicode 8 languages 
$ wc -m -c japanese
 6 16 japanese
 
the number of characters (6) is different from the number of bytes (16), as some of the characters are composed of more than one byte in UTF-8

- du command, getting file sizes with wc or du 

The du program can show this information for a file or a directory, but its only portable unit size

- find command, operate recursively on a directory hierarchy 

print filenames 
$ find ~/recipes

explicit with the -print action:

$ find ~/recipes -print

the -name with this glob-style pattern will print the name of any file or directory

To find files modified more than three days ago, you could write:

$ find ~/recipes -mtime +3 -print

can do this with the -prune action, which stops the descent at that point and continues with the rest of the tree

```
Usage: find [-H] [-L] [-P] [`level] [-D debugopts] [path...] [expression]

default path is the current directory; default expression is -print
expression may consist of: operators, options, tests, and actions:
operators (decreasing precedence; -and is implicit where no others are given):
      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2
      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2
positional options (always true): -daystart -follow -regextype

normal options (always true, specified before other expressions):
      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf
      --version -xdev -ignore_readdir_race -noignore_readdir_race
tests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N
      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME
      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN
      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE
      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN
      -readable -writable -executable
      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N
      -used N -user NAME -xtype [bcdpfls]      -context CONTEXT

actions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print
      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit
      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;
      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;

Valid arguments for -D:
exec, opt, rates, search, stat, time, tree, all, help
Use '-D help' for a description of the options, or see find(1)

Please see also the documentation at http://www.gnu.org/software/findutils/.
```

    + executing commands for each result 

    search string in all files with names ending in .vim in a directory named vim:

$ find vim -type f -name '*.vim' -exec grep -F search -- {} \;

an option terminator (--), and two special arguments:

{}: Replaced with each find result
\;: Terminates the command

    + find and xargs to accomplish something similar to the -exec action of find:

$ find vim -type f -name '*.vim' | xargs grep -F search --

xargs is with the non-standard find -print0 and xargs -0 options that specify null-byte terminators between each file

$ find vim -type f -name '*.vim' -print0 | xargs -0 grep -F search --

- sort and uniq commands 

two forms are the most useful:

$ sort /etc/shells

sort can sort data according to a particular column of its input data

$ sort -t: -k6,6 /etc/passwd

```
Usage: sort [OPTION]... [FILE]...
  or:  sort [OPTION]... --files0-from=F
Write sorted concatenation of all FILE(s) to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
Ordering options:

  -b, --ignore-leading-blanks  ignore leading blanks
  -d, --dictionary-order      consider only blanks and alphanumeric characters
  -f, --ignore-case           fold lower case to upper case characters
  -g, --general-numeric-sort  compare according to general numerical value
  -i, --ignore-nonprinting    consider only printable characters
  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'
  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)
  -n, --numeric-sort          compare according to string numerical value
  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)
      --random-source=FILE    get random bytes from FILE
  -r, --reverse               reverse the result of comparisons
      --sort=WORD             sort according to WORD:
                                general-numeric -g, human-numeric -h, month -M,
                                numeric -n, random -R, version -V
  -V, --version-sort          natural sort of (version) numbers within text

Other options:

      --batch-size=NMERGE   merge at most NMERGE inputs at once;
                            for more use temp files
  -c, --check, --check=diagnose-first  check for sorted input; do not sort
  -C, --check=quiet, --check=silent  like -c, but do not report first bad line
      --compress-program=PROG  compress temporaries with PROG;
                              decompress them with PROG -d
      --debug               annotate the part of the line used to sort,
                              and warn about questionable usage to stderr
      --files0-from=F       read input from the files specified by
                            NUL-terminated names in file F;
                            If F is - then read names from standard input
  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type
  -m, --merge               merge already sorted files; do not sort
  -o, --output=FILE         write result to FILE instead of standard output
  -s, --stable              stabilize sort by disabling last-resort comparison
  -S, --buffer-size=SIZE    use SIZE for main memory buffer
  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition
  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or /tmp;
                              multiple options specify multiple directories
      --parallel=N          change the number of sorts run concurrently to N
  -u, --unique              with -c, check for strict ordering;
                              without -c, output only the first of an equal run
  -z, --zero-terminated     line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit

KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a
field number and C a character position in the field; both are origin 1, and
the stop position defaults to the line's end.
```


# Input, Output and Redirection 
- Bash's support for classic shell redirection, specifying a source or a destination
- data-filtering possibilities using the sed and AWK programming languages

```
$ printf 'Hello, terminal!\n'

$ printf 'Hello, file!\n' > myfile
```


HOME can also be expanded for the file destination:

$ printf 'Hello, file!\n' > "$HOME"/myfile

    + only want to allow Bash to create new files, you can set the -C shell option with set:

$ set -C
$ printf 'Third command\n' > myfile

    + overwrite anyway 

$ set -C
$ printf 'Third command\n' >| myfile

- appending to files 

$ printf 'Second command\n' >> file

- created file permissions 

 create a new file using an output redirection, and examine it with ls -l:

$ printf 'Hello, world\n' > myfile 
$ ls -l myfile -rw-r--r-- 1 bashuser bash

first field is file type, normal file is -, directory is d 
next three rw- are the file owner permissions 
next three r-- are the file group permission, a user in the file group 
last three are the permission for the world 

a numeric notation with three octal numbers ranging from 0 to 7:

$ stat -c %a myfile

read and write privileges, so the first value is 4 + 2, or 6
delete is 1 

- choosing permissions for created files 

umask value of the process to find out which of those permissions it should not apply to the created file

other three digits like so:

0022, is a common value for users who are not root. Note the extra zero at the start, a common prefix to signal an octal numbe

an "empty" umask of 0000, Bash creates new files that are readable and writable for everyone:
$ unmask 
$ cat public-content > public

- redirecting errors 

standard error strea's file descriptor number, which is always 2:

$ grep pattern myfile /nonexistent > matches 2> errors

Also note that you can use 2>> to append error output to a file

 using the ampersand (&), syntax to specify 1 (the standard output stream's descriptor):

$ grep pattern myfile /nonexistent > matches 2>&1

- comm tool, which shows lines that differ between files, similar to diff

$ comm myfile1 myfile2 2> /dev/null
$ echo $?
1

- tee command, sending output to more than one place 

$ printf 'Copy this output\n' | tee myfile

$ printf 'Copy this output\n' | tee myfile1 myfile2 myfile3

- redirecting input 

use Bash to redirect input as often as you need to redirect output, because well-designed Unix programs can usually change their input behavior by specifying filenames

    +  tr Unix command is a simple way to translate characters in input to other characters
    
$ tr a-z A-Z
Hello, world!
HELLO, WORLD!

    + from pipe 

$ cat mylines | tr a-z A-Z

    + from file 
    
$ tr a-z A-Z < mylines

we can place the input redirection operator, <, elsewhere on the command line, including at the very start

$ < mylines tr a-z A-Z 

    + perform simultaneously 

$ tr a-z A-Z < mylines > mylines.capitalized 2> mylines.error

- using a long string as input with here documents 

input to cat all lines that are between the <<'EOF' line and the next occurrence of the EOF token as the first word of a new line;

```
#!/bin/bash
case $1 in
    -h|--help)
        cat <<'EOF'
foo command help:
-h, --help: Show this help
-q, --quiet: Run without diagnostics
-v, --verbose: Add extra diagnostics
EOF
        exit 0
        ;;
esac
```

- using pipes 

uppercase letters to lowercase with tr, sorts them, and then prints a count of how often each word is used, sorted by frequency

```
#!/bin/bash

# Convert all capital letters in the input to lowercase
tr A-Z a-z > words.lowercase

# Sort all the lowercase words in order
sort words.lowercase > words.sorted

# Print counts of how many times each word occurs
uniq -c words.sorted > words.frequency

# Sort that list by frequency, descending
sort -k1,1nr words.frequency
```

tr A-Z a-z | sort | uniq -c | sort -k1,1nr

- adding file contents to a stream 

$ cat myfile1 myfile2 myfile3 > myfiles.combined

We could combine them with one pipeline using the - representation for the standard input

- piping ouytput from multiple programs 

a group command, which is delimited with curly brackets, { and }:

$ { date ; hostname ; } | tr a-z A-Z

- filtering programs 

we'll look at the sed and AWK programming language interpreters, both of which are specified by POSIX

- sed stream editor 

read stream, edit, and send the result to output 

delete individual lines with the d command, by prefixing them with the line number
$ sed '1d' text-file 

substitutes a regular expression pattern into a given replacement:

$ sed 's/stream/river/' manual

```
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...

  -n, --quiet, --silent
                 suppress automatic printing of pattern space
      --debug
                 annotate program execution
  -e script, --expression=script
                 add the script to the commands to be executed
  -f script-file, --file=script-file
                 add the contents of script-file to the commands to be executed
  --follow-symlinks
                 follow symlinks when processing in place
  -i[SUFFIX], --in-place[=SUFFIX]
                 edit files in place (makes backup if SUFFIX supplied)
  -l N, --line-length=N
                 specify the desired line-wrap length for the `l' command
  --posix
                 disable all GNU extensions.
  -E, -r, --regexp-extended
                 use extended regular expressions in the script
                 (for portability use POSIX -E).
  -s, --separate
                 consider files as separate rather than as a single,
                 continuous long stream.
      --sandbox
                 operate in sandbox mode (disable e/r/w commands).
  -u, --unbuffered
                 load minimal amounts of data from the input files and flush
                 the output buffers more often
  -z, --null-data
                 separate lines by NUL characters
      --help     display this help and exit
      --version  output version information and exit

If no -e, --expression, -f, or --file option is given, then the first
non-option argument is taken as the sed script to interpret.  All
remaining arguments are names of input files; if no input files are
specified, then the standard input is read.
```
- awk programming language 

AWK program is a set of patterns for each record (normally a line) to match, for which an action is performed for each matching record

$ awk '{ print $2 }' groceries

We can do this with a print command and by specifying the second column with $2

print multiple columns by separating them with commas:

$ awk '{ print $2, $3 }' groceries

NR in the preceding command refers to the record number

As with sed, these examples only scratch the surface; AWK is a small programming language




# Variables and patterns 
- basic form of a variable 

myshell='GNU Bourne-Again shell'

safest to quote all the values in their assignments; it might be unnecessary in some cases

```
myshell='sh'
myvar='GNU'\''s Not Unix!'
myprompt="$USER@$HOST"
```

- listing variables 

$ today='August 9th'
$ printf '%s\n' "$today"
August 9th

$ declare -p today

list all 
$ declare -p

- naming variables 

all legal:

myvar
MYVAR
Myvar
mYVAR
_myvar
my_var
myvar_
my012

- variable name case 

using the ALL_UPPERCASE variable names for your own script variables is that environment variables, such as HOME

variable names such as  myshell and today are in lowercase. 

- clearing variables 

leaving the right side of an assignment to the variable blank:

$ system=

has an empty value:
bash$ declare -p system
declare -- system=""

    + remove varaible 

$ unset -v system
$ declare -p system
bash: declare: system: not found

- environment variables 

shell process after making an assignment. Consider this basic shell session, including an assignment to a variable named realname

bash$ declare -p BASHPID

get a new process ID in BASHPID, and the realname variable does not show as a set:

bash$ bash
bash$ declare -p BASHPID

use environment variables. The POSIX-specified command to do this is called export
```
bash$ REALNAME='Bash User'
bash$ export REALNAME
bash$ declare -p REALNAME
declare -x REALNAME="Bash User"
```

exported to the environment. This export makes the variable available to child processes

- calling programs with environment variables 

sort program uses locale settings to decide the sort order for some strings – specifically, it uses the LANG or LC_COLLATE environment variables

```
$ printf '%s\n' 'alligator' 'Alfred' >words
$ LC_COLLATE=en_US.UTF-8
$ export LC_COLLATE
$ sort words
alligator
Alfred
```
- expanding variables 

$ realname='Bash User'
$ printf '%s\n' "Hello, $realname."

use curly brackets:

$ printf '%s\n' "__Hello, ${realname}__"

    + not exist expanding, by default Bash does not issue any warnings; it just replaces the variable with an empty string
    
$ printf '%s\n' "Hello, $notset."
Hello, .

    + explicit throw error for an empty variable 
    
bash$ set -u
bash$ printf '%s\n' "Hello, $notset."
bash: notset: unbound variable

- reading a value into a variable 

$ read -r myname

Ctrl + D (end-of-file) after pressing Enter after the last preceding line; the entire first line of input will be used as the value for myname

always use the -r option with read, to avoid running into confusing issues with reading backslashed values.

- getting command to output variables 

$ myuser="$(whoami)"
$ printf '%s\n' "$myuser"
bashuser

inner expansion to suppress unwanted expansion:

$ mypwent="$(getent passwd "$(whoami)")"

backticks (`) used for command substitution. Bash still allows this syntax so that older scripts can run, but you should prefer the $(command) syntax to `command`

- parameter expansion forms 

$ prompt for POSIX specified forms 

- specify default values 

use the :- form "${myvar:-default}", where default is the string you want to use instead of the variable's value if it's unset or blank. 


$ cd -- "${MYSCRIPT_DIR:-/usr/local/myscript}"

use the := characters instead of :-, you can additionally assign the default value to the environment variable for the rest of the script

$ cd -- "${MYSCRIPT_DIR:=/usr/local/myscript}"

- string chopping 

The "${myvar#prefix}" form removes one occurrence of prefix from the variable's expansion
```
$ ta='type:json'
$ printf 'Type: %s\n' "${ta#type:}"
Type: json
```

a string from the end of the value instead using % instead of #
```
$ ta='type:json'
$ printf 'Field name: %s\n' "${ta%:*}"
Field name: type
```

escape or quote them:
```
$ text='*WARNING'
$ printf '%s\n' "${text#\*}"
WARNING
```

chop the longest possible match of a pattern with * in it, double the applicable sign: # becomes ##, and % becomes %%.
```
$ path=/usr/local/myscript/bin/myscript
$ printf 'Filename with path removed: %s\n' "${path##*/}"
Filename with path removed: myscript
```

- extracting substrings 

use the ${var:start} or ${var:start:length} form
```
bash$ title='== Password =='
bash$ printf '%s\n' "${title:3}"
Password ==
bash$ printf '%s\n' "${title:3:8}"
Password
```

specifying a negative start value, you can start the counting from the end of the string, starting at -1

```
$ alpha='abcdefghijk'
$ printf '%s\n' "${alpha: -3:2}"
```

- get string length 

${#myvar}" form can be used to expand to the length of a string, counts characters according to your locale, not bytes

```
bash$ alpha='abcdefghijk'
bash$ printf '%u\n' "${#alpha}"
11
```
a short and convenient alternative to counting characters with wc.

- substituting strings 

```
bash$ promise='I'\''ll do it today.'
bash$ printf '%s\n' "${promise/today/tomorrow}"
```



# Loop and conditionals 



# Scripts, Functions and Aliases 



# Best practices 

