Microsoft online document, Microsoft interface definition language (MIDL);Note=Erxin

# Reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-start-page



# Purpose 
- MIDL can be used in all client/server applications based on Windows operating systems.
- network environments that include such operating systems as Unix and Apple. Microsoft supports the Open Group (formerly known as the Open Software Foundation) DCE standard for RPC interoperability.

- MIDL compiler generates C-language files from IDL files.

- Application Configuration (ACF) files for MIDL


# Using MIDL compiler 
- invoking the compiler 

command line using the following command:

$ midl <options> filename.idl

MIDL compiler /help and /? switches

    + remarks 

The new global flag $(MIDL_OPTIMIZATION) exists in win32.mak. When an .idl file is compiled using this flag, the generated stub can utilize the latest RPC features available

- response files. A response file is a text file containing one or more MIDL compiler command-line options. 

You can specify a MIDL response file as, include one or more response files, with commandline parameters 

$ midl -Oicf @midl1.rsp -envwin32 @midl2.rsp itf.idl

- Using C/C++ preprocessor with MIDL 

By default, MIDL uses the preprocessor for the Microsoft C/C++ compiler from the same building environment

MIDL spawns separate preprocessor runs for top-level IDL and ACF files

included with the #include directive are handled by the preprocessor directly.

- C-preprocessor requirements for MIDL 

The MIDL switches /cpp_cmd, /cpp_opt, and /no_cpp are used to override the default behavior of the compiler.

the MIDL compiler switch /cpp_cmd enables an override of the default C/C++-preprocessor 

$ midl /cpp_cmd preprocessor_name idl-filename 

In the output stream of the preprocessor, the #line directives are present to enable better diagnostic messages.

The preprocessor must redirect output to the standard output device, stdout.

for the Microsoft C/C++ preprocessor the /E option would have to be used

$ midl /cpp_cmd cl.exe /cpp_opt "/E" file.idl

the #line directive in MIDL 
```
#line digit-sequence "filename" new-line
 
# digit-sequence "filename" new-line
```

if the /no_cpp switch is used, the input file must not have other preprocessor directives

- dealing with #defines in IDL files 

explanation applies to any files processed by MIDL, such as *.idl, *.acf, *.h files.

when MIDL replicates type definitions from an input file to the generated H file, the #defines are not replicated, do not use #defines directly in IDL files if they are to be used later from the generated H file

    + workarounds 
    
    Use the const declaration specification.
    
    ```
    const short ARRSIZE = 10
    ```
    
    will be compiled to 
    
    ```
    #define ARRSIZE 10
    ```

    Use separate header files that are imported or included in the IDL file, and later included in the C-source code.
    
    Use enumeration constants in the IDL file.

    Use cpp_quote to reproduce #define in the generated header file.
    
    handle **#**define statements is to package them in a separate header file, either into a file devoted to **#**define statements or into a file that contains only type definitions

    Importing a header or IDL file to another IDL file prevents the typedef statements from being replicated to the H file generated by MIDL 
    
    ```
    typedef enum midlworkaround { MAXSTRINGCOUNT = 300 };
    ```
    
    cpp_quote directive of MIDL can be used to write out an arbitrary string directly into the generated H file.
    ```
    cpp_quote ("#define ARRSIZE 10")
    ```
    
- verifying preprocessor options 

MIDL /cpp_opt switch, the preprocessor command line is composed of all the /I, /D and /U switches used in the MIDL command line, as well as /E and /nologo switches

To see the switches passed on to the preprocessor, use the compiler's /confirm switch.

- saving preprocessor output 

easiest and the least obtrusive way to obtain the preprocessed files from a MIDL compile run is to use the -savePP switch. The -savePP switch simply prevents MIDL from deleting the temporary files

$ midl -savePP -Id:\nt\public\sdk\inc -DNTENV=1 -Oicf -env win32 stub.idl


/E /nologo are the switches that MIDL adds when invoking the preprocessor
```
$ cl /E /nologo -Id:\nt\public\sdk\inc -DNTENV=1 stub.idl > stub.pp
$ cl /E /P -Id:\nt\public\sdk\inc -DNTENV=1 stub.idl
```


The /cpp_opt switch can also be used to obtain a preprocessed file
```
$ Midl -Oicf -win32 -cpp_opt "/E /P -Id:\nt\public\sdk\inc -DNTENV=1" stub.idl
```

- C/C++ compiler considerations 

    + natural alignment 

    A base type, such as short, float and __int64, and a pointer is aligned naturally
    
    base types have sizes of 1, 2, 4 or 8. Pointers have a size of 4 in 32-bit environments and 8 in 64-bit environments
    
    + A compound type is aligned naturally if each of its components is aligned naturally relative to the beginning of the type
    
    + connection between alignment and memory size of a type in languages like C or C++ and IDL as expressed by the operator sizeof(). The size is a multiple of the alignment
    
    Natural alignment is important because accessing misaligned data may cause an exception on some systems
    
    Data can be marked for a safe manipulation when misaligned, but typically that involves a speed penalty that may be substantial on some platforms
    
    + simple rule, new alignment of a packed type is the smaller of the packing level and its natural alignment. 
    
    a multiple of the new alignment. The sizeof() operator returns the reduced size for packed types.
    
    + 1 byte character 
    
```
struct mystructtype 
{    
    char c1;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
    long l2;  /* requires 4 bytes */
    char c3;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
 } mystruct;
```

This structure is naturally aligned at 4 and has the natural size of 12. will be misaligned if located in memory at an address that is not a multiple of 4

packing level 2, the structure is aligned at 2 and its size is 8. will be misaligned if located in memory at an address that is not a multiple of 2.

packing level 1, the structure is aligned at 1 and its size is 6, The structure packed with level 1 can be placed anywhere without causing a misalignment fault.

- C-Compiler definitions for proxy/stubs 

macros are invoked with the /D (or -D) preprocessor switch at the C-compile time
    
REGISTER_PROXY_DLL, 	Generates DllMain, DllRegisterServer, and DllUnregisterServer, self-register your proxy DLL in the system registry.

PROXY_CLSID=<clsid>, 	Specifies a class identifier for the server. I

PROXY_CLSID_IS={0x8hexdigits, ... {0x2hexdigits,0x2hexdigits,...}}      specify server's class id in binary hex format 

PROXY_CLSID=<clsid> macro when you want to explicitly specify the proxy/stub server's CLSID 

default DllRegisterServer function runs, it registers the server with ThreadingModel=Both.

makefile example 
```
example.h example.tlb example_p.c example_i.c dlldata.c : example.idl
    midl example.idl
dlldata.obj : dlldata.c
    CL /c /DWIN32 /DREGISTER_PROXY_DLL dlldata.c
example.obj : example_p.c
    CL /c /DWIN32 /DREGISTER_PROXY_DLL \
    /DPROXY_CLSID=7a98c250-6808-11cf-b73b-00aa00b677a7
example_p.c
iids.obj : example_i.c
PROXYSTUBOBJS = dlldata.obj example.obj iids.obj
PROXYSTUBLIBS = kernel32.lib rpcns4.lib rpcrt4.lib uuid.lib
proxy.dll : $(PROXYSTUBOBJX) example.def
    link /dll /out:proxy.dll /def:example.def
        $(PROXYSTUBOBJS) $(PROXYSTUBLIBS)
    regsvr32 /s proxy.dll
```

- using the __midl predefined constant 

MIDL compiler processes the input IDL and ACF files, __midl is defined by default and is used for conditional compilation to attain consistency throughout the build

example MIDL ver. 6.0.x has the __midl defined as 600.

/U switch removes any previous definition of a name by passing the name to the C preprocessor 

$ midl /U name 

- MIDL and RPC 

The MIDL compiler generates the C-language stub and header files necessary to create the interface between the client application and the server application

    + client stub 
    
    MIDL compiler switches /client, /cstub, and /out affect the client stub file.
    
    + server stub 
    
    MIDL compiler switches /server, /sstub, and /out affect the server stub file.
    
    + the header file 
    
    the generated header file contains an include line to the H file generated from the imported file. the files included with the #include directive. 
    
    MIDL compiler switches /header and /out affect the header file.
    
    + targeting stubs for specific 32 bit or 64 bit platforms
    
    Microsoft RPC and the MIDL 3.0 
    
    MIDL generates two types of guards: a platform-dependent guard (32-bit versus 64-bit) and a release-dependent guard (feature set dependency).
    ```
    #if !defined(__RPC_WIN32__)
    #error  Invalid build platform for this stub.
    #endif
    ```
    
    if the interface uses features supported only on WindowsÂ 2000 or later, MIDL generates a guard with the TARGET_IS_NT50_OR_LATER macro.
    
    The guard macros, defined in Rpcndr.h, depend on the setting of WINVER and _WIN32_WINNT and are evaluated by the C/C++ compiler.
    
    ```
    CFLAGS = $(CFLAGS) -D_WIN32_WINNT=0x500
    ```

- MIDL and COM 

the MIDL compiler combines all client and object server auxiliary routines and data into a single interface proxy file

the MIDL compiler generates an interface header file, an interface UUID file and an interface registration file. You will use all these files when creating a proxy DLL
    
    + the interface proxy file 
 
interface proxy file (U_p.c) is a C file that contains routines equivalent to those in the client stub and server stub files of an object (COM) interface

The interface proxy file includes the supporting routines and data only for methods of the interfaces defined in the current IDL file

proxy file contains the following two surrogate methods when compiled in the mixed mode (/Os), and equivalent interpreter data when compiled in the interpreter mode (/Oi).

        * The client-side surrogate, such as IFaceB_Method_Proxy 
    
        * The server-side surrogate, for example, IFaceB_Method_Stub

name for a proxy file generated from a file.idl is file_p.c.Use the /proxy MIDL compiler switch to override the default name

    + header file

    The default name for a header file generated from a file.idl is File.h, The /header MIDL compiler switch overrides the default name 

    + interface uuid file 
    
    IID file generated from a file.idl is File_i.c. The /iid MIDL compiler switch overrides the default name of the interface UUID file.
    
    + the interface registration file 
    
    interface registration file collects information that helps in the registration of COM interfaces packaged into a DLL or EXE file.
    
    the MIDL compiler implements a timeout approach to waiting on a file it cannot open,

    an input file is dlldata.c. The /dlldata MIDL compiler switch can be used to override the default name of the file
    
    + marshaling OLE data types 
    
    To use the BSTR data type in remote procedure calls, import the wtypes.idl file into your interface definition (IDL) file and link to Oleaut32.lib, your stubs use the ready-made helper functions BSTR_UserSize, BSTR_UserMarshal, BSTR_UserUnmarshal, and BSTR_UserFree.
    
    To use other Automation data types, such as VARIANT and SAFEARRAY, or types that use those types (for example, DISPPARAMS and EXCEPINFO), import the objidl.idl file into your IDL file and link to the oleaut32.lib at build time.
    
    To use OLE data types (such as CLIPFORMAT, SNB, STGMEDIUM, ASYNC_STGMEDIUM), or system handles (such as HMETAFILE_PICT, HENHMETAFILE, HMETAFILE, HBITMAP, HPALETTE, and HGLOBAL), import the objidl.idl file into your interface definition file and link to the ole32.lib
    
    The following OLE handles are also defined with the [wire_marshal] attribute, but only as handles within a computer since they cannot be used in remote procedure calls to other computers at this time: HWND, HMENU, HACCEL, HDC, HFONT, HICON, HBRUSH. Import the objidl.idl file into your IDL file and link to ole32.lib at build time to use these handles in interprocess communication on a single computer.
    
    more info, see The wire_marshal Attribute, The type_UserSize Function, The type_UserMarshal Function, The type_UserUnmarshal Function, The type_UserFree Function, and Targeting Stubs for Specific 32-bit or 64-bit Platforms.
    
- MIDL and ODL 


Microsoft Interface Definition Language (MIDL) now includes the complete Object Definition Language (ODL) syntax. generate a type library and optional header files for a COM application.


the documentation refers to an ODL file, it is referring to a file that Mktyplib.exe can parse. When it refers to an IDL file, it is referring to a file that the MIDL compiler can parse. 

    + reference 
    https://docs.microsoft.com/en-us/windows/win32/midl/midl-and-odl
    
- MIDLRT and windows runtime components 

    + reference 
    https://docs.microsoft.com/en-us/windows/win32/midl/midlrt-and-windows-runtime-components
    
- interface definitions and type libraries 

interface definition language (IDL) files and application configuration files (ACF) for MIDL, how to import files, type libraries, and system header files.

    + interfaces in distributed objects 

Applications based on remote procedure calls (RPC), Component Object Model (COM), and Distributed Component Object Model (DCOM) specify their interfaces using MIDL.

    + COM, DCOM, type libraries 
    
    type library, A type library (.tlb) is a binary file that stores information about a COM or DCOM object's properties and methods in a form that is accessible to other applications at runtime.
 
    The COM/DCOM run-time environment can also use a type library to provide automatic cross-apartment, cross-process, and cross-machine marshaling for interfaces described in type libraries.
    
    + characteristics of an interface 
    
    The IDL file specifies the characteristics of the application's interfaces on the wire 
    
    The ACF file specifies interface characteristics, such as binding handles, that pertain only to the local operating environment. The ACF file can also specify how to marshal and transmit a complex data 
    
    + interface definition file (IDL)
    
        * data types in the body 
        
        The interface body, which is enclosed in braces ({ }), contains the data types be used in RPC 
        
        OSF-DCE specification for RPC interfaces does not allow multiple interfaces in a single IDL file. Therefore, if you are compiling in MIDL's OSF-compatibility mode ( /osf), your IDL file can contain only one interface
        
    ```
    interface ITwo; //forward declaration
    interface IOne 
    {
    ...uses ITwo...
    }
    interface ITwo 
    {
    ...uses IOne...
    }    
    ```
        
    + type definition construct declarations and imports 
    
    multiple interfaces are not permitted when you use the /osf switch
    
    The import keyword specifies the names of one or more IDL files to import
    
        * constant declaration specifies Boolean, integer, character, wide-character, string, and void * constants. For more information, see const
        
        * A general declaration is similar to the C typedef statement with the addition of IDL type attributes
        
        * function 
    ```
[ 
    uuid(12345678-1234-1234-1234-123456789ABC), 
    version(3.1), 
    pointer_default(unique) 
] 
interface IdlGrammarExample 
{ 
    import "windows.idl", "other.idl"; 
    const wchar_t * NAME = L"Example Program"; 
    typedef char * PCHAR; 
 
    HRESULT DictCheckSpelling( 
        [in, string] PCHAR   word,     // word to look up 
        [out]        short * isPresent // 0 if not present 
    ); 
}
    ```
        
- IDL attributes 

    + Field Attributes
    + Aliasing and Marshaling Attributes
    
    This format, the Network Data Representation (NDR) format, is often called the wire format of the data
    
    marshaling the data, stubs must convert data from its native format in the program's memory space to NDR
    
    unmarshaling the data, t convert the data from NDR to the native format for that program.
    
call_as 	    Maps a nonremotable function to a remote procedure call.
iid_is 	        Provides the interface identifier of the COM interface that is the object of the pointer.
transmit_as 	Converts a data type to a simpler type for transmission over a network.
wire_marshal 	Similar to transmit_as but you implement the routines to size, marshal, unmarshal, and free the data.
    
    + Asynchronous Attributes
    
    An asynchronous procedure returns immediately without waiting for results
    
async 	    When applied to a function parameter, defines a handle that allows the caller to make an asynchronous call
    
async_uuid 	Directs the MIDL compiler to define both synchronous and asynchronous versions of a COM interface.

maybe 	    The client making this remote procedure call does not expect any response indicating delivery or completion of the call, and delivery is not guaranteed. 

message 	The remote procedure call is to be treated as an asynchronous message from the client to the server. The client makes the call and returns immediately
    
    + Array and Sized-Pointer Attributes

    specify characteristics of arrays and multiple levels of pointers
    
    size_is 	Specifies the amount of memory to be allocated for sized pointers, sized pointers to sized pointers, and single- or multidimensional arrays
    
    max_is 	The maximum value for an array index.
    
    length_is 	The number of array elements to be transmitted.
    
    first_is 	The index of the first array element to be transmitted.
    
    last_is 	Gives the index of the last array element to be transmitted.
    
    string 	Indicates that the one-dimensional char, wchar_t, byte (or equivalent) array, or the pointer to such an array, is to be handled as a string.
    
    range 	Specifies a range of allowable values for arguments or fields whose values are set at runtime.
    
        + reference pointers, unique pointers, and full pointer
        
        pointer attributes ref, unique, and ptr
        
        + A pointer attribute can be applied as a type attribute; as a field attribute that applies to a structure member, union member, or parameter; or as a function attribute return type, can also appear with the pointer_default keyword.
        
        + To apply different pointer attributes to multiple pointer declarators, you must define intermediate types 
        
        + pointer attributes using the following priority rules
        
        Attributes explicitly applied to the pointer type
        Attributes explicitly applied to the pointer parameter or member
        The pointer_default attribute in the IDL file that defines the type
        The pointer_default attribute in the IDL file that imports the type
        ptr (osf mode); unique (Microsoft RPC default mode)
        
        + pointer attribute can be inherit when import into another file, by default. Compile with /osf will not support 
        
        + A pointer returned by a function must be a unique pointer or a full pointer.
        
        + specify a pointer attribute at the top level of a typedef statement, the specified attribute is applied to the pointer declarator, as expected.
        

    + Data Type Attributes
    
    data types in a typedef statement to further define the usage or effect of the data type.
    
    context_handle 	Identifies a binding handle that maintains state (context) information
    
    handle 	Specifies a custom handle type specific to the application.
    
    ms_union 	Controls the NDR alignment of nonencapsulated unions. 
    
    pipe 	Allows transmission of an open-ended stream of typed data across a remote procedure call.
    
    transmit_as 	Specifies how a data type will be transmitted over a network, used for custom marshaling.
    
    v1_enum 	Directs that the specified enumerated type be transmitted as a 32-bit entity instead of 16 bit default 
    
    wire_marshal 	Similar to transmit_as but you implement the routines to size, marshal, unmarshal, and free the data.
    
    + Directional Attributes
    
    in 	The parameter is being passed from the caller to the called function.
    
    out 	The parameter is being passed from the called function to the caller.
    
    + Function Call Attributes
    
    message 	The remote procedure call is to be treated as an asynchronous message from the client to the server. 
    
    maybe 	The client making this remote procedure call does not expect any response indicating delivery or completion of the call. 
    
    broadcast 	The remote procedure call is to be sent to all of the servers on the network. 
    
    idempotent 	The call does not change state and returns the same information each time it is called with the same input parameters.
    
    callback 	Designates a function that resides in the client application, which the server can call to obtain information from the client.
    
    call_as 	Maps a nonremotable function to a remote procedure call.
    
    local 	Designates a local procedure for which MIDL does not generate stub code.
    
    
    + Interface Header Attributes
    
    async_uuid 	Directs the MIDL compiler to define both synchronous and asynchronous versions of a COM interface.
    
    uuid 	Designates a 128-bit value that distinguishes a particular interface from all others. the value may represent a GUID,  a CLSID or an IID 
    
    local 	Directs the MIDL compiler to generate header files only. 
    
    ms_union 	Controls the NDR alignment of nonencapsulated unions. 
    
    object 	Identifies the interface as a COM interface and directs the MIDL compiler to generate proxy/stub code
    
    version 	Identifies a particular version of an interface in cases where multiple versions of the interface exist. 
    
    pointer_default 	Specifies the default pointer type for all pointers except for those included in parameter lists.  type can be unique, ref, or ptr.
    
    endpoint 	Specifies a static (well-known) endpoint on which a server application listen 
    
    + Performance Attributes
    
    ignore 	Designates that a pointer contained in a structure or union and the object indicated by the pointer is not to be transmitted.
    
    local 	Designates a function that is local to the application for which MIDL does not need to generate stub code.
    
    wire_marshal 	Defines a data type as a simpler type for transmission over a network and allows you to implement marshaling and unmarshaling
    
    + Pointer Type Attributes
    ptr 	Designates a pointer as a full pointer, with all the capabilities of a C-language pointe
    
    ref     Designates a reference pointer, one that simply provides the address of some data. Reference pointers can never be null.
    
    unique 	Lets a pointer be null, but does not support aliasing.
    
    pointer_default 	Applied to an interface to specify the default pointer type for all pointers in that interface except top-level parameter pointers, which automatically default to ref pointers.
    
    iid_is 	Provides the interface identifier of the COM interface the object of the pointer 
    
    string 	Specifies that the pointer points to a string.
    
    + Structure and Union Attributes
    
    switch_* attributes to specify the characteristic of a union in a remote procedure call
    
    switch 	Selects the discriminant for an encapsulated union.
    
    switch_is 	Identifies the discriminant for a nonencapsulated union.
    
    switch_type 	Identifies the type of the discriminant for a nonencapsulated union.
    
    ignore 	Designates that a pointer contained in a structure or union and the object indicated by the pointer is not to be transmitted.
    
    + Type Library Attributes
    
    aggregatable 	Defines the coclass as supporting objects that can directly expose another object's interface pointer.
    
    appobject 	Identifies the coclass as an application object, which is associated with a full EXE application.
    
    bindable 	Indicates that the property supports data binding.  allows the client to be notified a property has changed 
    
    coclass 	Provides a listing of the supported interfaces for a component object.
    
    control 	Identifies a coclass or library as a COM control, from which a container site
    
    custom 	Defines a custom attribute (one not defined in MIDL).
    
    default 	Indicates that the interface or dispinterface, defined within a coclass, represents the default interface.
    
    defaultbind 	Indicates the single, bindable property that best represents the object.
    
    defaultcollelem 	Flags the property as an accessor function for an element of the default collection. 
    
    defaultvalue 	Allows specification of a default value for a typed optional parameter.
    
    defaultvtable 	Allows an object to have two different source interfaces.
    
    dispinterface 	Defines a set of properties and methods on which you can call IDispatch::Invoke.
    
    displaybind 	Indicates a property that should be displayed to the user as bindable.
    
    dllname(str) 	Defines the name of the DLL that contains the entry points for a module.
    
    dual 	Identifies an interface that exposes properties and methods both through IDispatch and directly through the Vtable.
    
    entry 	Specifies an exported function or constant in a module by identifying the entry point in the DLL.
    
    helpcontext 	Specifies a context identifier that lets the user view information about this element in the Help file.
    
    helpfile 	Sets the name of the Help file for a type library.
    
    helpstring 	Specifies a character string that is used to describe the element to which it applies.
    
    helpstringdll 	Sets the name of the DLL to use to perform the document string lookup.
    
    hidden 	Indicates that the item exists but should not be displayed in a user-oriented browser.
    
    id 	Specifies a DISPID for a member function
    
    immediatebind 	Indicates that the database will be notified immediately of all changes to a property of a data-bound object.
    
    lcid 	When applied to the library statement, along with a localeID argument, identifies the locale for a type library or for a function argument and lets you use international characters
    
    library 	Instructs the MIDL compiler to generate type library information for the interfaces and classes referenced inside the statement.
    
    licensed 	Indicates that the coclass to which it applies is licensed, and instances must be created using IClassFactory2.
    
    nonbrowsable 	Indicates that the property appears in an object browser but not appear in a property browser which show property value 
    
    noncreatable 	Prevents a client from using the default class factory to create instances of an object interface.
    
    nonextensible 	Specifies that the IDispatch implementation includes only the properties and methods listed in the interface description and cannot be extended
    
    ```
[
    uuid(uuid-number), 
    nonextensible 
    [, optional-attribute-list]
] 
interface | dispinterface interface-name 
{
    interface-definition
}
    ```
    
    oleautomation 	Indicates that an interface is compatible with automation.
    
    optional 	Specifies an optional parameter for a member function.
    
    propget 	Specifies a property accessor function.
    
    propput 	Specifies a property-setting function.
    
    propputref 	Specifies a property-setting function that uses a reference instead of a value.
    
    public 	Ensures that an alias declared with typedef becomes part of the type library.
    
    readonly 	Prohibits assigning a new value to a variable.
    
    requestedit 	Indicates that the property supports the OnRequestEdit notification.
    
    restricted 	Specifies that a library, or member of a module, interface, or dispinterface cannot be called arbitrarily.
    
    retval 	Designates the parameter that receives the return value of the member.
    
    source 	Indicates that a member of a coclass, property, or method is a source of events.
    
    string 	Indicates that the one-dimensional char, wchar_t, byte (or equivalent) array or the pointer to such an array must be treated as a string.
    
    uidefault 	Indicates that the type information member is the default member for display in the user interface.
    
    usesgetlasterror 	Specifies that a module entry point uses SetLastError to return error codes and that a caller can then call GetLastError to retrieve the error code if there is an error on entering a function.
    
    uuid 	Designates a unique identifier for a type library, coclass, or interface.
    
    vararg 	Specifies that the function takes a variable number of arguments.
    
    version 	Identifies a particular version of a type library.
    
- application configuration file, ACF 

Client may each need their own set of marshaling routine. It is inefficient to generate stub code for functions that will never be implemented in a particular client application.

local aspects of your interface in an application configuration file (ACF), you can separate the differences between the client interfaces from their network representation, allowing the server to send and receive data in a consistent format

```
[ interface-attribute-list] interface interface-name {. . .}
```

However, when you use the MIDL compiler option / acf to explicitly specify an ACF file name, the interface names do not have to match

- ACF attributes 

    + binding ACF attributes 
    
    async 	                Defines a handle that allows the caller to make an asynchronous call and return immediately without waiting for results
    
    auto_handle 	        Tells MIDL to let the stub code control the binding automatically. 
    
    context_handle_noserialize 	Guarantees that a context handle will never be serialized, regardless of the application's default behavior.
    
    context_handle_serialize 	Guarantees that a context handle will always be serialized, regardless of the application's default behavior
    
    explicit_handle 	    Lets the client application control the binding with an explicit parameter in each procedure.
    
    implicit_handle 	    Specifies a handle for procedures that do not have an explicit handle parameter.
    
    strict_context_handle 	Guarantees that the methods in the interface will only accept context handles that were created by a method of that interface.
    
    + stub optimization ACF attributes 
    
    codenocode 	Use the code and nocode attributes together to avoid generating stub code for unused functions. 
    
    optimize 	Lets you fine-tune the level of optimization that the MIDL compiler performs when generating stub code, by specifying that data is to be marshaled by either the mixed-mode or interpreted method. 
    
    + type conversion and marshaling ACF attributes 
    
    encodedecode 	Instructs MIDL to expose the type or procedure serialization (pickling) routines it generates for the stubs. 
    
    represent_as 	Specifies how a data type will be represented on the wire, when the exact nature of a client's data type is unimportant to the server
    
    user_marshal 	Controls how data is transmitted over the wire by implementing your own marshaling routines. 
    
    + memory management ACF attributes 
    
    allocate 	Specifies the way the client application and stub allocate and release memory for pointers. 
                allocate attribute to direct the stub to compute the size of all memory referenced through the pointer of the specified type and to make a single call to midl_user_allocate.
                
    byte_count 	Enables you to create a persistent, contiguous block of memory that can be reused over multiple remote procedure calls.             
    
    enable_allocate 	Specifies that the server stub code should enable the stub memory-management environment.
    
    + error and exception handling Acf attribute 
    
    comm_statusfault_status 	Let your client application handle exceptions gracefully by causing communication and server errors to be returned to the client as parameter values. 
    
    + using ACF attributes in an IDL file 
    
    You can use the /app_config MIDL compiler option to specify binding handle attributes in the IDL file rather than in a separate ACF file.
    
    apply the auto_handle, implicit_handle, and explicit_handle attributes to the header of an RPC interface in an IDL file.
    
- MIDL data types 

    + MIDL Base Types
    boolean 	8 bits. Not compatible with oleautomation interfaces; use VARIANT_BOOL instead.
    
    byte 	8 bits.
    char 	8 bits.
    double 	64-bit floating point number.
    error_status_t 	32-bit unsigned integer for returning status values for error handling.
    float 	32-bit floating point number.
    handle_t 	Primitive handle type for binding.
    hyper 	64-bit integer.
    int 	32-bit integer. On 16-bit platforms, cannot appear in remote functions without a size qualifier such as short, small, long or hyper.
    
    __int8 	8-bit integer. Equivalent to small.
    __int16 	16-bit integer. Equivalent to short.
    __int32 	32-bit integer. Equivalent to long.
    __int3264 	An integer that is 32-bit on 32-bit platforms, and is 64-bit on 64-bit platforms.
    __int64 	64-bit integer. Equivalent to hyper.
    long 	32-bit integer.
    short 	16-bt integer.
    small 	8-bit integer.
    void 	Indicates that the procedure does not return a value.
    void * 	32-bit pointer for context handles only.
    wchar_t 	16-bit predefined type for wide characters.
    
        * singed and unsigned types 
        
        DCE IDL compilers do not recognize the keyword signed. Therefore, this feature is not available when you use the MIDL compiler /osf switch.
        
        Visual C++ development environment, the /J command-line option changes the default sign of char from signed to unsigned.
        
        control the sign of variables of type char and small with the MIDL compiler command-line switch /char. This switch allows you to specify the default sign used by your compiler. 
        
        * other MIDL data types 
        
        MIDL recognizes a number of COM and Automation data types, such as BSTR, VARIANT, and SAFEARRAY, and COM handles, such as HMETAFILE_PICT, HENHMETAFILE, HMETAFILE, HBITMAP, HPALETTE, and HGLOBAL. 
        
    + MIDL Arrays
    
    An expression that evaluates to n signifies a lower bound of zero and an upper bound of n - 1.
    
    two values separated by an ellipsis that represent the lower and upper bounds of the array, as in [lower...upper].
    
    field attributes size_is, max_is, length_is, first_is, and last_is to specify the size of the array or the part of the array
    
    An array is called "conformant" if the upper bound of any dimension is determined at runtime.
    
    the array declaration must include a size_is or max_is attribute.
    
```
/* IDL file interface body */ 
#define MAX_INDEX 10 
 
typedef char  ATYPE[MAX_INDEX]; 
typedef short BTYPE[];        // Equivalent to [*]; 
typedef long  CTYPE[*][10];   // [][10] 
typedef float DTYPE[0..10];   // Equivalent to [11] 
typedef float ETYPE[0..(MAX_INDEX)];  
 
typedef struct 
{ 
    unsigned short size; 
    unsigned short length; 
    [size_is(size), length_is(length)] char string[*]; 
} counted_string; 
 
HRESULT MyFunction( 
     [in, out] short * pSize,  
     [in, out, string, size_is(*pSize)] char a[0..*] 
);
```

    RECT_TYPE can be defined as a two-dimensional array and the variable rect can be defined as an array of RECT_TYPE. 
    
    Microsoft RPC is C oriented. Following C-language conventions, only the first dimension of a multidimensional array can be determined at runtime.
    
    when the [string] attribute is used on multidimensional arrays, the attribute applies to the rightmost array
    
    The client application must allocate all memory for an [in] or [ in,out] array of reference pointers, [in], or [ in,out], [length_is], or [last_is] values.
    
    When embedded reference pointers are [out]-only parameters, the server-manager code must assign valid values to the array of reference pointers.
    
    ···
    typedef [ref] short * ARefPointer;
    typedef ARefPointer ArrayOfRef[10];
    HRESULT proc1( [out] ArrayOfRef Parameter );
    ···
    
    + MIDL Type Definitions
    
    follow c++ 
    
    + MIDL Enumerated Types
    
    The enum declaration is not translated by the MIDL compiler into #define statements, reproduced as a C-language enum declaration
    
    + MIDL Structures
    
    Fields of more complex types, such as pointers, arrays, and other constructed types, can be modified by type or field_attributes.
    
    + MIDL Unions
    
    a superset of the C/C++ union statement. MIDL provides two varieties of unions. 
    
    The encapsulated union is indicated by the presence of the switch keyword. 
    
    + MIDL Binding Handles

    the compiler will generate the structure with the union field named tagged_union.

    shape of unions must be the same across platforms to ensure interconnectivity.

```
typedef union _S1_TYPE switch (long l1) U1_TYPE 
{ 
    case 1024: 
        float f1; 
    case 2048: 
        double d2; 
} S1_TYPE; 
 
/* in generated header file */ 
typedef struct _S1_TYPE 
{ 
    long l1; 
    union 
    { 
        float f1; 
        double d2; 
    } U1_TYPE; 
} S1_TYPE;
```

    + noneencapsulated unions 
    
    nonencapsulated union is indicated by the presence of the type attribute [switch_type] and the field attribute [switch_is].
    
    + MIDL binding handles 
    
    MIDL supports the base type handle_t. Handles of this type are known as "primitive handles." support [handle] attribute 
    
    Handles defined in this way are known as "user-defined" or "customized" or "generic" handles.
    
    a handle that maintains state information using the [context_handle] attribute
    
    the RPC run-time libraries to manage the handle, you can request that the run-time libraries provide automatic binding, ACF keyword [auto_handle]
    
    a global variable, ACF keyword [implicit_handle]. The [explicit_handle] keyword is used to state that each remote function has an explicitly specified handle.

- importing files and type libraries 

+ The MIDL keywords include, import, and importlib let you reuse code by referencing existing header

    The generated file will have a line with a #include C-preprocessor directive with the indicated header file
    
    include directive lets you specify in an ACF file one or more C-language header files 
     
    use import directive to import a file to be used with IDL, the import directive ignores procedure prototypes, since no stubs are generated for anything in the imported file. 
    
    ```
[
  auto_handle
] 
interface X86PC
{ 
  include "gendefs.h", "protos.h", "myfile.h"; 
  //interface typdefs and function declarations here
}    

[
  uuid(. . .), object
] 
interface IKnown : IUnknown
{
  import "base.idl", "unknwn.idl", "helper.idl";
  //remainder of interface definition
}
    ```
    
    ODL importlib directive lets you reference a compiled type library in your IDL or ODL file. 
    
    The importlib directive must be inside a library statement, and must precede other type descriptions in the library
    
```
library NewBrowser
{
  importlib("stdole32.tlb");
  importlib("legacy.tlb");
  //remainder of library definition
};
```

- importing system header files 
    
use the #include directive to include header files in your IDL file, it is not recommended. The MIDL compiler will generate stubs for all functions defined in the IDL file being compiled.

include type definitions from header files in an IDL file

    + Use the import directive to include data types defined in a header file.
    
    + Create a helper IDL file with a dummy interface that includes the header files. only the typedefs will appear in the compiled stubs
    
```
//in helper.idl:
interface dummy
{ 
   #include "kitchensink.h"
   #include "system.h"
}

//in main.idl:
import "helper.idl";
```
    

# MIDL commandline reference 
- reference
https://docs.microsoft.com/en-us/windows/win32/midl/midl-command-line-reference
- remarks 

By default generation 
    Client stub (name_c.c)
    Server stub (name_s.c)
    Header file (name.h)

When the object attribute appears in the interface attribute list, COM interface:

    Interface proxy file (name_p.c)
    Interface header file (name.h)
    Interface UUID file (name_I.c)
    
When the local attribute appears in the interface attribute list, the compiler generates only the interface header file, Name.h.

The MIDL compiler provided with Microsoft RPC invokes the C preprocessor as needed to process the IDL file

The MIDL compiler switches /env, /server, /sstub, and /out affect the server stub file.

The MIDL compiler switches /header and /out affect the header file.

- the response file command 

A response file is a text file containing one or more MIDL compiler command-line options. 


# MIDL language reference 
- reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-language-reference

- This topic lists the reserved keywords in MIDL.

    + List of keywords that are reserved

FALSE

ISO_LATIN_1

ISO_UCS

ISO_MULTI_LINGUAL

NULL

SAFEARRAY

TRUE

__alignof

__asm

__cdecl

__declspec

__export

__external_symbol

__far

__fastcall

__float128

__float80

__fortran

__huge

__inline

__int128

__int32

__int3264

__int64

__interface_interception_info

__loadds

__method_property

__near

__pascal

__ptr32

__ptr64

__saveregs

__segment

__self

__stdcall

__unaligned

__w64

__winrt_type_serialization_info

_asm

_cdecl

_declspec

_export

_far

_fastcall

_fortran

_huge

_inline

_loadds

_near

_pascal

_saveregs

_segment

_self

_stdcall

auto

boolean

byte

case

cdecl

char

coclass, The coclass statement provides a listing of the supported interfaces for a component object.
```
[
    coclass-attribute-list
]
coclass classname
{
    [
        interface-attributes
    ] 
    [interface | dispinterface] interfacename 
    {
  . . . 
    }
}
```

const

contract

cpp_quote

declare_guid

default

dispinterface

double

enum

extern

far

float

handle_t

hyper

import

importlib

include

inline

int

interface

library

long

methods

midl_pragma

module

near

pascal

pipe

private_char_16

private_char_8

properties

register

short

signed

sizeof

small

static

stdcall

struct, The struct keyword is used in a structure type specifier.
```
struct [[ struct-tag ]] 
{
  [[ [ field-attribute-list ] ]] type-specifier declarator-list;
    ...
};
```

switch

typedef

union

unsigned

void

volatile

    + List of keywords that are reserved within a "[ ]" combination

aggregatable

align

allocate

annotation

appobject

async

async_uuid, The [async_uuid] interface attribute directs the MIDL compiler to define both synchronous and asynchronous versions of a COM interface.
```
[ 
    object, 
    uuid(string-uuid1), 
    async_uuid(string-uuid2)[ [, interface-attribute-list] 
]
interface interface-name : base-interface
{
    interface-definition
}
```

auto_handle

bem_handle

bindable

broadcast, [broadcast] specifies that remote procedure calls be sent to all servers on a local network.

bstring

byte_count

call_as

callback

code

comm_status

context_handle

context_handle_noserialize

context_handle_serialize

control

cs_char

cs_drtag

cs_rtag

cs_stag

cs_tag_rtn

custom

custom_allocator

decode

default_allocator

defaultbind, The [defaultbind] attribute indicates the single, bindable property that best represents the object.
```
[
    interface-attribute-list
] 
interface | dispinterface interface-name 
{
    [bindable, defaultbind [, attribute-list]] returntype function-name(params)
}
```

defaultcollelem

defaultvalue

defaultvtable

disable_consistency_check

displaybind

dllname

dual

enable_allocate

encode

endpoint

entry

explicit_handle

extension

fault_status

first_is

force_allocate

funcdescattr

handle

heap

helpcontext

helpfile

helpstring

helpstringcontext

helpstringdll

hidden

hostContract

id

idempotent

idldescattr

ignore

iid_is

immediatebind

implicit_handle

in

in_line

input_sync

interpret

last_is

lcid

length_is

licensed

local

local_call

long_enum

manual

max_is

maybe

message

min_is

ms_conf_struct

ms_union

nocode

nointerpret

nonbrowsable

noncreatable

nonextensible

notify

notify_flag

object

odl

off_line

oleautomation

optimize

optional

optional_interface

out

out_of_line

partial_ignore

pointer_default

predeclid

propget

propput

propputref

proxy

ptr

public

range

readonly

ref

replaceable

represent_as

requestedit

restricted

retval

sh_composition

sh_event

sh_file

sh_job

sh_mutex

sh_pipe

sh_process

sh_reg_key

sh_section

sh_semaphore

sh_socket

sh_thread

sh_token

shape

short_enum

size_is

source

strict_context_handle

string

switch_is

switch_type

system_handle

transmit_as

type_strict_context_handle

typedescattr

uidefault

unaligned

unique

user_marshal, The user_marshal ACF attribute associates a named local type in the target language (userm-type) with a transfer type (wire-type) that is transferred between client and server.
```
typedef [user_marshal(userm_type)] wire-type; 
unsigned long __RPC_USER  < userm_type >_UserSize(
    unsigned long __RPC_FAR *pFlags,
    unsigned long StartingSize,
    < userm_type >  __RPC_FAR * pUser_typeObject );
unsigned char __RPC_FAR * __RPC_USER  < userm-type >_UserMarshal(
    unsigned long __RPC_FAR *pFlags,
    unsigned char __RPC_FAR * Buffer,
    < userm_type >  __RPC_FAR * pUser_typeObject);
unsigned char __RPC_FAR * __RPC_USER  < userm_type >_UserUnmarshal(
    unsigned long  __RPC_FAR *  pFlags,
    unsigned char __RPC_FAR *  Buffer,
    < userm_type >  __RPC_FAR * pUser_typeObject);
void __RPC_USER  < userm_type >_UserFree(
    unsigned long  __RPC_FAR * pFlags,
    < userm_type >  __RPC_FAR * pUser_typeObject);
    
    
// Marshal a long as a structure containing two shorts.

typedef unsigned long FOUR_BYTE_DATA;
typedef struct _TWO_X_TWO_BYTE_DATA 
{ 
    unsigned short low; 
    unsigned short high; 
} TWO_X_TWO_BYTE_DATA;

// ACFL file

typedef [user_marshal(FOUR_BYTE_DATA)] TWO_X_TWO_BYTE_DATA;

// Marshaling functions:

// Calculate size that converted data will require in the buffer
unsigned long __RPC_USER FOUR_BYTE_DATA_UserSize( 
    ULONG __RPC_FAR * pulFlags, 
    ULONG __RPC_FAR ulStartingSize,
    FOUR_BYTE_DATA __RPC_FAR * pul);

// Copy FOUR_BYTE_DATA into buffer as TWO_X_TWO_BYTE_DATA
unsigned long __RPC_USER FOUR_BYTE_DATA_UserMarshal( 
    ULONG __RPC_FAR *pulFlags, 
    char __RPC_FAR * pBufferStart, 
    FOUR_BYTE_DATA __RPC_FAR * pul);

// Recreate FOUR_BYTE_DATA from TWO_X_TWO_BYTE_DATA in buffer
unsigned long __RPC_USER FOUR_BYTE_DATA_UserUnmarshal( 
    ULONG __RPC_FAR * pulFlags, 
    char __RPC_FAR * pBufferStart, 
    FOUR_BYTE_DATA __RPC_FAR * pul);

// Nothing to do here as the engine frees the top node and FOUR_BYTE_DATA is a flat data type.
void __RPC_USER FOUR_BYTE_DATA_UserFree( 
    ULONG __RPC_FAR * pulFlags, 
    FOUR_BYTE_DATA __RPC_FAR * pul);    
```

usesgetlasterror

uuid

v1_array

v1_enum

v1_string

v1_struct

vararg

vardescattr

version

winrt_remote_async

wire_marshal

zeroout_alignmentgap


# reference microsoft learn 
https://docs.microsoft.com/en-us/


# MIDL language reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-language-reference



# Compiler warning and errors 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-compiler-errors-and-warnings