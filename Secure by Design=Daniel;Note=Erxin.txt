Secure by Design=Daniel;Note=Erxin

# Introduction
- writing highly secure software. At the code level, you’ll discover security-promoting constructs like safe error handling, secure validation, and domain primitives. 

- multifactor authentication, password suites like 1Password https://1password.com/ and LastPass https://www.lastpass.com/, and notification services like Have I Been Pwned https://haveibeenpwned.com,

- Eric Evans. His ideas about Domain-Driven Design (DDD) provided a terminology to talk about how code should capture meaning

- When using a behavior-driven development (BDD) style to express tests (as we often like to do), the names of the test methods tend to become long sentences

- CSRF tokens, see https://en.wikipedia.org/wiki/Cross-site_request_forgery

- security requirements, A Field Study of Current Practice, http://johnwilander.se/research_publications/paper_sreis2005_wilander_gustavsson.pdf.

- categorizing security 
    + Confidentiality—Most often associated with talking about security, is about keeping things secret
    
    + Integrity—Refers to when it’s important that the information doesn’t change or is only allowed to change in specific, authorized ways.
    
    + Availability—Means data is at hand in a timely manner. 

    
- Open Web Application Security Project (OWASP) Top 10, https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project.
    
An XSS attack occurs when an attacker uses a web application to send malicious code to  a different user. The malicious code could, for example, be in the form of client-side JavaScript. If the attacker enters something like <script>alert(42);</script> 
    
- make your user security by design 

mport static org.apache.commons.lang3.Validate.*;

public class Username {    ①  
   private static final int MINIMUM_LENGTH = 4;
   private static final int MAXIMUM_LENGTH = 40;
   private static final String VALID_CHARACTERS = "[A-Za-z0-9_-]+";

   private final String value;

   public Username(final String value) {
      notBlank(value);

      final String trimmed = value.trim();
      inclusiveBetween(MINIMUM_LENGTH,
                       MAXIMUM_LENGTH,
                       trimmed.length());
      matchesPattern(trimmed,
                     VALID_CHARACTERS,
                     "Allowed characters are: %s", VALID_CHARACTERS);
      this.value = trimmed;
   }

   public String value() {
      return value;
   }
}

public class User {
   private final Long id;
   private final Username username;    ②  

   public User(final Long id, final Username username) {
      this.id = notNull(id);
      this.username = notNull(username);
   }

   // ...
}

    + advantages 
    
Software design is central to the interest and competence of most developers, which makes secure by design concepts easy to adapt.By focusing on design, business and security concerns gain equal priority in the view of both business experts and developers.By choosing good design constructs, nonsecurity experts are able to write secure code.By focusing on the domain, many security bugs are solved implicitly.
    
- validation should be executed in the following order 

Length check —Is the input length within the expected boundaries?
Lexical content check—Does the input contain the right characters and encoding?
Syntax check—Is the input format right?

- extensible markup language (XML), https://www.w3.org/XML/

we’ll use the Billion Laughs attack (which exploits the expandability property of XML entities during the parsing process) as a foundation when learning how to process XML securely. 
    
    + internal xml entities in a nutshell 

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE example [
<!ELEMENT example (#PCDATA)>
<!ENTITY title "Secure by Design">
]>
<example>&title;</example>    ①  
    
XML parser encounters the title entity, it expands the abbreviation and replaces it with the value found in the DTD

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE example [
<!ELEMENT example (#PCDATA)>
<!ENTITY title "Secure by Design">
]>
<example>Secure by Design</example>    ①  

Allowing entity expansion is handy indeed, but, unfortunately, it also opens up the possibility of entity expansion attacks

    + the billion laughs attack 

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE lolz [
<!ELEMENT lolz (#PCDATA)>
<!ENTITY lol "lol">
<!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
<!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
<!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
<!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
<!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>    ①  

lol9 expands into 10 lol8s, which then expands into 100 lol7s, and so on. use a design that combines parser configuration with a lexical content check

    + “XML External Entity (XXE) Prevention Cheat Sheet,” https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/.

import static javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING;

public final class XMLParser {
  static final String DISALLOW_DOCTYPE =
         "http://apache.org/xml/features/disallow-doctype-decl";
  static final String ALLOW_EXT_GEN_ENTITIES =
         "http://xml.org/sax/features/external-general-entities";
  static final String ALLOW_EXT_PARAM_ENTITIES =
         "http://xml.org/sax/features/external-parameter-entities";
  static final String ALLOW_EXTERNAL_DTD =
         "http://apache.org/xml/features/nonvalidating/load-external-dtd";

  public static Document parse(final InputStream input)
                                    throws SAXException, IOException {
    try {
     final DocumentBuilderFactory factory =
                            DocumentBuilderFactory.newInstance();

     factory.setExpandEntityReferences(false);    ①  
     factory.setFeature(FEATURE_SECURE_PROCESSING,    ②  
                                             true);
     factory.setFeature(DISALLOW_DOCTYPE, true);    ③  
     factory.setFeature(ALLOW_EXT_GEN_ENTITIES,    ④  
                                            false);
     factory.setFeature(ALLOW_EXT_PARAM_ENTITIES,    ⑤  
                                            false);
     factory.setFeature(ALLOW_EXTERNAL_DTD, false);    ⑥  

     return factory.newDocumentBuilder().parse(input);
   } catch(ParserConfigurationException e) {
           throw new IllegalStateException("Configuration Error", e);
   }
  }
}

- “Defense in Depth,” https://www.us-cert.gov/bsi/articles/knowledge/principles/defense-in-depth
- summary 

It’s better to view security as a concern to be met than to view it as a set of features to implement.
It’s impractical to achieve security by keeping it at the top of your mind all the time while developing. A better way is to find design practices that guide you to more secure solutions.
Any activity involving active decision-making should be considered part of the software design process and can thus be referred to as design.
Design is the guiding principle for how a system is built and is applicable on all levels, from code to architecture.
The traditional approach to software security struggles because it relies on the developer to explicitly think about security vulnerabilities while at the same time trying to focus on implementing business functionality. It requires every developer to be a security expert and assumes that the person writing the code can think of every potential vulnerability that can occur now or in the future.
By shifting the focus to design, you’re able to achieve a high degree of software security without the need to constantly and explicitly think about security.
A strong design focus lets you create code that’s more secure compared to the traditional approach to software security.
Every XML parser is implicitly vulnerable to entity attacks because entities are part of the XML language.
Using generic types to represent specific data is a potential door opener for security weaknesses.
Choosing the XML parser configuration is difficult without understanding the underlying parser implementation.
Secure by design promotes security in-depth by adding several layers of security.


# Intermission, the anti-hamlet 
- In SQL injection, the attacker tries to send commands to the database through the application. For more, see https://www.owasp.org/index.php/Top_10_2013-A1-Injection

Injection. Injection flaws, such as SQL, NoSQL, OS, and LDAP injection, occur when untrusted data is sent to an interpreter as part of a command or query

Broken Authentication. Application functions related to authentication and session management are often implemented incorrectly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume other users’ identities temporarily or permanently

Sensitive Data Exposure. Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. 

XML External Entities (XXE). Many older or poorly configured XML processors evaluate external entity references within XML documents. 

Broken Access Control. Restrictions on what authenticated users are allowed to do are often not properly enforced. 

Security Misconfiguration. Security misconfiguration is the most commonly seen issue.

Cross-Site Scripting XSS. XSS flaws occur whenever an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript

Insecure Deserialization. Insecure deserialization often leads to remote code execution.

Using Components with Known Vulnerabilities. Components, such as libraries, frameworks, and other software modules, run with the same privileges as the application

Insufficient Logging & Monitoring. Insufficient logging and monitoring, coupled with missing or ineffective integration with incident response, allows attackers to further attack systems, maintain persistence, pivot to more systems, and tamper, extract, or destroy data


- implicit concepts represented by language primitives 

void addCust(String name, String phone, String fax, int creditStatus, int vipLevel, String contact, String contactPhone, boolean partner)

- gotten lots of inspiration from Domain-Driven Design and its focus on understanding and modeling the domain in a strict way

class Book {    ①  
    BookTitle title;

    ISBN isbn;
    Money price;
    ...
}

class Quantity {    ②  

  ...
  Quantity(int quantityOfBooks) {
      isTrue(0 < quantityOfBooks, "Quantity must be positive");
      isTrue(quantityOfBooks <= 240,
        "Quantity must fit in through-store flow, which is limited to 240");
      ...
  }
}

class Order {
    void addOrderLine(Book book,
                      Quantity quantity) {    ③  

        ...
    }

    Quantity totalQuantity() {
        ...
    }
}

the quantity of the book will be checked automatically, an example of a domain primitive

- make the implicit explicit 
- summary 
Incomplete, missing, or shallow modeling leads to a design with security flaws.
A security flaw in the form of broken business integrity can live in production for a long time, bleeding money from your enterprise.
Conscious, explicit design results in a much more robust solution.


# Fundamentals
- DDD, domain driven design 

Focus on the core domain.
Explore models in a creative collaboration of domain practitioners and software practitioners.
Speak a ubiquitous language within an explicitly bounded context.

https://www.infoq.com/minibooks/domain-driven-design-quickly

- visual studio code for UML 

https://www.freecodecamp.org/news/inserting-uml-in-markdown-using-vscode/

- models are strict 

    + entities
    it distinguishable from others 
    consistent during its life cycle 
    contain other objects 
    responsible for the coordination of operations on the objects it owns 
    
    + value objects 
    no identity that defines it, rather it's defined by its value 
    immutable 
    should form a conceptual whole 
    can reference entities 
    explicitly defines and enforces important constrants 
    can be used as an attribute of entities and other value objects 
    can be short-lived 
    
    When your value object is modeled as a conceptual whole, it carries meaning when passed around, and it can uphold its constraints.

    Deferred Validation” (1994), http://c2.com/ppr/checks.html
    
    + aggregates, An aggregate is a conceptual boundary that you use to group parts of the model together.

    every aggregate has a boundary and a root 
    root is a single specific entitiy 
    root has global identity 
    root is the only member of the aggregate that objects outside the boundary can hold reference to 
    root conrols all access to the objects within the boundary 
    entities other than the root have local identify, their identities don't have to be known outside of the aggregate 
    the root can pass references to internal entities to other objects, but those references can only be used transiently and can never be hold onto 
    the root can pass references of value objects to other objects 
    invairants between the members of the aggregate are always enforced within each transaction 
    invariants that span multiple aggregates can't be expected to be consistent all the time, but they can eventually become consistent 
    objects within the aggregate can hold references to other aggregates 
    
        * example 
        
        //aggregate root 
        company{
            name 
            
            //aggregate boundary 
            0...N Employee {
                Role 
            }
        }

- Semantics of the ubiquitous language, Data crossing a semantic boundary is of special interest from a security perspective because this is where the meaning of a term could implicitly change, which could open up security weaknesses.

- identifying the bounded context. One of the core principles of the ubiquitous language is to avoid ambiguities, because they create a lot of confusion and misunderstanding

- interactions between contexts, drawing a context map 

http://www.melconway.com/Home/Conways_Law.html

conceptual view of why bounded contexts are important and how context maps are created. for example in finance context Order have a meaning and in Shipping context it have a different meaning 

- summary 
Building domain models is a good way to promote deep learning about the domain.
A domain model should be a strict and unambiguous representation of the domain that captures only the most important aspects.
When creating a domain model, you make a choice among many possible models.
The domain model forms a language for communicating about the system.
Entities, value objects, and aggregates are the basic building blocks for your domain model.
Entities have an identity that’s consistent during their life cycle and can contain other entities or value objects.
The uniqueness of entities always has a scope, and that scope depends on your model.
A value object doesn’t have an identity but rather is defined by its value.
A value object must always be immutable and should form a conceptual whole.
An aggregate is a conceptual boundary that groups together other model objects and is responsible for upholding invariants among those objects.
An aggregate always has an aggregate root and, in code, that root is typically the same as the aggregate.
The aggregate root has global identity because this is the only part of the aggregate that other parts of the model can hold a reference to.
The ubiquitous language is spoken by everyone on the team, including domain experts, to ensure a common understanding.
The domain model is bound by the semantics of the ubiquitous language.
The bounded context is the context in which the semantics of the model hold. As soon as the semantics change, the model breaks and the boundary of the context is found.
Using Conway’s Law is a good starting point when trying to find the boundary of a context.
Data crossing a semantic boundary is of special interest from a security perspective because this is where the meaning of a concept could implicitly change.


# Code constructs promoting security 
- strategies to solve security problems 

immutability, involving data integrity and availability 
failing fast, security problems involving illegal input and state 
validation, security problems involving input validation 

- each method is marked as synchronized to prevent concurrent field modification, which in turn can lead to thread contention (when threads are forced to wait for another thread to release one or more locks before executing).

public class Customer {
   private static final int MIN_INVOICE_SCORE = 500;  ①  
   private Id id;    ②  
   private Name name;    ③  
   private Order order;    ④  
   private CreditScore creditScore;    ⑤  

   public synchronized Id getId() {
      return id;
   }

   public synchronized void setId(final Id id) {
      this.id = id;
   }

   public synchronized Name getName() {
      return name;
   }

   public synchronized void setName(Name name) {
      this.name = name;
   }

   public synchronized Order getOrder() {
      this.order = OrderService.fetchLatestOrder(id);
      return order;
   }

   public synchronized void setOrder(Order order) {
      this.order = order;
   }

   public synchronized CreditScore getCreditScore() {
      return creditScore;
   }

   public synchronized void setCreditScore(CreditScore creditScore){
      this.creditScore = creditScore;    ⑥  
   }

   public synchronized boolean isAcceptedForInvoicePayment() {
      return creditScore.compute() >
                             MIN_INVOICE_SCORE;    ⑦  
   }
   ...
}

    + A ReadWriteLock is actually two locks: one for reading and one for writing. The read lock can be held by multiple reader threads until there’s a writer thread requesting the write lock, hence allowing parallel and concurrent access of data as long as it’s not modified. 

    + immutable values are safe to share between threads, no locking no blocking 
    
import static org.apache.commons.lang3.Validate.notNull;

public final class Customer {
   private final Id id;    ①  
   private final Name name;    ②  
   private final CreditScore creditScore;    ③  

   public Customer(final Id id, final Name name,
                   final CreditScore creditScore) {
      this.id = notNull(id);
      this.name = notNull(name);
      this.creditScore = notNull(creditScore);
   }

   public Id id() {
      return id;
   }

   public Name name() {
      return name;
   }

   public Order order() {
      return OrderService.fetchLatestOrder(id);
   }

   public boolean isAcceptedForInvoicePayment() {
      return creditScore.isAcceptedForInvoicePayment();
   }
}
    + don’t need mutable data structures to support change. What you need is to separate reads from writes and perform updates through channels other than those used when reading. This might seem overly complex, but if your system has an imbalance between reads and writes, it can be worth it

- The better option is to fail fast —to terminate the job as soon as it becomes clear that the preconditions aren’t met

https://martinfowler.com/ieeeSoftware/failFast.pdf

    + checking preconditions for method arguments 
    
public void queueCatName(String name) {
    if (name == null)    ①  
        throw new NullPointerException();
    if (!name.matches(".*s.*"))    ②  
        throw new IllegalArgumentException("Must contain s");
    if (catNames.contains(name))    ③  
        throw new IllegalArgumentException("Already queued");
    catNames.add(name);
}

- upholding invariants in constructors 

import org.apache.commons.lang3.Validate.*;

enum Sex {MALE, FEMALE;}

public class Cat {

    private String name;
    private final Sex sex;

    public Cat(String name, Sex sex) {
        notNull(name);    ①  
        matchesPattern(name,".*s.*",
                       "Cat name must contain s");    ②  
        notNull(sex);    ③  
        this.name = name;
        this.sex = sex;
    }
    ...
}

- contract enforced through fast fails 

import org.apache.commons.lang3.Validate.*;

public class CatNameList {
    private final List<String> catNames = new ArrayList<String>();

    public void queueCatName(String name) {    ①  
        notNull(name);    ②  
        matchesPattern(name,".*s.*",
                       "Cat name must contain s");    ③  
        isTrue(!catNames.contains(name),
               "Cat name already queued");    ④  
        catNames.add(name);
    }

    public String nextCatName() {
        validState(!catNames.isEmpty());    ⑤  
        return catNames.get(0);
    }

    public void dequeueCatName() {
        validState(!catNames.isEmpty());    ⑤  
        catNames.remove(0);
    }

    public int size() {    ①  
        return catNames.size();
    }
}

- validation, OWASP Foundation is a worldwide nonprofit organization that works for better software security. There’s a lot of excellent resources at their website, www.owasp.org.
    + OWASP top 10 
https://owasp.org/www-project-top-ten/

    + OWASP modsecurity core rule set 
    
The OWASP ModSecurity Core Rule Set (CRS) is a set of generic attack detection rules for use with ModSecurity or compatible web application firewalls
https://owasp.org/www-project-modsecurity-core-rule-set/
https://www.netnea.com/cms/apache-tutorial-6_embedding-modsecurity/

    + zed attack proxy 
https://owasp.org/www-project-zap/

    + web security test guide lines 
https://owasp.org/www-project-web-security-testing-guide/

- types validation 

origin 
size 
lexical content 
syntax 
semantics 

- uisng an access key, REST API where you can manage your AWS resources, such as the S3 cloud data storage.13  When sending an HTTP request to this API, you need to provide your access key as part of the HTTP Authorization header

http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html

    + aws request example 
GET /photos/puppy.jpg HTTP/1.1
Host: johnsmith.s3.amazonaws.com
Date: Mon, 26 Mar 2007 19:37:58 +0000

Authorization: AWS AKIAIOSFODNN7EXAMPLE:frJIUN8DYpKDtOLCwo//yllqDzg=

    + OAuth is a good place to start to learn 
http://www.oauth.com/

- checking size of data 

import org.apache.commons.lang3.Validate.*;

public class ISBN {
    private final String isbn;

    public ISBN(final String isbn) {
        notNull(isbn);
        inclusiveBetween(10, 10,isbn.length());
        isTrue(isbn.matches("[0-9X]*"));    ①  
        isTrue(isbn.matches("[0-9]{9}[0-9X]"));    ②  
        isTrue(checksumValid(isbn));    ③  
        this.isbn = isbn;
    }

    private boolean checksumValid(String isbn) { /.../ }
}

regexp engine will load and start processing that humongous string, not realizing it’s too big. An early length check protects the latter stages

data contains the expected type of content, such as the expected characters and encoding, which is called the lexical content.

- checking lexical content of data. fix the 1 billion laughs attacks. scans the data, not recognizing <!ENTITY as a legitimate lexeme. Leaf back to chapter 1, section 1.5, if you want to review the details

- summary 

Data integrity is about ensuring the consistency and accuracy of data during its entire life cycle.
Data availability is about ensuring data is obtainable and accessible at the expected level of performance in a system.
Immutable values are safe to share between threads without locks: no locking, no blocking.
Immutability solves data availability issues by allowing scalability and no locking between threads.
Immutability solves data integrity issues by preventing change.
Contracts are an effective way to clarify the responsibilities of objects and methods.
It’s better to fail fast in a controlled manner than to risk uncontrolled failures later. Fail fast by checking preconditions early in each method.
Validation can be broken down into checking origin, data size, lexical content, syntactic format, and semantics.
Origin checks can be done by checking the origin IP or requiring an access key to counteract DDoS attacks.
Data size checks can be done both at the system border and at object creation.
Lexical content checks can be done with a simple regular expression (regexp).
Syntax format checks might require a parser, which is more expensive in terms of CPU and memory.
Semantic checks often require looking at the data in the database, such as searching for an entity with a specific ID.
Earlier steps in the validation order are more economical to perform and protect the later, more expensive steps. If early checks fail, later steps can be skipped.


# Domain primitives 
- domain primitives and invariants

- context boundaries define meaning, mean exactly what the concept is in the current domain

- data transfer object (DTO) used to communicate with other domains. You can place invariants in those DTOs, but they won’t be the same constraints that exist in your domain

invariants of domain primitive are checked at the time of creation 
domain primitives can only exist if they are valid 
domain primitives should always be used instead of language primitives or generic types 
meaning is defined within the boundaries of the current domain 
your domain primitive library to create secure code 

- read one objects 
main purpose is to facilitate detection of unintentional use 
a senstive value or concept 
often a domain primitve 
can be read once and only once 
prevents serialization of sensitive data 
prevents subclassing and extension 


import static org.apache.commons.lang3.Validate.validState;

public final class Password implements Externalizable {

   private final char[] value;
   private boolean consumed = false;

   public Password(final char[] value) {
      this.value = validate(value).clone();    ①  
   }

   public synchronized char[] value() {    ②  
      validState(!consumed, "Password value has already been consumed");
      final char[] returnValue = value.clone();    ③  
      Arrays.fill(value, '0');    ④  
      consumed = true;    ⑤  
      return returnValue;
   }

   @Override
   public String toString() {
      return "Password{value=*****}";
   }

   @Override
   public void writeExternal(final ObjectOutput out) {
      deny();
   }

   @Override
   public void readExternal(final ObjectInput in) {
      deny();
   }

   private static void deny() {
      throw new UnsupportedOperationException(
            "Serialization of passwords is not allowed");
   }

   private static char[] validate(final char[] value) {
      // Validate length, characters and so forth
      return value;
   }
}

- deculttering entities 

input is always validated 
validation is consistent 
entity code is less clusttered and more to the point 
entity code is more readable 

https://www.sciencedaily.com/terms/absolute_zero.htm

- taint analysis 
Dytan: A Generic Dynamic Taint Analysis Framework

https://www.cc.gatech.edu/~orso/papers/clause.li.orso.ISSTA07.pdf

taint sources 
untainting, the way data is cleaned of suspicion through some type of check 
propagation policy 
taint sinks, the places where data is used in a senstive way 

“Dynamic Taint Propagation for Java,” by Vivek Haldar, Deepak Chandra, and Michael Franz (https://www.acsac.org/2005/papers/45.pdf).

- summary 

Domain primitives are the smallest building blocks and form the basis of your domain model.
You should never represent a concept in your domain model as a language primitive or a generic type.
If a term in your domain already exists outside of your domain but with a slightly different meaning, you should introduce a new term instead of redefining the existing one.
A domain primitive is immutable and can only exist if it’s valid in the current domain.
When domain primitives are used, the rest of the code is greatly simplified and becomes more secure.
You should harden APIs by using your domain primitive library.
A read-once object is a useful way to represent sensitive data in your code.
The value of a read-once object can only be retrieved once.
The read-once object design pattern can mitigate leakage of sensitive data.
Domain primitives provide the same type of security that concurrent taint analysis would.



# Ensuring integrity of state 
- managing state using entities, Entities are our preferred way to implement mutable state, but let’s briefly look at the alternatives
- consistent on creation 

public class Account {
    private AccountNumber number;    ①  
    private LegalPerson owner;    ①  
    private Percentage interest;    ①  
    private Money creditLimit;    ②  
    private AccountNumber fallbackAccount;    ②  

    public Account() {}    ③  

    public AccountNumber getNumber() {
        return number;
    }

    public void setNumber(AccountNumber number) {    ④  
        this.number = number;
    }

    public LegalPerson getOwner() {
        return owner;
    }

    public void setOwner(LegalPerson owner) {    ④  
        this.owner = owner;
    }
    ...
}

class AccountService {

    void openAccount() {
        Account account= new Account();    ⑤  
        account.setNumber(number);    ⑥  
        account.setOwner(accountowner);    ⑥  
        account.setInterest(interest);    ⑥  
        account.setCreditLimit(limit);    ⑦  
        ...
    }
}

- fluent interface, make the code read like text 

    + a method should either be a command or a query.3  A usual interpretation is that a command should change state but return nothing, and a query should return the answer but change nothing.
    
    + In a way, the object acts as its own builder (more on the builder pattern in the next section). But it completely misses the fluent part
    
class Person {
  private String firstname;
  ...
  public Person setFirstName(String firstname) {
    this.firstname = firstname;
    return this;
  }
  ...
}

Person p = new Person()
            .setFirstName("Deve").setLastName("Loper")
            .setProfession("Developer");

- builder pattern for upholding advanced constraints 

import static org.apache.commons.lang3.Validate.notNull;
import static org.apache.commons.lang3.Validate.validState;

public class Account {
    private final AccountNumber number;
    private final LegalPerson owner;
    private Percentage interest;
    private Money creditLimit;
    private AccountNumber fallbackAccount;

    private Account(AccountNumber number,
                    LegalPerson owner,
                    Percentage interest) {    ①  
        this.number = notNull(number);
        this.owner = notNull(owner);
        this.interest = notNull(interest);
    }

    ...

    private void checkInvariants() throws IllegalStateException {
        validState(fallbackAccount != null
                    ^ creditLimit != null);    ②  
    }

    public static class Builder {    ③  
        private Account product;

        public Builder(AccountNumber number,
                       LegalPerson owner,
                       Percentage interest) {    ④  
            product = new Account(number, owner, interest);
        }

        public Builder withCreditLimit(Money creditLimit) {
            validState(product != null);    ⑤  
            product.creditLimit = creditLimit;
            return this;    ⑥  
        }

        public Builder withFallbackAccount(AccountNumber fallbackAccount) {
            validState(product != null);    ⑤  
            product.fallbackAccount = fallbackAccount;
            return this;    ⑥  
        }

        public Account build() {
            validState(product != null);
            product.checkInvariants();    ⑦  
            Account result = product;
            product = null;    ⑧  
            return result;    ⑨  
        }
    }
}

- Separate the domain model and persistence model to emphasize that they are different contexts and to make the mapping explicit.

import org.apache.commons.lang3.Validate.*;

public class Account {
    private AccountNumber number;
    private LegalPerson owner;
    private Percentage interest;
    private Money creditLimit;
    private AccountNumber fallbackAccount;

    public Account(AccountNumber number,
                    LegalPerson owner,
                    Percentage interest) {    ①  
        this.number = notNull(number);    ②  
        this.owner = notNull(owner);    ②  
        this.interest = notNull(interest);    ②  
    }

    protected Account() {}    ③  

    public AccountNumber number() { ... }    ④  

    public LegalPerson owner() { ... }

    public void changeInterest(
                    Percentage interest) {    ⑤  
        notNull(interest);    ⑥  
        this.interest = interest;
    }

    public Money creditlimit() { ... }

    public void changeCreditLimit(
                    Money creditLimit) {    ⑦  
        notNull(creditLimit);
        this.creditLimit = creditLimit;
    }

    public AccountNumber fallbackAccount() {
        return fallbackAccount;
    }

    public void changeFallbackAccount(AccountNumber fallbackAccount) {
        notNull(fallbackAccount);
        this.fallbackAccount = Validate.notNull(fallbackAccount);
    }

    public void clearFallbackAccount() {
        this.fallbackAccount = null;
    }
}

class AccountService {
    void openAccount() {
        AccountNumber number = ...
        LegalPerson accountowner = ...
        Percentage interest = ...
        Money limit = ...    ⑧  
        Account account =
            new Account(number,
                        accountowner,
                        interest);    ⑨  
        account.changeCreditLimit(limit);    ⑩  
        accountRepostitory.registerNew(account);
    }
}

- getter and setter object open up the data field to arbitrary access and modification 
- avoid sharing mutable objects
class Person {

    private Date birthdate;

    Date birthdate() {
        return birthdate.clone();    ①  
    }
}
- catching advanced constraints in code 

two optional attributes: credit limit and fallback account. An advanced constraint might span both of these attributes. 

    + check advanced constraints in separate method
    
import static org.apache.commons.lang3.Validate.validState;

private void checkInvariants()
    throws IllegalStateException {    ①  

    validState(fallbackAccount != null
                ^ creditLimit != null);    ②  
}

    

- securing the integrity of collections 

class Order {
    private List<OrderLine> orderitems;    ①  
    public List<OrderLine> getOrderItems() {
        return new ArrayList(orderitems);    ②  
    }
}

static <T> List<T> unmodifiableList(List<? extends T> list)

- builder pattern for upholding 

void openAccount() {
    AccountBuilder accountBuilder =    ①  
            new AccountBuilder(number,    ②  
                               accountOwner,
                               interest);
    accountBuilder.withCreditLimit(limit);    ③  
④  
    Account account = accountBuilder.build();    ⑤  
    ...
}

- patterns 
    + Creation through a constructor with all mandatory attributes; optional attributes set via method calls
    
    + Creation through fluent interface
    
    + Creation through builder pattern
    
    + Public fields only for final attributes that can’t change
    
    + Restrictions on getter/setter methods
    Without restrictions, there’s no encapsulation
    
    + Securing collections through immutability
    

- summary 

Entities are the preferred way to handle mutable states.
Entities must be consistent on creation.
No-arg constructors are dangerous.
The builder pattern can be used to construct entities with complex constraints.
You need to protect the integrity of attributes when they’re accessed.
A private data field with unrestricted getter and setter methods isn’t more secure than a public data field.
You should avoid sharing mutable objects and use immutable domain primitives instead.
You shouldn’t expose a collection, but rather expose a useful property of the collection.
Collections can be protected by exposing an unmodifiable version.
You must take care so that the data in a collection can’t be changed from the outside.
    

# Reducing complexity of state 
- partially immutable entities, entities partially immutable to avoid integrity-breaking mistakes.

- entity rule upheld by a service method 

public class Person {
    private final boolean married;
    public Person(boolean married) {
        this.married = married;
    }
    public boolean isMarried() {
        return married;
    }
    public void date(Person datee) {}    ①  
}

public class Work {
    private Person boss;
    private Person employee;

    void afterwork() {
        // boss attempts to date
        if (!boss.isMarried()) {    ②  
            boss.date(employee);
        } else {    ③  
            logger.warn("bad egg");
        }
    }
}
- entity snapshot, makes it easier to grasp what states the entity can have. supports high capacity and fast response times by avoiding locking 

- implementing entity state as a seperate object 
- splitting the complex states into an entity chain 

a book order can be in a lot of distinct states, draw a state graph 

- splitting the state graph into phases 

- when to form an antity relay, one phase to another and few transition points 

entity replay, makes it easier to handle and complex state graphs 


# Leveraging your delivery pipleine for security 
- possible security weaknesses 

https://www.owasp.org/index.php/Web_Application_Penetration_Testing

- using a deliver pipleline 

build > {unit test, applicaiton test, integration test} > system test > availability tests > deploy 

    + unit test 
    normal input testing 
- mutable state, entities are also hard to code. 

void withdraw(Money amount) {
    if(this.balance.moreThan(amount)) {    ①  
        Money newBalance = this.balance.subtract(amount);    ②  
        this.balance = newBalance;    ③  
     } else {
        throw new InsufficientFundsException();
     }
}

- partially immutable entities 

class Order {
    private final CustomerID custid;    ①  
    Order(CustomerID custid) {
        Validate.notNull(custid);
        this.custid = custid;    ②  
    }
    public CustomerID getCustid() {    ③  
        return custid;
    }
}

class SomeOtherPartOfFlow {
    void processPayment(Order order) {
        registerDebt(order.getCustid(), order.value());
        ...
    }
}

allowed behavior, can change depending on what state entities are in

- entity state objects, entity should behave in a way that's appropriate to their state 

start -> unmarried -> marry -> married -+
              A                         |
              |                         |
              +-----divorce-------------+


public class Person {
    private final boolean married;
    public Person(boolean married) {
        this.married = married;
    }
    public boolean isMarried() {
        return married;
    }
    public void date(Person datee) {}    ①  
}

public class Work {
    private Person boss;
    private Person employee;

    void afterwork() {
        // boss attempts to date
        if (!boss.isMarried()) {    ②  
            boss.date(employee);
        } else {    ③  
            logger.warn("bad egg");
        }
    }
}

- implementing entity sate as a separate object 

import static org.apache.commons.lang3.Validate.validState;

public class MaritalStatus {

    private boolean married = false;    ①  

    public void date() {    ②  
        validState(!married,    ③  
                "Not appropriate to date when married");
    }

    public void marry() {
        validState(!married);    ③  
        married = true;
    }

    public void divorce() {
        validState(married);    ④  
        married = false;
    }
}


public class MaritalStatusTest {
    @Test
    public void should_allow_dating_when_unmarried() {
        MaritalStatus maritalStatus = new MaritalStatus();
        maritalStatus.date();
    }

    @Test(expected = IllegalStateException.class)
    public void should_not_allow_dating_when_married() {
        MaritalStatus maritalStatus = new MaritalStatus();
        maritalStatus.marry();
        maritalStatus.date();
    }

    @Test
    public void should_allow_dating_after_divorces() {
        MaritalStatus maritalStatus = new MaritalStatus();
        maritalStatus.marry();
        maritalStatus.divorce();
        maritalStatus.date();
    }
}

- entity represented with immutable objects 

import static org.apache.commons.lang3.Validate.*;

public class OrderSnapshot {    ①  
    public final OrderID orderid;
    public final CustomerID custid;
    private final List<OrderItem> orderItemList;

    public OrderSnapshot(OrderID orderid;
                            CustomerID custid,
                            List<OrderItem> orderItemList) {
        this.orderid = notNull(orderid);
        this.custid = notNull(custid);
        this.orderItemList =
            Collections
                .unmodifiableList(
                    notNull(orderItemList));    ②  
        checkBusinessRuleInvariants();
    }

    public List<OrderItem> orderItems() {
        return orderItemList;    ②  
    }

    public int nrItems() {    ③  
        ...
    }

    private void checkBusinessRuleInvariants() {
        validState(nrItems() <= 38, "Too large for ordinary shipping");
    }

}    ④  

public class OrderService {
    public OrderSnapshot findOrder(OrderID orderid) ...
    public List<OrderSnapshot> findOrdersByCustomer(CustomerID custid) ...
}

- entity relay, 

start -> under configuration -> complete but not paid -> complete but payment rejected -> under configuration 
                                    |
                                    V 
                                    paid -> shipped |<--> misplaced ------------->|
                                                    |-> delivered < - end state <-| lost 
...

in complex state switch conditions if we implement our logic in one single class then it will be too complex                                     

    + split the group into phanes 

- patterns 
partially immutable entity 

entity state object 

entity snapshot 

entity relay 

- summary 

Entities can be designed to be partially immutable.
State handling is easier to test and develop when extracted to a separate object.
Multithreaded environments for high capacity require a careful design.
Database locking can put a limit on availability of entities.
Entity snapshots are a way to regain high availability in multithreaded environments.
Entity relay (when fulfillment of one entity gives rise to another) is an alternative way to model an entity that has lots of different states.


# Leveraging your delivery pipeline for security 
- reference 
https://www.owasp.org/index.php/Web_Application_Penetration_Testing

- using a delivery pipeline 

Make sure all files have been checked into Git.
Build the application from the master branch.
Execute all unit tests and make sure they pass.
Execute all application tests and make sure they pass.
Execute all integration tests and make sure they pass.
Execute all system tests and make sure they pass.
Execute all availability tests and make sure they pass.
Deploy to production (if all previous steps pass).

    + example
build -> |unit test        | -> system test | avaliability test | -> deploy 
         |application test |
         |integration test |
         
- test types 

normal inputing 

boundary inputing 

invalid input testing

extreme input testing

- defense in depth, 

https://us-cert.cisa.gov/bsi/articles/knowledge/principles/defense-in-depth

https://us-cert.cisa.gov/

- regex buddy and regix magic 

http://www.regexbuddy.com/index.html, debug regex 

http://www.regexmagic.com/, generate regex

- verifying feature toggles. it is a practice that allows developers to rapidly develop and deploy features in a controlled and safe manner 

the perils of slippery toggles 

    + change the code directly
    
    boundary input 
    
    invalid input 
    
    extreme input 
    
    + defense in depth 
    https://www.us-cert.gov/bsi/articles/knowledge/principles/defense-in-depth
    + toggle the feature by change configuration 
    
    + methods for verify feature toggles 
    
    remove functionality in public API 
    
    replace existing fuctionality 
    
    new authentication/authorization 
    
    alternating behavior 
    
- automatic security tests 
https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series

    + understand the domain rules 

- unit test frameworks for different kinds of languages 

- regular expresions look around 

http://www.regular-expressions.info/lookaround.html

-  NCC Group white paper, “Second-Order Code Injection Attacks,” available at https://www.nccgroup.trust/uk/our-research/second-order-code-injection-attacks/.

html embedding 

cross-site scripting 

sql injection 

buffer overflow 

file includes, allows an attacker to inject malicious code sucn as file location referenes or configuration variables 

timing, synchronously or asynchronously by the application 

location 

environment 

source

    + XSS 
    
Testing for XSS injections can be done in a similar fashion by using dictionaries with different ways of expressing <script>, along with the less than (<) character


    + sql injection 
    
import static org.junit.Assert.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 
class EmailAddressTest {
  @TestFactory
  Stream<DynamicTest> should_reject_SQL() {
     return Stream.of(
           "'or%20select *",                         ①  
          "admin'--",                               ①  
           "<>\"'%;)(&+",                            ①  
           "'%20or%20''='",                          ①  
           "'%20or%20'x'='x",                        ①  
           "\"%20or%20\"x\"=\"x",                    ①  
           "')%20or%20('x'='x",                      ①  
           "0 or 1=1",                               ①  
           "' or 0=0 --",                            ①  
          "\" or 0=0 --")                           ①   
           .map(input ->
              dynamicTest("Rejected: " + input,
                 () -> assertThrows(                 ②  
                       RuntimeException.class,
                       () -> new EmailAddress(input))));
  }
}

- verifying feature toggles, This means you shouldn’t verify only the feature code in your application, but also the toggles themselves.

examples:

remove functionality in public API 

replace existing functionality 

new authentication/authorization 

alternating behavior 

- dealing with combinatory complexity 

- toogles are subject to auditing 

OWASP publishes a number of cheat sheets that you can use as a guide when writing your own security tests. See https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series.


- vulnerability scanning tools 

OWASP has a great list of tools at https://www.owasp.org/index.php/Category:Vulnerability_Scanning_Tools.

OWASP Dependency Check is an example of a tool you can use to scan for vulnerable dependencies; see https://www.owasp.org/index.php/OWASP_Dependency_Check.

- testing for availability 

“Engineering Principles for Information Technology Security (A Baseline for Achieving Security),” available at https://csrc.nist.gov/publications/detail/sp/800-27/rev-a/archive/2004-06-21. withdraw to 
https://csrc.nist.gov/publications/detail/sp/800-160/vol-1/final
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-160v1.pdf


US-CERT Security Tip ST04-015, “Understanding Denial-of-Service Attacks” at https://www.us-cert.gov/ncas/tips/ST04-015

distributed denial of service (DDoS) attack, A utility for arming (creating) many bees (micro EC2 instances) to attack (load test) targets (web applications).
https://github.com/newsapps/beeswithmachineguns

more generic term DoS attack

https://aws.amazon.com for more information on the Amazon Elastic Compute Cloud.

- exploiting domain rules,  “Domain-Driven Security’s Take on Denial-of-Service (DoS) Attacks,” available at http://www.diva-portal.org/smash/record.jsf?pid=diva2%3A945831.

- validating configuration 

examples of configuration hot spots to test 

web containers, http headers, CSRF tokens, output encoding 
network communication, transport layer security, https and so on 
data parsing, behavior of data parsers 
authentication mechanisms, authentication on/off, integration settings 

- HTTP headers to consider is the OWASP Secure Headers Project at https://www.owasp.org/index.php/OWASP_Secure_Headers_Project

- cross site tracing, https://www.owasp.org/index.php/Cross_Site_Tracing for details.

- Regular expressions can be sensitive to inefficient backtracking, and, therefore, you should check the length of input before sending it to the regular expression engine.


# Handling failures securely 
- using exceptions to deal with failure 















    

    The Open Web Application Security Project® (OWASP) is a nonprofit foundation that works to improve the security of software.

supplying malicious data to check for flaws input validation, such as flaws that enable sql injection or buffer overflow attacks 

- working with security tests 

application focused, the application in parts other than the domain,  correct behavior from the infrastructure running the application. Examples include checking for open ports and looking at the privileges of the running process. or input validation 

infrastructure focused,  correct behavior from the infrastructure running the application. Examples include checking for open ports and looking at the privileges of the running process.

    + vulnerability scanning tools 
    
    https://www.owasp.org/index.php/Category:Vulnerability_Scanning_Tools
    
    https://www.owasp.org/index.php/OWASP_Dependency_Check
    
- leveraging infrastructure as code 

    + testing for availability, https://csrc.nist.gov/publications/detail/sp/800-27/rev-a/archive/2004-06-21
    
    + understanding denail of service attacks, https://www.us-cert.gov/ncas/tips/ST04-015
    
    DDoS, but more commonly referred to as DoS attack

    “Domain-Driven Security’s Take on Denial-of-Service (DoS) Attacks,” available at http://www.diva-portal.org/smash/record.jsf?pid=diva2%3A945831.
     
    Domain DoS attacks are extremely difficult to detect because there’s no difference between benevolent and malevolent use of domain rules
    
    + HTTP headers, to consider is the OWASP Secure Headers Project at https://www.owasp.org/index.php/OWASP_Secure_Headers_Project.
    
    + knowing your default 
    
    + TRACE is an HTTP method known to be used to perform cross-site tracing (XST) attacks, so you don’t want to enable TRACE unless you have to
    
    https://www.owasp.org/index.php/Cross_Site_Tracing
    
- summary 

By dividing tests into normal testing, boundary testing, invalid input testing, and extreme input testing, you can include security in your unit test suites.
Regular expressions can be sensitive to inefficient backtracking, and, therefore, you should check the length of input before sending it to the regular expression engine.
Feature toggles can cause security vulnerabilities, but you can mitigate those vulnerabilities by verifying the toggle mechanisms using automated tests.
A good rule of thumb is to create a test for every toggle you add, and you should test all possible combinations of them.
You should watch out for the combinatory complexity that large numbers of toggles can lead to. The best way to avoid this is by keeping the number of toggles as small as possible.
The toggle mechanism itself can be subject to auditing and record keeping.
Incorporating automated security tests into your build pipeline can give you the ability to run a mini penetration test as often as you like.
Availability is an important security aspect that needs to be considered in every system.
Simulating DoS attacks helps in understanding weaknesses in the overall design.
A domain DoS attack is extremely difficult to protect against because it’s only the intent that distinguishes it from regular usage.
Many security problems are caused by misconfiguration, and the cause for faulty configuration can be either unintentional changes, intentional changes, or misunderstood configuration.
Configuration hot spots are good indicators for finding areas in your configuration where testing is most critical.
It’s important to know the default behavior of the tools you use and assert that behavior with tests.

    
# Hanlding failures securely 
- important to never include business data in technical exceptions, regardless of whether it’s sensitive or not
- throw exceptions, The only reason that findFirst works in fetchAccountFor is because of the underlying relationship between account and account number.

import static Result.Failure.INSUFFICIENT_FUNDS;
import static Result.success;
import static org.apache.commons.lang3.Validate.notNull;
 
public final class Account {
 
  public Result transfer(final Amount amount,
                         final Account toAccount) {
     notNull(amount);
     notNull(toAccount);
 
     if (balance().isLessThan(amount)) {    ①  
        return INSUFFICIENT_FUNDS.failure();    ②  
     }
 
     return executeTransfer(amount, toAccount);    ③  
  }
 
  public Amount balance() {
     return calculateBalance();
  }
 
  // ...
}

- dealing with exception payload, security benefits of designing failures as expected outcomes 

    + Ambiguity between domain exceptions and technical exceptions
    + exception payload leaking into logs 
    + inadvertently leaking sensitive information 
    
- designing for adailability 

https://csrc.nist.gov/publications/detail/sp/800-27/rev-a/archive/2004-06-21

main goal of a resilient system is to survive failures and continue to provide its service. 

- responsiveness, To make the system more responsive without rejecting requests, you could, for example, place all the processing work in a queue

- XSS, https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)

An XSS polyglot is an attack vector that successfully executes a JavaScript (for example, alert('XSS')) in all three contexts

<div class="{{input}}"></div>
<noscript>{{input}}</noscript>
<!--{{input}}-->

- summary 

Separating business exceptions and technical exceptions is a good design strategy because technical details don’t belong in the domain.
You shouldn’t intermix technical and business exceptions using the same type.
It’s a good design practice to never include business data in technical exceptions, regardless of whether it’s sensitive or not.
You can create more secure code by designing for failures and treating failures as normal, unexceptional results.
Availability is an important security goal for software systems.
Resilience and responsiveness are traits that add security by improving the availability of a system.
You can use design patterns like circuit breakers, bulkheads, and timeouts to design for availability.
Repairing data before validation is dangerous and should be avoided at all costs.
You should never echo input verbatim.


# Benefits of cloud thinking 
- twelve factors 

https://12factor.net/

codebase, tracked in revision 

dependencies, explicitly declare and isolate dependencies 

config, store config in environment 

backing servcies, treat backing services as attached resources 

build, release, run, strictly separate build and run stages 

processes, execute the app as one or more stateless processes 

port binding, export services via port binding 

concurrency, scale out via the process model 

disposability, maximize robustness with fast startup and graceful shutdown 

dev/prod parity, keep development, staging and production as similar as possible 

logs, treat logs as event streams 

admin prcoesses, run admin/management tasks as one off processes 

- storing configuration in the environment 

- don't put environment configuration in code 

- YAML Ain’t Markup Language is a human-readable data serialization language. For more information, see http://yaml.org.

- Secrets should be provided at runtime, and the responsibility for managing them should rest with a limited set of people, not everyone with access to the codebase.

    + A cloud application should be run as a specific process (or processes), separated from the activity of building it or deploying it to the execution environment. 

    +  An application shouldn’t connect to a database specified in code. Instead, which database to use should be part of the deployment, as mentioned in the previous section on storing configuration in the environment. when connection to the database is managed by the environment, it's possible to detach the database and attach another during the runtime 

    + a process might be interrupted or killed at any moment, even in the middle of long-running processing.
    
    + file system shouldn't be relied on as a safe, longtime storage in the way you're used to from local filesystem in cloud 
    
    + avoid logging to file 
    
    + From a security perspective, logs should be locked away and never looked at; but in practice, logs are consumed in a completely different way.

- general data protection regulation,  information about the GDPR, see https://ec.europa.eu/info/law/law-topic/data-protection_en.


- whether a public cloud environment is more secure than an on-premise setup (or vice versa).
- storing configuration in the environment
- never save secret in code or resource 
- deploying and running are seperate things 
- process instances don't hold state 
    + A backing service is an external resource your application uses, typically by accessing it over the network. 
    
    can be a database for persistent storage 
    a message queue 
    a logging service 
    
    + An important aspect of backing services is that they should be managed by the environment—not by the application

- logging as a service 

- administrative tasks deployed to the server ready to run via a separate API 

clients 
|
V 
-----------------------------------------------------+
API or GUI for usual functionality                   |
|                   |                  |     admin   |<---administrators 
V                   |                  |     API     |
component0          V                  |             |
                 component1            V             |    
                                    component2 
------------------------------------------------------
OS                                                  |             
------------------------------------------------------
|
V
database 

no direct access to OS and database 

- centralized load balancing 

- client side load balancing, using a service discovery service to decide which service to call on the caller  

- enterpise security

https://builttoadapt.io/the-three-r-s-of-enterprise-security-rotate-repave-and-repair-f64f6d6ba29d

rotate, rotate every secrets every few minutes 

repave, servers and applications every few hours to prevent malicious software spread in the system 

repair vulnerable software as soon as possible 

- rotate, password and certificate are injected by platform into the runtime environment of the application 

- summary 

The twelve-factor app and cloud-native concepts can be used to increase the security of applications and systems.
You should run your application as stateless processes that can be started or decommissioned for any occasion.
Any result of processing should be stored to a backing service, such as a database, log service, or distributed cache.
Separating code and configuration is the key to allowing deployment to multiple environments without rebuilding the application.
Sensitive data should never be stored in resource files, because it can be accessed even after the application has terminated.
Configuration that changes with the environment should be part of the environment.
Administration tasks are important and should be part of the solution; they should be run as processes on the node.
Logging shouldn’t be done to a local file on disk, because it yields several security issues.
Using a centralized logging service yields several security benefits, regardless of whether you’re running an application in the cloud or on-premise.
Service discovery can increase security by improving availability and promoting an ever-changing system.
Applying the concept of the three R’s—rotate, repave, and repair—significantly improves many aspects of security. Designing your applications for the cloud is a prerequisite for doing this.



# Intermission an insurance policy for free 
- the difference between early deliberate discovery and late ignorant discovery 

https://dannorth.net/2010/08/30/introducing-deliberate-discovery/

- summary 

Do deliberate discovery early to get deep insights into subtle aspects of the domain.
Start specific, then abstract later.
Collect expertise from all adjacent domains.
Refactor names if they change semantics, especially if they change semantics outside the bounded context.



# Applying the fundamentals 
- ambiguous parameter lists
    + replace all 
    + find and fix the problems 
    + new api and refactor away the old API 

- identifying logging of unchecked strings 

public TableReservation fetch(final String reservationId) {
   logger.info("Fetching table reservation: " +
                                  reservationId);    ①  
   // fetch table reservation logic
   return tableReservation;
}
- summary 

Introducing domain primitives should be done at the semantic boundary of your context.
Ambiguous parameters in APIs are a common source of security bugs.
You should be on the lookout for ambiguous parameters when reading code and address them using the direct approach, the discovery approach, or the new API approach.
Never log unchecked user input, because it opens up the risk of second-order injection attacks.
Limit the number of times a sensitive value can be accessed, because it allows you to detect unintentional access.
Use explicit accessor methods for data that you want to log. Otherwise, new fields can end up in logs by accident.
Because defensive code constructs can be harmful, clarify them using contracts and domain primitives.
The DRY (Don’t Repeat Yourself) principle is about repeated representation of knowledge, not about repeated text.
Trying to reduce repeated text that isn’t repeated knowledge can cause unnecessary dependencies.
Failing to reduce repeated knowledge because the text differs can cause vulnerable inconsistencies.
Tests reveal possible weaknesses in your code, and you should look for invalid and extreme input tests.
Ensure that your domain primitives encompass an entire conceptual whole.
Be on the lookout for domain types lacking proper validation and address them with domain primitives and secure entities.


# Guidance in legacy code 
- microservices 
https://www.martinfowler.com/articles/microservices.html

an architectural style that structures an application as a collection of loosely coupled services, which implement business capabilities

https://microservices.io/

    + independent runtimes 
    + independent updates 
    + designed for down 
    + each service is a bounded context 
    + importance of designing your API 
    + splitting monoliths 
    + senstive data across services 
    
    in a microservice architecture, in OAuth 2.0, the first request is given a token (the JSON Web Token, or JWT) based on the caller.
    
    + thinking sensitive 
    
    Log data is transformed into JSON in an external normalization step.
    
    + Semantic versioning
    
    X.Y.Z, X is the major version, Y is the minor version, Z is the patch version 
    
    
    A change in major version means that incompatible changes have been introduced to the public API.
    A change in minor version means that changes have been made in a backward-compatible manner.
    A change in patch version means that only backward-compatible bug fixes have been introduced.
    
    A service must be uniquely identifiable by its name, version number, and instance ID.
    A transaction must be traceable across systems.
        
- summary 

A good microservice should have an independent runtime, allow independent updates, and be designed for other services being down.
Treating each microservice as a bounded context helps you design more secure APIs.
Secure design principles such as domain primitives and context mapping are also applicable when designing microservice APIs.
In order to avoid common security pitfalls, only expose domain operations in APIs, use explicit context mapping between services, and pay extra attention to evolving APIs.
It’s important to analyze confidentiality, integrity, availability, and traceability (CIA-T) across all services.
Identify data that’s sensitive and possibly needs to be secured across services.
The integrity of log data is important from a security standpoint.
Normalization and categorization of log data requires extensive domain knowledge and should be part of the service design.
A service must be uniquely identifiable by its name, version number, and instance ID.
A transaction must be traceable across systems.
Using a logger with a domain-oriented API facilitates a design that considers the confidentiality of log data.
Don’t intermix sensitive and nonsensitive data in the same log, because that can lead to accidental information leakage.


# A final word don't forget about security 
- what to include in a code security review 

Is proper encoding used when sending/receiving data in the web application?
Are security-related HTTP headers used properly?
What measures have been taken to mitigate cross-site scripting attacks?
Are the invariants checked in domain primitives strict enough?
Are automated security tests executed as part of the delivery pipeline?
How often are passwords rotated in the system?
How often are certificates rotated in the system?
How is sensitive data prevented from accidentally being written to logs?
How are passwords protected and stored?
Are the encryption schemes used suitable for the data being protected?
Are all queries to the database parameterized?
Is security monitoring performed and is there a process for dealing with detected incidents?

- aggregating information 

OWASP Dependency-Track project (https://dependencytrack.org) is an example of an open source tool that can aggregate vulnerability reports for multiple applications.

- run security penetration tests 

- learning from your mistakes 

Context-driven testing (CDT)
The context-driven approach was initially developed by James Bach, Brian Marick, Bret Pettichord, and Cem Kaner in 2001. The essence of CDT is that testing practices completely depend on the current situation and context in which an application resides

http://context-driven-testing.com/
    
- basic understanding of security, https://www.owasp.org/index.php/Top_10-2017_Top_10

- making security a source of inpsiration 
injection flaws 
strings 
design by contract immutability 
|
V 
domain primitives 

- summary 
You should use code security reviews as a recurring part of your secure software development process.
As your technology stack grows, it becomes important to invest in tooling that provides quick access to information about security vulnerabilities across the entire stack.
It can be beneficial to proactively set up a strategy for dealing with security vulnerabilities as part of your regular development cycle.
Pen tests can be used to challenge your design and detect microlesions caused by evolving domain models.
Feedback from a pen test should be used as an opportunity to learn from your mistakes.
Bug bounty programs can be used to simulate a continuous, never-ending pen test, but bug bounty programs are complex and require a great deal from an organization.
It’s important to study the field of security.
Knowledge from different domains can be used to solve security problems.
Incident handling and problem resolution have different focuses.
Incident handling needs to involve the whole team.
The security incident mechanism should focus on learning to become more resistant to attack.




    