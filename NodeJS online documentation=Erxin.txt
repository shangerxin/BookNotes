NodeJS online documentation=Erxin

# reference 
- 12.18.2
https://nodejs.org/dist/latest-v12.x/docs/api/

- check javascript new features 
$ node --v8-options | grep "in progress"

- The current behaviour of the --harmony flag on Node.js is to enable staged features only

- check v8 version 
$ node -p process.versions.v8

- contribution doc 
https://github.com/nodejs/node/blob/master/CONTRIBUTING.md


# About these document 
- have three statbility levels 
0, deprecated 
1, experimenetal 
2, stable


# Usage examples 
- usages 
$ node [options] [V8 options] [script.js | -e "script" | - ] [arguments]


# APIs 

## Assertion testing 
- Assert 

https://nodejs.org/dist/latest-v12.x/docs/api/assert.html

- functions 

Strict assertion mode
Legacy assertion mode

Class: assert.AssertionError
    new assert.AssertionError(options)
assert(value[, message])

assert.deepEqual(actual, expected[, message])
    Comparison details

assert.deepStrictEqual(actual, expected[, message])
    Comparison details
assert.doesNotMatch(string, regexp[, message])
assert.doesNotReject(asyncFn[, error][, message])
assert.doesNotThrow(fn[, error][, message])
assert.equal(actual, expected[, message])
assert.fail([message])
assert.fail(actual, expected[, message[, operator[, stackStartFn]]])
assert.ifError(value)
assert.match(string, regexp[, message])
assert.notDeepEqual(actual, expected[, message])
assert.notDeepStrictEqual(actual, expected[, message])
assert.notEqual(actual, expected[, message])
assert.notStrictEqual(actual, expected[, message])
assert.ok(value[, message])
assert.rejects(asyncFn[, error][, message])
assert.strictEqual(actual, expected[, message])
assert.throws(fn[, error][, message])



# Async hooks 
- async_hooks, The async_hooks module provides an API to track asynchronous resources. It can be accessed using

const async_hooks = require('async_hooks');

https://nodejs.org/dist/latest-v12.x/docs/api/async_hooks.html

This callback may be called multiple times, for example, the 'connection' event in net.createServer(), or just a single time like in fs.open(). A resource can also be closed before the callback is called. AsyncHook does not explicitly distinguish between these different cases 

If Workers are used, each thread has an independent async_hooks interface, and each thread will use a new set of async IDs.

- functions 

    Async hooks
        Terminology

        Public API

            Overview

                async_hooks.createHook(callbacks)
                    Error handling
                    Printing in AsyncHooks callbacks

            Class: AsyncHook
                asyncHook.enable()
                asyncHook.disable()

                Hook callbacks

                    init(asyncId, type, triggerAsyncId, resource)
                        type
                        triggerAsyncId
                        resource
                        Asynchronous context example
                    before(asyncId)
                    after(asyncId)
                    destroy(asyncId)
                    promiseResolve(asyncId)
                async_hooks.executionAsyncResource()
                async_hooks.executionAsyncId()
                async_hooks.triggerAsyncId()
        Promise execution tracking

        JavaScript embedder API

            Class: AsyncResource
                new AsyncResource(type[, options])
                asyncResource.runInAsyncScope(fn[, thisArg, ...args])
                asyncResource.emitDestroy()
                asyncResource.asyncId()
                asyncResource.triggerAsyncId()
            Using AsyncResource for a Worker thread pool
            Integrating AsyncResource with EventEmitter

        Class: AsyncLocalStorage
            new AsyncLocalStorage()
            asyncLocalStorage.disable()
            asyncLocalStorage.getStore()
            asyncLocalStorage.enterWith(store)
            asyncLocalStorage.run(store, callback[, ...args])
            asyncLocalStorage.exit(callback[, ...args])
            Usage with async/await
            Troubleshooting


# Buffer 
- Buffer 

In Node.js, Buffer objects are used to represent binary data in the form of a sequence of bytes. Many Node.js APIs, for example streams and file system operations, support Buffers, as interactions with the operating system or other processes generally always happen in terms of binary data
    
Instances of Buffer, and instances of Uint8Array in general, are similar to arrays of integers from 0 to 255, but correspond to fixed-sized blocks of memory and cannot contain any other values.
    
https://nodejs.org/dist/latest-v12.x/docs/api/buffer.html

```
require('buffer').Buffer;

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer's
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value & 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from('tést');

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from('tést', 'latin1');

```

- functions 
    Buffer
        Buffers and character encodings
        Buffers and TypedArrays
        Buffers and iteration

        Class: Buffer
            Class Method: Buffer.alloc(size[, fill[, encoding]])
            Class Method: Buffer.allocUnsafe(size)
            Class Method: Buffer.allocUnsafeSlow(size)
            Class Method: Buffer.byteLength(string[, encoding])
            Class Method: Buffer.compare(buf1, buf2)
            Class Method: Buffer.concat(list[, totalLength])
            Class Method: Buffer.from(array)
            Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])
            Class Method: Buffer.from(buffer)
            Class Method: Buffer.from(object[, offsetOrEncoding[, length]])
            Class Method: Buffer.from(string[, encoding])
            Class Method: Buffer.isBuffer(obj)
            Class Method: Buffer.isEncoding(encoding)
            Class Property: Buffer.poolSize
            buf[index]
            buf.buffer
            buf.byteOffset
            buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])
            buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
            buf.entries()
            buf.equals(otherBuffer)
            buf.fill(value[, offset[, end]][, encoding])
            buf.includes(value[, byteOffset][, encoding])
            buf.indexOf(value[, byteOffset][, encoding])
            buf.keys()
            buf.lastIndexOf(value[, byteOffset][, encoding])
            buf.length
            buf.parent
            buf.readBigInt64BE([offset])
            buf.readBigInt64LE([offset])
            buf.readBigUInt64BE([offset])
            buf.readBigUInt64LE([offset])
            buf.readDoubleBE([offset])
            buf.readDoubleLE([offset])
            buf.readFloatBE([offset])
            buf.readFloatLE([offset])
            buf.readInt8([offset])
            buf.readInt16BE([offset])
            buf.readInt16LE([offset])
            buf.readInt32BE([offset])
            buf.readInt32LE([offset])
            buf.readIntBE(offset, byteLength)
            buf.readIntLE(offset, byteLength)
            buf.readUInt8([offset])
            buf.readUInt16BE([offset])
            buf.readUInt16LE([offset])
            buf.readUInt32BE([offset])
            buf.readUInt32LE([offset])
            buf.readUIntBE(offset, byteLength)
            buf.readUIntLE(offset, byteLength)
            buf.subarray([start[, end]])
            buf.slice([start[, end]])
            buf.swap16()
            buf.swap32()
            buf.swap64()
            buf.toJSON()
            buf.toString([encoding[, start[, end]]])
            buf.values()
            buf.write(string[, offset[, length]][, encoding])
            buf.writeBigInt64BE(value[, offset])
            buf.writeBigInt64LE(value[, offset])
            buf.writeBigUInt64BE(value[, offset])
            buf.writeBigUInt64LE(value[, offset])
            buf.writeDoubleBE(value[, offset])
            buf.writeDoubleLE(value[, offset])
            buf.writeFloatBE(value[, offset])
            buf.writeFloatLE(value[, offset])
            buf.writeInt8(value[, offset])
            buf.writeInt16BE(value[, offset])
            buf.writeInt16LE(value[, offset])
            buf.writeInt32BE(value[, offset])
            buf.writeInt32LE(value[, offset])
            buf.writeIntBE(value, offset, byteLength)
            buf.writeIntLE(value, offset, byteLength)
            buf.writeUInt8(value[, offset])
            buf.writeUInt16BE(value[, offset])
            buf.writeUInt16LE(value[, offset])
            buf.writeUInt32BE(value[, offset])
            buf.writeUInt32LE(value[, offset])
            buf.writeUIntBE(value, offset, byteLength)
            buf.writeUIntLE(value, offset, byteLength)
            new Buffer(array)
            new Buffer(arrayBuffer[, byteOffset[, length]])
            new Buffer(buffer)
            new Buffer(size)
            new Buffer(string[, encoding])
        buffer.INSPECT_MAX_BYTES
        buffer.kMaxLength
        buffer.transcode(source, fromEnc, toEnc)

        Class: SlowBuffer
            new SlowBuffer(size)

        Buffer constants
            buffer.constants.MAX_LENGTH
            buffer.constants.MAX_STRING_LENGTH

        Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()
            The --zero-fill-buffers command line option
            What makes Buffer.allocUnsafe() and Buffer.allocUnsafeSlow() "unsafe"?

- binary-to-text encoding, Converting a Buffer into a string is typically referred to as encoding, and converting a string into a Buffer as decoding

utf8
utf16le 
latin1 
base64
hex 
ascii
latin1binary
ucs2, alias of utf16e

```
Buffer.from('1ag', 'hex');
// Prints <Buffer 1a>, data truncated when first non-hexadecimal value
// ('g') encountered.

Buffer.from('1a7g', 'hex');
// Prints <Buffer 1a>, data truncated when data ends in single digit ('7').

Buffer.from('1634', 'hex');
// Prints <Buffer 16 34>, all data represented.
```

# C++ addons 
- C++ addons,  shared objects written in C++. The require() function can load Addons as ordinary Node.js modules. Addons provide an interface between JavaScript and C/C++ libraries

N-API, nan, or direct use of internal V8, libuv and Node.js libraries. 

https://nodejs.org/dist/latest-v12.x/docs/api/addons.html

- N-API, doc 
https://nodejs.org/dist/latest-v12.x/docs/api/n-api.html

- contents 
    C++ addons

        Hello world

            Context-aware addons
                Worker support
            Building
            Linking to libraries included with Node.js
            Loading addons using require()
        Native abstractions for Node.js
        N-API

        Addon examples
            Function arguments
            Callbacks
            Object factory
            Function factory
            Wrapping C++ objects
            Factory of wrapped objects
            Passing wrapped objects around

- components and APIs 
V8: the C++ library Node.js uses to provide the JavaScript implementation. 

libuv: The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform.

Internal Node.js libraries. Node.js itself exports C++ APIs that Addons can use, the most important of which is the node::ObjectWrap class

Node.js includes other statically linked libraries including OpenSSL. These other libraries are located in the deps/ directory in the Node.js source tree.

- Hello world example 

    + addon written in C++ which equal to javascript code 
    
```
module.exports.hello = () => 'world';
```

    + steps to create C++ addon 
    
        1.  create file hello.cc 
        ```
        // hello.cc
        #include <node.h>

        namespace demo {

        using v8::FunctionCallbackInfo;
        using v8::Isolate;
        using v8::Local;
        using v8::NewStringType;
        using v8::Object;
        using v8::String;
        using v8::Value;

        void Method(const FunctionCallbackInfo<Value>& args) {
          Isolate* isolate = args.GetIsolate();
          args.GetReturnValue().Set(String::NewFromUtf8(
              isolate, "world", NewStringType::kNormal).ToLocalChecked());
        }

        void Initialize(Local<Object> exports) {
          NODE_SET_METHOD(exports, "hello", Method);
        }

        NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)  //no semi-colon 

        }  // namespace demo

        ```

        all node addons must export an initialization function with the pattern 
        
        ```
        void Initialize(Local<Object> exports);
        NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
        ```

- content-aware addons, sometime the addon need to be loaded multiple times in multiple contexts 

example the Electron runtime runs multiple instances of Node.js in a single process. Each instance will have its own require() cache, and thus each instance will need a native addon to behave correctly when loaded via require().

can be constructed by using the macro NODE_MODULE_INITIALIZER

```
using namespace v8;

extern "C" NODE_MODULE_EXPORT void
NODE_MODULE_INITIALIZER(Local<Object> exports,
                        Local<Value> module,
                        Local<Context> context) {
  /* Perform addon initialization steps here. */
}
```

    + The choice to build a context-aware addon carries with it the responsibility of carefully managing global static data. Since the addon may be loaded multiple times, potentially even from different threads, any global static data stored in the addon must be properly protected, and must not contain any persistent references to JavaScript objects. 
    
        1. define a class will hold per-addon-instance data 
        
        static void DeleteInstance(void* data) {
          // Cast `data` to an instance of the class and delete it.
        }

        2. Heap-allocate an instance of this class in the addon initializer.
        
        3. Call node::AddEnvironmentCleanupHook(), passing it the above-created instance and a pointer to DeleteInstance(). Ensure the environment is torn down 

        4. Store the instance of the class in a v8::External, and
        
        Pass the v8::External to all methods exposed to JavaScript by passing it to v8::FunctionTemplate::New() or v8::Function::New() which creates the native-backed JavaScript functions. The third parameter of v8::FunctionTemplate::New() or v8::Function::New() accepts the v8::External and makes it available in the native callback using the v8::FunctionCallbackInfo::Data() method.

        5. example 
        
```
#include <node.h>

using namespace v8;

class AddonData {
 public:
  explicit AddonData(Isolate* isolate):
      call_count(0) {
    // Ensure this per-addon-instance data is deleted at environment cleanup.
    node::AddEnvironmentCleanupHook(isolate, DeleteInstance, this);
  }

  // Per-addon data.
  int call_count;

  static void DeleteInstance(void* data) {
    delete static_cast<AddonData*>(data);
  }
};

static void Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  // Retrieve the per-addon-instance data.
  AddonData* data =
      reinterpret_cast<AddonData*>(info.Data().As<External>()->Value());
  data->call_count++;
  info.GetReturnValue().Set((double)data->call_count);
}

// Initialize this addon to be context-aware.
NODE_MODULE_INIT(/* exports, module, context */) {
  Isolate* isolate = context->GetIsolate();

  // Create a new instance of `AddonData` for this instance of the addon and
  // tie its life cycle to that of the Node.js environment.
  AddonData* data = new AddonData(isolate);

  // Wrap the data in a `v8::External` so we can pass it to the method we
  // expose.
  Local<External> external = External::New(isolate, data);

  // Expose the method `Method` to JavaScript, and make sure it receives the
  // per-addon-instance data we created above by passing `external` as the
  // third parameter to the `FunctionTemplate` constructor.
  exports->Set(context,
               String::NewFromUtf8(isolate, "method", NewStringType::kNormal)
                  .ToLocalChecked(),
               FunctionTemplate::New(isolate, Method, external)
                  ->GetFunction(context).ToLocalChecked()).FromJust();
}
```

- worker support
    + in order to be loaded from multiple node.js environment requires 
    
    Be an N-API addon, or
    Be declared as context-aware using NODE_MODULE_INIT() as described above

    + In order to support Worker threads, addons need to clean up any resources they may have allocated when such a thread exists.

```
void AddEnvironmentCleanupHook(v8::Isolate* isolate,
                               void (*fun)(void* arg),
                               void* arg);
```
    + example 
```
// addon.cc
#include <assert.h>
#include <stdlib.h>
#include <node.h>

using node::AddEnvironmentCleanupHook;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Object;

// Note: In a real-world application, do not rely on static/global data.
static char cookie[] = "yum yum";
static int cleanup_cb1_called = 0;
static int cleanup_cb2_called = 0;

static void cleanup_cb1(void* arg) {
  Isolate* isolate = static_cast<Isolate*>(arg);
  HandleScope scope(isolate);
  Local<Object> obj = Object::New(isolate);
  assert(!obj.IsEmpty());  // assert VM is still alive
  assert(obj->IsObject());
  cleanup_cb1_called++;
}

static void cleanup_cb2(void* arg) {
  assert(arg == static_cast<void*>(cookie));
  cleanup_cb2_called++;
}

static void sanity_check(void*) {
  assert(cleanup_cb1_called == 1);
  assert(cleanup_cb2_called == 1);
}

// Initialize this addon to be context-aware.
NODE_MODULE_INIT(/* exports, module, context */) {
  Isolate* isolate = context->GetIsolate();

  AddEnvironmentCleanupHook(isolate, sanity_check, nullptr);
  AddEnvironmentCleanupHook(isolate, cleanup_cb2, cookie);
  AddEnvironmentCleanupHook(isolate, cleanup_cb1, isolate);
}
```

load the addon 

```
// test.js
require('./build/Release/addon');
```

- building 
    + create a file called binding.gyp in the top-level of the project describing the build configuration of the module using a JSON-like format. use node-gyp to compile nodejs addons 
    
    https://github.com/nodejs/node-gyp
    
    node-gyp is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js.
    
```
{
  "targets": [
    {
      "target_name": "addon",
      "sources": [ "hello.cc" ]
    }
  ]
}
```
    
//TODO


# C/C++ addons with N-API 
//TODO 

# Child process
- Child process, The child_process module provides the ability to spawn child processes in a manner that is similar, but not identical, to popen(3). This capability is primarily provided by the child_process.spawn()

```
const { spawn } = require('child_process');
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

By default, pipes for stdin, stdout, and stderr are established between the parent Node.js process and the spawned child. These pipes have limited (and platform-specific) capacity.  If child process write to stdout. the child process will block waiting for the pipe buffer to accept more data. This is identical to the behavior of pipes in the shell. Use the { stdio: 'ignore' } option if the output will not be consumed

https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html
- functions 

    Child process

        Asynchronous process creation
            Spawning .bat and .cmd files on Windows
            child_process.exec(command[, options][, callback])
            child_process.execFile(file[, args][, options][, callback])
            child_process.fork(modulePath[, args][, options])

            child_process.spawn(command[, args][, options])
                options.detached
                options.stdio

        Synchronous process creation
            child_process.execFileSync(file[, args][, options])
            child_process.execSync(command[, options])
            child_process.spawnSync(command[, args][, options])

        Class: ChildProcess
            Event: 'close'
            Event: 'disconnect'
            Event: 'error'
            Event: 'exit'
            Event: 'message'
            subprocess.channel
            subprocess.connected
            subprocess.disconnect()
            subprocess.exitCode
            subprocess.kill([signal])
            subprocess.killed
            subprocess.pid
            subprocess.ref()

            subprocess.send(message[, sendHandle[, options]][, callback])
                Example: sending a server object
                Example: sending a socket object
            subprocess.signalCode
            subprocess.spawnargs
            subprocess.spawnfile
            subprocess.stderr
            subprocess.stdin
            subprocess.stdio
            subprocess.stdout
            subprocess.unref()
        maxBuffer and Unicode
        Shell requirements
        Default Windows shell
        Advanced serialization


# Cluster 
- Cluster, A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes 

create child process that all share server ports 
```
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // Fork workers.
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  // Workers can share any TCP connection
  // In this case it is an HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}
```

https://nodejs.org/dist/latest-v12.x/docs/api/cluster.html

On Windows, it is not yet possible to set up a named pipe server in a worker.

The worker processes are spawned using the child_process.fork() method, so that they can communicate with the parent via IPC and pass server handles back and forth

- functions 

    Cluster
        How it works

        Class: Worker
            Event: 'disconnect'
            Event: 'error'
            Event: 'exit'
            Event: 'listening'
            Event: 'message'
            Event: 'online'
            worker.disconnect()
            worker.exitedAfterDisconnect
            worker.id
            worker.isConnected()
            worker.isDead()
            worker.kill([signal])
            worker.process
            worker.send(message[, sendHandle[, options]][, callback])
        Event: 'disconnect'
        Event: 'exit'
        Event: 'fork'
        Event: 'listening'
        Event: 'message'
        Event: 'online'
        Event: 'setup'
        cluster.disconnect([callback])
        cluster.fork([env])
        cluster.isMaster
        cluster.isWorker
        cluster.schedulingPolicy
        cluster.settings
        cluster.setupMaster([settings])
        cluster.worker
        cluster.workers


# Command line options 
- command line options, To view this documentation as a manual page in a terminal, run man node.

```
$ node [options] [V8 options] [script.js | -e "script" | -] [--] [arguments]

//more doc on debugger sections for inspect 
$ node inspect [script.js | -e "script" | <host>:<port>] …

$ node --v8-options
```

https://nodejs.org/dist/latest-v12.x/docs/api/cli.html

- options 

    Command line options
        Synopsis

        Options
            -
            --
            --abort-on-uncaught-exception
            --completion-bash
            --cpu-prof
            --cpu-prof-dir
            --cpu-prof-interval
            --cpu-prof-name
            --disable-proto=mode
            --disallow-code-generation-from-strings
            --enable-fips
            --enable-source-maps
            --experimental-import-meta-resolve
            --experimental-json-modules
            --experimental-loader=module
            --experimental-modules
            --experimental-policy
            --experimental-repl-await
            --experimental-specifier-resolution=mode
            --experimental-vm-modules
            --experimental-wasi-unstable-preview1
            --experimental-wasm-modules
            --force-context-aware
            --force-fips
            --frozen-intrinsics
            --heapsnapshot-signal=signal
            --heap-prof
            --heap-prof-dir
            --heap-prof-interval
            --heap-prof-name
            --http-parser=library
            --http-server-default-timeout=milliseconds
            --icu-data-dir=file
            --input-type=type
            --inspect-brk[=[host:]port]
            --inspect-port=[host:]port

            --inspect[=[host:]port]
                Warning: binding inspector to a public IP:port combination is insecure
            --inspect-publish-uid=stderr,http
            --insecure-http-parser
            --jitless
            --max-http-header-size=size
            --napi-modules
            --no-deprecation
            --no-force-async-hooks-checks
            --no-warnings
            --openssl-config=file
            --pending-deprecation
            --policy-integrity=sri
            --preserve-symlinks
            --preserve-symlinks-main
            --prof
            --prof-process
            --redirect-warnings=file
            --report-compact
            --report-directory=directory
            --report-filename=filename
            --report-on-fatalerror
            --report-on-signal
            --report-signal=signal
            --report-uncaught-exception
            --throw-deprecation
            --title=title
            --tls-cipher-list=list
            --tls-keylog=file
            --tls-max-v1.2
            --tls-max-v1.3
            --tls-min-v1.0
            --tls-min-v1.1
            --tls-min-v1.2
            --tls-min-v1.3
            --trace-deprecation
            --trace-event-categories
            --trace-event-file-pattern
            --trace-events-enabled
            --trace-exit
            --trace-sigint
            --trace-sync-io
            --trace-tls
            --trace-uncaught
            --trace-warnings
            --track-heap-objects
            --unhandled-rejections=mode
            --use-bundled-ca, --use-openssl-ca
            --use-largepages=mode
            --v8-options
            --v8-pool-size=num
            --zero-fill-buffers
            -c, --check
            -e, --eval "script"
            -h, --help
            -i, --interactive
            -p, --print "script"
            -r, --require module
            -v, --version

        Environment variables
            NODE_DEBUG=module[,…]
            NODE_DEBUG_NATIVE=module[,…]
            NODE_DISABLE_COLORS=1
            NODE_EXTRA_CA_CERTS=file
            NODE_ICU_DATA=file
            NODE_NO_WARNINGS=1
            NODE_OPTIONS=options...
            NODE_PATH=path[:…]
            NODE_PENDING_DEPRECATION=1
            NODE_PENDING_PIPE_INSTANCES=instances
            NODE_PRESERVE_SYMLINKS=1
            NODE_REDIRECT_WARNINGS=file
            NODE_REPL_HISTORY=file
            NODE_REPL_EXTERNAL_MODULE=file
            NODE_TLS_REJECT_UNAUTHORIZED=value

            NODE_V8_COVERAGE=dir
                Coverage output
                Source map cache
            OPENSSL_CONF=file
            SSL_CERT_DIR=dir
            SSL_CERT_FILE=file
            UV_THREADPOOL_SIZE=size

        Useful V8 options
            --max-old-space-size=SIZE (in megabytes)


# Console 
- console, The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.

- functions 

    Console

        Class: Console
            new Console(stdout[, stderr][, ignoreErrors])
            new Console(options)
            console.assert(value[, ...message])
            console.clear()
            console.count([label])
            console.countReset([label])
            console.debug(data[, ...args])
            console.dir(obj[, options])
            console.dirxml(...data)
            console.error([data][, ...args])
            console.group([...label])
            console.groupCollapsed()
            console.groupEnd()
            console.info([data][, ...args])
            console.log([data][, ...args])
            console.table(tabularData[, properties])
            console.time([label])
            console.timeEnd([label])
            console.timeLog([label][, ...data])
            console.trace([message][, ...args])
            console.warn([data][, ...args])

        Inspector only methods
            console.profile([label])
            console.profileEnd([label])
            console.timeStamp([label])


# Crypto 
- Crypto, The crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions

```
const crypto = require('crypto');

const secret = 'abcdefg';
const hash = crypto.createHmac('sha256', secret)
                   .update('I love cupcakes')
                   .digest('hex');
console.log(hash);
// Prints:
//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e

```

https://nodejs.org/dist/latest-v12.x/docs/api/crypto.html
- function 

Crypto

    Determining if crypto support is unavailable

    Class: Certificate
        Certificate.exportChallenge(spkac)
        Certificate.exportPublicKey(spkac[, encoding])
        Certificate.verifySpkac(spkac)

        Legacy API
            new crypto.Certificate()
            certificate.exportChallenge(spkac)
            certificate.exportPublicKey(spkac)
            certificate.verifySpkac(spkac)

    Class: Cipher
        cipher.final([outputEncoding])
        cipher.setAAD(buffer[, options])
        cipher.getAuthTag()
        cipher.setAutoPadding([autoPadding])
        cipher.update(data[, inputEncoding][, outputEncoding])

    Class: Decipher
        decipher.final([outputEncoding])
        decipher.setAAD(buffer[, options])
        decipher.setAuthTag(buffer)
        decipher.setAutoPadding([autoPadding])
        decipher.update(data[, inputEncoding][, outputEncoding])

    Class: DiffieHellman
        diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])
        diffieHellman.generateKeys([encoding])
        diffieHellman.getGenerator([encoding])
        diffieHellman.getPrime([encoding])
        diffieHellman.getPrivateKey([encoding])
        diffieHellman.getPublicKey([encoding])
        diffieHellman.setPrivateKey(privateKey[, encoding])
        diffieHellman.setPublicKey(publicKey[, encoding])
        diffieHellman.verifyError
    Class: DiffieHellmanGroup

    Class: ECDH
        Class Method: ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])
        ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])
        ecdh.generateKeys([encoding[, format]])
        ecdh.getPrivateKey([encoding])
        ecdh.getPublicKey([encoding][, format])
        ecdh.setPrivateKey(privateKey[, encoding])
        ecdh.setPublicKey(publicKey[, encoding])

    Class: Hash
        hash.copy([options])
        hash.digest([encoding])
        hash.update(data[, inputEncoding])

    Class: Hmac
        hmac.digest([encoding])
        hmac.update(data[, inputEncoding])

    Class: KeyObject
        keyObject.asymmetricKeyType
        keyObject.export([options])
        keyObject.symmetricKeySize
        keyObject.type

    Class: Sign
        sign.sign(privateKey[, outputEncoding])
        sign.update(data[, inputEncoding])

    Class: Verify
        verify.update(data[, inputEncoding])
        verify.verify(object, signature[, signatureEncoding])

    crypto module methods and properties
        crypto.constants
        crypto.DEFAULT_ENCODING
        crypto.fips
        crypto.createCipher(algorithm, password[, options])
        crypto.createCipheriv(algorithm, key, iv[, options])
        crypto.createDecipher(algorithm, password[, options])
        crypto.createDecipheriv(algorithm, key, iv[, options])
        crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])
        crypto.createDiffieHellman(primeLength[, generator])
        crypto.createDiffieHellmanGroup(name)
        crypto.createECDH(curveName)
        crypto.createHash(algorithm[, options])
        crypto.createHmac(algorithm, key[, options])
        crypto.createPrivateKey(key)
        crypto.createPublicKey(key)
        crypto.createSecretKey(key)
        crypto.createSign(algorithm[, options])
        crypto.createVerify(algorithm[, options])
        crypto.diffieHellman(options)
        crypto.generateKeyPair(type, options, callback)
        crypto.generateKeyPairSync(type, options)
        crypto.getCiphers()
        crypto.getCurves()
        crypto.getDiffieHellman(groupName)
        crypto.getFips()
        crypto.getHashes()
        crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)
        crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)
        crypto.privateDecrypt(privateKey, buffer)
        crypto.privateEncrypt(privateKey, buffer)
        crypto.publicDecrypt(key, buffer)
        crypto.publicEncrypt(key, buffer)
        crypto.randomBytes(size[, callback])
        crypto.randomFillSync(buffer[, offset][, size])
        crypto.randomFill(buffer[, offset][, size], callback)
        crypto.scrypt(password, salt, keylen[, options], callback)
        crypto.scryptSync(password, salt, keylen[, options])
        crypto.setEngine(engine[, flags])
        crypto.setFips(bool)
        crypto.sign(algorithm, data, key)
        crypto.timingSafeEqual(a, b)
        crypto.verify(algorithm, data, key, signature)

- Crypto constants 
OpenSSL options 
OpenSSL engine constants 
Other OpenSSL constants 
Node.js crypto constants 

- Certificate, SPKAC is a Certificate Signing Request mechanism originally implemented by Netscape and was specified formally as part of HTML5's keygen element.

most common usage output generated by HTML5 <keygen> element, use https://www.openssl.org/docs/man1.1.0/apps/openssl-spkac.html OpenSSL's SPKAC implementation 

```
const { Certificate } = require('crypto');
const spkac = getSpkacSomehow();
const challenge = Certificate.exportChallenge(spkac);
console.log(challenge.toString('utf8'));
// Prints: the challenge as a UTF8 string

```

- Cipher, Instances of the Cipher class are used to encrypt data. The class can be used in one of two ways

    + As a stream that is both readable and writable, where plain unencrypted data is written to produce encrypted data on the readable side
    
    + Using the cipher.update() and cipher.final() methods to produce the encrypted data

```
const crypto = require('crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// Key length is dependent on the algorithm. In this case for aes192, it is
// 24 bytes (192 bits).
// Use async `crypto.scrypt()` instead.
const key = crypto.scryptSync(password, 'salt', 24);
// Use `crypto.randomBytes()` to generate a random iv instead of the static iv
// shown here.
const iv = Buffer.alloc(16, 0); // Initialization vector.

const cipher = crypto.createCipheriv(algorithm, key, iv);

let encrypted = '';
cipher.on('readable', () => {
  let chunk;
  while (null !== (chunk = cipher.read())) {
    encrypted += chunk.toString('hex');
  }
});
cipher.on('end', () => {
  console.log(encrypted);
  // Prints: e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa
});

cipher.write('some clear text data');
cipher.end();
```
- Decipher, Instances of the Decipher class are used to decrypt data. 
    + As a stream that is both readable and writable, where plain encrypted data is written to produce unencrypted data on the readable side
    
    + Using the decipher.update() and decipher.final() methods to produce the unencrypted data

```
const crypto = require('crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// Key length is dependent on the algorithm. In this case for aes192, it is
// 24 bytes (192 bits).
// Use the async `crypto.scrypt()` instead.
const key = crypto.scryptSync(password, 'salt', 24);
// The IV is usually passed along with the ciphertext.
const iv = Buffer.alloc(16, 0); // Initialization vector.

const decipher = crypto.createDecipheriv(algorithm, key, iv);

let decrypted = '';
decipher.on('readable', () => {
  while (null !== (chunk = decipher.read())) {
    decrypted += chunk.toString('utf8');
  }
});
decipher.on('end', () => {
  console.log(decrypted);
  // Prints: some clear text data
});

// Encrypted with same algorithm, key and iv.
const encrypted =
  'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
decipher.write(encrypted, 'hex');
decipher.end();
```

- DiffieHellman, is a utility for creating Diffie-Hellman key exchanges.

```
const crypto = require('crypto');
const assert = require('assert');

// Generate Alice's keys...
const alice = crypto.createDiffieHellman(2048);
const aliceKey = alice.generateKeys();

// Generate Bob's keys...
const bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());
const bobKey = bob.generateKeys();

// Exchange and generate the secret...
const aliceSecret = alice.computeSecret(bobKey);
const bobSecret = bob.computeSecret(aliceKey);

// OK
assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
```
 
- ECDH class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH) key exchanges.

- Hash class is a utility for creating hash digests of data. It can be used in one of two ways:

    + As a stream that is both readable and writable, where data is written to produce a computed hash digest on the readable side
    
    + Using the hash.update() and hash.digest() methods to produce the computed hash
    
use hash objects as streams
```
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.on('readable', () => {
  // Only one element is going to be produced by the
  // hash stream.
  const data = hash.read();
  if (data) {
    console.log(data.toString('hex'));
    // Prints:
    //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
  }
});

hash.write('some data to hash');
hash.end();
```

using hash and piped streams 
```
const crypto = require('crypto');
const fs = require('fs');
const hash = crypto.createHash('sha256');

const input = fs.createReadStream('test.js');
input.pipe(hash).pipe(process.stdout);
```
    
using hash.update(), hash.digest() methods 
```
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.update('some data to hash');
console.log(hash.digest('hex'));
// Prints:
//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50

```

- Hmac class is a utility for creating cryptographic HMAC digests
    + As a stream that is both readable and writable
    + Using the hmac.update() and hmac.digest() methods to produce the computed HMAC diges
    
```
const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.on('readable', () => {
  // Only one element is going to be produced by the
  // hash stream.
  const data = hmac.read();
  if (data) {
    console.log(data.toString('hex'));
    // Prints:
    //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
  }
});

hmac.write('some data to hash');
hmac.end();
```
    
```
const crypto = require('crypto');
const fs = require('fs');
const hmac = crypto.createHmac('sha256', 'a secret');

const input = fs.createReadStream('test.js');
input.pipe(hmac).pipe(process.stdout);
```

```
const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.update('some data to hash');
console.log(hmac.digest('hex'));
// Prints:
//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
 
```

- KeyObject, Node.js uses a KeyObject class to represent a symmetric or asymmetric key, and each kind of key exposes different functions. 

- Sign, The Sign class is a utility for generating signatures. It can be used in one of two ways

Use as stream 
```
const crypto = require('crypto');

const { privateKey, publicKey } = crypto.generateKeyPairSync('ec', {
  namedCurve: 'sect239k1'
});

const sign = crypto.createSign('SHA256');
sign.write('some data to sign');
sign.end();
const signature = sign.sign(privateKey, 'hex');

const verify = crypto.createVerify('SHA256');
verify.write('some data to sign');
verify.end();
console.log(verify.verify(publicKey, signature, 'hex'));
// Prints: true

```

```
const crypto = require('crypto');

const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
});

const sign = crypto.createSign('SHA256');
sign.update('some data to sign');
sign.end();
const signature = sign.sign(privateKey);

const verify = crypto.createVerify('SHA256');
verify.update('some data to sign');
verify.end();
console.log(verify.verify(publicKey, signature));
// Prints: true

```

- Verify class is a utility for verifying signatures. It can be used in one of two ways


# Debugger 
- Debugger, Node.js includes an out-of-process debugging utility accessible via a V8 Inspector

```
$ node inspect myscript.js
< Debugger listening on ws://127.0.0.1:9229/80e7a814-7cd3-49fb-921a-2e02228cd5ba
< For help, see: https://nodejs.org/en/docs/inspector
< Debugger attached.
Break on start in myscript.js:1
> 1 (function (exports, require, module, __filename, __dirname) { global.x = 5;
  2 setTimeout(() => {
  3   console.log('world');
debug>

```

https://nodejs.org/dist/latest-v12.x/docs/api/debugger.html

- function 

    Debugger
        Watchers

        Command reference
            Stepping
            Breakpoints
            Information
            Execution control
            Various

        Advanced usage
            V8 inspector integration for Node.js



# Deprecated APIs 

# DNS 
- DNS, The dns module enables name resolution. For example, use it to look up IP addresses of host names.
```
const dns = require('dns');

dns.lookup('example.org', (err, address, family) => {
  console.log('address: %j family: IPv%s', address, family);
});
// address: "93.184.216.34" family: IPv4

```

https://nodejs.org/dist/latest-v12.x/docs/api/dns.html
- function 

    DNS

        Class: dns.Resolver
            Resolver([options])
            resolver.cancel()
        dns.getServers()

        dns.lookup(hostname[, options], callback)
            Supported getaddrinfo flags
        dns.lookupService(address, port, callback)
        dns.resolve(hostname[, rrtype], callback)
        dns.resolve4(hostname[, options], callback)
        dns.resolve6(hostname[, options], callback)
        dns.resolveAny(hostname, callback)
        dns.resolveCname(hostname, callback)
        dns.resolveMx(hostname, callback)
        dns.resolveNaptr(hostname, callback)
        dns.resolveNs(hostname, callback)
        dns.resolvePtr(hostname, callback)
        dns.resolveSoa(hostname, callback)
        dns.resolveSrv(hostname, callback)
        dns.resolveTxt(hostname, callback)
        dns.reverse(ip, callback)
        dns.setServers(servers)

        DNS promises API
            Class: dnsPromises.Resolver
            dnsPromises.getServers()
            dnsPromises.lookup(hostname[, options])
            dnsPromises.lookupService(address, port)
            dnsPromises.resolve(hostname[, rrtype])
            dnsPromises.resolve4(hostname[, options])
            dnsPromises.resolve6(hostname[, options])
            dnsPromises.resolveAny(hostname)
            dnsPromises.resolveCname(hostname)
            dnsPromises.resolveMx(hostname)
            dnsPromises.resolveNaptr(hostname)
            dnsPromises.resolveNs(hostname)
            dnsPromises.resolvePtr(hostname)
            dnsPromises.resolveSoa(hostname)
            dnsPromises.resolveSrv(hostname)
            dnsPromises.resolveTxt(hostname)
            dnsPromises.reverse(ip)
            dnsPromises.setServers(servers)
        Error codes

        Implementation considerations
            dns.lookup()
            dns.resolve(), dns.resolve*() and dns.reverse()


# Domain (deprecated) 


# ECMAScript modules 
- ECMAScript, ECMAScript modules are the official standard format to package JavaScript code for reuse

ES module exports a function 
```
// addTwo.mjs
function addTwo(num) {
  return num + 2;
}

export { addTwo };
```

import the module 
```
// app.mjs
import { addTwo } from './addTwo.mjs';

// Prints: 6
console.log(addTwo(4));
```

// package.json, the module type ES module is enable by default 
{
  "type": "module"
}

https://nodejs.org/dist/latest-v12.x/docs/api/esm.html

- function 

    ECMAScript modules
        Introduction

        Enabling
            package.json "type" field
            Package scope and file extensions
            --input-type flag

        Packages

            Package entry points
                Main entry point export
                Subpath exports
                Package exports fallbacks
                Exports sugar
                Conditional exports
                Nested conditions
                Self-referencing a package using its name

            Dual CommonJS/ES module packages
                Dual package hazard

                Writing dual packages while avoiding or minimizing hazards
                    Approach #1: Use an ES module wrapper
                    Approach #2: Isolate state

        import Specifiers

            Terminology
                data: Imports
        import.meta

        Differences between ES modules and CommonJS
            Mandatory file extensions
            No NODE_PATH
            No require, exports, module.exports, __filename, __dirname
            No require.resolve
            No require.extensions
            No require.cache
            URL-based paths

        Interoperability with CommonJS
            require
            import statements
            import() expressions
        CommonJS, JSON, and native modules
        Builtin modules
        Experimental JSON modules
        Experimental Wasm modules

        Experimental loaders

            Hooks
                resolve hook
                getFormat hook
                getSource hook
                transformSource hook
                getGlobalPreloadCode hook
                dynamicInstantiate hook

            Examples
                HTTPS loader
                Transpiler loader

        Resolution algorithm
            Features
            Resolver algorithm
            Customizing ESM specifier resolution algorithm


# Errors 
- Errors, Node.js will generally experience four categories of errors
    1. Standard JavaScript errors such as <EvalError>, <SyntaxError>, <RangeError>, <ReferenceError>, <TypeError>, and <URIError>
    2. System errors triggered by underlying operating system
    3. User-specified errors triggered by application code
    4. AssertionErrors are a special class of error that can be triggered when Node.js 

https://nodejs.org/dist/latest-v12.x/docs/api/errors.html
- functions 
Errors

    Error propagation and interception
        Error-first callbacks

    Class: Error
        new Error(message)
        Error.captureStackTrace(targetObject[, constructorOpt])
        Error.stackTraceLimit
        error.code
        error.message
        error.stack
    Class: AssertionError
    Class: RangeError
    Class: ReferenceError
    Class: SyntaxError

    Class: SystemError
        error.address
        error.code
        error.dest
        error.errno
        error.info
        error.message
        error.path
        error.port
        error.syscall
        Common system errors
    Class: TypeError
    Exceptions vs. errors

    OpenSSL errors
        error.opensslErrorStack
        error.function
        error.library
        error.reason

    Node.js error codes
        ERR_AMBIGUOUS_ARGUMENT
        ERR_ARG_NOT_ITERABLE
        ERR_ASSERTION
        ERR_ASYNC_CALLBACK
        ERR_ASYNC_TYPE
        ...


# Events 
- Events, Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture. emit events are instances of the EventEmitter class

```
const myEmitter = new MyEmitter();
myEmitter.on('event', function(a, b) {
  console.log(a, b, this, this === myEmitter);
  // Prints:
  //   a b MyEmitter {
  //     domain: null,
  //     _events: { event: [Function] },
  //     _eventsCount: 1,
  //     _maxListeners: undefined } true
});
myEmitter.emit('event', 'a', 'b');
```

```
const myEmitter = new MyEmitter();
let m = 0;
myEmitter.once('event', () => {
  console.log(++m);
});
myEmitter.emit('event');
// Prints: 1
myEmitter.emit('event');
// Ignored

```
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error

https://nodejs.org/dist/latest-v12.x/docs/api/events.html
- function 

    Events
        Passing arguments and this to listeners
        Asynchronous vs. synchronous
        Handling events only once
        Error events
        Capture rejections of promises

        Class: EventEmitter
            Event: 'newListener'
            Event: 'removeListener'
            EventEmitter.listenerCount(emitter, eventName)
            EventEmitter.defaultMaxListeners
            EventEmitter.errorMonitor
            emitter.addListener(eventName, listener)
            emitter.emit(eventName[, ...args])
            emitter.eventNames()
            emitter.getMaxListeners()
            emitter.listenerCount(eventName)
            emitter.listeners(eventName)
            emitter.off(eventName, listener)
            emitter.on(eventName, listener)
            emitter.once(eventName, listener)
            emitter.prependListener(eventName, listener)
            emitter.prependOnceListener(eventName, listener)
            emitter.removeAllListeners([eventName])
            emitter.removeListener(eventName, listener)
            emitter.setMaxListeners(n)
            emitter.rawListeners(eventName)
            emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])
        events.once(emitter, name)
        events.captureRejections
        events.captureRejectionSymbol
        events.on(emitter, eventName)

- capture rejections of promises 
```
const ee1 = new EventEmitter({ captureRejections: true });
ee1.on('something', async (value) => {
  throw new Error('kaboom');
});

ee1.on('error', console.log);

const ee2 = new EventEmitter({ captureRejections: true });
ee2.on('something', async (value) => {
  throw new Error('kaboom');
});

ee2[Symbol.for('nodejs.rejection')] = console.log;
```


# File system 
- File system, interacting with the file system in a manner closely modeled around standard POSIX (Portable Operating System Interface) functions.

https://nodejs.org/dist/latest-v12.x/docs/api/fs.html
- functions
    File system

        File paths
            URL object support
        File descriptors
        Threadpool usage

        Class: fs.Dir
            dir.close()
            dir.close(callback)
            dir.closeSync()
            dir.path
            dir.read()
            dir.read(callback)
            dir.readSync()
            dir[Symbol.asyncIterator]()

        Class: fs.Dirent
            dirent.isBlockDevice()
            dirent.isCharacterDevice()
            dirent.isDirectory()
            dirent.isFIFO()
            dirent.isFile()
            dirent.isSocket()
            dirent.isSymbolicLink()
            dirent.name

        Class: fs.FSWatcher
            Event: 'change'
            Event: 'close'
            Event: 'error'
            watcher.close()

        Class: fs.ReadStream
            Event: 'close'
            Event: 'open'
            Event: 'ready'
            readStream.bytesRead
            readStream.path
            readStream.pending

        Class: fs.Stats
            stats.isBlockDevice()
            stats.isCharacterDevice()
            stats.isDirectory()
            stats.isFIFO()
            stats.isFile()
            stats.isSocket()
            stats.isSymbolicLink()
            stats.dev
            stats.ino
            stats.mode
            stats.nlink
            stats.uid
            stats.gid
            stats.rdev
            stats.size
            stats.blksize
            stats.blocks
            stats.atimeMs
            stats.mtimeMs
            stats.ctimeMs
            stats.birthtimeMs
            stats.atimeNs
            stats.mtimeNs
            stats.ctimeNs
            stats.birthtimeNs
            stats.atime
            stats.mtime
            stats.ctime
            stats.birthtime
            Stat time values

        Class: fs.WriteStream
            Event: 'close'
            Event: 'open'
            Event: 'ready'
            writeStream.bytesWritten
            writeStream.path
            writeStream.pending
        fs.access(path[, mode], callback)
        fs.accessSync(path[, mode])
        fs.appendFile(path, data[, options], callback)
        fs.appendFileSync(path, data[, options])

        fs.chmod(path, mode, callback)
            File modes
        fs.chmodSync(path, mode)
        fs.chown(path, uid, gid, callback)
        fs.chownSync(path, uid, gid)
        fs.close(fd, callback)
        fs.closeSync(fd)
        fs.constants
        fs.copyFile(src, dest[, flags], callback)
        fs.copyFileSync(src, dest[, flags])
        fs.createReadStream(path[, options])
        fs.createWriteStream(path[, options])
        fs.exists(path, callback)
        fs.existsSync(path)
        fs.fchmod(fd, mode, callback)
        fs.fchmodSync(fd, mode)
        fs.fchown(fd, uid, gid, callback)
        fs.fchownSync(fd, uid, gid)
        fs.fdatasync(fd, callback)
        fs.fdatasyncSync(fd)
        fs.fstat(fd[, options], callback)
        fs.fstatSync(fd[, options])
        fs.fsync(fd, callback)
        fs.fsyncSync(fd)
        fs.ftruncate(fd[, len], callback)
        fs.ftruncateSync(fd[, len])
        fs.futimes(fd, atime, mtime, callback)
        fs.futimesSync(fd, atime, mtime)
        fs.lchmod(path, mode, callback)
        fs.lchmodSync(path, mode)
        fs.lchown(path, uid, gid, callback)
        fs.lchownSync(path, uid, gid)
        fs.link(existingPath, newPath, callback)
        fs.linkSync(existingPath, newPath)
        fs.lstat(path[, options], callback)
        fs.lstatSync(path[, options])
        fs.mkdir(path[, options], callback)
        fs.mkdirSync(path[, options])
        fs.mkdtemp(prefix[, options], callback)
        fs.mkdtempSync(prefix[, options])
        fs.open(path[, flags[, mode]], callback)
        fs.opendir(path[, options], callback)
        fs.opendirSync(path[, options])
        fs.openSync(path[, flags, mode])
        fs.read(fd, buffer, offset, length, position, callback)
        fs.read(fd, [options,] callback)
        fs.readdir(path[, options], callback)
        fs.readdirSync(path[, options])

        fs.readFile(path[, options], callback)
            File descriptors
        fs.readFileSync(path[, options])
        fs.readlink(path[, options], callback)
        fs.readlinkSync(path[, options])
        fs.readSync(fd, buffer, offset, length, position)
        fs.readSync(fd, buffer, [options])
        fs.readv(fd, buffers[, position], callback)
        fs.readvSync(fd, buffers[, position])
        fs.realpath(path[, options], callback)
        fs.realpath.native(path[, options], callback)
        fs.realpathSync(path[, options])
        fs.realpathSync.native(path[, options])
        fs.rename(oldPath, newPath, callback)
        fs.renameSync(oldPath, newPath)
        fs.rmdir(path[, options], callback)
        fs.rmdirSync(path[, options])
        fs.stat(path[, options], callback)
        fs.statSync(path[, options])
        fs.symlink(target, path[, type], callback)
        fs.symlinkSync(target, path[, type])
        fs.truncate(path[, len], callback)
        fs.truncateSync(path[, len])
        fs.unlink(path, callback)
        fs.unlinkSync(path)
        fs.unwatchFile(filename[, listener])
        fs.utimes(path, atime, mtime, callback)
        fs.utimesSync(path, atime, mtime)

        fs.watch(filename[, options][, listener])

            Caveats
                Availability
                Inodes
                Filename argument
        fs.watchFile(filename[, options], listener)
        fs.write(fd, buffer[, offset[, length[, position]]], callback)
        fs.write(fd, string[, position[, encoding]], callback)

        fs.writeFile(file, data[, options], callback)
            Using fs.writeFile() with file descriptors
        fs.writeFileSync(file, data[, options])
        fs.writeSync(fd, buffer[, offset[, length[, position]]])
        fs.writeSync(fd, string[, position[, encoding]])
        fs.writev(fd, buffers[, position], callback)
        fs.writevSync(fd, buffers[, position])

        fs Promises API

            Class: FileHandle
                filehandle.appendFile(data, options)
                filehandle.chmod(mode)
                filehandle.chown(uid, gid)
                filehandle.close()
                filehandle.datasync()
                filehandle.fd
                filehandle.read(buffer, offset, length, position)
                filehandle.read(options)
                filehandle.readFile(options)
                filehandle.readv(buffers[, position])
                filehandle.stat([options])
                filehandle.sync()
                filehandle.truncate(len)
                filehandle.utimes(atime, mtime)
                filehandle.write(buffer[, offset[, length[, position]]])
                filehandle.write(string[, position[, encoding]])
                filehandle.writeFile(data, options)
                filehandle.writev(buffers[, position])
            fsPromises.access(path[, mode])
            fsPromises.appendFile(path, data[, options])
            fsPromises.chmod(path, mode)
            fsPromises.chown(path, uid, gid)
            fsPromises.copyFile(src, dest[, flags])
            fsPromises.lchmod(path, mode)
            fsPromises.lchown(path, uid, gid)
            fsPromises.link(existingPath, newPath)
            fsPromises.lstat(path[, options])
            fsPromises.mkdir(path[, options])
            fsPromises.mkdtemp(prefix[, options])
            fsPromises.open(path, flags[, mode])
            fsPromises.opendir(path[, options])
            fsPromises.readdir(path[, options])
            fsPromises.readFile(path[, options])
            fsPromises.readlink(path[, options])
            fsPromises.realpath(path[, options])
            fsPromises.rename(oldPath, newPath)
            fsPromises.rmdir(path[, options])
            fsPromises.stat(path[, options])
            fsPromises.symlink(target, path[, type])
            fsPromises.truncate(path[, len])
            fsPromises.unlink(path)
            fsPromises.utimes(path, atime, mtime)
            fsPromises.writeFile(file, data[, options])

        FS constants
            File access constants
            File copy constants
            File open constants
            File type constants
            File mode constants
        File system flags


# Globals 
- Globals, These objects are available in all modules. The following variables may appear to be global but are not. They exist only in the scope of modules, see the module system documentation

    __dirname
    __filename
    exports
    module
    require()
    
javascript built-in objects 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects

nodejs global objects 
https://nodejs.org/dist/latest-v12.x/docs/api/globals.html
- functions, nodejs global objects 

    Global objects
        Class: Buffer
        __dirname
        __filename
        clearImmediate(immediateObject)
        clearInterval(intervalObject)
        clearTimeout(timeoutObject)
        console
        exports
        global
        module
        process
        queueMicrotask(callback)
        require()
        setImmediate(callback[, ...args])
        setInterval(callback, delay[, ...args])
        setTimeout(callback, delay[, ...args])
        TextDecoder
        TextEncoder
        URL
        URLSearchParams
        WebAssembly
        
- javascript global objects 
    + Value properties

These global properties return a simple value. They have no properties or methods.

    Infinity
    NaN
    undefined
    globalThis

    + Function properties

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

    eval()
    uneval() 
    isFinite()
    isNaN()
    parseFloat()
    parseInt()
    encodeURI()
    encodeURIComponent()
    decodeURI()
    decodeURIComponent()
    Deprecated
        escape() 
        unescape() 

    + Fundamental objects

These are the fundamental, basic objects upon which all other objects are based. This includes general objects, booleans, functions, and symbols.

    Object
    Function
    Boolean
    Symbol

    + Error objects

Error objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

    Error
    AggregateError 
    EvalError
    InternalError 
    RangeError
    ReferenceError
    SyntaxError
    TypeError
    URIError

    + Numbers and dates

These are the base objects representing numbers, dates, and mathematical calculations.

    Number
    BigInt
    Math
    Date

    + Text processing

These objects represent strings and support manipulating them.

    String
    RegExp

    + Indexed collections

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

    Array
    Int8Array
    Uint8Array
    Uint8ClampedArray
    Int16Array
    Uint16Array
    Int32Array
    Uint32Array
    Float32Array
    Float64Array
    BigInt64Array
    BigUint64Array

    + Keyed collections

These objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

    Map
    Set
    WeakMap
    WeakSet

    + Structured data

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

    ArrayBuffer
    SharedArrayBuffer 
    Atomics 
    DataView
    JSON

    + Control abstraction objects

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

    Promise
    Generator
    GeneratorFunction
    AsyncFunction

    + Reflection

    Reflect
    Proxy

    + Internationalization

Additions to the ECMAScript core for language-sensitive functionalities.

    Intl
    Intl.Collator
    Intl.DateTimeFormat
    Intl.ListFormat
    Intl.NumberFormat
    Intl.PluralRules
    Intl.RelativeTimeFormat
    Intl.Locale

    + WebAssembly

    WebAssembly
    WebAssembly.Module
    WebAssembly.Instance
    WebAssembly.Memory
    WebAssembly.Table
    WebAssembly.CompileError
    WebAssembly.LinkError
    WebAssembly.RuntimeError

    + Other

    arguments

- global, the top-level scope is the global scope.
- process, have its own section document 
https://nodejs.org/dist/latest-v12.x/docs/api/process.html#process_process


# HTTP 
- HTTP, HTTP server and client one must require('http'). HTTP message headers are represented by an object like this:

{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'host': 'mysite.com',
  'accept': '*/*' }
  
Keys are lowercased. Values are not modified. NodeJS full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.

raw headers as they were received [key, value, key2, value2, ...]

[ 'ConTent-Length', '123456',
  'content-LENGTH', '123',
  'content-type', 'text/plain',
  'CONNECTION', 'keep-alive',
  'Host', 'mysite.com',
  'accepT', '*/*' ]

https://nodejs.org/dist/latest-v12.x/docs/api/http.html
- functions 
    HTTP

        Class: http.Agent
            new Agent([options])
            agent.createConnection(options[, callback])
            agent.keepSocketAlive(socket)
            agent.reuseSocket(socket, request)
            agent.destroy()
            agent.freeSockets
            agent.getName(options)
            agent.maxFreeSockets
            agent.maxSockets
            agent.requests
            agent.sockets

        Class: http.ClientRequest
            Event: 'abort'
            Event: 'connect'
            Event: 'continue'
            Event: 'information'
            Event: 'response'
            Event: 'socket'
            Event: 'timeout'
            Event: 'upgrade'
            request.abort()
            request.aborted
            request.connection
            request.end([data[, encoding]][, callback])
            request.finished
            request.flushHeaders()
            request.getHeader(name)
            request.maxHeadersCount
            request.path
            request.removeHeader(name)
            request.reusedSocket
            request.setHeader(name, value)
            request.setNoDelay([noDelay])
            request.setSocketKeepAlive([enable][, initialDelay])
            request.setTimeout(timeout[, callback])
            request.socket
            request.writableEnded
            request.writableFinished
            request.write(chunk[, encoding][, callback])

        Class: http.Server
            Event: 'checkContinue'
            Event: 'checkExpectation'
            Event: 'clientError'
            Event: 'close'
            Event: 'connect'
            Event: 'connection'
            Event: 'request'
            Event: 'upgrade'
            server.close([callback])
            server.headersTimeout
            server.listen()
            server.listening
            server.maxHeadersCount
            server.setTimeout([msecs][, callback])
            server.timeout
            server.keepAliveTimeout

        Class: http.ServerResponse
            Event: 'close'
            Event: 'finish'
            response.addTrailers(headers)
            response.connection
            response.cork()
            response.end([data[, encoding]][, callback])
            response.finished
            response.flushHeaders()
            response.getHeader(name)
            response.getHeaderNames()
            response.getHeaders()
            response.hasHeader(name)
            response.headersSent
            response.removeHeader(name)
            response.sendDate
            response.setHeader(name, value)
            response.setTimeout(msecs[, callback])
            response.socket
            response.statusCode
            response.statusMessage
            response.uncork()
            response.writableEnded
            response.writableFinished
            response.write(chunk[, encoding][, callback])
            response.writeContinue()
            response.writeHead(statusCode[, statusMessage][, headers])
            response.writeProcessing()

        Class: http.IncomingMessage
            Event: 'aborted'
            Event: 'close'
            message.aborted
            message.complete
            message.destroy([error])
            message.headers
            message.httpVersion
            message.method
            message.rawHeaders
            message.rawTrailers
            message.setTimeout(msecs[, callback])
            message.socket
            message.statusCode
            message.statusMessage
            message.trailers
            message.url
        http.METHODS
        http.STATUS_CODES
        http.createServer([options][, requestListener])
        http.get(options[, callback])
        http.get(url[, options][, callback])
        http.globalAgent
        http.maxHeaderSize
        http.request(options[, callback])
        http.request(url[, options][, callback])

- http.Agent 

Agent is responsible for managing connection persistence and reuse for HTTP clients. It maintains a queue of pending requests for a given host and port, reusing a single socket connection for each until the queue is empty, at which time the socket is either destroyed or put into a pool where it is kept to be used again

Pooled connections have TCP Keep-Alive enabled for them. Servers may also refuse to allow multiple requests over the same connection

good practice, to destroy() an Agent instance when it is no longer in use, because unused sockets consume OS resources.

```
http.get(options, (res) => {
  // Do stuff
}).on('socket', (socket) => {
  socket.emit('agentRemove');
});
```

```
const http = require('http');
const keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);
```

- http.ClientRequest, created internally and returned from http.request(). It represents an in-progress request whose header has already been queued.

To get the response, add a listener for 'response' to the request object. 'response' will be emitted from the request object when the response headers have been received.

if a 'response' event handler is added, then the data from the response object must be consumed by response.read() or response.resume() then 'end' event will be fired 

- http.Server, Extends: <net.Server>, a request with an HTTP Expect: 100-continue is received. If this event is not listened for, the server will automatically respond with a 100 Continue as appropriate.

- http.ServerResponse, Extends: <Stream>,  created internally by an HTTP server, not by the user. It is passed as the second parameter to the 'request' event.

- http.IncomingMessage, An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the 'request' and 'response' event respectively. 

- http.METHODS, A list of the HTTP methods that are supported by the parser.


# HTTP/2 
- HTTP/2, The http2 module provides an implementation of the HTTP/2 protocol. It can be accessed using

```
const http2 = require('http2');
```

https://nodejs.org/dist/latest-v12.x/docs/api/http2.html

- functions 


    HTTP/2

        Core API
            Server-side example
            Client-side example

            Class: Http2Session
                Http2Session and sockets
                Event: 'close'
                Event: 'connect'
                Event: 'error'
                Event: 'frameError'
                Event: 'goaway'
                Event: 'localSettings'
                Event: 'ping'
                Event: 'remoteSettings'
                Event: 'stream'
                Event: 'timeout'
                http2session.alpnProtocol
                http2session.close([callback])
                http2session.closed
                http2session.connecting
                http2session.destroy([error][, code])
                http2session.destroyed
                http2session.encrypted
                http2session.goaway([code[, lastStreamID[, opaqueData]]])
                http2session.localSettings
                http2session.originSet
                http2session.pendingSettingsAck
                http2session.ping([payload, ]callback)
                http2session.ref()
                http2session.remoteSettings
                http2session.setTimeout(msecs, callback)
                http2session.socket
                http2session.state
                http2session.settings([settings][, callback])
                http2session.type
                http2session.unref()

            Class: ServerHttp2Session
                serverhttp2session.altsvc(alt, originOrStream)
                Specifying alternative services
                serverhttp2session.origin(...origins)

            Class: ClientHttp2Session
                Event: 'altsvc'
                Event: 'origin'
                clienthttp2session.request(headers[, options])

            Class: Http2Stream

                Http2Stream Lifecycle
                    Creation
                    Destruction
                Event: 'aborted'
                Event: 'close'
                Event: 'error'
                Event: 'frameError'
                Event: 'timeout'
                Event: 'trailers'
                Event: 'wantTrailers'
                http2stream.aborted
                http2stream.bufferSize
                http2stream.close(code[, callback])
                http2stream.closed
                http2stream.destroyed
                http2stream.endAfterHeaders
                http2stream.id
                http2stream.pending
                http2stream.priority(options)
                http2stream.rstCode
                http2stream.sentHeaders
                http2stream.sentInfoHeaders
                http2stream.sentTrailers
                http2stream.session
                http2stream.setTimeout(msecs, callback)
                http2stream.state
                http2stream.sendTrailers(headers)

            Class: ClientHttp2Stream
                Event: 'continue'
                Event: 'headers'
                Event: 'push'
                Event: 'response'

            Class: ServerHttp2Stream
                http2stream.additionalHeaders(headers)
                http2stream.headersSent
                http2stream.pushAllowed
                http2stream.pushStream(headers[, options], callback)
                http2stream.respond([headers[, options]])
                http2stream.respondWithFD(fd[, headers[, options]])
                http2stream.respondWithFile(path[, headers[, options]])

            Class: Http2Server
                Event: 'checkContinue'
                Event: 'request'
                Event: 'session'
                Event: 'sessionError'
                Event: 'stream'
                Event: 'timeout'
                server.close([callback])
                server.setTimeout([msecs][, callback])

            Class: Http2SecureServer
                Event: 'checkContinue'
                Event: 'request'
                Event: 'session'
                Event: 'sessionError'
                Event: 'stream'
                Event: 'timeout'
                Event: 'unknownProtocol'
                server.close([callback])
                server.setTimeout([msecs][, callback])
            http2.createServer(options[, onRequestHandler])
            http2.createSecureServer(options[, onRequestHandler])
            http2.connect(authority[, options][, listener])

            http2.constants
                Error codes for RST_STREAM and GOAWAY
            http2.getDefaultSettings()
            http2.getPackedSettings([settings])
            http2.getUnpackedSettings(buf)
            Headers object
            Settings object
            Using options.selectPadding()
            Error handling
            Invalid character handling in header names and values
            Push streams on the client
            Supporting the CONNECT method
            The extended CONNECT protocol

        Compatibility API
            ALPN negotiation

            Class: http2.Http2ServerRequest
                Event: 'aborted'
                Event: 'close'
                request.aborted
                request.authority
                request.complete
                request.destroy([error])
                request.headers
                request.httpVersion
                request.method
                request.rawHeaders
                request.rawTrailers
                request.scheme
                request.setTimeout(msecs, callback)
                request.socket
                request.stream
                request.trailers
                request.url

            Class: http2.Http2ServerResponse
                Event: 'close'
                Event: 'finish'
                response.addTrailers(headers)
                response.connection
                response.end([data[, encoding]][, callback])
                response.finished
                response.getHeader(name)
                response.getHeaderNames()
                response.getHeaders()
                response.hasHeader(name)
                response.headersSent
                response.removeHeader(name)
                response.sendDate
                response.setHeader(name, value)
                response.setTimeout(msecs[, callback])
                response.socket
                response.statusCode
                response.statusMessage
                response.stream
                response.writableEnded
                response.write(chunk[, encoding][, callback])
                response.writeContinue()
                response.writeHead(statusCode[, statusMessage][, headers])
                response.createPushResponse(headers, callback)
        Collecting HTTP/2 performance metrics

-  there are no browsers known that support unencrypted HTTP/2, the use of http2.createSecureServer() is necessary when communicating with browser clients.
```
const http2 = require('http2');
const fs = require('fs');

const server = http2.createSecureServer({
  key: fs.readFileSync('localhost-privkey.pem'),
  cert: fs.readFileSync('localhost-cert.pem')
});
server.on('error', (err) => console.error(err));

server.on('stream', (stream, headers) => {
  // stream is a Duplex
  stream.respond({
    'content-type': 'text/html',
    ':status': 200
  });
  stream.end('<h1>Hello World</h1>');
});

server.listen(8443);
```

generate the certificate and key for this example, run
 
$ openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost' -keyout localhost-privkey.pem -out localhost-cert.pem

client
```
const http2 = require('http2');
const fs = require('fs');
const client = http2.connect('https://localhost:8443', {
  ca: fs.readFileSync('localhost-cert.pem')
});
client.on('error', (err) => console.error(err));

const req = client.request({ ':path': '/' });

req.on('response', (headers, flags) => {
  for (const name in headers) {
    console.log(`${name}: ${headers[name]}`);
  }
});

req.setEncoding('utf8');
let data = '';
req.on('data', (chunk) => { data += chunk; });
req.on('end', () => {
  console.log(`\n${data}`);
  client.close();
});
req.end();
```

- Http2Session, http2.Http2Session class represent an active communications session between an HTTP/2 client and server. 

rarely have occasion to work with the Http2Session object directly, with most actions typically taken through interactions with either the Http2Server or Http2Stream objects

Http2Session instances are created by the Http2Server instance when a new HTTP/2 connection is received

Client-side Http2Session instances are created using the http2.connect() method.

- Each instance of the Http2Stream class represents a bidirectional HTTP/2 communications stream over an Http2Session instance.

ServerHttp2Stream and ClientHttp2Stream classes, each of which is used specifically by either the Server or Client side, respectively.

```
const http2 = require('http2');
const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respond({ ':status': 200 });
  stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
    if (err) throw err;
    pushStream.respond({ ':status': 200 });
    pushStream.end('some pushed data');
  });
  stream.end('some data');
});
```

- Http2Server, Instances of Http2Server are created using the http2.createServer() function. The Http2Server class is not exported directly by the http2 module.

```
const http2 = require('http2');

// Create an unencrypted HTTP/2 server.
// Since there are no browsers known that support
// unencrypted HTTP/2, the use of `http2.createSecureServer()`
// is necessary when communicating with browser clients.
const server = http2.createServer();

server.on('stream', (stream, headers) => {
  stream.respond({
    'content-type': 'text/html',
    ':status': 200
  });
  stream.end('<h1>Hello World</h1>');
});

server.listen(80);
```

- ALPN negotiation allows supporting both HTTPS and HTTP/2 over the same socket. The req and res objects can be either HTTP/1 or HTTP/2, and an application must restrict itself to the public API of HTTP/1, and detect if it is possible to use the more advanced features of HTTP/2
```
const { createSecureServer } = require('http2');
const { readFileSync } = require('fs');

const cert = readFileSync('./cert.pem');
const key = readFileSync('./key.pem');

const server = createSecureServer(
  { cert, key, allowHTTP1: true },
  onRequest
).listen(4443);

function onRequest(req, res) {
  // Detects if it is a HTTPS request or HTTP/2
  const { socket: { alpnProtocol } } = req.httpVersion === '2.0' ?
    req.stream.session : req;
  res.writeHead(200, { 'content-type': 'application/json' });
  res.end(JSON.stringify({
    alpnProtocol,
    httpVersion: req.httpVersion
  }));
}
```
- Collecting HTTP/2 performance metrics
```
const { PerformanceObserver } = require('perf_hooks');

const obs = new PerformanceObserver((items) => {
  const entry = items.getEntries()[0];
  console.log(entry.entryType);  // prints 'http2'
  if (entry.name === 'Http2Session') {
    // Entry contains statistics about the Http2Session
  } else if (entry.name === 'Http2Stream') {
    // Entry contains statistics about the Http2Stream
  }
});
obs.observe({ entryTypes: ['http2'] });
```

entry name is Http2Stream, PerformanceEntry will contain the following properties 
    + byesRead 
    + bytesWritten 
    + id<number> the identifier of the Http2Session 
    + timeToFirstByte<number> 
    + timeToFirstSent<number> 
    + timeToFirstHeader<number>

entry name is HttpSession will contain 
    + byesRead 
    + bytesWritten 
    + frameReceived 
    + frameSent 
    + maxConcurrentStreams 
    + pingRTT 
    + streamAverageDuration 
    + streamCount 
    + type 


# HTTPS
- HTTPS, HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a separate module.
https://nodejs.org/dist/latest-v12.x/docs/api/https.html
- functions 

    HTTPS

        Class: https.Agent

            new Agent([options])
                Event: 'keylog'

        Class: https.Server
            server.close([callback])
            server.headersTimeout
            server.listen()
            server.maxHeadersCount
            server.setTimeout([msecs][, callback])
            server.timeout
            server.keepAliveTimeout
        https.createServer([options][, requestListener])
        https.get(options[, callback])
        https.get(url[, options][, callback])
        https.globalAgent
        https.request(options[, callback])
        https.request(url[, options][, callback])

- https.Agent, An Agent object for HTTPS similar to http.Agent. See https.request() for more information.

- https.Sever 
```
// curl -k https://localhost:8000/
const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
};

https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('hello world\n');
}).listen(8000);
```

or 
```
const https = require('https');
const fs = require('fs');

const options = {
  pfx: fs.readFileSync('test/fixtures/test_cert.pfx'),
  passphrase: 'sample'
};

https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('hello world\n');
}).listen(8000);
```

```
const https = require('https');

https.get('https://encrypted.google.com/', (res) => {
  console.log('statusCode:', res.statusCode);
  console.log('headers:', res.headers);

  res.on('data', (d) => {
    process.stdout.write(d);
  });

}).on('error', (e) => {
  console.error(e);
});
```


# Inspector 
- Inspector, The inspector module provides an API for interacting with the V8 inspector.

https://chromedevtools.github.io/devtools-protocol/v8/
- functions 

    Inspector
        inspector.close()
        inspector.console
        inspector.open([port[, host[, wait]]])
        inspector.url()
        inspector.waitForDebugger()

        Class: inspector.Session
            Constructor: new inspector.Session()
            Event: 'inspectorNotification'
            Event: <inspector-protocol-method>;
            session.connect()
            session.connectToMainThread()
            session.disconnect()
            session.post(method[, params][, callback])

        Example usage
            CPU profiler
            Heap profiler

```
$ node --inspect -p 'inspector.url()'
Debugger listening on ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34
For help see https://nodejs.org/en/docs/inspector
ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34

$ node --inspect=localhost:3000 -p 'inspector.url()'
Debugger listening on ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a
For help see https://nodejs.org/en/docs/inspector
ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a

$ node -p 'inspector.url()'
undefined
```

- CPU profiler 

https://chromedevtools.github.io/devtools-protocol/v8/Profiler
```
const inspector = require('inspector');
const fs = require('fs');
const session = new inspector.Session();
session.connect();

session.post('Profiler.enable', () => {
  session.post('Profiler.start', () => {
    // Invoke business logic under measurement here...

    // some time later...
    session.post('Profiler.stop', (err, { profile }) => {
      // Write profile to disk, upload, etc.
      if (!err) {
        fs.writeFileSync('./profile.cpuprofile', JSON.stringify(profile));
      }
    });
  });
});
```

- Heap profiler 
https://chromedevtools.github.io/devtools-protocol/v8/HeapProfiler

```
const inspector = require('inspector');
const fs = require('fs');
const session = new inspector.Session();

const fd = fs.openSync('profile.heapsnapshot', 'w');

session.connect();

session.on('HeapProfiler.addHeapSnapshotChunk', (m) => {
  fs.writeSync(fd, m.params.chunk);
});

session.post('HeapProfiler.takeHeapSnapshot', null, (err, r) => {
  console.log('HeapProfiler.takeHeapSnapshot done:', err, r);
  session.disconnect();
  fs.closeSync(fd);
});
```


# Internationalization 
- Internationalization 

JavaScript global Intl object 

String.prototype.normalize()
String.prototype.toLowerCase()
String.prototype.toUpperCase()

String.prototype.localeCompare() and Date.prototype.toLocaleString()

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl

https://nodejs.org/dist/latest-v12.x/docs/api/intl.html

ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.
http://site.icu-project.org/

build node js with options to control enable or disable ICU support 
```

    --with-intl=none/--without-intl
    --with-intl=system-icu
    --with-intl=small-icu (default)
    --with-intl=full-icu

```

ECMAScript language specification 
https://tc39.github.io/ecma262/

```
const january = new Date(9e8);
const english = new Intl.DateTimeFormat('en', { month: 'long' });
const spanish = new Intl.DateTimeFormat('es', { month: 'long' });

console.log(english.format(january));
// Prints "January"
console.log(spanish.format(january));
// Prints "M01" on small-icu
// Should print "enero"

```

- functions 

    Internationalization support

        Options for building Node.js
            Disable all internationalization features (none)
            Build with a pre-installed ICU (system-icu)

            Embed a limited set of ICU data (small-icu)
                Providing ICU data at runtime
            Embed the entire ICU (full-icu)
        Detecting internationalization support



# Modules 
- Modules, In the Node.js module system, each file is treated as a separate module. For example, consider a file named foo.js:
```
const circle = require('./circle.js');
console.log(`The area of a circle of radius 4 is ${circle.area(4)}`);
```

circle.js content 
```
const { PI } = Math;

exports.area = (r) => PI * r ** 2;

exports.circumference = (r) => 2 * PI * r;
```

The module.exports property can be assigned a new value (such as a function or object).

https://nodejs.org/dist/latest-v12.x/docs/api/modules.html

- functions 

    Modules
        Accessing the main module
        Addenda: Package manager tips
        Addenda: The .mjs extension
        All together...

        Caching
            Module caching caveats
        Core modules
        Cycles
        File modules
        Folders as modules
        Loading from node_modules folders
        Loading from the global folders
        The module wrapper

        The module scope
            __dirname
            __filename
            exports
            module

            require(id)
                require.cache
                require.extensions
                require.main

                require.resolve(request[, options])
                    require.resolve.paths(request)

        The module object
            module.children

            module.exports
                exports shortcut
            module.filename
            module.id
            module.loaded
            module.parent
            module.path
            module.paths
            module.require(id)

        The Module object
            module.builtinModules
            module.createRequire(filename)
            module.createRequireFromPath(filename)
            module.syncBuiltinESMExports()

        Source map v3 support
            module.findSourceMap(path[, error])

            Class: module.SourceMap
                new SourceMap(payload)
                sourceMap.payload
                sourceMap.findEntry(lineNumber, columnNumber)
                
https://nodejs.org/dist/latest-v12.x/docs/api/modules.html

-  folder at /usr/lib/node/<some-package>/<some-version> hold the contents of a specific version of a package

- The .mjs extension is reserved for ECMAScript Modules which cannot be loaded via require(). See ECMAScript Modules for more details.

- require pseudocode 
```
require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with '/'
   a. set Y to be the filesystem root
3. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
   c. THROW "not found"
4. LOAD_SELF_REFERENCE(X, dirname(Y))
5. LOAD_NODE_MODULES(X, dirname(Y))
6. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as its file extension format. STOP
2. If X.js is a file, load X.js as JavaScript text. STOP
3. If X.json is a file, parse X.json to a JavaScript Object. STOP
4. If X.node is a file, load X.node as binary addon. STOP

LOAD_INDEX(X)
1. If X/index.js is a file, load X/index.js as JavaScript text. STOP
2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
3. If X/index.node is a file, load X/index.node as binary addon. STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. If "main" is a falsy value, GOTO 2.
   c. let M = X + (json main field)
   d. LOAD_AS_FILE(M)
   e. LOAD_INDEX(M)
   f. LOAD_INDEX(X) DEPRECATED
   g. THROW "not found"
2. LOAD_INDEX(X)

LOAD_NODE_MODULES(X, START)
1. let DIRS = NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_PACKAGE_EXPORTS(DIR, X)
   b. LOAD_AS_FILE(DIR/X)
   c. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = [GLOBAL_FOLDERS]
4. while I >= 0,
   a. if PARTS[I] = "node_modules" CONTINUE
   b. DIR = path join(PARTS[0 .. I] + "node_modules")
   c. DIRS = DIRS + DIR
   d. let I = I - 1
5. return DIRS

LOAD_SELF_REFERENCE(X, START)
1. Find the closest package scope to START.
2. If no scope was found, return.
3. If the `package.json` has no "exports", return.
4. If the name in `package.json` is a prefix of X, then
   a. Load the remainder of X relative to this package as if it was
      loaded via `LOAD_NODE_MODULES` with a name in `package.json`.

LOAD_PACKAGE_EXPORTS(DIR, X)
1. Try to interpret X as a combination of name and subpath where the name
   may have a @scope/ prefix and the subpath begins with a slash (`/`).
2. If X does not match this pattern or DIR/name/package.json is not a file,
   return.
3. Parse DIR/name/package.json, and look for "exports" field.
4. If "exports" is null or undefined, return.
5. If "exports" is an object with some keys starting with "." and some keys
  not starting with ".", throw "invalid config".
6. If "exports" is a string, or object with no keys starting with ".", treat
  it as having that value as its "." object property.
7. If subpath is "." and "exports" does not have a "." entry, return.
8. Find the longest key in "exports" that the subpath starts with.
9. If no such key can be found, throw "not found".
10. let RESOLVED =
    fileURLToPath(PACKAGE_EXPORTS_TARGET_RESOLVE(pathToFileURL(DIR/name),
    exports[key], subpath.slice(key.length), ["node", "require"])), as defined
    in the ESM resolver.
11. If key ends with "/":
    a. LOAD_AS_FILE(RESOLVED)
    b. LOAD_AS_DIRECTORY(RESOLVED)
12. Otherwise
   a. If RESOLVED is a file, load it as its file extension format. STOP
13. Throw "not found
```
- loading from global folders 

Node.js will search in the following list of GLOBAL_FOLDERS:
```
    1: $HOME/.node_modules
    2: $HOME/.node_libraries
    3: $PREFIX/lib/node
```


# Net 
- Net, The net module provides an asynchronous network API for creating stream-based TCP or IPC servers. net module supports IPC with named pipes on Windows, and Unix domain sockets on other operating systems.

On Windows, the local domain is implemented using a named pipe. The path must refer to an entry in \\?\pipe\ or \\.\pipe\. 

```
net.createServer().listen(
  path.join('\\\\?\\pipe', process.cwd(), 'myctl'));
```

```
const server = net.createServer((socket) => {
  socket.end('goodbye\n');
}).on('error', (err) => {
  // Handle errors here.
  throw err;
});

// Grab an arbitrary unused port.
server.listen(() => {
  console.log('opened server on', server.address());
});
```

https://nodejs.org/dist/latest-v12.x/docs/api/net.html

- functions 

    Net

        IPC support
            Identifying paths for IPC connections

        Class: net.Server
            new net.Server([options][, connectionListener])
            Event: 'close'
            Event: 'connection'
            Event: 'error'
            Event: 'listening'
            server.address()
            server.close([callback])
            server.connections
            server.getConnections(callback)

            server.listen()
                server.listen(handle[, backlog][, callback])
                server.listen(options[, callback])
                server.listen(path[, backlog][, callback])
                server.listen([port[, host[, backlog]]][, callback])
            server.listening
            server.maxConnections
            server.ref()
            server.unref()

        Class: net.Socket
            new net.Socket([options])
            Event: 'close'
            Event: 'connect'
            Event: 'data'
            Event: 'drain'
            Event: 'end'
            Event: 'error'
            Event: 'lookup'
            Event: 'ready'
            Event: 'timeout'
            socket.address()
            socket.bufferSize
            socket.bytesRead
            socket.bytesWritten

            socket.connect()
                socket.connect(options[, connectListener])
                socket.connect(path[, connectListener])
                socket.connect(port[, host][, connectListener])
            socket.connecting
            socket.destroy([error])
            socket.destroyed
            socket.end([data[, encoding]][, callback])
            socket.localAddress
            socket.localPort
            socket.pause()
            socket.pending
            socket.ref()
            socket.remoteAddress
            socket.remoteFamily
            socket.remotePort
            socket.resume()
            socket.setEncoding([encoding])
            socket.setKeepAlive([enable][, initialDelay])
            socket.setNoDelay([noDelay])
            socket.setTimeout(timeout[, callback])
            socket.unref()
            socket.write(data[, encoding][, callback])

        net.connect()
            net.connect(options[, connectListener])
            net.connect(path[, connectListener])
            net.connect(port[, host][, connectListener])

        net.createConnection()
            net.createConnection(options[, connectListener])
            net.createConnection(path[, connectListener])
            net.createConnection(port[, host][, connectListener])
        net.createServer([options][, connectionListener])
        net.isIP(input)
        net.isIPv4(input)
        net.isIPv6(input)
        

# OS 
- OS, os module provides operating system-related utility methods and properties. 
- functions 

    OS
        os.EOL
        os.arch()
        os.constants
        os.cpus()
        os.endianness()
        os.freemem()
        os.getPriority([pid])
        os.homedir()
        os.hostname()
        os.loadavg()
        os.networkInterfaces()
        os.platform()
        os.release()
        os.setPriority([pid, ]priority)
        os.tmpdir()
        os.totalmem()
        os.type()
        os.uptime()
        os.userInfo([options])
        os.version()

        OS constants
            Signal constants

            Error constants
                POSIX error constants
                Windows-specific error constants
            dlopen constants
            Priority constants
            libuv constants
- os.arch(),  CPU architecture 
- signal constants, exported by os.constants.signals
SIGHUP
SIGINT 
SIGQUIT
SIGILL
SIGTRAP
SIGABRT
SIGIOT 
SIGBUS
SIGFPE
SIGKILL
SIGUSER1, SIGUSER2
SIGSEGV 
SIGPIPE
SIGALRM
SIGTERM
SIGCHLD
SIGSTKFLT
SIGCONT
SIGSTOP, instruct the operating system to halt a process 
SIGTSTP, send to a process to request it to stop 
SIGBREAK, when a user wish to interrupt a process 
SIGTTIN, TTY is read in the background 
SIGTTOU, TTY is written in the background 
SIGURG, socket has urgent data to read
SIGXCPU, exceeded its limit on CPU usage 
SIGXFSZ, when a file grows larger than the maximum allowed 
SIGVTALRM, virtual timer elapsed 
SIGPROF, system timer elapsed 
SIGWINCH, controlling terminal has changed its size
SIGIO, when I/O is available 
SIGPOLL, synonym for SIGIO 
SIGLOST, a file lock has been lost 
SIGPWR, notify a power failure 
SIGINFO, synonym for SIGPWR 
SIGSYS, sent to a process to notify a bad argument 
SIGUNUSED, synonym for SIGSYS

- Error constants, os.constants.errno 

- POSIX error constants 

- windows-specific error constants 

- dlopen constants 

- proprity conststants 

- libuv constants 
UV_UDP_REUSEADDR


# Path 
- Path, The path module provides utilities for working with file and directory paths.
https://nodejs.org/dist/latest-v12.x/docs/api/path.html

path.basename() might yield different results on POSIX and Windows
 
On POSIX:
```
path.basename('C:\\temp\\myfile.html');
// Returns: 'C:\\temp\\myfile.html'
```

On Windows:
```
path.basename('C:\\temp\\myfile.html');
// Returns: 'myfile.html'

```

On windows path.resolve('C:\\') can potentially return a different result than path.resolve('C:'). the concept of per-drive working directory. https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths

    + A UNC name of any format, which always start with two backslash characters ("\\"). For more information, see the next section.
    + A disk designator with a backslash, for example "C:\" or "d:\".
    + A single backslash, for example, "\directory" or "\file.txt". This is also referred to as an absolute path.

current directory may or may not be the root directory depending on what it was set to during the most recent "change directory" operation on that disk.

    + "C:tmp.txt" refers to a file named "tmp.txt" in the current directory on drive C.
    + "C:tempdir\tmp.txt" refers to a file in a subdirectory to the current directory on drive C.

https://nodejs.org/dist/latest-v12.x/docs/api/path.html
- functions 

    Path
        Windows vs. POSIX
        path.basename(path[, ext])
        path.delimiter
        path.dirname(path)
        path.extname(path)
        path.format(pathObject)
        path.isAbsolute(path)
        path.join([...paths])
        path.normalize(path)
        path.parse(path)
        path.posix
        path.relative(from, to)
        path.resolve([...paths])
        path.sep
        path.toNamespacedPath(path)
        path.win32
    
- path.sep, Provides the platform-specific path segment separator:


# Performance hooks 
- Performance measurement APIs, This module provides an implementation of a subset of the W3C Web Performance APIs as well as additional APIs for Node.js-specific performance measurements.
    + high resolution time, https://www.w3.org/TR/hr-time-2
    + performance timeline, https://w3c.github.io/performance-timeline/
    + using timing, https://www.w3.org/TR/user-timing/

```
const { PerformanceObserver, performance } = require('perf_hooks');

const obs = new PerformanceObserver((items) => {
  console.log(items.getEntries()[0].duration);
  performance.clearMarks();
});
obs.observe({ entryTypes: ['measure'] });
performance.measure('Start to Now');

performance.mark('A');
doSomeLongRunningProcess(() => {
  performance.measure('A to Now', 'A');

  performance.mark('B');
  performance.measure('A to B', 'A', 'B');
});
```

https://nodejs.org/dist/latest-v12.x/docs/api/perf_hooks.html

- functions 

    Performance measurement APIs

        perf_hooks.performance
            performance.clearMarks([name])
            performance.mark([name])
            performance.measure(name[, startMark[, endMark]])
            performance.nodeTiming
            performance.now()
            performance.timeOrigin
            performance.timerify(fn)

        Class: PerformanceEntry
            performanceEntry.duration
            performanceEntry.name
            performanceEntry.startTime
            performanceEntry.entryType
            performanceEntry.kind
            performanceEntry.flags

        Class: PerformanceNodeTiming extends PerformanceEntry
            performanceNodeTiming.bootstrapComplete
            performanceNodeTiming.environment
            performanceNodeTiming.loopExit
            performanceNodeTiming.loopStart
            performanceNodeTiming.nodeStart
            performanceNodeTiming.v8Start

        Class: perf_hooks.PerformanceObserver
            new PerformanceObserver(callback)
            performanceObserver.disconnect()
            performanceObserver.observe(options)

        Class: PerformanceObserverEntryList
            performanceObserverEntryList.getEntries()
            performanceObserverEntryList.getEntriesByName(name[, type])
            performanceObserverEntryList.getEntriesByType(type)

        perf_hooks.monitorEventLoopDelay([options])

            Class: Histogram
                histogram.disable()
                histogram.enable()
                histogram.exceeds
                histogram.max
                histogram.mean
                histogram.min
                histogram.percentile(percentile)
                histogram.percentiles
                histogram.reset()
                histogram.stddev

        Examples
            Measuring the duration of async operations
            Measuring how long it takes to load dependencies

- performanceObserver

```
const {
  performance,
  PerformanceObserver
} = require('perf_hooks');

const obs = new PerformanceObserver((list, observer) => {
  // Called three times synchronously. `list` contains one item.
});
obs.observe({ entryTypes: ['mark'] });

for (let n = 0; n < 3; n++)
  performance.mark(`test${n}`);
```

```
const {
  performance,
  PerformanceObserver
} = require('perf_hooks');

const obs = new PerformanceObserver((list, observer) => {
  // Called once. `list` contains three items.
});
obs.observe({ entryTypes: ['mark'], buffered: true });

for (let n = 0; n < 3; n++)
  performance.mark(`test${n}`);
```
- example measure duration of async operations 
```
'use strict';
const async_hooks = require('async_hooks');
const {
  performance,
  PerformanceObserver
} = require('perf_hooks');

const set = new Set();
const hook = async_hooks.createHook({
  init(id, type) {
    if (type === 'Timeout') {
      performance.mark(`Timeout-${id}-Init`);
      set.add(id);
    }
  },
  destroy(id) {
    if (set.has(id)) {
      set.delete(id);
      performance.mark(`Timeout-${id}-Destroy`);
      performance.measure(`Timeout-${id}`,
                          `Timeout-${id}-Init`,
                          `Timeout-${id}-Destroy`);
    }
  }
});
hook.enable();

const obs = new PerformanceObserver((list, observer) => {
  console.log(list.getEntries()[0]);
  performance.clearMarks();
  observer.disconnect();
});
obs.observe({ entryTypes: ['measure'], buffered: true });

setTimeout(() => {}, 1000);
```

- example measure loading dependencies 
```
'use strict';
const {
  performance,
  PerformanceObserver
} = require('perf_hooks');
const mod = require('module');

// Monkey patch the require function
mod.Module.prototype.require =
  performance.timerify(mod.Module.prototype.require);
require = performance.timerify(require);

// Activate the observer
const obs = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  entries.forEach((entry) => {
    console.log(`require('${entry[0]}')`, entry.duration);
  });
  obs.disconnect();
});
obs.observe({ entryTypes: ['function'], buffered: true });

require('some-module');
```


# Policies 
- Policies, experimental support for creating policies on loading code 

https://nodejs.org/dist/latest-v12.x/docs/api/policy.html
- functions 

    Policies
        Enabling

        Features
            Error behavior
            Integrity checks

            Dependency redirection
                Example: Patched dependency


# Process 
- Process, process object is a global that provides information about, and control over, the current Node.js process. As a global, it is always available to Node.js applications. It is an instance of a EventEmitter

```
process.on('beforeExit', (code) => {
  console.log('Process beforeExit event with code: ', code);
});

process.on('exit', (code) => {
  console.log('Process exit event with code: ', code);
});

console.log('This message is displayed first.');
```

https://nodejs.org/dist/latest-v12.x/docs/api/process.html
- functions 

    Process

        Process events
            Event: 'beforeExit'
            Event: 'disconnect'
            Event: 'exit'
            Event: 'message'
            Event: 'multipleResolves'
            Event: 'rejectionHandled'

            Event: 'uncaughtException'
                Warning: Using 'uncaughtException' correctly
            Event: 'uncaughtExceptionMonitor'
            Event: 'unhandledRejection'

            Event: 'warning'
                Emitting custom warnings
            Signal events
        process.abort()
        process.allowedNodeEnvironmentFlags
        process.arch
        process.argv
        process.argv0
        process.channel
        process.chdir(directory)
        process.config
        process.connected
        process.cpuUsage([previousValue])
        process.cwd()
        process.debugPort
        process.disconnect()
        process.dlopen(module, filename[, flags])
        process.emitWarning(warning[, options])

        process.emitWarning(warning[, type[, code]][, ctor])
            Avoiding duplicate warnings
        process.env
        process.execArgv
        process.execPath
        process.exit([code])
        process.exitCode
        process.getegid()
        process.geteuid()
        process.getgid()
        process.getgroups()
        process.getuid()
        process.hasUncaughtExceptionCaptureCallback()
        process.hrtime([time])
        process.hrtime.bigint()
        process.initgroups(user, extraGroup)
        process.kill(pid[, signal])
        process.mainModule
        process.memoryUsage()
        process.nextTick(callback[, ...args])
        process.noDeprecation
        process.pid
        process.platform
        process.ppid
        process.release

        process.report
            process.report.compact
            process.report.directory
            process.report.filename
            process.report.getReport([err])
            process.report.reportOnFatalError
            process.report.reportOnSignal
            process.report.reportOnUncaughtException
            process.report.signal
            process.report.writeReport([filename][, err])
        process.resourceUsage()
        process.send(message[, sendHandle[, options]][, callback])
        process.setegid(id)
        process.seteuid(id)
        process.setgid(id)
        process.setgroups(groups)
        process.setuid(id)
        process.setUncaughtExceptionCaptureCallback(fn)

        process.stderr
            process.stderr.fd

        process.stdin
            process.stdin.fd

        process.stdout
            process.stdout.fd
            A note on process I/O
        process.throwDeprecation
        process.title
        process.traceDeprecation
        process.umask([mask])
        process.uptime()
        process.version
        process.versions
        Exit codes
        
- Signal events, Signal events will be emitted when the Node.js process receives a signal. Signals are not available on Worker threads.

```
// Begin reading from stdin so the process does not exit.
process.stdin.resume();

process.on('SIGINT', () => {
  console.log('Received SIGINT. Press Control-D to exit.');
});

// Using a single function to handle multiple signals
function handle(signal) {
  console.log(`Received ${signal}`);
}

process.on('SIGINT', handle);
process.on('SIGTERM', handle);
```

- process.dlopen(module, filename[, flags]), process.dlopen() method allows to dynamically load shared objects. It is primarily used by require() to load C++ Addons. We should use require to load C++ addons except there are specific reasons

how to load a C++ Addon, named as binding, that exports a foo function. All the symbols will be loaded before the call returns
```
const os = require('os');
process.dlopen(module, require.resolve('binding'),
               os.constants.dlopen.RTLD_NOW);
module.exports.foo();
```

https://nodejs.org/dist/latest-v12.x/docs/api/os.html#os_dlopen_constants
RTLD_LAZY, laszy binding 
RTLD_NOW, resolve all undefined symbols before dlopen returns
RTLD_GLOBAL, Symbols defined by the library will be made available for symbol resolution of subsequently loaded libraries
RTLD_LOCAL
RTLD_DEEPBIND, Make a self-contained library use its own symbols in preference to symbols from previously loaded libraries

process.dlopen() (for instance, to specify dlopen flags), it's often useful to use require.resolve() to look up the module's path.

- process.nextTick, process.nextTick() adds callback to the "next tick queue". This queue is fully drained after the current operation on the JavaScript stack runs to completions and before the event loop is allowed to continue

```
function definitelyAsync(arg, cb) {
  if (arg) {
    process.nextTick(cb);
    return;
  }

  fs.stat('file', cb);
}
```


# Punycode (deprecated)
- Punycode, Punycode is a encoding syntax by which a Unicode (UTF-8) string of characters can be translated into the basic ASCII-characters permitted in network host names.


# Query strings 
- Query strings, provides utilities for parsing and formatting URL query strings. It can be accessed using:

```
const querystring = require('querystring');

querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });
// Returns 'foo=bar&baz=qux&baz=quux&corge='

querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');
// Returns 'foo:bar;baz:qux'
```

https://nodejs.org/dist/latest-v12.x/docs/api/querystring.html
- functions 

    Query string
        querystring.decode()
        querystring.encode()
        querystring.escape(str)
        querystring.parse(str[, sep[, eq[, options]]])
        querystring.stringify(obj[, sep[, eq[, options]]])
        querystring.unescape(str)


# Readline 
- Readline, provides an interface for reading data from a Readable stream (such as process.stdin) one line at a time

```
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.question('What do you think of Node.js? ', (answer) => {
  // TODO: Log the answer in a database
  console.log(`Thank you for your valuable feedback: ${answer}`);

  rl.close();
});
```

https://nodejs.org/dist/latest-v12.x/docs/api/readline.html

- functions 

    Readline

        Class: Interface
            Event: 'close'
            Event: 'line'
            Event: 'pause'
            Event: 'resume'
            Event: 'SIGCONT'
            Event: 'SIGINT'
            Event: 'SIGTSTP'
            rl.close()
            rl.pause()
            rl.prompt([preserveCursor])
            rl.question(query, callback)
            rl.resume()
            rl.setPrompt(prompt)
            rl.write(data[, key])
            rl[Symbol.asyncIterator]()
            rl.line
            rl.cursor
            rl.getCursorPos()
        readline.clearLine(stream, dir[, callback])
        readline.clearScreenDown(stream[, callback])

        readline.createInterface(options)
            Use of the completer function
        readline.cursorTo(stream, x[, y][, callback])
        readline.emitKeypressEvents(stream[, interface])
        readline.moveCursor(stream, dx, dy[, callback])
        Example: Tiny CLI
        Example: Read file stream line-by-Line
        TTY keybindings
- example read file stream line by line 
```
const fs = require('fs');
const readline = require('readline');

async function processLineByLine() {
  const fileStream = fs.createReadStream('input.txt');

  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });
  // Note: we use the crlfDelay option to recognize all instances of CR LF
  // ('\r\n') in input.txt as a single line break.

  for await (const line of rl) {
    // Each line in input.txt will be successively available here as `line`.
    console.log(`Line from file: ${line}`);
  }
}

processLineByLine();
```


# REPL 
- REPL, provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program
```
const repl = require('repl');
const msg = 'message';

repl.start('> ').context.m = msg;

const repl = require('repl');
const msg = 'message';

const r = repl.start('> ');
Object.defineProperty(r.context, 'm', {
  configurable: false,
  enumerable: true,
  value: msg
});
```

https://nodejs.org/dist/latest-v12.x/docs/api/repl.html

- functions 

    REPL

        Design and features
            Commands and special keys

            Default evaluation
                JavaScript expressions
                Global and local scope
                Accessing core Node.js modules
                Global uncaught exceptions
                Assignment of the _ (underscore) variable
                await keyword
            Reverse-i-search

            Custom evaluation functions
                Recoverable errors
            Customizing REPL output

        Class: REPLServer
            Event: 'exit'
            Event: 'reset'
            replServer.defineCommand(keyword, cmd)
            replServer.displayPrompt([preserveCursor])
            replServer.clearBufferedCommand()
            replServer.parseREPLKeyword(keyword[, rest])
            replServer.setupHistory(historyPath, callback)
        repl.start([options])

        The Node.js REPL
            Environment variable options
            Persistent history
            Using the Node.js REPL with advanced line-editors
            Starting multiple REPL instances against a single running instance

- commands and special keys supported by all REPL instances 
.break 
.clear 
.exit 
.help 
.save, save current session to file 
    $ .save ./file/to/save.js 

.load 
.editor, enter editor mode 

<ctrl>-C: When pressed once, has the same effect as the .break command
<ctrl>-D: Has the same effect as the .exit command.
<tab>


# Report 
- Report, JSON-formatted diagnostic summary, written to a file.
$ node --report-uncaught-exception --report-on-signal --report-on-fatalerror app.js

or 
```
process.report.writeReport('./foo.json');
```

https://nodejs.org/dist/latest-v12.x/docs/api/report.html

- contents 

    Diagnostic report
        Usage
        Configuration
        Interaction with workers


# Stream 
- Stream 

```
const stream = require('stream');
```
https://nodejs.org/dist/latest-v12.x/docs/api/stream.html
- functions 

    Stream
        Organization of this document

        Types of streams
            Object mode
            Buffering

        API for stream consumers

            Writable streams

                Class: stream.Writable
                    Event: 'close'
                    Event: 'drain'
                    Event: 'error'
                    Event: 'finish'
                    Event: 'pipe'
                    Event: 'unpipe'
                    writable.cork()
                    writable.destroy([error])
                    writable.destroyed
                    writable.end([chunk[, encoding]][, callback])
                    writable.setDefaultEncoding(encoding)
                    writable.uncork()
                    writable.writable
                    writable.writableEnded
                    writable.writableCorked
                    writable.writableFinished
                    writable.writableHighWaterMark
                    writable.writableLength
                    writable.writableObjectMode
                    writable.write(chunk[, encoding][, callback])

            Readable streams
                Two reading modes
                Three states
                Choose one API style

                Class: stream.Readable
                    Event: 'close'
                    Event: 'data'
                    Event: 'end'
                    Event: 'error'
                    Event: 'pause'
                    Event: 'readable'
                    Event: 'resume'
                    readable.destroy([error])
                    readable.destroyed
                    readable.isPaused()
                    readable.pause()
                    readable.pipe(destination[, options])
                    readable.read([size])
                    readable.readable
                    readable.readableEncoding
                    readable.readableEnded
                    readable.readableFlowing
                    readable.readableHighWaterMark
                    readable.readableLength
                    readable.readableObjectMode
                    readable.resume()
                    readable.setEncoding(encoding)
                    readable.unpipe([destination])
                    readable.unshift(chunk[, encoding])
                    readable.wrap(stream)
                    readable[Symbol.asyncIterator]()

            Duplex and transform streams
                Class: stream.Duplex

                Class: stream.Transform
                    transform.destroy([error])
            stream.finished(stream[, options], callback)
            stream.pipeline(...streams, callback)
            stream.Readable.from(iterable, [options])

        API for stream implementers
            Simplified construction

            Implementing a writable stream
                Constructor: new stream.Writable([options])
                writable._write(chunk, encoding, callback)
                writable._writev(chunks, callback)
                writable._destroy(err, callback)
                writable._final(callback)
                Errors while writing
                An example writable stream
                Decoding buffers in a writable stream

            Implementing a readable stream
                new stream.Readable([options])
                readable._read(size)
                readable._destroy(err, callback)
                readable.push(chunk[, encoding])
                Errors while reading
                An example counting stream

            Implementing a duplex stream
                new stream.Duplex(options)
                An example duplex stream
                Object mode duplex streams

            Implementing a transform stream
                new stream.Transform([options])
                Events: 'finish' and 'end'
                transform._flush(callback)
                transform._transform(chunk, encoding, callback)
                Class: stream.PassThrough

        Additional notes

            Streams compatibility with async generators and async iterators
                Consuming readable streams with async iterators
                Creating readable streams with async generators
                Piping to writable streams from async iterators
            Compatibility with older Node.js versions
            readable.read(0)
            readable.push('')
            highWaterMark discrepancy after calling readable.setEncoding()

- types of streams 
Writable, 
Readable 
Duplex 
Transform

Both Writable and Readable streams will store data in an internal buffer that can be retrieved using writable.writableBuffer or readable.readableBuffer
- utility functions, utility functions stream.pipeline(), stream.finished() and stream.Readable.from().

- API for stream consumers 
```
const http = require('http');

const server = http.createServer((req, res) => {
  // `req` is an http.IncomingMessage, which is a readable stream.
  // `res` is an http.ServerResponse, which is a writable stream.

  let body = '';
  // Get the data as utf8 strings.
  // If an encoding is not set, Buffer objects will be received.
  req.setEncoding('utf8');

  // Readable streams emit 'data' events once a listener is added.
  req.on('data', (chunk) => {
    body += chunk;
  });

  // The 'end' event indicates that the entire body has been received.
  req.on('end', () => {
    try {
      const data = JSON.parse(body);
      // Write back something interesting to the user:
      res.write(typeof data);
      res.end();
    } catch (er) {
      // uh oh! bad json!
      res.statusCode = 400;
      return res.end(`error: ${er.message}`);
    }
  });
});

server.listen(1337);

// $ curl localhost:1337 -d "{}"
// object
// $ curl localhost:1337 -d "\"foo\""
// string
// $ curl localhost:1337 -d "not json"
// error: Unexpected token o in JSON at position 1
```

- decoding buffers in a writable stream 
```
const { Writable } = require('stream');
const { StringDecoder } = require('string_decoder');

class StringWritable extends Writable {
  constructor(options) {
    super(options);
    this._decoder = new StringDecoder(options && options.defaultEncoding);
    this.data = '';
  }
  _write(chunk, encoding, callback) {
    if (encoding === 'buffer') {
      chunk = this._decoder.write(chunk);
    }
    this.data += chunk;
    callback();
  }
  _final(callback) {
    this.data += this._decoder.end();
    callback();
  }
}

const euro = [[0xE2, 0x82], [0xAC]].map(Buffer.from);
const w = new StringWritable();

w.write('currency: ');
w.write(euro[0]);
w.end(euro[1]);

console.log(w.data); // currency: €

```

- duplex stream, A Duplex stream is one that implements both Readable and Writable, such as a TCP socket connection

```
const { Duplex } = require('stream');
const kSource = Symbol('source');

class MyDuplex extends Duplex {
  constructor(source, options) {
    super(options);
    this[kSource] = source;
  }

  _write(chunk, encoding, callback) {
    // The underlying source only deals with strings.
    if (Buffer.isBuffer(chunk))
      chunk = chunk.toString();
    this[kSource].writeSomeData(chunk);
    callback();
  }

  _read(size) {
    this[kSource].fetchSomeData(size, (data, encoding) => {
      this.push(Buffer.from(data, encoding));
    });
  }
}
```


# String decoder 
- string decoder, decoding Buffer objects into strings in a manner that preserves encoded multi-byte UTF-8 and UTF-16 characters. 

```
const { StringDecoder } = require('string_decoder');
const decoder = new StringDecoder('utf8');

const cent = Buffer.from([0xC2, 0xA2]);
console.log(decoder.write(cent));

const euro = Buffer.from([0xE2, 0x82, 0xAC]);
console.log(decoder.write(euro));
```

https://nodejs.org/dist/latest-v12.x/docs/api/string_decoder.html
- functions 


    String decoder

        Class: StringDecoder
            new StringDecoder([encoding])
            stringDecoder.end([buffer])
            stringDecoder.write(buffer)


# Timers 
- Timers, exposes a global API for scheduling functions to be called at some future period of time. Because the timer functions are globals
https://nodejs.org/dist/latest-v12.x/docs/api/timers.html

- functions 

    Timers

        Class: Immediate
            immediate.hasRef()
            immediate.ref()
            immediate.unref()

        Class: Timeout
            timeout.hasRef()
            timeout.ref()
            timeout.refresh()
            timeout.unref()

        Scheduling timers
            setImmediate(callback[, ...args])
            setInterval(callback, delay[, ...args])
            setTimeout(callback, delay[, ...args])

        Cancelling timers
            clearImmediate(immediate)
            clearInterval(timeout)
            clearTimeout(timeout)
            
- class Timeout, This object is created internally and is returned from setTimeout() and setInterval(). It can be passed to either clearTimeout() or clearInterval() in order to cancel the scheduled action       

```
const util = require('util');
const setImmediatePromise = util.promisify(setImmediate);

setImmediatePromise('foobar').then((value) => {
  // value === 'foobar' (passing values is optional)
  // This is executed after all I/O callbacks.
});

// Or with async function
async function timerExample() {
  console.log('Before I/O callbacks');
  await setImmediatePromise();
  console.log('After I/O callbacks');
}
timerExample();
```


# TLS/SSL 
- TLS/SSL, provides an implementation of the Transport Layer Security (TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL

TLS/SSL is a public/private key infrastructure (PKI) for most common cases. Seach client and server must have a private key 

$ openssl genrsa -out ryans-key.pem 2048

With TLS/SSL, all servers (and some clients) must have a certificate. Certificates are public keys that correspond to a private key. It is digitally signed either by a Certificate Authority or by the owner of the private key (such certificates are referred to as "self-signed")

$ openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem

CSR file is generated, it can either be sent to a Certificate Authority for signing or used to generate a self-signed certificate.

self-signed certificate using the OpenSSL command-line

$ openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem

Once the certificate is generated it can be used to generate a .pfx or .p12 file 

$ openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem -certfile ca-cert.pem -out ryans.pfx

in: is the signed certificate 
inkey: is the associated private key 
certfile: is concatenation of all certificate autority(CA) certs intoa a single file. 
$ cat ca1-cert.pem ca2-cert.pem > ca-cert.pem

- Perfect forward secrecy is achieved by randomly generating a key pair for key-agreement on every TLS/SSL handshake. Current have two ways 

DHE: An ephemeral version of the Diffie Hellman key-agreement protocol.
ECDHE: An ephemeral version of the Elliptic Curve Diffie Hellman key-agreement protocol.

$ openssl dhparam -outform PEM -out dhparam.pem 2048

all TLSv1.3 cipher suites use ECDHE.
 
- ALPN and SNI, ALPN (Application-Layer Protocol Negotiation Extension) and SNI (Server Name Indication) are TLS handshake extensions:

    ALPN: Allows the use of one TLS server for multiple protocols (HTTP, HTTP/2)
    SNI: Allows the use of one TLS server for multiple hostnames with different SSL certificates.

- TLS-PSK support is available as an alternative to normal certificate-based authentication. It uses a pre-shared key instead of certificates to authenticate a TLS connection, providing mutual authentication. 

TLS-PSK is only a good choice where means exist to securely share a key with every connecting machine, so it does not replace PKI (Public Key Infrastructure) for the majority of TLS uses. 

Session ticket keys are cryptographic keys, and they must be stored securely. With TLS 1.2 and below, if they are compromised all sessions that used tickets encrypted with them can be decrypted. 

$ openssl s_client -connect localhost:443 -reconnect

- Certificate object, A certificate object has properties corresponding to the fields of the certificate.

raw, <Buffer> encoded X.509 certificate data 
subject, <Object> 
issuer, <Object>
valid_from, <string> 
valid_to, <string> 
serialNumber, <string> 
fingerprint, <string> 
fingerprint256, <string> 
ext_key_usage, <Array> 
subjectaltname, <string> 
infoAccess, <Array>
issuerCertificate, <Object> 

RSA keys 
bits, <number> RSA bit size 
exponent, <string>, RSA exponent 
modulus, <string> 
pubkey, <Buffer> 

EC keys 
pubkey, <Buffer> 
bits, <number>
asn1Curve, string> 
nistCurve, <string> 

- example using tls.createServer()

```
// Assumes an echo server that is listening on port 8000.
const tls = require('tls');
const fs = require('fs');

const options = {
  // Necessary only if the server requires client certificate authentication.
  key: fs.readFileSync('client-key.pem'),
  cert: fs.readFileSync('client-cert.pem'),

  // Necessary only if the server uses a self-signed certificate.
  ca: [ fs.readFileSync('server-cert.pem') ],

  // Necessary only if the server's cert isn't for "localhost".
  checkServerIdentity: () => { return null; },
};

const socket = tls.connect(8000, options, () => {
  console.log('client connected',
              socket.authorized ? 'authorized' : 'unauthorized');
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding('utf8');
socket.on('data', (data) => {
  console.log(data);
});
socket.on('end', () => {
  console.log('server ends connection');
});
```
 
 
# Trace events (Experimental)
- Trace events, trace_events module provides a mechanism to centralize tracing information generated by V8, Node.js core, and userspace code.

avaliable node category 
node
node.async_hooks 
node.bootstrap 
node.console 
node.dns.native 
node.environment 
node.fs.sync 
node.perf 
node.promises.rejections 
node.vm.script 
v8 

$ node --trace-event-categories v8,node,node.async_hooks server.js

https://nodejs.org/dist/latest-v12.x/docs/api/tracing.html

- functions 
    Trace events

        The trace_events module

            Tracing object
                tracing.categories
                tracing.disable()
                tracing.enable()
                tracing.enabled
            trace_events.createTracing(options)
            trace_events.getEnabledCategories()

- enable capture node.perf category 
```
const trace_events = require('trace_events');
const tracing = trace_events.createTracing({ categories: ['node.perf'] });
tracing.enable();  // Enable trace event capture for the 'node.perf' category

// do work

tracing.disable();  // Disable trace event capture for the 'node.perf' category

```

- Tracing object is used to enable or disable tracing for sets of categories. Instances are created using the trace_events.createTracing() method
```
const trace_events = require('trace_events');
const t1 = trace_events.createTracing({ categories: ['node', 'v8'] });
const t2 = trace_events.createTracing({ categories: ['node.perf', 'node'] });
t1.enable();
t2.enable();

// Prints 'node,node.perf,v8'
console.log(trace_events.getEnabledCategories());

t2.disable(); // Will only disable emission of the 'node.perf' category

// Prints 'node,v8'
console.log(trace_events.getEnabledCategories());
```


# TTY 
- TTY, provides the tty.ReadStream and tty.WriteStream classes. In most cases, it will not be necessary or possible to use this module directly. 

Node.js detects that it is being run with a text terminal ("TTY") attached, process.stdin will, by default, be initialized as an instance of tty.ReadStream and both process.stdout and process.stderr will, by default be instances of tty.WriteStream.

```
$ node -p -e "Boolean(process.stdout.isTTY)"
true
$ node -p -e "Boolean(process.stdout.isTTY)" | cat
false
```

- functions

    TTY

        Class: tty.ReadStream
            readStream.isRaw
            readStream.isTTY
            readStream.setRawMode(mode)

        Class: tty.WriteStream
            Event: 'resize'
            writeStream.clearLine(dir[, callback])
            writeStream.clearScreenDown([callback])
            writeStream.columns
            writeStream.cursorTo(x[, y][, callback])
            writeStream.getColorDepth([env])
            writeStream.getWindowSize()
            writeStream.hasColors([count][, env])
            writeStream.isTTY
            writeStream.moveCursor(dx, dy[, callback])
            writeStream.rows
        tty.isatty(fd)


# UDP/datagram 
- UDP/datagram sockets, provides an implementation of UDP datagram sockets.
```
const dgram = require('dgram');
const server = dgram.createSocket('udp4');

server.on('error', (err) => {
  console.log(`server error:\n${err.stack}`);
  server.close();
});

server.on('message', (msg, rinfo) => {
  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
});

server.on('listening', () => {
  const address = server.address();
  console.log(`server listening ${address.address}:${address.port}`);
});

server.bind(41234);
// Prints: server listening 0.0.0.0:41234

```

a random port number and is bound to the "all interfaces" address ('0.0.0.0' for udp4 sockets, '::0' for udp6 sockets.)

```
const dgram = require('dgram');
const message = Buffer.from('Some bytes');
const client = dgram.createSocket('udp4');
client.send(message, 41234, 'localhost', (err) => {
  client.close();
});

const buf1 = Buffer.from('Some ');
const buf2 = Buffer.from('bytes');
const client = dgram.createSocket('udp4');
client.send([buf1, buf2], 41234, (err) => {
  client.close();
});
```

https://nodejs.org/dist/latest-v12.x/docs/api/dgram.html

- functions 


    UDP/datagram sockets

        Class: dgram.Socket
            Event: 'close'
            Event: 'connect'
            Event: 'error'
            Event: 'listening'
            Event: 'message'
            socket.addMembership(multicastAddress[, multicastInterface])
            socket.addSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])
            socket.address()
            socket.bind([port][, address][, callback])
            socket.bind(options[, callback])
            socket.close([callback])
            socket.connect(port[, address][, callback])
            socket.disconnect()
            socket.dropMembership(multicastAddress[, multicastInterface])
            socket.dropSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])
            socket.getRecvBufferSize()
            socket.getSendBufferSize()
            socket.ref()
            socket.remoteAddress()

            socket.send(msg[, offset, length][, port][, address][, callback])
                Note about UDP datagram size
            socket.setBroadcast(flag)

            socket.setMulticastInterface(multicastInterface)
                Example: IPv6 outgoing multicast interface
                Example: IPv4 outgoing multicast interface
                Call results
            socket.setMulticastLoopback(flag)
            socket.setMulticastTTL(ttl)
            socket.setRecvBufferSize(size)
            socket.setSendBufferSize(size)
            socket.setTTL(ttl)
            socket.unref()

        dgram module functions
            dgram.createSocket(options[, callback])
            dgram.createSocket(type[, callback])


# URL 
- URL, utilities for URL resolution and parsing. It can be accessed using:

┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
(All spaces in the "" line should be ignored. They are purely for formatting.)

https://url.spec.whatwg.org/

https://nodejs.org/dist/latest-v12.x/docs/api/url.html
- functions 

    URL
        URL strings and URL objects

        The WHATWG URL API

            Class: URL
                Constructor: new URL(input[, base])
                url.hash
                url.host
                url.hostname
                url.href
                url.origin
                url.password
                url.pathname
                url.port

                url.protocol
                    Special schemes
                url.search
                url.searchParams
                url.username
                url.toString()
                url.toJSON()

            Class: URLSearchParams
                Constructor: new URLSearchParams()
                Constructor: new URLSearchParams(string)
                Constructor: new URLSearchParams(obj)
                Constructor: new URLSearchParams(iterable)
                urlSearchParams.append(name, value)
                urlSearchParams.delete(name)
                urlSearchParams.entries()
                urlSearchParams.forEach(fn[, thisArg])
                urlSearchParams.get(name)
                urlSearchParams.getAll(name)
                urlSearchParams.has(name)
                urlSearchParams.keys()
                urlSearchParams.set(name, value)
                urlSearchParams.sort()
                urlSearchParams.toString()
                urlSearchParams.values()
                urlSearchParams[Symbol.iterator]()
            url.domainToASCII(domain)
            url.domainToUnicode(domain)
            url.fileURLToPath(url)
            url.format(URL[, options])
            url.pathToFileURL(path)

        Legacy URL API

            Legacy urlObject
                urlObject.auth
                urlObject.hash
                urlObject.host
                urlObject.hostname
                urlObject.href
                urlObject.path
                urlObject.pathname
                urlObject.port
                urlObject.protocol
                urlObject.query
                urlObject.search
                urlObject.slashes
            url.format(urlObject)
            url.parse(urlString[, parseQueryString[, slashesDenoteHost]])
            url.resolve(from, to)

        Percent-encoding in URLs
            Legacy API
            WHATWG API

- class URL, implemented by following the WHATWG URL Standard. 

- default url.port for common protocols 

protocol	port
"ftp"	21
"file"	
"gopher"	70
"http"	80
"https"	443
"ws"	80
"wss"	443

```
const myURL = new URL('https://example.org:8888');
console.log(myURL.port);
```

- URLSearchParams API provides read and write access to the query of a URL
```
const myURL = new URL('https://example.org/?abc=123');
console.log(myURL.searchParams.get('abc'));
// Prints 123

let params;

// Using an array
params = new URLSearchParams([
  ['user', 'abc'],
  ['query', 'first'],
  ['query', 'second']
]);
console.log(params.toString());
// Prints 'user=abc&query=first&query=second'

// Using a Map object
const map = new Map();
map.set('user', 'abc');
map.set('query', 'xyz');
params = new URLSearchParams(map);
console.log(params.toString());
// Prints 'user=abc&query=xyz'

```


# Utilities 
- Util,  supports the needs of Node.js internal APIs. Many of the utilities are useful for application and module developers as well. To access it:

```
const util = require('util');
const EventEmitter = require('events');

function MyStream() {
  EventEmitter.call(this);
}

util.inherits(MyStream, EventEmitter);

MyStream.prototype.write = function(data) {
  this.emit('data', data);
};

const stream = new MyStream();

console.log(stream instanceof EventEmitter); // true
console.log(MyStream.super_ === EventEmitter); // true

stream.on('data', (data) => {
  console.log(`Received data: "${data}"`);
});
stream.write('It works!'); // Received data: "It works!"

```

ES6 class inherits 
```
const EventEmitter = require('events');

class MyStream extends EventEmitter {
  write(data) {
    this.emit('data', data);
  }
}

const stream = new MyStream();

stream.on('data', (data) => {
  console.log(`Received data: "${data}"`);
});
stream.write('With ES6');
```

https://nodejs.org/dist/latest-v12.x/docs/api/util.html
- functions 

    Util
        util.callbackify(original)
        util.debuglog(section)
        util.deprecate(fn, msg[, code])
        util.format(format[, ...args])
        util.formatWithOptions(inspectOptions, format[, ...args])
        util.getSystemErrorName(err)
        util.inherits(constructor, superConstructor)
        util.inspect(object[, options])

        util.inspect(object[, showHidden[, depth[, colors]]])

            Customizing util.inspect colors
                Modifiers
                Foreground colors
                Background colors
            Custom inspection functions on objects
            util.inspect.custom
            util.inspect.defaultOptions
        util.isDeepStrictEqual(val1, val2)

        util.promisify(original)
            Custom promisified functions
            util.promisify.custom

        Class: util.TextDecoder

            WHATWG supported encodings
                Encodings Supported Without ICU
                Encodings Supported by Default (With ICU)
                Encodings requiring full ICU data
            new TextDecoder([encoding[, options]])
            textDecoder.decode([input[, options]])
            textDecoder.encoding
            textDecoder.fatal
            textDecoder.ignoreBOM

        Class: util.TextEncoder
            textEncoder.encode([input])
            textEncoder.encodeInto(src, dest)
            textEncoder.encoding

        util.types
            util.types.isAnyArrayBuffer(value)
            util.types.isArrayBufferView(value)
            util.types.isArgumentsObject(value)
            util.types.isArrayBuffer(value)
            util.types.isAsyncFunction(value)
            util.types.isBigInt64Array(value)
            util.types.isBigUint64Array(value)
            util.types.isBooleanObject(value)
            util.types.isBoxedPrimitive(value)
            util.types.isDataView(value)
            util.types.isDate(value)
            util.types.isExternal(value)
            util.types.isFloat32Array(value)
            util.types.isFloat64Array(value)
            util.types.isGeneratorFunction(value)
            util.types.isGeneratorObject(value)
            util.types.isInt8Array(value)
            util.types.isInt16Array(value)
            util.types.isInt32Array(value)
            util.types.isMap(value)
            util.types.isMapIterator(value)
            util.types.isModuleNamespaceObject(value)
            util.types.isNativeError(value)
            util.types.isNumberObject(value)
            util.types.isPromise(value)
            util.types.isProxy(value)
            util.types.isRegExp(value)
            util.types.isSet(value)
            util.types.isSetIterator(value)
            util.types.isSharedArrayBuffer(value)
            util.types.isStringObject(value)
            util.types.isSymbolObject(value)
            util.types.isTypedArray(value)
            util.types.isUint8Array(value)
            util.types.isUint8ClampedArray(value)
            util.types.isUint16Array(value)
            util.types.isUint32Array(value)
            util.types.isWeakMap(value)
            util.types.isWeakSet(value)
            util.types.isWebAssemblyCompiledModule(value)

        Deprecated APIs
            util._extend(target, source)
            util.isArray(object)
            util.isBoolean(object)
            util.isBuffer(object)
            util.isDate(object)
            util.isError(object)
            util.isFunction(object)
            util.isNull(object)
            util.isNullOrUndefined(object)
            util.isNumber(object)
            util.isObject(object)
            util.isPrimitive(object)
            util.isRegExp(object)
            util.isString(object)
            util.isSymbol(object)
            util.isUndefined(object)
            util.log(string)


# V8 
- V8,  exposes APIs that are specific to the version of V8 built into the Node.js binary. It can be accessed using:
```
const { writeHeapSnapshot } = require('v8');
const {
  Worker,
  isMainThread,
  parentPort
} = require('worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);

  worker.once('message', (filename) => {
    console.log(`worker heapdump: ${filename}`);
    // Now get a heapdump for the main thread.
    console.log(`main thread heapdump: ${writeHeapSnapshot()}`);
  });

  // Tell the worker to create a heapdump.
  worker.postMessage('heapdump');
} else {
  parentPort.once('message', (message) => {
    if (message === 'heapdump') {
      // Generate a heapdump for the worker
      // and return the filename to the parent.
      parentPort.postMessage(writeHeapSnapshot());
    }
  });
}
```

https://nodejs.org/dist/latest-v12.x/docs/api/v8.html
- functions 

    V8
        v8.cachedDataVersionTag()
        v8.getHeapSpaceStatistics()
        v8.getHeapSnapshot()
        v8.getHeapStatistics()
        v8.getHeapCodeStatistics()
        v8.setFlagsFromString(flags)
        v8.writeHeapSnapshot([filename])

        Serialization API
            v8.serialize(value)
            v8.deserialize(buffer)

            Class: v8.Serializer
                new Serializer()
                serializer.writeHeader()
                serializer.writeValue(value)
                serializer.releaseBuffer()
                serializer.transferArrayBuffer(id, arrayBuffer)
                serializer.writeUint32(value)
                serializer.writeUint64(hi, lo)
                serializer.writeDouble(value)
                serializer.writeRawBytes(buffer)
                serializer._writeHostObject(object)
                serializer._getDataCloneError(message)
                serializer._getSharedArrayBufferId(sharedArrayBuffer)
                serializer._setTreatArrayBufferViewsAsHostObjects(flag)

            Class: v8.Deserializer
                new Deserializer(buffer)
                deserializer.readHeader()
                deserializer.readValue()
                deserializer.transferArrayBuffer(id, arrayBuffer)
                deserializer.getWireFormatVersion()
                deserializer.readUint32()
                deserializer.readUint64()
                deserializer.readDouble()
                deserializer.readRawBytes(length)
                deserializer._readHostObject()
            Class: v8.DefaultSerializer
            Class: v8.DefaultDeserializer

- v8.DefaultSerializer, v8.DefaultDeserializer, A subclass of Serializer that serializes TypedArray (in particular Buffer) and DataView objects as host objects


# VM 
- VM,  compiling and running code within V8 Virtual Machine contexts. The vm module is not a security mechanism. Do not use it to run untrusted code.

https://nodejs.org/dist/latest-v12.x/docs/api/vm.html

```
const vm = require('vm');

const x = 1;

const context = { x: 2 };
vm.createContext(context); // Contextify the object.

const code = 'x += 40; var y = 17;';
// `x` and `y` are global variables in the context.
// Initially, x has the value 2 because that is the value of context.x.
vm.runInContext(code, context);

console.log(context.x); // 42
console.log(context.y); // 17

console.log(x); // 1; y is not defined.

```

https://nodejs.org/dist/latest-v12.x/docs/api/vm.html
- functions 

    VM (executing JavaScript)

        Class: vm.Script
            Constructor: new vm.Script(code[, options])
            script.createCachedData()
            script.runInContext(contextifiedObject[, options])
            script.runInNewContext([contextObject[, options]])
            script.runInThisContext([options])

        Class: vm.Module
            module.dependencySpecifiers
            module.error
            module.evaluate([options])
            module.link(linker)
            module.namespace
            module.status
            module.identifier

        Class: vm.SourceTextModule
            Constructor: new vm.SourceTextModule(code[, options])
            sourceTextModule.createCachedData()

        Class: vm.SyntheticModule
            Constructor: new vm.SyntheticModule(exportNames, evaluateCallback[, options])
            syntheticModule.setExport(name, value)
        vm.compileFunction(code[, params[, options]])
        vm.createContext([contextObject[, options]])
        vm.isContext(object)
        vm.runInContext(code, contextifiedObject[, options])
        vm.runInNewContext(code[, contextObject[, options]])
        vm.runInThisContext(code[, options])
        Example: Running an HTTP server within a VM
        What does it mean to "contextify" an object?
        Timeout limitations when using process.nextTick(), promises, and queueMicrotask()

- vm.Script, class contain precompiled scripts that can be executed in specific contexts
- vm.Module (experimenetal), provides a low-level interface for using ECMAScript modules in VM contexts. 

available with the --experimental-vm-modules command flag enabled

- vm.runInNewContext() first contextifies the given contextObject (or creates a new contextObject if passed as undefined), compiles the code, runs it within the created context, then returns the result. Running code does not have access to the local scope

```
const vm = require('vm');

const contextObject = {
  animal: 'cat',
  count: 2
};

vm.runInNewContext('count += 1; name = "kitty"', contextObject);
console.log(contextObject);
// Prints: { animal: 'cat', count: 3, name: 'kitty' }

```

- vm.runInThisContext() compiles code, runs it within the context of the current global and returns the result.
```
const vm = require('vm');
let localVar = 'initial value';

const vmResult = vm.runInThisContext('localVar = "vm";');
console.log(`vmResult: '${vmResult}', localVar: '${localVar}'`);
// Prints: vmResult: 'vm', localVar: 'initial value'

const evalResult = eval('localVar = "eval";');
console.log(`evalResult: '${evalResult}', localVar: '${localVar}'`);
// Prints: evalResult: 'eval', localVar: 'eval'

```

- script.runInThisContext() or vm.runInThisContext(), the code is executed within the current V8 global context. The code passed to this VM context will have its own isolated scope.

```
'use strict';
const vm = require('vm');

const code = `
((require) => {
  const http = require('http');

  http.createServer((request, response) => {
    response.writeHead(200, { 'Content-Type': 'text/plain' });
    response.end('Hello World\\n');
  }).listen(8124);

  console.log('Server running at http://127.0.0.1:8124/');
})`;

vm.runInThisContext(code)(require);
```

The require() in the above case shares the state with the context it is passed from. This may introduce risks when untrusted code is executed

- In V8, a context is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of V8.

method vm.createContext() is called, the contextObject argument (or a newly-created object if contextObject is undefined) is associated internally with a new instance of a V8 Context. 

- Timeout limitations when using process.nextTick(), promises and queueMicrotask. all contexts share the same microtask and nextTick queues.

the following code executed by vm.runInNewContext() with a timeout of 5 milliseconds schedules an infinite loop to run after a promise resolves. The scheduled loop is never interrupted by the timeout
```
const vm = require('vm');

function loop() {
  while (1) console.log(Date.now());
}

vm.runInNewContext(
  'Promise.resolve().then(loop);',
  { loop, console },
  { timeout: 5 }
);
```


# WASI (experimental)
-  WASI API provides an implementation of the WebAssembly System Interface specification. 

```
'use strict';
const fs = require('fs');
const { WASI } = require('wasi');
const wasi = new WASI({
  args: process.argv,
  env: process.env,
  preopens: {
    '/sandbox': '/some/real/path/that/wasm/can/access'
  }
});
const importObject = { wasi_snapshot_preview1: wasi.wasiImport };

(async () => {
  const wasm = await WebAssembly.compile(fs.readFileSync('./demo.wasm'));
  const instance = await WebAssembly.instantiate(wasm, importObject);

  wasi.start(instance);
})();
```

WebAssembly system interface 
https://wasi.dev/

use wabt to compile .wat to .wasm 
$ wat2wasm demo.wat

https://github.com/WebAssembly/wabt


https://nodejs.org/dist/latest-v12.x/docs/api/wasi.html
- functions 

    WebAssembly System Interface (WASI)

        Class: WASI
            new WASI([options])
            wasi.start(instance)
            wasi.wasiImport
- classs WASI, provides the WASI system call API and additional convenience methods for working with WASI-based applications.


# Worker threads 
- Worker threads, module enables the use of threads that execute JavaScript in parallel

child_process or cluster, worker_threads can share memory. They do so by transferring ArrayBuffer instances or sharing SharedArrayBuffer instances
```
const {
  Worker, isMainThread, parentPort, workerData
} = require('worker_threads');

if (isMainThread) {
  module.exports = function parseJSAsync(script) {
    return new Promise((resolve, reject) => {
      const worker = new Worker(__filename, {
        workerData: script
      });
      worker.on('message', resolve);
      worker.on('error', reject);
      worker.on('exit', (code) => {
        if (code !== 0)
          reject(new Error(`Worker stopped with exit code ${code}`));
      });
    });
  };
} else {
  const { parse } = require('some-js-parsing-library');
  const script = workerData;
  parentPort.postMessage(parse(script));
}
```

```
const { Worker, isMainThread } = require('worker_threads');

if (isMainThread) {
  // This re-loads the current file inside a Worker instance.
  new Worker(__filename);
} else {
  console.log('Inside Worker!');
  console.log(isMainThread);  // Prints 'false'.
}
```

https://nodejs.org/dist/latest-v12.x/docs/api/worker_threads.html
- functions 

    Worker threads
        worker.isMainThread
        worker.moveMessagePortToContext(port, contextifiedSandbox)
        worker.parentPort
        worker.receiveMessageOnPort(port)
        worker.resourceLimits
        worker.SHARE_ENV
        worker.threadId
        worker.workerData
        Class: MessageChannel

        Class: MessagePort
            Event: 'close'
            Event: 'message'
            port.close()

            port.postMessage(value[, transferList])
                Considerations when transferring TypedArrays and Buffers
            port.ref()
            port.start()
            port.unref()

        Class: Worker
            new Worker(filename[, options])
            Event: 'error'
            Event: 'exit'
            Event: 'message'
            Event: 'online'
            worker.getHeapSnapshot()
            worker.postMessage(value[, transferList])
            worker.ref()
            worker.resourceLimits
            worker.stderr
            worker.stdin
            worker.stdout
            worker.terminate()
            worker.threadId
            worker.unref()

- Worker class represents an independent JavaScript execution thread. Most Node.js APIs are available inside of it.

exposed through worker.postMessage() and the worker.on('message') event on the Worker object for the parent thread

    + differences inside a Worker environment
    
    The process.stdin, process.stdout and process.stderr may be redirected by the parent thread.
    
    The require('worker_threads').isMainThread property is set to false.
    
    The require('worker_threads').parentPort message port is available.
    
    process.exit() does not stop the whole program, just the single thread, and process.abort() is not available.
    
    process.chdir() and process methods that set group or user ids are not available.
    
    process.env is a copy of the parent thread's environment variables, unless otherwise specified. Changes to one copy will not be visible in other threads, and will not be visible to native add-ons (unless worker.SHARE_ENV has been passed as the env option to the Worker constructor).

    process.title cannot be modified.
    
    Signals will not be delivered through process.on('...').
    
    Execution may stop at any point as a result of worker.terminate() being invoked.
    
    IPC channels from parent processes are not accessible.
    
    The trace_events module is not supported.
    
    Native add-ons can only be loaded from multiple threads if they fulfill certain conditions.
    

    + Creating Worker instances inside of other Workers is possible.
    
    + web worker document
    
https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API

    + example 
    
```
const assert = require('assert');
const {
  Worker, MessageChannel, MessagePort, isMainThread, parentPort
} = require('worker_threads');
if (isMainThread) {
  const worker = new Worker(__filename);
  const subChannel = new MessageChannel();
  worker.postMessage({ hereIsYourPort: subChannel.port1 }, [subChannel.port1]);
  subChannel.port2.on('message', (value) => {
    console.log('received:', value);
  });
} else {
  parentPort.once('message', (value) => {
    assert(value.hereIsYourPort instanceof MessagePort);
    value.hereIsYourPort.postMessage('the worker is sending this');
    value.hereIsYourPort.close();
  });
}
```


# Zlib 
- Zlib, provides compression functionality implemented using Gzip, Deflate/Inflate, and Brotli.

```
const { createGzip } = require('zlib');
const { pipeline } = require('stream');
const {
  createReadStream,
  createWriteStream
} = require('fs');

const gzip = createGzip();
const source = createReadStream('input.txt');
const destination = createWriteStream('input.txt.gz');

pipeline(source, gzip, destination, (err) => {
  if (err) {
    console.error('An error occurred:', err);
    process.exitCode = 1;
  }
});

// Or, Promisified

const { promisify } = require('util');
const pipe = promisify(pipeline);

async function do_gzip(input, output) {
  const gzip = createGzip();
  const source = createReadStream(input);
  const destination = createWriteStream(output);
  await pipe(source, gzip, destination);
}

do_gzip('input.txt', 'input.txt.gz')
  .catch((err) => {
    console.error('An error occurred:', err);
    process.exitCode = 1;
  });
```

https://nodejs.org/dist/latest-v12.x/docs/api/zlib.html
- functions 

    Zlib
        Threadpool usage and performance considerations
        Compressing HTTP requests and responses

        Memory usage tuning
            For zlib-based streams
            For Brotli-based streams
        Flushing

        Constants
            zlib constants

            Brotli constants
                Flush operations
                Compressor options
                Decompressor options
        Class: Options
        Class: BrotliOptions
        Class: zlib.BrotliCompress
        Class: zlib.BrotliDecompress
        Class: zlib.Deflate
        Class: zlib.DeflateRaw
        Class: zlib.Gunzip
        Class: zlib.Gzip
        Class: zlib.Inflate
        Class: zlib.InflateRaw
        Class: zlib.Unzip

        Class: zlib.ZlibBase
            zlib.bytesRead
            zlib.bytesWritten
            zlib.close([callback])
            zlib.flush([kind, ]callback)
            zlib.params(level, strategy, callback)
            zlib.reset()
        zlib.constants
        zlib.createBrotliCompress([options])
        zlib.createBrotliDecompress([options])
        zlib.createDeflate([options])
        zlib.createDeflateRaw([options])
        zlib.createGunzip([options])
        zlib.createGzip([options])
        zlib.createInflate([options])
        zlib.createInflateRaw([options])
        zlib.createUnzip([options])

        Convenience methods
            zlib.brotliCompress(buffer[, options], callback)
            zlib.brotliCompressSync(buffer[, options])
            zlib.brotliDecompress(buffer[, options], callback)
            zlib.brotliDecompressSync(buffer[, options])
            zlib.deflate(buffer[, options], callback)
            zlib.deflateSync(buffer[, options])
            zlib.deflateRaw(buffer[, options], callback)
            zlib.deflateRawSync(buffer[, options])
            zlib.gunzip(buffer[, options], callback)
            zlib.gunzipSync(buffer[, options])
            zlib.gzip(buffer[, options], callback)
            zlib.gzipSync(buffer[, options])
            zlib.inflate(buffer[, options], callback)
            zlib.inflateSync(buffer[, options])
            zlib.inflateRaw(buffer[, options], callback)
            zlib.inflateRawSync(buffer[, options])
            zlib.unzip(buffer[, options], callback)
            zlib.unzipSync(buffer[, options])


# Linux dll injection 
https://github.com/DavidBuchanan314/dlinject
https://github.com/kubo/injector
https://github.com/gaffe23/linux-inject
https://www.aldeid.com/wiki/Ptrace-anti-debugging
https://github.com/AonCyberLabs/Cexigua
https://linux.die.net/man/2/ptrace
https://www.networkworld.com/article/3404621/tracking-down-library-injections-on-linux.html
https://www.evilsocket.net/2015/05/01/dynamically-inject-a-shared-library-into-a-running-process-on-androidarm/
https://www.evilsocket.net/2015/05/04/android-native-api-hooking-with-library-injecto/
https://github.com/evilsocket/arminject
https://www.howtogeek.com/363845/what-is-code-injection-on-windows/


#