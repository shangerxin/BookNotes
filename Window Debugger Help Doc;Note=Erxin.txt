Window Debugger Help Doc;Note=Erxin

# Introduction
- window sdk 10 debugger document note 

# Getting started with windows debugging, window debug main process 
- if your code is communicate with low level hardware then suggest not use virtual machine as target 
- determine if you are will be doing kernel or user mode debugging 
	+ kernel mode 
	gain full access to system resource 
	os functionality and system driver have this privileged 
	
	+ user mode for normal application process 
	
some of the debug command may have different function 

- set up debug environment 
- connect the target and host system 
	+ set up kernel mode debugging manually, over 
	
	+ setup debug environment in visual studio 
	
- choose 32-bit or 64-bit debugging tool 
- configure symbols 
- configure source code 
- familiar with debugger operations 
- become familiar with debugging techniques 
- use the debugger reference commands 
- use debugging extensions for specific technologies 


# getting start with windbg(user-mode)
- launch notepad adn attach windbg 
	+ attach to process 
	+ specify symbol path 
	> .sympath srv* 
	Symbol search path is: srv* 
	Expanded Symbol search path is: cache*;SRV*http://msdl.microsoft.com/download/symbols

for custom build application to set symbo by 
> .sympath srv*

> .sympath+ C:\MyApp\x64\Debug

> .srcpath C:\MyApp\MyApp

	+ reload to initla windbg find and loading symbol files 
	> .reload 
	
	+ see symbols for the notepad.exe module 
	> x notepad!*
	
	to see symbols contain main 
	> x notepad!*main 
	
	+ put a break point at notepad!WinMain enter this 
	> bu notepad!WinMain 
	
	+ verify your breakpoint was set by 
	> bl 
	
	+ start notepad running by 
	> g 
	
	+ check all the code modules that are loaded in the notepad process 
	> lm 
	
	+ check stack trace 
	> k 
	
	+ list all the threads 
	> ~ 
	
	+ look at the stack trace for thread 0 
	> ~0s 
	
	+ quit debugging 
	> qd 
	
	+ when encounter a problem, let winDbg analyze the error information by 
	> !analyze -v
	
 
# getting started with windbg (kernel-mode)
- setup a kernel-model debugging 
host computer 
target computer 

debug cable type 
ethernet 
usb 2/3 
1394 
serial(null modem)

if window 8+ then all types of cable are supported, if not the ethernet is not avalable 

- establish a kernel-mode debugging session 
	+ from network cable 
	+ from usb 2.0
- get started using windbg 
	+ on host open windbg, establish a kernel-model debugging sessions from File|Kernel Debug menu 
	+ from the windbg window cmd line enter 
	> .sympath srv* 
	
	> .reload
	
	+ see a list of loaded module 
	> lm 
	
	+ start target computer running 
	> g 
	
	+ break again 
	
	+ examine the _FILE_OBJECT data type in the nt module 
	> dt nt!_FILE_OBJECT
	
	+ enter the command to examine some of the symbols in the nt module 
	> x nt!*CreateProcess* 
	
	+ enter this command to put a breakpoint at MmCreateProcessAddressSpace 
	> bu nt!MmCreateProcessAddressSpace
	
	verify the setted breakpoints 
	> bl 
	
	> g 
	
	if target computer doesn't break into the debugger immediately, perform a few actions(such as open nodepad)
	
	+ after break input 
	> .reload 
	> k 
	to check the call stack 
	
	+ on the view check disassmbly, choose step over or press F10 
	
	+ clear your breakpoint by entering this command 
	> bc * 
	
	+ list all processes 
	> !process 0 0 
	
	+ copy the address of one process and enter this command 
	> !process Address 2 
	
	+ copy the address of one thread enter 
	> !thread Address 
	
	+ see all the device nodes in the plug and play device tree enter 
	> !devnode 0 1 
	
	+ see device nodes along their hardware resources 
	> !devnode 0 9 
	
	+ see device node that has a service name of disk 
	> !devnode 0 1 disk 
	
	+ output of !devnode 0 1 displays the address of the physical device object(PDO) for the node. copy address of a physical object(PDO) and enter this 
	> !devstack PdoAddress 
	
	+ get information about driver disk.sys 
	> !drvobj disk 2 
	
	+ output of !drvobj displays addresses of dispatch routines for example CLASSNP!ClassGlobalDispatch, to set and verify breakpoint with 
	> bu CLASSPNP!ClassGlobalDispatch
	> bl 
	after hit break point 
	> .reload 
	> k 
	
	+ end debug session 
	> qd 
	
- window debug command and syntax 
https://msdn.microsoft.com/en-us/library/windows/hardware/ff540507%28v=vs.85%29.aspx
    + syntax rules 
    
     omit the space between a command and its first parameter 
     
     .expr (Choose Expression Evaluator) command to display or chang
     
        * masm 
        
        set to masm evaluator 
        $ .expr /s masm
        $ ? @rip 
        
        0x prefix (hexadecimal), the 0n prefix (decimal), the 0t prefix (octal), or the 0y prefix (binary).
        
        64-bit values in the xxxxxxxx`xxxxxxxx format. accent(`)
         
        two colons (::) or two underscores (__) to indicate the members of a class.
        
        grave accent (`) or an apostrophe (') in a symbol name only if you add a module name
        
        @@ at before to temp switch to c++ expression rule 
        @@c++(...)
        @@masm(...)
        
        * check below content 
    + command tokens within debugger commands and meta-commands.
    
; (Command Separator)

{ } (Block Delimiter)

${ } (Alias Interpreter)

$$ (Comment Specifier)

* (Comment Line Specifier)

.block

.break

.catch

.continue

.do

.else

.elsif

.for

.foreach

.if

.leave

.printf

.while
        
    + commands, various debugger commands that you can use in CDB, KD, and WinDbg

    $<, $><, $$<, $$><, $$ >a< (Run Script File)
    ? (Command Help)
    ? (Evaluate Expression)
    ?? (Evaluate C++ Expression)
    # (Search for Disassembly Pattern)
    || (System Status)
    ||s (Set Current System)
    | (Process Status)
    |s (Set Current Process)
    ~ (Thread Status)
    ~e (Thread-Specific Command)
    ~f (Freeze Thread)
    ~u (Unfreeze Thread)
    ~n (Suspend Thread)
    ~m (Resume Thread)
    ~s (Set Current Thread)
    ~s (Change Current Processor)
    a (Assemble)
    ad (Delete Alias)
    ah (Assertion Handling)
    al (List Aliases)
    as, aS (Set Alias)
    ba (Break on Access)
    bc (Breakpoint Clear)
    bd (Breakpoint Disable)
    be (Breakpoint Enable)
    bl (Breakpoint List)
    bp, bu, bm (Set Breakpoint)
    br (Breakpoint Renumber)
    bs (Update Breakpoint Command)
    bsc (Update Conditional Breakpoint)
    c (Compare Memory)
    d, da, db, dc, dd, dD, df, dp, dq, du, dw, dW, dyb, dyd (Display Memory)
    dda, ddp, ddu, dpa, dpp, dpu, dqa, dqp, dqu (Display Referenced Memory)
    dds, dps, dqs (Display Words and Symbols)
    dg (Display Selector)
    dl (Display Linked List)
    ds, dS (Display String)
    dt (Display Type)
    dtx (Display Type - Extended Debugger Object Model Information)
    dv (Display Local Variables)
    dx (Display Debugger Object Model Expression)
    e, ea, eb, ed, eD, ef, ep, eq, eu, ew, eza, ezu (Enter Values)
    f, fp (Fill Memory)
    g (Go)
    gc (Go from Conditional Breakpoint)
    gh (Go with Exception Handled)
    gn, gN (Go with Exception Not Handled)
    gu (Go Up)
    ib, iw, id (Input from Port)
    j (Execute If - Else)
    k, kb, kc, kd, kp, kP, kv (Display Stack Backtrace)
    l+, l- (Set Source Options)
    ld (Load Symbols)
    lm (List Loaded Modules)
    ln (List Nearest Symbols)
    ls, lsa (List Source Lines)
    lsc (List Current Source)
    lse (Launch Source Editor)
    lsf, lsf- (Load or Unload Source File)
    lsp (Set Number of Source Lines)
    m (Move Memory)
    n (Set Number Base)
    ob, ow, od (Output to Port)
    p (Step)
    pa (Step to Address)
    pc (Step to Next Call)
    pct (Step to Next Call or Return)
    ph (Step to Next Branching Instruction)
    pt (Step to Next Return)
    q, qq (Quit)
    qd (Quit and Detach)
    r (Registers)
    rdmsr (Read MSR)
    rm (Register Mask)
    s (Search Memory)
    so (Set Kernel Debugging Options)
    sq (Set Quiet Mode)
    ss (Set Symbol Suffix)
    sx, sxd, sxe, sxi, sxn, sxr, sx- (Set Exceptions)
    t (Trace)
    ta (Trace to Address)
    tb (Trace to Next Branch)
    tc (Trace to Next Call)
    tct (Trace to Next Call or Return)
    th (Trace to Next Branching Instruction)
    tt (Trace to Next Return)
    u (Unassemble)
    uf (Unassemble Function)
    up (Unassemble from Physical Memory)
    ur (Unassemble Real Mode BIOS)
    ux (Unassemble x86 BIOS)
    vercommand (Show Debugger Command Line)
    version (Show Debugger Version)
    vertarget (Show Target Computer Version)
    wrmsr (Write MSR)
    wt (Trace and Watch Data)
    x (Examine Symbols)
    z (Execute While)

    + meta-commands in CDB, KD and WinDbg 
    
    .abandon, end debugging sessions and leave target in debugging state 
    .allow_exec_cmds
    .allow_image_mapping 
    .apply_dbp, apply data breakpoint to context 
    .asm, change disassembly options 
    .attach 
    .beep 
    .bpcmds, display breakpoint commands 
    ...
    https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/meta-commands
    
    + control keys 
    ctrl+a, toggle baud rate 
    ctrl+b, quit local debugger 
    ctrl+c, break 
    ctrl+d, toggle debug info 
    ctrl+f, break to kd 
    ctrl+k, change post reboot break state 
    ctrl+p, debug current debugger 
    ctrl+r, re-synchronize 
    ctrl+v, toggle verbose mode 
    ctrl+w, show debugger version 
    
    + general extension commands 
    frequently used during both user-mode and kernel-mode debugging.
    https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/general-extensions
    
    $ !acl Address [Flags]
    display contents of an access control list 
    
    $ !address Address 
    
    $ !analyze 
    display info about current extension 
    
    ...
    
    + kernel extension 
    https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/kernel-mode-extensions
    
    + user mode extension 
    https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/user-mode-extensions
    
    !avrf, 
    !critsec extension displays a critical section.
    !dp(!ntsdexts.dp), Ntsdexts.dll displays a CSR process.
    !dreg KeyPath,  displays registry information.
    !dt extension displays information about a CSR thread.
    !findstack Symbol, locates all of the stacks that contain a specified symbol
    !gatom extension displays the global atom table.
    !igrep extension searches for a pattern in disassembly
    !locks extension in Ntsdexts.dll displays a list of critical sections associated with the current process
    !mapped_file extension displays the name of the file that backs the file mapping
    !runaway extension displays the time consumed by each thread
    !threadtoken extension displays the current impersonation state
    !uniqstack extension displays all of the stacks for all of the threads exclude dupliated stacks 
    !vadump extension displays all virtual memory ranges and info 
    !vprot display virtual memory protection information 

# Choosing 32bit or 64bit debugger 
- when use visual studio, you don't have to consider this 
- when use windbg, kd, cdb, or ntsd you have to make choice yourself
- when x64 base host with running 64 bit version of windows 
	+ analyzing a dump file, you can ue either 32 or 64 
	
	+ live kernel-mode debug, you can use either 32-bit or 64 base on target 
	
	+ debugging user mode on same computer, 64 for 64, 32 for 32 
	

# debugging environment 
- contains 
vs 
windbg 
kd, kernel debugger 
ntkd 
cdb, console debugger 
ntsd, nt symbolic debugger 

- VS with integrated window debugger 
	+ supported 
Configure a set of target computers for debugging. 
Configure the debugging connections to a set of target computers. 
Launch a kernel-mode debugging session between the host computer and a target computer. 
Debug a user-mode process on the host computer. 
Debug a user-mode process on a target computer. 
Connect to remote debugging sessions. 
View assembly code and source code. 
View and manipulate local variables, parameters, and other symbols. 
View and manipulate memory. 
Navigate call stacks. 
Set breakpoints. 
Execute debugger commands. 

	+ also support develop and debug drivers some of the WDK capabilities are integrated into VS 
Configure a set of target computers for driver testing. 
Create and sign a driver package. 
Deploy a driver package to a target computer. 
Install and load a driver on a target computer. 
Test a driver on a target computer. 

- windbg, support user and kernel mode, use VS debug symbol format. can access any public function's name that is exposed by modules that were compiled with COFF symbol files such as *.dbg files 

- kd, character-based console program, enables in depth analysis of kernel mode activity on all nt-based operating system. debug driver or monitor os. typically you need two computer 

- ntkd, variation of kd. variation of the kd debugger. identical to kd except spawns a new text window when it is started, where as kd inherits the command prompt window from which it was invoked 

- cdb, character-based console program enables low-level analysis of window user-mode memory and constructs. 

powerful for debugging a program current running or has recently crashed(live analysis)

it can be used to obtain stack trace or look at the guilty parameters 

with cdb you can display and execute program code, set bp and examine change values in memory. cbd can access memory location through addresses or global symbols you can refer to data and instructions by name rather than by address 

support multiple processes can read poth paged and non-paged memory. it target is console app then will share console with cdb also support spawn a new window 

- ntsd, it is identical to cbd in every way, except spawns a new text window. fully capable of debugging console and window program. Controlling NTSD from the kernel debugger is therefore especially useful, since it results in an extremely light-weight debugger that places almost no burden on the computer containing the target application. This combination can be used to debug system processes, shutdown, and the later stages of boot up.

check the chapter about the user-mode debugger from the kernel debugger 


# Setting up Debugging(kernel -mode and user mode)
## setup kernel-mode in VS 
### Setup kernel-mode debugging over network cable in VS 
- to use VS do kernel-mode debugging you must have Windows Driver Kit integrated with VS 
check more info from window driver development http://go.microsoft.com/fwlink/p?linkid=301383

- configure host and target 
	+ on host in VS, go to the computer configuration dialog select Provision computer and choose debugger settings 
	
	+ connection type select network 
	
	+ port choose from 49152 through 65535 
	
	+ use the automatic generated key 
	
	+ set the bus parameter if target computer contain more than one network cards. if target only contain one card than keep it empty 
	Bus Parameters, enter b.d.f where b, d, and f are the bus number, device number, and function number of the adapter
	
	+ configuration process takes several minutes and might automatically reboot the target computer once or twice 
	
	+ enable or disable kernel debugging by command Prompt window as Administrator and enter the command bcdedit /debug off. Reboot the target computer.
	$ bcdedit /debug off 
	
	+ verify dbgsettings on target 
	
	$ bcdedit /dbgsettings 
	$ bcdedit /enum 
	
	if you don't see the value entered for Bus paramters, enter this command 
	$ bcdedit /set "{dbgsettings}" busparams b.d.f

	where b, d, and f are the bus, device, and function numbers of the network adapter on the target computer that you have chosen to use for debugging
	
	Reboot the target computer.
	
	+ starting the debugging session 
	on host VS|Tools | Attach to Process 
	
	from transport choose Window Kernel Mode Debugger 
	
	Qualifier select name of the target computer that your previous configured 
	
	+ click attach 
	
- creating your own key, Network debugging uses a 256-bit key that is specified as four 64-bit values, in base 36, separated by periods. Each 64-bit value is specified by using up to 13 characters

- troubleshooting tips for debugging over a network cable . windbg or kd must have access through the firewall 

- change port number 
on host VS | Driver menu |Configure Computers 
select target computer click next 
select Provision computer and choose debugger settings and next 
reset the port number and next 


### setting up kernel-mode debugging of a virtual machine in VS 
- virtual machine can be located on the same physical computer as the debugger or on a different computer 

required WDK 

- in the virtual machine enter command 
> bcdedit /debug on 
> bcdedit /dbgsettings serial debugport:n baudrate:115200 
  
n is the COM port on the virtual machine 
  
reboot 

- in the VM configure the COM port to map to a named pip. check your virtual machine document for this 

- configuring the host 

	+ Driver menu Test|Configure computer 
	
	+ add new computer give the physical computer name contain the VM 
	+ select manually configure debuggers and do not provision and click next 
	+ connect type click serial 
	+ check pipe and check reconnect 
	+ if the debugger is running on the same computer name as VM enter this pip name 
	\\.\pipe\pip-name 
	
	on different physical computer use 
	\\vm-host\pip\pip-name 
	
	+ finish 
	
- starting debugging session 
	+ on host VS|Tools|Attach to process 
	+ transport choose window kernel mode debugger 
	+ qualifier select name of the physical computer that is running the target virtual machine 
	+ attach 
- generation 2 virtual machine 
	+ COM ports are not presented in generation 2 virtual machines. you can add COM ports through powershell or wmi for COM ports to be displayed 
	
		* disable secure boot by entering this powershell comand 
		Set-VMFirmware-Vmname vm-name -EnableSecureBoot Off 
		
		* add a com port to the virtual machine by 
		Set-VMFirmware-Vmname vm-name 1 \\.\pipe\PipeName 
		
		* configures the first com port on virtual machine TestVM to connect to named pipe 
		Set-VMFirmware-Vmname TestVM 1 \\.\pipe\TestPipe
	
### setting up kernel-mode debugging over a newwork cable manually 
	
### supported eithernet NICs for network kernel debugging in window 8+


### setup user mode debugging in VS 
- there are two user-mode debuggers available in VS one is the windows user-mode debugger 
	+ one contain in the debuggings tools for windows 
	+ VS debugger which is part of VS 
	
- debugging user-mode process on the local computer, attach process or launching process under the debugger 

- debugging a user-mode process on a target computer 
debugger runs on the host computer the code that is being debugged runs on target computer 
	+ in VS use the user-mode debugger to attach process 
	+ on target computer set Control Panel>Network and Internet>Network and Sharing Center>Advanced sharing settings. Under Guest or Public, select Turn on network discovery and Turn on file and printer sharing.
	+ do the rest of configuration on the host 
	+ VS tools > attach to process 
	+ for transport choose window user mode debugger 
	+ qualifier click browse 
	+ click add 
	+ enter target computer 
	+ click Configure Target Computer
	+ Click ok 
	
- if target is a VM host, requires, set up network debugging before add hyper-v role. if set debugging after added hyper-v role, must change the network settings for your virtual machines to bridge them to the microsoft kernel network debug adapter. other wise the virtual machines will not have access to the network 
	+ target computer has a single network interface card 
	+ install the hyper-v role on the target computer 
	+ create one or more virtual machines on the target computer 
	
    
### configure tools.ini
- contains information to initialize the command-line debuggers 
- windbg saves initialization settings in workspaces 
- tools.ini entries are shown in the following table 

$u0:value ... $u9:value, assign values to fixed-name aliases 
DebugChildren:flag TRUE or FALSE
LazyLoad 
SetDll:filename, set extension dll. 
StopFirst:flag
StopOnProcessExit:flag 
sxd:event, sets the debugger resposne and the handling status for the specified exception or event 
sxe:event
IniFile, specifies the name of the ini file 
- section headers 
[CDB], [NTSD], and [KD].
- example 
[NTSD]
sxe: 3c
sxe: cc
$u0: VeryLongName
VerboseOutput:true


### Using KDbgCtrl
- KDbgCtrl, kernel debugging control, kdbgctrl.exe can be used to control the kernel debugging connection from the target computer
- can control five different settings 
full kernel debugging 
automatic kernel debugging 
user-mode error handling 
blocking of kernel debugging 
the size of DbgPrint buffer 

- first must enable kernel debugging  
- full kernel debugging is enable by default 
$ kdbgctrl -c 
check current settings 

$ kdbgctrl -d 
disable settings 

$ kdbgctrl -e 
enable settings 

- automatic kernel debugging, if full kernel debugging is not enabled then the automatic kernel debugging means only the target computer could init a kernel debug connection 
- user mode error handling, some user-mode events will cause the target computer to break into the kernel debugger 

- block kernel debugging, wait to enable kernel debugging until after the target computer started 
- change the size of DbgPrint buffer 
$ kdbgctrl -sdb 0x100000 


### Debug Universal drivers, step by step lab, echo kernel-mode 

## conditional breakpoints 
- with either the j(execute if - else) command or the .if token, followed by the gc(go from conditional breakpoint) command. 

0:000> bp Address "j (Condition) 'OptionalCommands'; 'gc' "

0:000> bp Address ".if (Condition) {OptionalCommands} .else {gc}"

- base on string comparison 
break into the debugger only if a string variable matches a pattern, for example. suppose want to break at kernel32!CreateEventW only if the lpName argument points to a string that matches the pattern "global*"

bp kernel32!CreateEventW "$$<c:\\commands.txt"

the script file commands.txt contain the following statements 
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }

The lpName argument passed to the CreateEventW function is the fourth argument, so it is stored in the r9 register (x64 processor)

If lpName is not NULL, use as and ${} to create an alias named EventName. Assign to EventName the null-terminated Unicode string beginning at the address pointed to by lpName. On the other hand, if lpName is NULL, use ad to delete any existing alias named EventName
Use $spat to compare the string represented by EventName to the pattern "Global*". If the string does not match the pattern, use gc to continue without breaking. If the string does match the pattern, break and display the string represented by EventName

$spat performs a case-insensitive match 

- conditional breakpoint base on register value 
The following command will break at the beginning of the myFunction function if the eax register is equal to 0xA3:

0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"
 
The following 


# Debugging Resources 
- debugging tools for windows: new for window 10 
.settings, set debug settings set modify display load and save settings in the debugger, settings naemspace 
dx, display NatVis expression 

	+ new command ofr NatVis 
	.nvlist 
	.nvload 
	.nvunload 
	.nvunloadall 
	
blueTooth extensions, Bthkd.dll 
Storage kernel debugger extensions 
	+ new symproxy information inculding symProxy automated Installation 
	http symbol stores 
	symproxy 
	installing symproxy 
	configuring the registry 
	configuring iss for symproxy 
cdb commandline options 
!analyze, update to include information about using this extension with UMDF 2.15 
!wdfkd.wdfcrashdump, update to include information about using this extension with UMDF 2.15 
!irp, updated, starting with window 10 irp major and mino code text 
using debugger markup language 
crash dump analysis using windbg 
debug universal drivers 


## Tools included in debugging tools for windows 
- adplus, automatically create memory dump files and log files 
- dumpchk, validate a memory dump file 
- gflags, control registry keys and other settings 
- kill, terminate a process 
- logger and logviewer, record and display function calls and other actions of a program 
- PLMDebug, use the windows debugger to debug window store apps, support manual control suspending, resuming, and terminating a window store app 
- remote tool, any console program including, kd, cbd, and ntsd, check detail from remote debugging through remote.exe 
- tlist, list all running process 
- umdh, analyze heap allocations 
- usbview, display usb host controllers and connected devices 
- DbgRpc, display microsoft remote procedure call state information 
- KDbgCtrl, control and configure the kernel debugging connection 
- SrcSrv, a source server that can be used to deliver source files while debugging 
- SymProxy, create a single http symbol server on your network that all your debuggers can point to, Symproxy.dll is in the SymProxy folder in the installation directory 

64 bit OS installs for the debugging tools is C:\Program Files (x86)\Windows Kits\10\Debuggers\
32 bit  C:\Program Files. To determine if you should use the 32 bit or 64 bit tools

- symchk, compare executable files to symbol files to verify that the correct symbols are available 
- symstore, create a symbol store 
- agestore, removes old entries in the downstream store of a symbol server or a source server 
- dbh, display information about the contents of a symbol file 
- pdbCopy, remove private symbol information and control which public symbols are included in the file 
- DbgSrv, a process server used for remote debugging 
- KdSrv, a kd connection server 
- DbEngPrx, a repeater(small proxy server) for remote debugging 
- Breakin, causes a user-mode break to occur in a process, for help, open a command prompt window 
- list
- RTLsit, remote task list viewer, Rtlist.exe 

### ADPlus
- v7.0 is a total rewrite of ADPlus in manage code, allows us to eaisly add new features, add some additional features compare to ADPlus.vbs, a new component called ADPlusManager to distributed environment such as HPC computer cluster 


### DumpChk 
- performs a quick analysis of a crash dump file 
- command 
$ DumpChk [-y SymbolPath] DumpFile


## GFlags 
- GFlags, is the global flags editor, enables and disables advanced debugging, diagostic and troubleshooting features. used to turn on indicators that other tools track, count and log 

- overview of Glags 
	+ page heap verification features can help you to identify memory leaks and buffer errors in kernel-mode drivers 
	+ contain dialog box and command-line interface, but some features only accessbile from one interface 
	+ features 
		* page heap verification includes the functions of pageheap.exe 
		* no reboot required for the special pool feature 
		* object referece tracing, for tracing of object referencing and dereferencing in the kernel, supported vista+
		* new dialog box design 
		
- requirements administrator right 
- reference gflags examples 
https://technet.microsoft.com/en-us/library/cc738435(v=ws.10).aspx


### GFlags Overview 
### GFlags Details 
### GFlags Commands 
### GFlags and PageHeap 
### Monitoring Silent Process Exit 

## Global Flags Dialog Box 
## Global Flag Reference 
## GFlags Reference 
## GFLags Example 
- displaying global flags 
- setting a flag by using a flag abbreviation 
- setting a flag by using its hexadecimal value 
- setting multiple flags 
- clearing a flag 
- clearing all flags for an image file 
- enlarging the user-mode stack trace database 
- detecting a pool memory leak 
- detecting a heap memory leak in process 
- enable page heap verification 
- using page heap verification to find a bug 
- listing image files with global flags 
- configuring special pool 
- using object reference tracing 

## Kill tool 
- kill tool, kill.exe terminates one or more process and all of their threads, works only on processes running on the local computer 

$ kill [/f] {PID|Pattern*}

## Logger 
- can be activated through two different vehicles. one way is to use the stand-alone logger.exe program. the other is to start cdb or windbg use the logexts.dll debugger extensions 
logger vehicle works as well, but using the debugger gives you the full power of the debugger along with the power of logger 
- using the debugger and logexts.dll 
one way to active logger is use debugger attach the target and use !logexts.logi or !logexts.loge extesion command. this is inject logger into the target application 

there actually be two instances of logexts.dll running since this module is both a debugger extension dll and the program that is injected into the target application. they communicated through a shared section of memory 

	+ using the logger extension commands 
	!logexts.logi, inject logger into target, initialize but not enable 
	!logexts.loge, enables logging 
	!logexts.logd, disable logging, API hooks to be removed in an effort to allow the program to run freely. COM hooks are not removed because they cannot be re-enabled at will 
	!logexts.logo, displays or modifies output options. there are three types of options, message to debugger, text file, or an *.lgv file which could be view by logViewer 
	if you disable the text file output, a .txt file zero also will be output which may overwrite previous-saved text 
	COM hook are not removed because they could not be reenabled 
	!logexts.logb, display or flushes the current output buffer 
	!logexts.logm, display or creates a module inclusion/exclusion list 

- using logger.exe, run the stand-alone logger program to a single target 
$ logger target-path`

after that a logger window will appear for change settings 
API setting, displays the available API categories 
logging
inclusion/exclusion list 
flush the buffer 
go, start the application 

- restrictions and limitations, logger increase stack consumption for process. can expose bugs in application that usually related to uninitialized variables. the only workarund is to try siabling categories of functions in an attempt to isolate the area that is causing the problem 

### LogViewer
- utility can manipulate an .lgv file which is a compressed log file produced by the logger tool 
...

### Logging manifest
- logging manifest is the group of "header" files that define the functions and COM interfaces that are intercepted and logged. 
designation of OUT parameter 
definition of flag masks 
definition of failure cases 
designation of parameters that can be aliased for log differencing 

- manifest file placement 
- manifest file format 

### PLMDebug 
- a tool that enables you to use the windows debugger to debug windows store app 
...

### Remote Tool 
- remote.exe is a command-line tool that lets you run and control any console program from a remote computer 
- components 
	+ a server application that starts a console program and opens a named pipe for client connections 
	+ a client application taht establishes a connection to a server 
	+ a query feature that lists the remote sessions 
- with remote tool you could start multiple server sessions on a single computer where multiple clients can connect to each sessions 

- remote server syntax 
$ remote /s Command SessionName [/f Color] [/b] [/u User [/u User...]] [/ud User [/ud User...]] [/v | /-v]

- remote client syntax 
$  remote /c Server SessionName [/L Lines] [/f] [/b] [/k ColorFile] 

- remote server query command 
$ remote /q Computer

- remote session commands to communicate with the remote tool during the console session 
@H, displays the session commands on server and client computer 
@M message, displays the specified message on all server and client computer 
@P message, generates a popup window on the server computer 
@Q, quite 
@K, disconnects all clients and ends the remote session 

- remote tool example
...

### TList 
- tlist, task list viewer
all process running on the computer along with their process id 
a tree showing which processes created each process 
details of the process including its virtual memory use and the command that started the process 
threads running in each process, including their ids, entry points last reported error and thread state 
the modules running in each process, including the version number atributes and virtual address of the module 

- command 
$ tlist [/p ProcessName | PID | Pattern | /t | /c | /e | /k | /m [Module] | /s | /v

- example 
...


### UMDH
- user mode dump heap tool, umdh.exe, analyzes the microsoft windows heap memory allocations for a given process. have following modes 
	+ analyze a running process, mode 1, umdh.exe will capture all heaps 
	
	+ analyze umdh log files, mode 2, the log file is previous created by umdh.exe 

- commands 
...

### USBView, universal serial bus viewer, usbview.exe, is a window graphical user interface application that enables you to browse all USB controlelrs and connected USB devices on your computer 

## Tools related to debugging tools for windows 
- application verifier 
- window error reporting 
...

## Source code

## security considerations 

## processor architecture 
- x86 architecture 
    + registers 32bit
eax  Accumulator
ebx  Base register
ecx  Count register
edx  Double-precision register
esi  Source index register
edi  Destination index register
ebp  Base pointer register
esp  Stack pointer
 
    + each 32bit register have two 16bit subregisters  
ax  Low 16 bits of eax
bx  Low 16 bits of ebx
cx  Low 16 bits of ecx
dx  Low 16 bits of edx
si  Low 16 bits of esi
di  Low 16 bits of edi
bp  Low 16 bits of ebp
sp  Low 16 bits of esp

al  Low 8 bits of eax
ah  High 8 bits of ax
bl  Low 8 bits of ebx
bh  High 8 bits of bx
cl  Low 8 bits of ecx
ch  High 8 bits of cx
dl  Low 8 bits of edx
dh  High 8 bits of dx
 
    + using the ? (Evaluate Expression) command, registers should be prefixed with an "at" sign ( @ ). 
    
    the (@) is not required in the r (Registers) command. For instance, r ax=5 will always be interpreted correctly.
    
    + calling conventions, eax, ecx, and edx, which can be changed across a function call, and esp, which must be updated according to the calling convention
    
    The eax register receives function return values if the result is 32 bits or smaller. If the result is 64 bits, then the result is stored in the edx:eax pair.


        * a list of calling conventions used on the x86 architecture:

Win32 (__stdcall)
Function parameters are passed on the stack, pushed right to left, and the callee cleans the stack.

Native C++ method call (also known as thiscall)
Function parameters are passed on the stack, pushed right to left, the "this" pointer is passed in the ecx register, and the callee cleans the stack.

COM (__stdcall for C++ method calls)
Function parameters are passed on the stack, pushed right to left, then the "this" pointer is pushed on the stack, and then the function is called. The callee cleans the stack.

__fastcall
The first two DWORD-or-smaller arguments are passed in the ecx and edx registers. The remaining parameters are passed on the stack, pushed right to left. The callee cleans the stack. 

__cdecl, combines "C" and "declaration"; names are just names
Function parameters are passed on the stack, pushed right to left, and the caller cleans the stack. The __cdecl calling convention is used for all functions with variable-length parameters.

    + example, user mode could ignore the iopl and the entire last line 
eax=00000000 ebx=008b6f00 ecx=01010101 edx=ffffffff esi=00000000 edi=00465000
eip=77f9d022 esp=05cffc48 ebp=05cffc54 iopl=0         nv up ei ng nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000286
    
    + x86 flags 
of Overflow Flag
df Direction Flag
if Interrupt Flag
sf Sign Flag
zf Zero Flag
af Auxiliary Carry Flag
pf Parity Flag
cf Carry Flag
tf Trap Flag
 If tf equals 1, the processor will raise a STATUS_SINGLE_STEP exception after the execution of one instruction. This flag is used by a debugger to implement single-step tracing. It should not be used by other applications.
 
iopl
 I/O Privilege Level 
 This is a two-bit integer, with values between zero and 3. It is used by the operating system to control access to hardware. It should not be used by applications.
 
    + change register value 
r sf=0
 
    + conditions, describes the state of one or more flags
Z ZF=1
 Result of last operation was zero. 
 
NZ ZF=0
 Result of last operation was not zero. 
 
C CF=1
 Last operation required a carry or borrow. (For unsigned integers, this indicates overflow.)
 
NC CF=0
 Last operation did not require a carry or borrow. (For unsigned integers, this indicates overflow.)
 
S SF=1
 Result of last operation has its high bit set. 
 
NS SF=0
 Result of last operation has its high bit clear. 
 
O OF=1
 When treated as a signed integer operation, the last operation caused an overflow or underflow. 
 
NO OF=0
 When treated as signed integer operation, the last operation did not cause an overflow or underflow. 
 
    + The cmp instruction compares its two operands, and then sets flags as if subtracted one operand from the other. The following conditions can be used to check the result of cmp value1, value2.
E ZF=1 value1 == value2.
NE ZF=0 value1 != value2.
GE,NL SF=OF value1 >= value2. Values are treated as signed integers. 
LE, NG ZF=1 or SF!=OF value1 <= value2. Values are treated as signed integers.
G,NLE ZF=0 and SF=OF value1 > value2. Values are treated as signed integers.
L,NGE SF!=OF value1 < value2. Values are treated as signed integers.
AE,NB CF=0 value1 >= value2. Values are treated as unsigned integers.
BE,NA CF=1 or ZF=1 value1 <= value2. Values are treated as unsigned integers.
A,NBE CF=0 and ZF=0 value1 > value2. Values are treated as unsigned integers.
B,NAE CF=1 value1 < value2. Values are treated as unsigned 
 
    + Data types 
byte: 8 bits 
word: 16 bits 
dword: 32 bits 
qword: 64 bits (includes floating-point doubles) 
tword: 80 bits (includes floating-point extended doubles) 
oword: 128 bits

    + notation 
r, r1, r2...
 Registers
 
m 
 Memory address (see the succeeding Addressing Modes section for more information.)
 
#n 
 Immediate constant
 
r/m 
 Register or memory
 
r/#n 
 Register or immediate constant
 
r/m/#n 
 Register, memory, or immediate constant
 
cc
 A condition code listed in the preceding Conditions section.
 
T 
 "B", "W", or "D" (byte, word or dword)
 
accT
 Size T accumulator: al if T = "B", ax if T = "W", or eax if T = "D"
 
    + addressing modes, There are several different addressing modes, but they all take the form T ptr [expr], where T is some data type (see the preceding Data Types section) and expr is some expression involving constants and registers.

    For example, BYTE PTR [esi+edx*8+3] means "take the value of the esi register, add to it eight times the value of the edx register, add three, then access the byte at the resulting address."
    
    + Pipelining
The Pentium is dual-issue, which means that it can perform up to two actions in one clock tick. However, the rules on when it is capable of doing two actions at once (known as pairing) are very complicated.

Because x86 is a CISC processor, you do not have to worry about jump delay slots.

    + Synchronized Memory Access
Load, modify, and store instructions can receive a lock prefix, which modifies the instruction as follows:

Before issuing the instruction, the CPU will flush all pending memory operations to ensure coherency. All data prefetches are abandoned.

While issuing the instruction, the CPU will have exclusive access to the bus. This ensures the atomicity of the load/modify/store operation.

The xchg instruction automatically obeys the previous rules whenever it exchanges a value with memory.

All other instructions default to nonlocking.

    + Jump prediction, Unconditional jumps are predicted to be taken.

Conditional jumps are predicted to be taken or not taken, depending on whether they were taken the last time they were executed. The cache for recording jump history is limited in size.

If the CPU does not have a record of whether the conditional jump was taken or not taken the last time it was executed, it predicts backward conditional jumps as taken and forward conditional jumps as not taken.

    + Alignment
The x86 processor will automatically correct unaligned memory access, at a performance penalty. No exception is raised.

A memory access is considered aligned if the address is an integer multiple of the object size. For example, all BYTE accesses are aligned (everything is an integer multiple of 1), WORD accesses to even addresses are aligned, and DWORD addresses must be a multiple of 4 in order to be aligned.

The lock prefix should not be used for unaligned memory accesses
    
- x86 instructions 
    + introduction 
On the x86 processor, instructions are variable-sized, so disassembling backward is an exercise in pattern matching. To disassemble backward from an address, you should start disassembling at a point further back than you really want to go, then look forward until the instructions start making sense. 

For well-packed switch statements, the compiler emits data directly into the code stream, so disassembling through a switch statement will usually stumble across instructions that make no sense. Find the end of the data and continue disassembling there 
    + Instruction notation 
        * general, instructions is to put the destination register on the left and the source on the right. 
        
        * exception, Arithmetic instructions are typically two-register with the source and destination registers combining. The result is stored into the destination.
        
        * Some of the instructions have both 16-bit and 32-bit versions, but only the 32-bit versions are listed here. Not listed here are floating-point instructions, privileged instructions, and instructions that are used only in segmented models 
        
    + example, many of the instructions are expressed in combined form, as shown in the following example.

    MOV r1, r/m/#n r1 = r/m/#n
    
    first parameter must be a register, but the second can be a register, a memory reference, or an immediate value.

    + example 
    MOV r1/m, r/m/#n r1/m = r/m/#n
 
    first parameter can be a register or a memory reference, and the second can be a register, memory reference, or immediate value.
    
    + memory and data transfer instructions do not affect flags 
    
    + effective address 
    LEA r, m 
    
    Load effective address.(r = address of m)
 
    LEA eax, [esi+4] 
    means eax = esi + 4. This instruction is often used to perform arithmetic.

    + Data transfer 
    MOV r1/m, r2/m/#n 
    r1/m = r/m/#n
     
    MOVSX r1, r/m 
    Move with sign extension.
     
    MOVZX r1, r/m
    Move with zero extension.
     
    MOVSX and MOVZX are special versions of the mov instruction that perform sign extension or zero extension from the source to the destination. This is the only instruction that allows the source and destination to be different size
    
    + Stack manipulation 
PUSH r/m/#n
 Push value onto stack.
 
POP r/m
 Pop value from stack.
 
PUSHFD
 Push flags onto stack.
 
POPFD
 Pop flags from stack.
 
PUSHAD
 Push all integer registers.
 
POPAD
 Pop all integer registers.
 
ENTER #n, #n
 Build stack frame.
 
LEAVE
 Tear down stack frame
 
The C/C++ compiler does not use the enter instruction. (The enter instruction is used to implement nested procedures in languages like Algol or Pascal.) 

    + data conversion 
CBW
 Convert byte (al) to word (ax).
 
CWD
 Convert word (ax) to dword (dx:ax).
 
CWDE
 Convert word (ax) to dword (eax).
 
CDQ
 convert dword (eax) to qword (edx:eax).
 
All conversions perform sign extension.

    + arithmetic 
ADD r1/m, r2/m/#n
 r1/m += r2/m/#n
 
ADC r1/m, r2/m/#n
 r1/m += r2/m/#n + carry
 
SUB r1/m, r2/m/#n
 r1/m -= r2/m/#n
 
SBB r1/m, r2/m/#n
 r1/m -= r2/m/#n + carry
 
NEG r1/m
 r1/m = -r1/m
 
INC r/m
 r/m += 1
 
DEC r/m
 r/m -= 1
 
CMP r1/m, r2/m/#n
 Compute r1/m - r2/m/#n
 
cmp compute the substraction and throw the result away


MUL r/m8
 ax = al * r/m8
 
MUL r/m16
 dx:ax = ax * r/m16
 
MUL r/m32
 edx:eax = eax * r/m32
 
IMUL r/m8
 ax = al * r/m8
 
IMUL r/m16
 dx:ax = ax * r/m16
 
IMUL r/m32
 edx:eax = eax * r/m32
 
IMUL r1, r2/m
 r1 *= r2/m
 
IMUL r1, r2/m, #n
 r1 = r2/m * #n
 
the state of flags after multiplication is undefined 

DIV r/m8
 (ah, al) = (ax % r/m8, ax / r/m8)
 
DIV r/m16
 (dx, ax) = dx:ax / r/m16
 
DIV r/m32
 (edx, eax) = edx:eax / r/m32
 
IDIV r/m8
 (ah, al) = ax / r/m8
 
IDIV r/m16
 (dx, ax) = dx:ax / r/m16
 
IDIV r/m32
 (edx, eax) = edx:eax / r/m32
 
Unsigned and signed division. The first register in the pseudocode explanation receives the remainder and the second receives the quotient. If the result overflows the destination, a division overflow exception is generated. The state of flags after division is undefined.

SETcc r/m8
 Set r/m8 to 0 or 1
If the condition cc is true, then the 8-bit value is set to 1. Otherwise, the 8-bit value is set to zero.

    + binary-coded decimal 
DAA
 Decimal adjust after addition.
 
DAS
 Decimal adjust after subtraction.

instructions for COBOL 


    + These instructions adjust the al register after performing a packed binary-coded decimal operation.

AAA
 ASCII adjust after addition.
 
AAS
 ASCII adjust after subtraction.
 
    + Bits 
AND r1/m, r2/m/#n
 r1/m = r1/m and r2/m/#n
 
OR r1/m, r2/m/#n
 r1/m = r1/m or r2/m/#n
 
XOR r1/m, r2/m/#n
 r1/m = r1/m xor r2/m/#n
 
NOT r1/m
 r1/m = bitwise not r1/m
 
TEST r1/m, r2/m/#n
 Compute r1/m and r2/m/#n
 
The test instruction computes the logical AND operator and sets flags according to the result, but throws the result away. It is typically followed by a conditional jump  that tests the result of the logical AND.


SHL r1/m, cl/#n
 r1/m <<= cl/#n
 
SHR r1/m, cl/#n
 r1/m >>= cl/#n zero-fill
 
SAR r1/m, cl/#n
 r1/m >>= cl/#n sign-fill
 
the last bit shifted out is placed in the carry 

SHLD r1, r2/m, cl/#n
 Shift left double.
shift r1 left by cl/#n, filling with the top bits of r2/m. The last bit shifted out is placed in the carry.

SHRD r1, r2/m, cl/#n
Shift r1 right by cl/#n, filling with the bottom bits of r2/m. The last bit shifted out is placed in the carry.
 

Rotation is like shifting, except that the bits that are shifted out reappear as the incoming fill bits. The C-language version of the rotation instructions incorporate the carry bit into the rotation.
ROL r1, cl/#n
 Rotate r1 left by cl/#n.
 
ROR r1, cl/#n
 Rotate r1 right by cl/#n.
 
RCL r1, cl/#n
 Rotate r1/C left by cl/#n.
 
RCR r1, cl/#n
 Rotate r1/C right by cl/#n.
 
 
BT r1, r2/#n
 Copy bit r2/#n of r1 into carry.
 
BTS r1, r2/#n
 Set bit r2/#n of r1, copy previous value into carry.
 
BTC r1, r2/#n
 Clear bit r2/#n of r1, copy previous value into carry.
 
    + Control flow 
Jcc dest Branch conditional.
 
JMP dest Jump direct.
 
JMP r/m Jump indirect.
 
CALL dest Call direct.
 
CALL r/m Call indirect.

The call instruction pushes the return address onto the stack then jumps to the destination.

 
RET #n
The ret instruction pops and jumps to the return address on the stack. A nonzero #n in the RET instruction indicates that after popping the return address, the value #n should be added to the stack pointer.


LOOP 
Decrement ecx and jump if result is nonzero.
 
LOOPZ
Decrement ecx and jump if result is nonzero and zr was set.
 
LOOPNZ
Decrement ecx and jump if result is nonzero and zr was clear.
 
JECXZ
Jump if ecx is zero.
These instructions are remnants of the x86's CISC heritage and in recent processors are actually slower than the equivalent instructions written out the long way.

    + string manipulation 
MOVST 
 Move T from esi to edi.
 
CMPST
 Compare T from esi with edi.
 
SCAST
 Scan T from edi for accT.
 
LODST
 Load T from esi into accT.
 
STOST
 Store T to edi from accT.
 
After performing the operation, the source and destination register are incremented or decremented by sizeof(T), according to the setting of the direction flag (up or down).

The instruction can be prefixed by REP to repeat the operation the number of times specified by the ecx register.

The rep mov instruction is used to copy blocks of memory.
 rep mov
The rep stos instruction is used to fill a block of memory with accT.
 rep stos

    + flags 
LAHF
 Load ah from flags.
 
SAHF
 Store ah to flags.
 
STC
 Set carry.
 
CLC
 Clear carry.
 
CMC
 Complement carry.
 
STD
 Set direction to down.
 
CLD
 Set direction to up.
 
STI
 Enable interrupts.
 
CLI
 Disable interrupts.
 
    + interlocked instructions 
XCHG r1, r/m
 Swap r1 and r/m.
 
XADD r1, r/m
 Add r1 to r/m, put original value in r1.
 
CMPXCHG r1, r/m
 Compare and exchange conditional. the atomic version of the CMPXCHG are:
   cmp     accT, r/m
   jz      match
   mov     accT, r/m
   jmp     done
match:
   mov     r/m, r1
done:
 
    + miscellaneous 
INT #n
 Trap to kernel.
 
BOUND r, m
 Trap if r not in range.
 
NOP No operation.
 
XLATB al = [ebx + al]
 
BSWAP r
 Swap byte order in register.
 
special case of int instruction 
INT 3 
Debugger breakpoint trap. The opcode for INT 3 is 0xCC. The opcode for NOP is 0x90. When debugging code, you may need to patch out some code. You can do this by replacing the offending bytes with 0x90. 

    + idiom
XOR r, r
 r = 0
 
TEST r, r
 Check if r = 0.
 
ADD r, r
 Shift r left by 1.
 
- annotated x86 disassembly 
...

- the x64 processor 
- x64 architecture 
- x64 instructions 
- annotated x64 disassembly 

## Debugger engine and extension APIs 
- introduction 

### Debugger engine overview 

### Using the debugger engine API 

### writing DbgEng Extensions 

### Writing WdbgExts Extensions 

### Writing Custom Analysis Debugger Extensions 

### Glossary 

# Debugger Operation
## Debugging using VIsual Studio 

## Debugging Using Windbg 
### Debugging a User mode process using WinDbg 
- attach to a running process 
	+ from menu 
	+ from command 
$windbg -p ProcessID 
$windbg -pn ProcessName 

	+ debugger command window 
if windbg already attach to a process you could use command .attach attach a running process in the command window 

debugger always starts multiple target processes simultaneously, unless some of their threads are frozen or suspended 

- attaching to a running process noninvasively 

	+ menu, File|Attach to Process select Noninvasive 
	+ commandline 
	$ windbg -pv -p <process-id>
	$ windbg -pv -pn <process-name>
	
	+ debugger command window 
	.attach -v  
	if debugger is already active. the debugger can not noninvasive debug more than one process at a time 
	
- spawning a new process, the process that debugger create is behave slight different. It use the heap which is created by debugger. Force the process use the standard heap by NO_DEBUG_HEAP environment variable or the -hd command-line option
	
because the process is a child process which inherit the debugger permission may also influence the action 

	+ menu 
	+ command line 
	$ windbg [-o] ProgramName [Arguments]
	
	$ windbg .create 
	
	control the process start directory by .createdir (set created proces directory) before call the .create command. You can use the .createdir -I command or the -noinh command-line option to control whether the target application inherits the debugger's handles
	
	active or deactive child debugging by .childdbg 

### Open a dump file using windbg 
- menu 
- commandline 
$ windbg -y SymbolPath -i ImagePath -z DumpFileName
- already open then use 
.opendump ( open dump file ) follow by g (go)

### live kernel-mode debugging using windbg 

### Ending a debug session in windbg 
- menu File|Exit 
unless use user-mode debugging with -pd option or kernel mode. if in kernel debugging mode then the target computer may in frozen state or running, if frozen then could reconnect to resume the debugging state 

- ending a user-mode session without existing 

	+ .kill command 
	+ q command unless you start debugger with -pd option 
	+ choose stop debugging from debug menu 
	+ shift+f5 
	+ toolbar stop debugging button 
	
- end a user-mode debugging session to dormat mode and set the target running again 
	+ enter .detach command 
	+ choose Debug|Detach Debugee 
	+ qd command 
	+ q command if you started the debugger with the -pd option 
	
- end a user-mode debugging return the debugger to dromant mode but leave the target in debugging state with .abandoned command 

- ending a kernel-mode session without exiting. end a kernel mode debugging session. leave the target computer frozen 
	+ q command 
	+ menu 
	+ shift+f5 
	+ toolbar 
	
### Setting Symbol and executable image paths in windbg 
- use the symbol server by srv* or symsrv* string 
- control the symbol path in windbg 
	+ set from menu in windbg
File|Symbol File Path 

	+ use command .sympath, use using a symbol server. .symfix is similar to .sympath but saves typing 
	
	+ start debugger with -y to specify the symbol path 
	
	+ use  _NT_SYMBOL_PATH and _NT_ALT_SYMBOL_PATH environment variables to set the path

- executable image path, executable is a binary file that the processor can run. typically have the .exe, .dll or .sys extension 

before os run an executable it loads it into memory. the copied file in memory is called image in window 

- most of the time debugger knows the executable file location, but small memory dump files in kernel-mode don't contain the info 

user-mode minidump do not contain the application binaries 
The debugger's executable image path is a string that consists of multiple directory paths, separated by semicolons. 

- control the executable image path in windbg 
	+ File|Image File Path 
	+ use command .exepath 
	+ use commandline option -i 
	+ use environment variable _NT_EXECUTABLE_IMAGE_PATH 
	
### Remote debugging in windbg 

### Entering debugger commands in windbg 
- use alt+1 to open the command window 

### Using the command browser window in windbg
- it is used to displays and stores the text results of a debugger command 
$ .browse
- support multiple instance 
- open command browser window 
- switch between different command window by alt+shift+N 
- commands enter in the command browser window are executed by the debugger engine, not by the windbg user interface. this means you can't enter user interface command like .cls 


### Setting breakpoints in windbg 
- menu Edit|Breakpoints 
- alt+F9 will display a list box contain all the break points 
- code window, the disassembly window and the source windows highlight lines that have breakpoints set. enabled breakpoints are read and disabled breakpoints are yellow 
press f9 to set breakpoint 


### Viewing the call stack in windbg 
- call stack is the chain of function calls that have led to the current location of the program counter. it is display based on the current program counter unless you change the register context 

- debugger command window 
	+ command k in command window 
	+ calls call stack window 
	View|Call Stack 
	
	double click a line to change the context 
	
	+ near the upper right corner contain the buttons and commands 
	raw args, displays the first three parameters that are passed to the function  
	func info 
	source 
	address 
	nonvolatile regs, displays the nonvolatile portion of the register context 
	frame nums 
	arg types 
	always floating 
	move with frame 
	
### Assembly Code Debugging in WinDbg 
- view the assembly code by enter the command u, ub, uu(Unassemble) commands in the debugger command window 

- disassembly window 
View|Disassemlby 

alt+shift+7 

	+ support operation 
	disassemble different section of memory in the offset box type the memory you want to disassemble 
	
	+ to see other sections of memory, click the next previous buttons or press the page up or page down keys will go to the preceding or following sections of memory. use arrow key to navigate in the current window items 
	
	+ title toolbar button support 
	go to current address 
	disassemble before current instructions
	show source line for each instructions
	show source file for each instructions
	
    
### Source code debugging in windbg 
- control the source path in windbg 
	+ menu , File|Source File Path 
	ctrl + p
	
	+ command .srcpath or .srcfix 
	+ use .lsrcpath (set local source path) for using a source server or .lsrcfix 
	
	+ commandline -lsrcpath or -srcpath 
	+ use environment variable _NT_SOURCE_PATH 
	
- opening and closing source files 
	+ menu 
	+ command .open 
	+ lsf command (load or unload source files)
	
- windbg invoke source editor with these parameters 
$ c:\my\path\myeditor.exe -file %f -line %l
 
- source window colors and hover evaluation 
	+ open source window's shortcut menu select source languge to <none> for turn off syntax collor 
	
	+ the hover evaluation is equal to the command dt(display type command)


### Viewing and Editing Memory in Windbg 
- debugger command window 
	+ menu View|Memory, alt+5 
	
- using a memory window, displays data in several columns, the first column display the beginning address of each line 

change the display format from the tool bar to control the format 

ascii characters will be display in the right 

by default memory window displays virtual memory. this is only avaliable in user mode. in kernel model could use memory options to display physical memory and other data spaces 

- in memory window you can do 
	+ write to memory 
	+ to see other sections of memory 
	+ navigate within the window use the arrow keys 
	+ change memory location to view use the address box 
	+ change data type by display format 
	
- in the title bar click the icon to display more commands 
display format 
previous, next 
auto-fit columns 
dock 
move to new dock 
...

properties to open Memory Options 

- memory options dialog if in kernel mode there will be six memory types available such as 
virtual memory 
physical memory 
bus data 
control data 
i/o (i/o port information)
MSR(mode-specific register information)


### Viewing and editing global variables in windbg 
- debugger interprets the name of a global variable as a virtual address. you can use all the the commands in accessing memory by virtual address to display global variables

d* command display contents of a specified memory address or range 
e* writes a value to the specified memory address 

dt find a variety of data types 
ds display string 
dl display linked list 
d*s display words and symbols 
!address extension command display information about the property of the memory 

m moves the content of one memory range to another 
f write a pattern to a memory range 
c compare contents of two memory ranges 
s search memory 
.holdmem hold and compare one memory range to another  

most of the command interpret the parameter in current radix, use 0x befre hex 
use n command to set number base 
use evalue expression ? to quickly convert numbers from one base to another or use the .formats command show number formats 

you can use any command to display the address that is associate with any symbol 

- use watch window to display and change variables alt+2 


### Viewing and editing local variables in windbg 
- use command 
dv 
dt 

- open locals window alt+3, contain four columns 
name
value, support change value  
type, also support enter a extension command in the type column. the debugger will pass the address of the symbol to this extension will display the resulting beneath the current row. if the symbol is a thread environment block you can enter !teb in the type to run the !teb extension

location, show the offset 
if a local variable is an instance of a class that contains vtables the name column display the vtables and you can expand the vtables to show the function pointers. if have a base class, _vtcast_Class is displayed to indicate the members that are being added because of the derived class 
local context determines which set of local variables will be displayed in the locals window, locals window is automatically updated 

- command in the toolbar menus 
typecast 
type 
locations 
display 16-bit values as unicode 
always display numbers in default radix 
...


### Viewing and editing registers in windbg 
- x86, x64 process have different collections of registers 

- commands 
	+ r command in command window to view registers 
	
	+ customize the display with command rm 
	
	+ stepping through your code with p(step) or t(trace) commands you see a register display at every step 
	
	+ r option also controls several one-bit register known as flags 
	
- register window 
	+ menu View|Registers alt + 4 

- register window support 
value 
in user mode, registers window displays the registers that are associated with the current thread 
in kernel mode, registers window displays the registers that are associated with the current register context. only the most important registers for the specified register context are actually displayed 

- customize register list dialog box. you can't actually delete a register from the list, if do it will appear at the end 

watch window also support display registers 


### Controlling Processes and Threads in Windbg 
- display the system process and thread info also support select a new system, process, and thread to active 

- open the process and threads window alt+9, alt+shift+9 to close 
click a line in the window to active another thread or process 


### Configuration Exceptions adn Events and Windbg 
- configure windbg react to specified exceptions and events in a specific way 

for each exxception you can set the break status and handling status for each event 

	+ Debug|Event Filters click event that you want from the list in the Event Filters, select enabled, disabled, output or ignore 
	
	+ Use the SXE, SXD, or SXI command 
	
- configure the handling status by 
	+ Debug|Event Filters and then select handled or not handled 
	+ use the SXE, SXD, SXN or SXI command 

	
### Keeping a log file in windbg 
- can write a log file that records the debugging session this log file contains all of the contents of the debugger command window 

- opening a new log file in several ways
	+ Edit|Open/Close Log file from Edit menu 
	
	+ use -logo command line 
	
	+ use command .logopen (open log file) command. if use the /t option the date and time are appended. /u then the file will writen in unicode 
	
- appending to an existing file 
	+ choose Open/Close log file from the edit menu 
	+ when you start windbg in a command prompt window use -loga command line option 
	+ command .logappend (append log file) command 
	
- close a log 
	+ menu 
	+ .logclose 
	
- checking log status 
	+ menu Edit|Open/Close log file 
	+ .logfile will display command 

    
### Using the watch window 
- open watch window alt+2, for display global, local, registers 
reference previous notes ### Viewing and editing global variables in windbg 


### Using the scratch pad 
- it is a clipboard on which you can type and save text 
- open View|Scratch Pad, alt+8 
- support operations 
type in to edit 
close the window the text will remain when reopen  
	

## Debugging Using KD and NTKD 
## Debugging Using CDB and NTSD 

## Local Kernel-mode Debugging 


## Conrolling the target 
- when the debugger connects to a kernel mode target the debugger leaves the target running unles yu use the -b command line 

when debugger connect to a user-mode target it immedaitely stops the taget unless you use the -g commmand line 

- when the target is runnning 
	+ issue a break command, if the application executing system code or are in wait operation it will breaks only after controls has returned to the application's code 
	
	+ if certain events occur if a breakpoint is hit the application closes normally 
	
- when target is stopped 
	+ continue run, by go command 
	+ step through by debug command window 
	+ if an excpetion occurs you can use Go With Exception Handled adn Go With Excption Not Handed commands to resume execution and control the status of exception 

	+ select a source code in line support run to cursor 
	+ user mode support restart command, it is only avaliable for the process which is created by debugger 
	
	+ windbg only, close target application and clear the debugger, use Stop Debugging 
	
- command forms these commands also support in CDB, KD, WinDbg, in windbg the commands are in debug menu 

command		 windbg command	  windbg shortcut		 effect 
				run to cursor	   f7, ctrl+f10
				stop debugging	  shift+f5			
ctrl+c		  break			   ctrl+break 
.restart		restart			 ctrl+shift+f5 
g			   go				  
gc(go with conditional breakpoint)							 
gh(go with exception handled) 
gn(go with excpetion not handled)
gu(go up)	   step out			shift+f11 
p(step)		 step over 
pa(step to address) 
pc(step to next call)
pct(step to next branching instruction)
pt(step to next return)
t(trace)		step into 
tb(trace to next branch)
tc(trace to next call)
tct(trace to next call or return)
th(trace to next branching instruction)
tt(trace to next return)
wt(trace and watch data), Target executes until the completion of the whole specified function. Statistics are then displayed.

- with command line option -g to attach user mode without stop 
- CDB and windbg also support -G which cause the debugging session end if the application completes properly 
$ cdb -g -G ApplicationName 

use -pt to set break timeout, if a break command is issued and the debugger cannot break into the target after this time the debugger display a "break-in time out" message 

default value is 30 seconds 


## Enabling Postmortem debugging 
- most application errors are called exceptions, included access violation, division-by-zero, numerical overflows. breakpoints can be inserted in to the code by a debugger, or invoked through a function such as DbgBreakPoint 

- precedence used for error handling 
	+ if a user-mode debugger is attached to the faulting process, all errors will cause the target to break into this debugger. no other-handling methods will be used even if the gn(go with exception not handled) is used 
	+ no user-mode debugger attached then application need handle these by it self 
	+ if no user-mode debugger but a kernel model debugger is connected window will try to use it 
	if window 2003+ support prevent a user-mode interrupt from breaking into the kernel debugger, you can use the KDbgCtrl utility with -du parameter 
	
	in the kernel debugger could use the gh(go with exception handled) to disregard the error and continue the target ou can use gn(go with exception not handled) to bypass the kernel debugger and window will try t use a just-in-time debugger which referred as the postmortem debugger 
	
	+ if there is no postmortem debugger than window error report will display a message box. if appropriate values are set in the registry WER will also write a dump file 
	
- specifying a postmortem debugger 
	+ set the postmortem debugger to windbg run
	$ windbg -I 
	I must capitalized, then it will be active whenever an application crash 
	
	+ set to cdb 
	$ cdb -ieac 
	
	+ set to ntsd 
	$ ntsd -iae 
	
	when the debuggers are called the command line arguments should be 
	$ debugger -p %ld -e %ld -g [keyString]
	The -p %ld parameter specifies the process ID that will be debugged, the -e %ld parameter provides the event that caused the exception, and the -g parameter causes the debugger to skip the initial breakpoint. If the -iaec switch is used when installing CDB or NTSD as the postmortem debugger, the additional arguments specified as KeyString will then follow. 

- editing the registry key to set the postmortem debugger 
HKLM\Software\Microsoft\Windows NT\CurrentVersion\AeDebug

On a 64-bit platform, the postmortem settings for 32-bit processes are stored under this registry key:

HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug

relative registry entries 
Debugger, to the fullpath of the debugger 
Auto, set to 0 or 1, if equal to 0 a message box will be displayed first 


## Using the debugger command window 
### Using debugger commands 
- kd or cdb the debugger command window is set to the whole window 
- visual studio refer to the window which is labeled "Debugger Immediate Window" which have two panel 
	+ in the small, bottom pane yu enter commands
	+ large upper will view the command output 
	
- command prompt 
	+ user mode 
2:005> 

the 2 is refer to the current process number and 005 is the current thread number 

	+ kernel mode 
kd> 

if the target process have multiple processors then the curnt processor appears before the prompt 
0: kd> 

	+ if debugger is busy there will be a message 
*BUSY*

	+ use command .pcmd to add text to this prompt (set prompt command)
	
- kinds of commands 
	+ some commands are available only in the live debugging and other available only in a dump debug 
	
	+ user mode and kernel mode 
	
	+ target is running on certain processors 
	
- editing repeating and canceling commands 

	+ find previous command use arrow keys 
	
	+ press ESC to clear current line 
	
	+ tab to automatic complete typing 
		* start with "." dot them match to a dot command 
		* start with "!" matched to an extension command 
		* otherwise the text is matched with a symbol 
	
	+ use wildcard characters in the text and press TAB to expand to the full set of text completion options 
	$ fo*!ba 
	will expend to all module start with "fo" and all symbols included all symbols that start with "bar"

	complete all extension command that have prcb in them by 
	!*prcb and then pressing TAB 
	
	+ maximum command length is 4096 if controlling the user-mode debugger from kernel mode debugger the maximum length is 512 
	
	+ press ENTER to repeat the previous commad by default in CDB and KD 
	
	+ ctrl+c to cut of a long display in cdb or kd, in windbg use Debug|Break or Ctrl+break 
	
	+ clear screen by .cls clear screen in cdb or kd, in windbg use Edit|Clear command output 
	
- expression syntax, many commands and extensions accept expressions as their argument, debugger evaluates these before executing the command 

- aliases for avoid retype complex phrases 

- self-repeating commands, to repeat an action or conditionally execute other commands 

j (execute if-else) conditional command 
z (execute while) conditional command 
~e (thread-sepcific command) command qualifier 
!list extension command 

- control scrolling, press any key or command output will auto scroll down. disable this in windbg by View|Options uncheck the Automatically scroll 

- windbg text features 
	+ word wrap affects the whole window, not recommend 
	+ Edit|Add to Command Output, adds a comment in the debugger command window 
	+ customize the colors that are used for the text and the background of the debugger View|Options 
- remote debugging, the debugging client can access a limited number of commands to change this by use -clines command line option or the _NT_DEBUG_HISTORY_SIZE 


### Evaluating expressions 
- have two different expression 
	+ MASM, all symbols are treated as address
	+ c++, symbols are understood as the appropriate data types 
	
- each syntax is sued 
use _NT_EXPR_EVAL before the debugger started 
use the -ee {masm|c++} command line option 
use .expr(choose expression evaluator) command 

by default MASM is used 
	
- evalue a expression without change debugger state by ?(Evaluate expression) command 

all the debugging information window interpret their arguments throught the default expression evaluator 

	+ ?? (evaluate C++ expression) 
	+ watch window use the c++ expression evaluator 
	+ locals window use the C++ expression evaluator 
	+ some extension command use MASM evaluator 
	+ if any part of an expression is enclosed in parenthese and you insert two at signs(@@) before the expression, the expression is evaluated by the expression evaluator that would not typically be used in this case 
	
two at signs enable you to use two different evaluators of a single command. each appearance of the two at signs switches to the other expression evaluator 

c++ expression syntax is useful for manipulating structures and variables, but not well suited as a parser for the parameters of a debugger command 

- numbers in expression 
interpreted according to the current radix. the n(set number base) command can be used to set the default radix to 16, 10, or 85%29

default radix can be overridden by the 0x prefix, 0n (decimal), 0t(octal) or 0y(bynary)

number in c++ are interpreted as decimal numbers unless you specify differently 

- display numbers in serveral bases at the same time use .formats(show number formats) commads 

- symbols in expressions 

	+ MASM expressions each symbol is interpreted as an address, is variable, function, seg
	+ in c++ exression each symbol is interpreted according to its type
	
- is a symbol name ambiguous with the module name and an exclamation point (!). to specify a symbol is local use the $! before the symbol name. 

- operators in expressions. each expressions use different collection of operators 


### Using shell commands 
- use shell command .shell, if you are remote debugging the shell command are execute on the server 
- the .noshell(prohibit shell command) will disable all the shell command. the shell command will keep disable even use .restart(restart kernel connection) command

if you are running a debugging server you might want to disable the shell commands because remote connection can run shell on your computer 
- network driver control, File|Map network and Disconnect network driver always changes windbg is running on 


### Using aliaes
- debuggers support three kinds of aliaes 
	+ user-named aliaes 
	+ fixed-name aliases but they are named $u0, $u1, ...$u9 
    
    Use the r (Registers) command to define the alias equivalents for fixed-name aliases. 
    
	+ set and named automatic alaes 
	
- defining a user named alias, you can set alias to string in memory, number expression, contents of a file, value of an environment variable or output of one or more debugger command 

names are case sensitive 

redefine a user-named alias used as(set alias) or aS(set Alias) command 

- remove an alias 
ad(delete alias) command 

- list all alias 
al(list aliases) command 

- defining a fixed-named alias, there are 10 fixed-name aliases $u0...$u9. their alias equivalents can be any string that does not contain the ENTER keystroke. use r(registers) command to define the alias equivalent. 

when define a fixed-name alias, you must insert a period(.) before the letter "u". the text after the equal sign(=) is the alias equivalent. should not enclose alias equivalent in quotation marks unless you want quotation mark in result 

- automatic aliases 
$ntnsym, nt symbols on the computer's native architecture, equal either ntdll or nt 
$ntwsym, nt symbols during 32-bit debugging that uses wow64, could be ntdll32 or 
$ntsym, same as $ntnsym 
$CurrentDumpFile
$CurrentDumpPath 
$CurrentDumpArchiveFile 
$CurrentDumpArchivePath 


### Using script files 
- is a text file contain a sequence of debugger command 
- execute a script file 
	+ kd and cdb, create a script file named Ntsd.ini and put it in the directory where you are starting the debugger from. it will be automatic executed. use command line -cf to specify different startup file 
	
	+ use -cfr option 
	+ use the $<, $><, and $$>< command to execute a script file after debugger is running 
	
- supported commands 
You cannot use commands that are available only in WinDbg (such as .lsrcfix (Use Local Source Server), .lsrcpath (Set Local Source Path), .open (Open Source File), and .write_cmd_hist (Write Command History)) in script files, even if the script file is executed in WinDbg. In addition, you cannot use the .beep (Speaker Beep), .cls (Clear Screen), .hh (Open HTML Help File), .idle_cmd (Set Idle Command), .remote (Create Remote.exe Server), kernel-mode .restart (Restart Kernel Connection), user-mode .restart (Restart Target Application), or .wtitle (Set Window Title) commands in a script file

- you can only use .remote_exit command in script file that kd or cdb uses 


### Using debugger command programs 
#### Elements of a debugger command program 
- control flow tokens 
.if, .for and .while 

- use brace {} to enclose a bock of statement, bare pare of braces is not a block. it required a prefix flow control token. when enter a block all aliases with in the block are evaluated 

if you want to create a block only to evaluate aliaes, should use .block token 

- program can use user-named aliases or fixed-name aliaes. for numeric or typed variables, could use $tn pseudo-registers 

check the reference ###Pseduo-Register Syntax for more detail 

- user-named aliases are evaluated only if they are not next to other text. if you want to evaluate an alias that is next to other text, use the ${} (Alias interpreter) token. it support evaluate in variety of ways 

- add comments to a debugger command program which start with $$(comment specifier). 

- typically MASM syntax, when want to use c++ element use @@c++() token to switch to c++ syntax for that clause 

- the useful string operation tokens 
$scmp, $sicmp, $spat 

check the MASM numbers and operators for more detail 


#### Control flow tokens 
- the final command before a closing brace does not have to be followed by a semicolon 

- there is a individual reference for each tokens 
.if 
.else 
.elsif 
.foreach 
.for 
.while 
.break 
.do 
.continue 
.catch 
.leave is used to exit from .catch block 
.printf
.block, token performs no action 

- extensions tokens 
!for_each_module, !for_each_frame, !for_each_local 


#### execute a debugger command program 
- from debugger command window 
- write all the commands in a single line in a script file and execute with $<, $><, $$<, and $$>< commands 
$$><(run script file)


#### Debugger command program examples 
- .foreach
.foreach (place { s-[1]w 77000000 L?4000000 5a4d }) { dc place L8 } 

- walking the process list, save in a text file and execute with $$><(file-name)

	+ The $t0, $t1, and $t2 pseudo-registers are used as variables in this program. The program also uses aliases named Procc and $ImageName.

	+ This program uses the MASM expression evaluator. However, the @@c++( ) token appears one time. 

	+ The ? flag is used with the r (Registers) command. This flag assigns typed values to the pseudo-register $t2
	
	+ example 

$$  Get process list LIST_ENTRY in $t0.
r $t0 = nt!PsActiveProcessHead

$$  Iterate over all processes in list.
.for (r $t1 = poi(@$t0);
	  (@$t1 != 0) & (@$t1 != @$t0);
	  r $t1 = poi(@$t1))
{
	r? $t2 = #CONTAINING_RECORD(@$t1, nt!_EPROCESS, ActiveProcessLinks);
	as /x Procc @$t2

	$$  Get image name into $ImageName.
	as /ma $ImageName @@c++(&@$t2->ImageFileName[0])

	.block
	{
		.echo ${$ImageName} at ${Procc}
	}

	ad $ImageName
	ad Procc
}

- walking the LDR_DATA_TABLE_ENTRY list, will display full path of each list entry 

	+ user-named alias $Base and $Mod are used. The ${/v:} token interprets the alias literally preventing it from being replaced if it was defined before the script is run 
	
	+ .block is used to add extra lias replacement step. it is used to let .echo command recieve the value of $Mod and $Base 
	
	+ example 
$$ Get module list LIST_ENTRY in $t0.
r? $t0 = &@$peb->Ldr->InLoadOrderModuleList
 
$$ Iterate over all modules in list.
.for (r? $t1 = *(ntdll!_LDR_DATA_TABLE_ENTRY**)@$t0;
 (@$t1 != 0) & (@$t1 != @$t0);
	  r? $t1 = (ntdll!_LDR_DATA_TABLE_ENTRY*)@$t1->InLoadOrderLinks.Flink)
{
	$$ Get base address in $Base.
 as /x ${/v:$Base} @@c++(@$t1->DllBase)
 
 $$ Get full name into $Mod.
 as /msu ${/v:$Mod} @@c++(&@$t1->FullDllName)
 
 .block
	{
		.echo ${$Mod} at ${$Base}
	}
 
	ad ${/v:$Base}
	ad ${/v:$Mod}
}



## Using the windbg graphical interface 
- double click title to undock 
- drag and drop to position or window to dock 
...


### Using debugging information windows 
- windbg has ten kinds of debugging information windows, you can have only one instance of the following windows open at the same time 
	+ debugger command window 
	+ watch window 
	+ locals window 
	+ register window 
	+ calls window 
	+ disassembly window 
	+ processes and threads window 
	+ scratch pad 
	+ can display multiple source window and memory window at the same time 
	
    
### Opening a window 
- use accelerate key alt+1~9 to open the relative window 
command alt+1
watch alt+2 
locals alt+3
registers alt+4 
memory alt+5 
calls alt+6 
disassembly alt+7 
scratch pad alt+8 
processes and threads alt+9 
source window ctrl+O

- configuring a window, each debugging information window has a shortcut menu that you can access by right-click the title bar of the window or by clicking the icon near the upper-right corner of the title bar 
such as quick access to the relative help page 

- moving through a window 
some window support the find, go to address or go to line command they only change the windbg display but not affect the execution of the target 

	+ find command
	ctrl+f, enter the text you want to find 
	
	+ go to address 
	ctrl + g 
	when the view code offset dialog box appears enter the address that you want to search. debugger moves the cursor to the begging of the function or address in the disassembly window or a source window 
	
	+ moving a specific line, go to line command search for a line in the active source widnow, if the active window is not a source window you cannot use the go to line command. to active this option click go to line on the edit menu or press ctrl+L 

- changing text properties, setting the font, font style and font size. all debugging information windows hare the same font. click Font on the View menu 

change tab width by Options|View in the tab width enter the number of spaces 

- positioning the windows 
...


###Using workspaces 


####Using ThemesProvided in debugging tools 
- provided by debugging tools for window those themes are 
Standard.reg, 
Standardvs.reg, 
Srcdisassembly.reg, 
Multimon.reg, for multiple monitor 

#### Using the toolbar and status bar 
- toolbar 
- statusbar 
Message 
Ln, Col, line number and column number 
Sys, shows the internal decimal number of the system that you are debugging. 
Proc, internal decimal number of the process id 
Thrd, thread id 
ASM, current debugging mode, such as ASM. if it unavaliable then windbg is running in source mode 
OVR, if overtype is active or it is insert mode 
CAPS
NUM 
...

## Using Debugger Extension 
- VS, windbg, cdb, kd all allow the use of debugger extension commands. these commands are exposed by DLLs 

### Loading Debugger extension dll 
- set the default extension DLL location 
	+ use the environment variable _NT_DEBUGGER_EXTENSION_PATH, can be a number of directory paths separated by semicolons 
	
	+ .load command, .unload, unloadall 
	+ CDB only, use the tools.ini file to set the default extension dll 
	+ use -a command-line option 
	+ .extpath to set the extension search path 
	+ .setdll set default extension dll 
	+ .chain(list debugger extensions) display all the loaded debugger exntesion modules in their default search order
	
- load a extension dll by use the full !module.extension syntax to issue a command from that module 

- the extension dlls ship with the debugging tools for windows package are each placed in different subdirectory 
	+ winxp dir contain xp+ extensions 
	+ winext contains extension for any version of window. dbghelp.dll module located in the base directory of the debugging tools for windows 
	
### Using debugger extension commands 
- the extension command is similar to debugger commands with the syntax 
$ ![module.]extension [arguments]

the module name should not contain .dll. if module include full path then the limit is 255 characters .

if the module is not ready then it will be loaded with LoadLibrary(module). after that it call the GetProcAddress to locate the extension name in the module. The name is case-sensitive 

- search order. if module name is not specified, the search order is 
	+ the extension modules that work with all operating system and both Dbghelp.dll and winext\ext.dll 
	
	+ for kerl mode should use winext\kext.dll and user mode winext\uext.dll 
	+ both operating syste specific and mode-specific
	
- .setdll( set default extension dll) to promote any module to top of the search chain 
- .chain, display all loaded extension module 


### Writing new debugger extensions 
- there are two types of debugger extensions 
	+ DbgEng extensions, are based on the prototypes in the dbgeng.h and also those in the wdbgexts.h 
	
	+ WdbgExts extensions. based on the prototypes in the wdbgexts.h 
	

##Remote debugging 
## Debugging Previous versions of windows 
...
- debugging tools for window 7 and xp are included in the SDK for window 7 and .net framework 4.0
...

# Debugging Techniques 
## Standard debugging techniques 
### Using Breakpoints 
- specify location of a breakpoint by virtal address. if you put a breakpoint on a routine without offset then it active when that routine is entered 

	+ a breakpoint can associated with a certain thread 
	+ a breakpoint can enable a fixed number of passes through an address before it is triggered 
	+ can automatically issue certain command when it trigger 
	+ can set on non-executable memory and watch for that location to be read or written to 
	
- if you are debugging more than one process in user mode the collection of breakpoints depends on the current process. to view break points you need to select the process as current process. To control the process by #Controlling process and threads 

- commands for controlling and displaying breakpoints 
bl, breakpoint list and status 
.bpcmds, display breakpoint commands to list all breakpoints along with the commands that were used to create them 
bp, set breakpoint 
bu, set unresolved breakpoint 
bm, set symbol breakpoint set new breakpoints on symbols that match a specified pattern 
ba, break on access, set a processor breakpoint, also known as data breakpoint can be triggered when the memeory location is written to 
bc, permanently remove one or more breakpoints 
bd, disable 
be, enable 
br, renumber to change the id of an existing breakpoint 
bs, udpate breakpoint change the command associated with an existing breakpoint 
bsc, update conditional breakpoint to change the condition under which an existing conditional breakpoint occurs 

- each breakpoint have a decimal id 
- include a command in a breakpoint that is automatically executed 
$ bu MyFunction+0x47 ".dump c:\bpdump.dmp; g"

this command will break at myFunction+0x47 and writes a dump file and resume execute 

if use kernel mode debugger control a user-mode debugger then don't use the g command in the breakpoint command string 

- kerl mode maximum of breakpoints number is 32 
- processor breakpoints is depends on the target processor arhictecture 

### Breakpoint Syntax 
- address in breakpoints to set breakpoint 
$ bp 0040108c 
$ bp main+5c 
$ bp `source.c:31`

- breakpoints on methods, put breakpoint on the method in myClass in two way 
	+ in MASM expression syntax indicate a method by a double colon or a double underscore 
	$ bp MyClass::MyMethod 
	$ bp MyClass__MyMethod 
	
	+ C++ expression syntax must indicate a method by double colon 
	$ bp @@(MyClass::MyMethod)
	
- check #Evaluating expresion for more detail 
- breakpionts using compilcated text 
	+ set a breakpoint on complicated functions, including functions that contain spaces, as well as member of a C++ public class. enclose the expresion in parenthese 
	$ bp(??MyPublic) 
	$ bp(Operator new)
	
	+ more versatile technique is to use @!"chars" syntax, in MASM evaluator that enables you to provide the arbitrary text for symbol resolution. Must start three symbols @!" and end with a quotation mark ("). Without this you cannot use spaces angle bracktes or other special characters in symbol names in MASM.
	also set the bu command by using the @!"chars" syntax 
	
	$ bu @!"ExecutableName!std::pair<unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> > >::operator="

	ExecutableName is the executable file. this escape synatx is more useful for c++ and managed code 
	
	+ set a breakpoint on arbitrary text in c++ syntax use 
	$ bu @@c++(text) 
	
- breakpoint in scripts. use a numerical expression that resolves to an integer that corresponds to a breakpoint id 
$ b?[Expression]

the square brackets are required, this synatx allow debugger scripts programmically select a breakpoint for example breakpoint is depending on the value of a user-defined pseudo-register 
$ b?[@$t0]


### Unresolved Breakpoints(bu breakpoints)
- a breakpoint is set for a routine name that has not been loaded, the breakpoint is called a deferred, virtual or unresolved breakpoint. Every time a new application is loaded it checked for this routine name if this routine appear, debugger computes the actual coded addres of the virtal breakpoint and enables the breakpoint 

- module unloaded and reloaded not effect the bu breakpoint on the other handle bp breakpoint is immediately resolved to an address 

- three primary differences between bp and bu breakpoints 
	+ bp is always converted to an address. bu breakpoint assocaited with symbolic value 
	+ bp breakpoint address is found in a loaded module if the module unloaded then the breakpoint is removed. bu breakpoint will persist 
	+ bp breakpoint are not saved in windbg workspace. bu are saved 
	
- address breakpoint could be set by bp or bm(set symbol breakpoint) when /d switch is included. 
- unresolved breakpoint can be set by bu or bm command which not used with /d swith 
- command display breakpoint is include all breakpoints 
- Windbg Breakpoints dialog display all breakpoint and indicate unresolved with "u". when using the mose in the windbg to Disassemlby window or Source Window the debugger creates an unresolved breakpoint 

### Processor breakpoint 
- controlled by the processor at the request of debugger. known as processor breakpoint and data breakpoint. Breakpoints are controlled by debugger is known as software breakpoint 

processor breakpoints are usually set on program data this the reason they are called "data breakpoint" but they can also be set on executable code 

software breakpoint are usually set on executable code 

- processor breakpoint is triggered when specific memory location is accessed. four types of processor breakpoints 
	+ e, trigger when retrieves an instruction from a specific address 
	+ r, read/write specify address 
	+ w, write specify address 
	+ i(i/o), when I/O port at the specified address is accessed 
	
- each processor breakpoint has a size associated with it. a w(write) breakpoint could be set at the address 0x70001008 with a size of four bytes. this would monitor the address from 0x70001008 to 0x7000100B, inclusive. 

when a processor perform a operation on a memory region, which overlap with the processor breakpoint then check the processor architecture manual for "debug register" or "debug control register" for more detail 

x86 processor it will be triggered 

a e(execute) breakpoint is set on address 0x00401003 then a two-byte instruction spanning the address check the processor manual 

processor distinguishes between user-mode breakpoint and kernel mode breakpoint. a kernel-mode breakpoint might or might not affect a user-mode process, depending on whether the user-mode code is using the debug register state 

on multiprocessor computer, processor breakpoint applies to all processors. use the .apply_dbp(apply data breakpoint to context)

- software breakpoint. when the debugger sets a software breakpoint it temporarily replaces the content of that memory location with a break instruction. the debugger remembers the original contents of this location 

- availability of processor breakpoint types 

window server 2003 sp1 on an itanium-based computer that use wow64 to emulate x86. e breakpoint do not work

i(i/o) is available only during kernel-model debugging 

not all data sizes can be used with all processor breakpoint types. the permitted sizes depend on the processor of the target computer. check #break on access for more detail 

- limitation of software breakpoint and processor breakpoint 
	+ specify a data address rather than a program address when using bp or bm /a commands it only safe when you are certain that will be only used as executable code or may lead to data corruption 
	
	+ bp, bu and bm commands set software breakpoint by replacing the processor instruction with a break instruction. these cannot be used in read-only code. to set a breakpoint in such code required to se ba(break on access) with e option 
	
	+ cannot create multiple processor breakpoint at the same address that differ only in the command that is automatically executed when the breakpoint is triggered. can create multiple breakpoints at same address that differ only their other restriction ba /p /t /c /C options 
	
	+ initial bereakpoint in a user-mode cannot be a processor breakpoint 
- controlling software breakpoint and processor breakpoint 
	+ software can be created with bp, bm and bu 
	
	+ processor breakpoint can be created by ba 
	
    
### Initial breakpoint 
- when debugger starts a new target application, an initial breakpoint automatically occurs after the main image and all statically linked DLLs are loaded before any DLL initialization routines are called 

when debugger attaches to an existing user-mode application, an initial breakpoint occurs immedaitely

the -g command-line option cause the windbg or CDB to ignore the initial breakpoint. 

to stop on actual application about to begin use set breakpoint on main or winmain routine and then use g command 

### User space and system space 
- window gives each user-mode application a block of virtual addresses this known as the user space of that application. The other large block of address known as system space or kernel space. it cannot be access by the application 

in kernel mode you can set breakpoint in user space with bp, bu and ba or with Breakpoint dialog box. But you must use the process context to specify the user-mode process that owns that address space by using .process /i 

breakpoint in user space are alwasy associated with the process whose process context was active when the breakpoint were set. if you both started user-mode and kernel mode debugging it will first break into user-mode debugger. use .breakin command to transfer the control to kernel mode debugger 

- determining the range of user space and system space. use dp(display memory) command from a kernel debugger to display the window global variable MmHighestUserAddress. this variable contain the address of the top of user space 

kd$ dp nt!mmhighestuseraddress L1 

### Risks Entailed When Setting Breakpoints 
- how the debugger creates breakpoints:

The debugger saves the contents of 0x770000F5 and overwrites this memory with a breakpoint instruction.

If you try to display this memory in the debugger, the debugger does not show the breakpoint instruction that it has written. Instead, the debugger shows the memory that "should" be there. That is, the debugger shows the original memory, or any modifications to that memory that you have made since inserting the breakpoint.

If you use the BC command to remove the breakpoint, the debugger restores the original memory to its proper location.

When you put a breakpoint at 0x770000F5, the debugger saves this byte and a break instruction is written here. However, when the application runs, it reaches the 0x770000F4 address and recognizes this address as the first byte of a multibyte instruction. The processor then tries to combine 0x770000F4, 0x770000F5, and possibly some later bytes into a single instruction. This combination can create a variety of behaviors, none of which are desirable.


- when setting a breakpoint by specify a memory address or a symbol plus an offset, you must not put this breakpoint in the middle of an instruction. 
	+ example 
 
770000f1 5e			   pop	 esi
770000f2 5b			   pop	 ebx
770000f3 c9			   leave
770000f4 c21000		   ret	 0x10
770000f7 837ddc00		 cmp	 dword ptr [ebp-0x24],0x0
 
if put a breakpoint by bp, bu or ba command you must specify the 0x770000F4 address 

if you put a breakpoint in 0x770000F5 by ba command the processor puts a breakpoint at that location but it will never be triggered because the processor consider the 0x770000F4 to be the actual address of the instruction 

if you put a breakpoint in the 0x770000F5 by bp or bu command the debugger writes a breakpoint at that location. however this breakpoint might corrupt the target. because when processor execute to that address and try to combine the instruction will use the wrong data which already replaced by the debugger 

when use bp, bu or ba make sure always put the breakpoints at the proper address. If use the userinterface you don't have to worry this. 


### Conditional breakpoints in Windbg and other window debuggers 
- break in only if a specify condition is satisfied 

condition breakpoint is created by combining a breakpoint with either the j(Execute If-Else) command or the .if token, followed by the gc(Go from conditional breakpoint)

	+ syntax 
$ bp address "j (condition) 'optionalCommands'; 'gc'"

$ bp address ".if(condition){OptionalCommands} .else {gc}"
$ bp `mysource.cpp:143` ".if (poi(MyVar)>0n20) {} .else {gc}"

specify source line number by grave accents(`)

when breakpoint hit the command in straight quotation marks(") is executed 

in C++ expression MyVar is treat as integer. in MASM expression the MyVar is treat as an address. thus you need to use the poi operator to dereference it.(if your variable is a c pointer then you need to dereference it twice. poi(poi(MyPtr))

0n prefix means the variable is decimal 

gc(go for conditional breakpoint) command this will resume before the breakpoint was hit 

- conditional breakpoint based on string comparison 
$ bp kernel32!CreateEventW "$$<c:\\commands.txt"

the bp command create a conditional breakpoint base on the script file 

script file content 
 
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }
 
this will check the argument lpName of the function CreateEventW 

The lpName argument passed to the CreateEventW is the fourth argument, so ti stored in the r9 register(x64 processor). the script performs the following steps 

If lpName is not NULL, use as and ${} to create an alias named EventName. Assign to EventName the null-terminated Unicode string beginning at the address pointed to lpName. if lpName is null then use ad to delete existing alias named EventName

use $spat to compare the string by EventName and pattern "Global*", $spat is a case insenstive match 

- conditional breakpoints and register sign extension. set a breakpoint that is conditional on a register value 

	+ break a the myFunction if eax register is equal to 0xA3 
 
0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"
 
	+ these commands will not works 
 
0:000> bp mydriver!myFunction "j @eax = 0xc0004321  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xc0004321  {} .else {gc}"
 
the reason is the preceding command will fail is that MASM expression sign-extends registers whose high bit equals one. When eax have the value 0xC0004321. it will be treated as 0xFFFFFFFF`C0004321 in computations. even though eax will still be displayed as 0xC0004321. It is signed extended in kernel mode not in user mode. Therefore the preceding command will not work properly in user mode. if you mask the high bit of eax the command will work properly in kernel mode -- but will fail in user-mode 
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010 A 
1011 B 
1100 C 
1101 D 
1110 E 
1111 F 

you should formulate your commands defensively against sign extension in both modes. use mask AND with 32-bit register 
 
0:000> bp mydriver!myFunction "j (@eax & 0x0`ffffffff) = 0x0`c0004321  '';'gc'" 
0:000> bp mydriver!myFunction ".if (@eax & 0x0`ffffffff) = 0x0`c0004321  {} .else {gc}"
 
- condition breakpoint in windbg by menu Edit|Breakpoints and enter the condition 

    + set a alias 
    + reuse the alias and test with string comparison 

.if(${/d:prop}){ad ${/v:prop};};as /ma ${/v:prop} @@c++(&((*(name.ptr))->d.inlineStorageLatin1));.if($spat(@"${prop}", "document") == 1){.echo ok};ad *;

cmd 
bp bp xul!js::LookupName+0x1b "$$<c:\\commands.txt"
 
//in commands.txt  
 .if(${/d:prop}){ad ${/v:prop};};as /ma ${/v:prop} @@c++(&((*(name.ptr))->d.inlineStorageLatin1));.if($spat(@"${prop}", "addEventListener") == 1){.echo access addEventListener;}.else{ad *; gc;}

- restriction on conditional breakpoints if you are controlling user-mode debugger from kernel mode debugger, you cannot use conditional breakpoints or any other breakpoint commands contain gc or g commands. if you use then the interface might not be abel to keep uo and you will unable to breakback into CDB 


### Executing Unitl a specified state is reached 
- using a breakpoint to control execution. more complex breakpoint can 
	+ trigger on when this address is executed by a specific thread 
	+ allow a specified number of passes through this address before being triggered 
	+ automatically issue a specified command when it is triggered 
	+ watch a specified address in non-executable memory, being triggered when that memory is read or written to 
	
- breakpoints and Pseudo-Registers use $thread pseudo-register which is always equal to the current thread. 

	+  create a breakpoint that will be triggered every time that NtOpenFile is called by the thread which was active at the time you issued the bp command:

kd>bp /t @$thread nt!ntopenfile 

check more detail from the #Pseudo-Registers

- Using a script file to control execution. a script file that calls itself recursively, testing the desired state in each iteration. use command such as t(trace) to execute a single step 
	+ execute until eax contains the value 0x1234, script file is called eaxstep 
	.if (@eax == 1234) { .echo 1234 } .else { t "$<eaxstep" }

	issue the command from debugger command window 
	$ t "$<eaxstep"
	
this t command will execute a single step and then execute the quoted command. $< (run script file)


## Writing new debugging extensions 
- check detail from #Writing DbgEng Extensions and #Writing WdbgExts Extensions
...


## Reading and Writing Memory 
- memory can be referenced by adddresses or by the names of variables 

### Accessing Memory by virtual address 
- variable format 
hexadecimal bytes 
word 
double words 
quad-words 
integers(short, long, quad integers and unsinged integers)
floating-point numbers(10-byte, 16-byte, 32-byte and 64-byte real number)
ascii characters 

- commands 
d*, display memory command displays the contents of a specified memory address or rage 
e*, enter values command

- specific data type 
dt, display type, contain highly versatile and options 
ds, display string 
dl, display linked list 
d*s, display words and symbols finds double-words or quad-words that might contain symbol information 
!address, extension command displays information about the property of the memory that is located at specific address 

- manipulate memory ranges 
m, move memory 
f, fill memory 
c, compare memory 
s, search memory 
.holdmem, hold and compare memory 

- most of the time the commands interpret their parameters in current radix 

memory window display integers and real numbers in decimal format and display other formats in hexadecimal format 

use n command to change default radix 
convert numbers use ?(evaluate expression) to convert or .formats(show number formats) command 

user mode debugging the virtual address is control by the current process. 
kernel mode debugging the virtal address is control by debugger 

### Accessing memory by physical address 
- read from a physical address by 
!db, !dc, !dd, !dp, !du and !dw extesion command 

- write to 
!eb, !ed 

- fp command wrtes a pattern to a physical memory range, repeating till the range is full 

when using windbg in kernel mode, can access physical memory directly from memory window 

- search physical memory by 
!search 

- more detail check #converting virtual address to physical address 


### Accessing global variable 
- The name of global variables are stored in the symbol files that are created when an application is compiled. The debugger interpret the as a virtual address 

use ?(evaluate expression) command to display the address that is associated with any symbol 

- obtain variable address and display by 
 
0:000> ? MyCounter 
Evaluate expression: 1244892 = 0012fedc
0:000> dd 0x0012fedc L1 
0012fedc  00000052
 
1244892 is the decimal version of the address 
the second command display the value 0x52 which is decimal 82 

- accessing local variables. similar to global variable but to indicate to a command a variable is local which need to precede the symbol with a dollar sign($) and an exclamation point(!) as in $!var 

- editing local variables 
	+ VS or windbg supply different ways 
	+ dv(display local variables) will display the names and values of all local variables 
	+ !for_each_local extension enables you to execute a single command repeatedly 

- debugger interprete the local variables base on the local context. By default this context matches the location of the program counter. But debugger could change the context 


### Controlling variables throught the watch window 
- the watch window is not effect by change the local context. only those variables that are defined in the scope of the current program counter can have their values displayed or modified 


### Converting virtual address to physical addresses 
- there are two ways 
	+ !vtop extension 
	+ !pte extension 
	
- suppose you are debugging a target computer ang want to investigate virtual address 0x0012F980 here is the process to use !vtop to find the physical address  
	+ make sure workin in hexadecimal else use command 
	$ n 16 
	
	+ determine the byte index of the address. it is equal to the lowest 12 bits of the virtual address so it is 0x980 
	
	+ determine the directory base of the address by using the !process extension 
	kd> !process 0 0 
	**** NT ACTIVE PROCESS DUMP ****
	....
	PROCESS ff779190  SessionId: 0  Cid: 04fc	Peb: 7ffdf000  ParentCid: 0394
	 DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8.
	  Image: MyApp.exe
	+ determine the page frame number of the directory base 0x098fd000 so the page frame number is 0x98FD
	+ use the !vtop extension the first parameter should be the frame number and the second is the virtual address in question 
	kd> !vtop 98fd 12f980
	Pdi 0 Pti 12f
	0012f980 09de9000 pfn(09de9)

	the last line display the beginning address of the physical page 
	
	!d* extension display memory at a specified physical address 
	kd> !dc 9de9980
	
	d* (display memory) commands uses a virtual address as its argument 
	kd> dc 12f980 
	
	these two command will get the same address 
	
- converting a virtual address to a physical address using !pte 
	+ work on 16 radex 
	+ determine the by index, which is 0x980 
	+ set process context to the desire process 
	kd> !process 0 0 
	**** NT ACTIVE PROCESS DUMP ****
	....
	PROCESS ff779190  SessionId: 0  Cid: 04fc	Peb: 7ffdf000  ParentCid: 0394
		DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8.
		Image: MyApp.exe
	
	kd> .process /p ff779190 
	
	+ use the !pte extension with the virtual address as its argument. PDE, page directory entry, PTE page table entry 
	kd> !pte 12f980
				   VA 0012f980
	PDE at   C0300000		PTE at C00004BC
	contains 0BA58067	  contains 09DE9067
	pfn ba58 ---DA--UWV	pfn 9de9 ---DA--UWV
	
	look in the last row of the right column the notation pnf 9de9. 0x9de9 is the page frame number (PFN) of this PTE. multiple the frame number by 0x1000(shift it left 12 bits). the result 0x09de9000 is the physical address of the beginning of the page 
	
	+ add the byte index to the address 0x09de9000 + 0x980 = 0x9de9980 is the desired physical address 
	
- converting addresses by hand
...

### Using the !analyze extension 
- the first step in debugging a crashed target computer or application is to use the !analyze extension command. use -v option for display more 

- contain topics 
	+ use-mode !analyze -v 
	+ kernel-mode !analyze -v 
	+ followup field and the triage.ini file 
	+ addtional !analyze the techniques 
	
- use-mode !analyze -v 
	+ the displayed exception information could also be found by command .exr(display exception record)

	+ stack command field shows the command that was used to obtain the STACK_TEXT. you can use this command to repeat this stack 
	STACK_COMMAND:  .ecxr ; kb

- kernel-mode 
	+ IRQL, interrupt request level 
	
	+ .trap(display trap frame) command 
	
	+ Ln (list nearest symbols) command to determine what module and function these address reside in 
	
- followup field and the triage.ini file contains the module name and function owners check #Specifying Module and Function Owners for more detail 

- addtional !analyze techniques 
if you do not believe the bug id is correct, you can override the bucket choice by using !analyze with -D 
use !analyze -f to force complete in crash 

if you think the problem is due to hang you could use !analyze -hang to check if there are any threads are blocking other threads 

use command !deadlock extension for deteck in kernel mode 

automatic ignore issues by supply a xml file containing in a formatted list of known issues 
!analyze -c - loadKnownIssuesFile extension to load this file 


### Handling a bug check when driver verifier is enabled 
- driver verifier detects driver errors at run time
...

### Noinvasive debugging(user mode)
- if a user-mode application is already running, the debugger can debug it noninvasively. noninvasive debugging is useful if the target application has stopped responding. 

- noninvasive debugging, the debugger doesn't attach to the arget application but it suspended all the thread of the target and then access to the target's memory, registers and other such information. however debugger cannot control the target so command like go do not work 

- CDB command line 
$ cdb -pv -p ProcessId 
$ cdb -pv -pn ProcessName 

- windbg command line 
$ windbg -pv -p ProcessID 


### Debugging in assembly mode 
- the debugger will automatically displays the contents of memory locations and registers as they are accessed and the address of the program counter 

- disassembly code 
u, unassemble disassembles and displays a specified section of machine language 
uf, unassemble function, disassemble a function 
up, unassemble from physical memory of a specified section 
ur, unassemlbe real mode BIOS, command disassembles and displays a specified 16-bit real-mode code 
ux, unassemble x86 BIOS the x86-based BIOS code instruction set a specified address 
Disassembly window, windbg only 

- example 
0040116b	45		  inc		 ebp			
0040116c	fc		  cld						
0040116d	8945b0	  mov		 eax,[ebp-0x1c] 

if a line contain a branch instruction the notation [br=1] or [br=0] to indicate the is taken or not 

- manipulate assembly code 
	+ #(search for disassembly pattern command) this command is equivalent to searching the four columns of the disassembly display 
	+ a(assemble) command can take assembly instructions and translate them into binary machine code 
	
- assembly mode and source mode. single-stpping through an application the size of a step is depend on the mode, which is one line of assembly or one line of source 

change the mode by 
	+ l+, l- set source options commands to control the mode the l-t command activates assembly mode 
	+ clear the source mode command on debug menu (windbg only )
	
- if your application was written in assembly the disassembly might not exactly match your code. can load the source to switch to source mode debugging 

### Debugging in source mode 
- compilation requirements, you must have compiler or linker create symbols(.pdb files). Prevent source optimization for debugging by 
MSC_OPTIMIZATION marco to /Od /Oi to avoid optimization 

- locating the symbol files and source files 

- source debugging, need setup symbols and source path. 
	+ you app started, ntdll.dll load your application 
	+ your code start point 
	$ bp main 
	to set a breakpoint in main 
	
	+ if you issue a break by using the ctrl+c, ctrl+break or debug|break the debugger creates a new thread so ou cannot see your source code 
	
- source debugging in the windbg gui 

support hover a symbol to evaluate 

active source mode in windbg by command l+t command, click Source Mode on debug menu or the toolbar 

- source debugging in debugger command window 
.lines command toggle source line support or start the debugger use command-line option 

l+t command to performed one source line at a time 
l+t to setp one assembly instruction 
l+s command display the current source line 
l+l, only see the line number 
l+o 
lsp, set number of source lines 
ENTER repeat the last command 
	+ example 
$ l+s 
$ l+t 

- source lines and offsets 
	+ display memory offset 
$ ? `[[module!]filename][:linenumber]`

	+ also could use it to set breakpiont in source 
	
- stepping and tracing in source mode 
p command will step over a nested single line such as 
print("%x\n", GetTickCount();

to step over certain calls while tracing into other calls use .setp_filter(set step filter) to indicate which calls to step over. 
can use _step_filter to filter out framework functions such as MFC, ATL 

### Debugging optimized code and inline functions 
- window 8+ support debug optimized code and inline function. debugger display inline functions in the call stack inline function only displays local varibles but not parameters 

- accurate display of local variables and paramters 
use dv -v command to see the locations of the paramters and local variables 

x command to list all the caller sites of the inline function 

use .frame command to check the inline function meory status 

- display local structures 
C++ 
0:000> dt My1

use k to check stack 

If you look at frame 1 in the stack trace, you can see the local variables for the main function. Notice that two of the variables are stored in registers.

Because the Windows debugger can enumerate all the caller sites of an inline function, it can set a breakpoints inside the inline function by calculating the offsets from the caller sites. You can use the bm command (which is used to set breakpoints that match regular expression patterns) to set breakpoints for inline functions


### debugging managed code using the windows debugger 
- windbg, cdb and ntsd to debugger managed code required sos debugging extension sos.dll and a data access component(mscordacwks.dll)

- the version of filename of CLR used by .net framework 
.net version			CLR version		 CLR filename 
1.10					1.1				 mscorwks.dll 
2.0					 2.0				 mscorwks.dll 
3.0					 2.0				 mscorwks.dll 
3.5					 2.0				 mscorwks.dll 
4.0					 4.0				 clr.dll 
4.5					 4.0				 clr.dll 

- debugging managed code must load two components 
	+ DAC, data access component, mscordacwks.dll 
	+ SOS debugging extension, sos.dll, it is contain in the .net framework installation location, .net 1.x required window sdk 7 
	
	+ assume debugger running on the same computer with the target 
	$ .cordll -ve -u -l 
	to load DAC 
	
	display module information 
	lmv mclr 
	lmv mscorwks 
	
	if sos.dll doesn't load automatcally required to use command 
	$ .loadby sos clr (4.0+)
	$ .loadby sos mscorwks(1.0 - 2.0)
	
	http://go.microsoft.com/fwlink/?LinkID=223345
	
	alternatively can use 
	$ .load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\sos.dll

	+ using MS public symbol server 
	.sympath+srv* (add symbol server to symbol path)
	!sym noisy 
	.cordll -ve -u -l 
	
- using SOS debugging extension 
.chain command 

!sos.help, test sos debugging extension 
sos.DumpDomain 
!sos.Threads command 

### Debugging windows store apps using the windows debugger 
- use PLMDebug tool to suspending, resuming and terminating a window store app 

### Changing contexts 
- in kernel mode the virtual address and register name eax content are ambiguous. we need specify the context in which such phrases can be understood 

- debugger have five different contexts that you can set while your debugging 
	+ the session context indicates the default user session 
	+ the process context determines how the debugger interprets virtual addresses 
	+ user-mode address context is a almost never set directly. it is automatically set when you change process context 
	+ the register context determines how the debugger interprets registers and also controls the results of a stack trace. this context is also known as the thread context. if you specify an explicit conext that is used instead of the current register context 
	+ the local context determine how the debugger interprets the local variables. This context is also known as the scope 
	
- session context from window xp+ each multiple logon sessions can run at the same time, each logon session has its own processes. 

!session, to display all logon sessions or changes the current session context 

session context is used by the !sprocess and !spoolused extensions when the session number is entered as "-2"

when session context changed then process context is automatically changed 

- process context, each process has its own page directory that records how virtual addresses are mapped to physical addresses. when any thread within a process is executing the OS use this page directory to interpret virtual address 

kernel mode debugging change process context by 
.process command 

on an Itanium-based processor, a single process might have more than one page directory, then could use .context command to swith the address context 

- register context, each thread has its own register values. in user-mode debugging the current thread typically determines the register context 

.cxr, display context record 
.ecxr, display exception context record 

- kernel mode debugging you can control the register context by using a variety of debugger commands 
.thread 
.cxr 
.trap( display trap frame)

- change processor mode by command . to make sure current processor mode setting is match the debug register context 
.effmach

- local context, use .frame(set local context) command or double-click the desired frame in the calls window 

in use mode debugging the local context is always a frame within the stack trace of the current thread 
in kernel mode debugging the local context is always a frame within the stack trace of the current register context's thread 

local context is reset if any events occur 
	+ any program execution stepping or tracing 
	+ thread delimiter (~) in any command 
	+ any change to the register context 
	
!for_each_frame extension enables you to execute a single command repeatedly 

### Controlling processes and threads 
- the current process is the debugger is currently controlling, the current thread is the one that was active when the debugger attached to the process or caused the exception 

- in kernel mode required to use changed context to switch process 

- display processes and threads 
|, process status 
~, thread status 
processa and thread window 

- change the current process 
|s, set current process command 
~s, set current thread command 
process and thread window in wndbg 

- freezing and suspending threads 
each thread has a suspend count that is associated with it. if this count is one or larger then system does not run the thread. if the count is zero or lower the system runs when appropriate 

	+ when the debugger attaches to a process, it increments the suspend counts of all threads in that process by one 
	+ when detach it decrement all suspend counts by one 
	
	+ control the suspend count of any thread from the debugger by using the following methods 
	~n, suspend thread increments the specified thread's suspend count by one 
	~m, resume thread, command decrements the specified thread's suspend count by one 
	
	+ debugger can also freeze a thread, this action is similar to suspend the thread in some ways. "frozen" is a debugger setting. nothing relative to window OS. 
	
	by default all threads are unfronzen. when debugger cause a process to execute the threads are fronzen do not execute. if debugger detaches then all threads unfreeze 
	
	freeze by 
	~f, freeze thread 
	~u, unfreeze thread 
	
- threads and processes in other commands 
~e, thread specific command qualifier before many commands and exetension commands 

	+ example 
~*e !gle 
repeats the !gle extension command for every thread that is being debugged.


### Using debugger markup language, DML 
- lmD command is an example of a command that is capable of providing DML output. 

the module name is a link that you can click to get more detailed information 

- DML defines a small set of tags that can be included in command output. one example is the <link> tag. you can experiment with the <link> tag and other DML tags by using the .dml_start and .browse commands 
$ .browse .dml_start filepath 
executes the commands stored in a DML file. the output is displayed in the Command Browser Window instead of command window 

	+ example 
//suppose the c:\dml.txt contains the following lines 
cmd 
My DML Experiment
<link cmd="lmD musb*">List modules that begin with usb.</link>
 
//the following command display the text and link in the command browser window 
cmd 
.browse .dml_start c:\DmlExperiment.txt
 
- capable of generating DML output 
.dml_start 
.dml_flow 
!dml_proc 
lmD 
kM 
.chain /D 
.help /D 
.printf /D 

the .perfer_dml commands turns DML on or off. when DML is turned on commands that are capable of generating DML output will generate DML output by default 

start from window 10 the right click behavior is available in DML. 
 
<link cmd="u MyProgram!memcpy">
<altlink name="Set Breakpoint (bp)" cmd="bp MyProgram!memcpy" />
u MyProgram!memcpy
</link>


### Controlling Exceptions and Events 
- check more from #Enabling Postmortem Debugging 
- resume executing by 
gh or gn 

- kernel-mode exceptions, exceptions that occur in kernel-mode code are more serious than user-mode exceptions. if kernel-mode exceptions are not handled, a bug check is issued and the system stops 

if a kernel-mode debugger is attached to the system the debugger is notified before the blue screen 

- controlling exceptions and events from the debugger 
	+ the event can cause a break into the debugger as soon as it occurs
	+ event can break in after other error handlers have been given an opportunity to respond (second chance)
	+ event can also send the debugger a message but continue executing 
	+ debug can ignore the event 
	
- control break status and handling status by 
SXE, SXD, SXN, or SXI command in the debugger command window 
-x, -xe, -xd, -xn, or -xi option in CDB command line 
sxe or sxd keyword in tools.ini file CDB only 
click event filters on the debug menu to open the event filters dialog 

for the SX*, -x*, sx* you can add the -h option to cause the handling status to be set instead 

- display the most recent exception or event by 
.lastevent 

- controlling break status, the value in the brackets is the default value 
SXE,-xe; break (enable )

SXD, -xd; second change break (disabled)

SXN, -xn; output notify (notify)

SXI, -xi	ignore 

- controling the handling status, all events are considered unhandled unless you use the gh command, all exception are consider unhandled unless you use the sx* command toghether with -h options 

check full list of event by #Event Definitions and Defaults section 

when you use the SX* command on cc, hc, bpec and ssec events, or when use SX* command with -h option on an exception the following action occur

Command	 Status name		 Description 
SXE		 handled			 event is considered handled when resume 
SXD,SXN, SXI not handled 

- automatic commands, use command string can contain multiple commands that are separated with semicolons 

the command string can end with, g, gh, gn 

gn go with exception not handled 
gh, go with exception handled 

- Event definitions and defaults, if you change the default handling status handled will effect all the exception-handling routines 

Event code	  meaning					 default break status 
asrt			assert failure			  break 
av			  access violation 
dm			  data misalighed 
dz			  integer division by zero 
c000008e		floating point division by zero 
eh			  C++ EH exception 
gp			  Guard page violation 
ii			  illegal instruction 
iov			 integer overflow 
ip			  in-page i/o error 
isc			 invalid system call 
isq			 invalid lock sequence 
sbo			 stack buffer overlfow 
wkd			 wake debugger 
aph			 application hang  the app is stop reponding 
3c			  child application termination 
chhc			invalid handle 
Number		  any numbered exception 

	+ exceptions which are used to communicate with the debugger 
dbce, special debugger command exception 
vcpp, sepcial visual c++ exception 
wos, wow64 single step exception 
wob, wow64 breakpoint exception 
ssessec, single step exception 
bpebpec, breakpoint exception 
ccecc, ctrl+c or ctrl+break 

An application can use DBG_COMMAND_EXCEPTION (dbce) to communicate with the debugger. 

	+ exception for debugging manage code 
clr, common language runtime exception 
clrn, common language runtime notification exception 

	+ support change break status of the following events 
ser, system error 
cpr[:Process], process creation 
epr[:Process], process exit 
ct, thread creation 
ld[:Module], load module 
ud[:Module], unload module 
out[:Output], target application output 
ibp, initial breakpoint 
iml, inital module load (kernel only)


### Finding the process id 
- several ways to find a process id 
tasklist 
tlist 
debugger 
task manager 

- debugger command 
.tlist 

- csrss and user-mode drivers, client server run-time subsystem process(CSRSS) #debugging CSRSS 


### Debugging a stackoverflow 
- use-mode threads can encounter, three possible causes 
	+ a thread uses the entire stack reserved for it, often cause by infinite recursion 
	+ a thread cannot extend the stack because out run out page file 
	+ a thread cannot extend the stack because the system is within the brief period used to extend the page file 
	
- the variable layout in the stack is base on the setting of compiler, debug/release will have different optimization

- check the event cause the debugger to break in by 
$ .lastevent 
Last event: Exception C00000FD, second chance 

the exception code could be found out in the ntstatus.h 

- display the call stack 
$ k 
ChildEBP RetAddr
009fdd0c 71a32520 COMCTL32!_chkstk+0x25
009fde78 77cf8290 COMCTL32!ListView_WndProc+0x4c4
009fde98 77cfd634 USER32!_InternalCallWinProc+0x18
009fdf00 77cd55e9 USER32!UserCallWinProcCheckWow+0x17f
009fdf3c 77cd63b2 USER32!SendMessageWorker+0x4a3
009fdf5c 71a45b30 USER32!SendMessageW+0x44
009fdfec 71a45bb0 COMCTL32!CCSendNotify+0xc0e
009fdffc 71a1d688 COMCTL32!CICustomDrawNotify+0x2a
009fe074 71a1db30 COMCTL32!Header_Draw+0x63
009fe0d0 71a1f196 COMCTL32!Header_OnPaint+0x3f
009fe128 77cf8290 COMCTL32!Header_WndProc+0x4e2
009fe148 77cfd634 USER32!_InternalCallWinProc+0x18
009fe1b0 77cd4490 USER32!UserCallWinProcCheckWow+0x17f
009fe1d8 77cd46c8 USER32!DispatchClientMessage+0x31
009fe200 77f7bb3f USER32!__fnDWORD+0x22
009fe220 77cd445e ntdll!_KiUserCallbackDispatcher+0x13
009fe27c 77cfd634 USER32!DispatchMessageWorker+0x3bc
009fe2e4 009fe4a8 USER32!UserCallWinProcCheckWow+0x17f
00000000 00000000 0x9fe4a8 

The target thread has broken into COMCTL32!_chkstk which indicate a stack problem 

investigate the relative threads by 
$ ~*k 
   0  id: 570.574   Suspend: 1 Teb 7ffde000 Unfrozen
   .....

   1  id: 570.590   Suspend: 1 Teb 7ffdd000 Unfrozen
   .....
   
stack information is contained in the TEB(thread, environment block) at 0x7ffdc000. use command !teb to show it which required symbols 

with not symbols then use command dd the with block address. with complete symbol could use dt TEB to do this. without simple required to check the header file ntpsapi.h to do this 
typedef struct _TEB {
	NT_TIB NtTib;
	PVIOD EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;
	ULONG LastErrorValue;
	..
	PVOID DeallocationStack;
}TEB;

typedef struct _NT_TIB{
	struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
	PVOID StackBase;
	PVOID StackLimit;
	...
} NT_TIB;

$ dd 0x7ffdc000 L4 
7ffdc000   009fdef0 00a00000 009fc000 00000000 
the second and third dword in the TEB struct point to the bottom and top of the stack 

caculate the stack size by 
$ ? a00000-9fc000

the maximal stack size is stored in the field DeallocationStack. After some calculation you can determine that this field's offset is 0xE0c 
$ dd 77ffdc000+e0c L1 
wil display the maximun stack size

compare to the current stack size will know the remaining stack 

break into KD to get furthermore information with !vm extension to display virtual memory information 
$ .breakin 

$ !vm 
during the user mode debugging, other process may still use the ntsd command to allocate virtual memory. so there is no way to exactly view the virtual memory state during the stackoverflow happen. but we could analyzing the function call by 
$ k 
and disassemble the first few instructions for the Header_Draw 
$ u COMCTL32!Header_Draw 
...

### Manually walking a stack 
- some time the stack trace function will fail in debugger 
- manual walk a stack concept is dump out the stack pointer find out where the modules are loaded, find possible function addresses, find possible function addresses and verify by checking to see if each possible stack entry makes a call to the next 

kb command (display stack backtrace) command has an additional feature on intel system. by doing a kb=[ebp] [eip] [esp] the debugger will display the stack trace for frame with the given values for base pointer 

find out what modules are loaded where by x(examine symbols) command 
kd> x 

dumping out the stack pointer to look for address by x*! 
kd> dd esp 
kd> dd 

to determine which value are likely function address by check the value 
	+ most integers are going to be smaller value which means they will mostly zeros when displayed as DWORDs 
	+ most pointers to local addresses will be near the stack pointer 
	+ status code usually begin with a c(c00000d6). unicode and ascii string can be identified by the fact that each character will be in the range of 20-7f. in kd dc command will show the characters on right 
	
	+ the function addresss will be in the range listed by x*! 
	
	investing address by list nearest symbols command by In for each address 
	
	kd> ln 80136039 
	....
	
	check the display 
	
	to verify each symbol unassemble immedately before return address specified to see if it des a call to the function above it by 
	kd> u 8136039-2 11 
	
	recheck the answer by the command k 
	
### Debugging a stack trace that has jscript frame 
- JSript stack dump creation may incorrectly 

use command 
.stkwalk_force_frame_pointer 1 
to correct it 

### debugging an application failure 
- most common exception 
access violation, this is occur when invalid pointer is dereference 
argument faults 
exceptions 
critical section time-out(deadlocks) 
in-page i/o errors 
user-mode exception have many possible causes. if an unknown exception occurs locate it in ntstatus.h or winerror.h 
critical section timeouts occur when one thread is waiting for a critical section for a long time. require to anaylysis of the stack trace 
in-page i/o erros are almost always hardware failures check the code in ntstatus.h 

### Reattaching to the target application 
- xp+, does not depend on whether used with -pd option 
	+ determine the processid 
	+ start a new instance of cdb or windbg use -pe command-line option 
	$ debugger -pe -p PID 
	
	or use .attach command in a debugger 
	
	+ if the proces does not respond properly, it might have a suspend count that is too high. use the commad ~m(resume thread) to reduce the suspend count 
	
	detach from the process but leave it frozen in a debugging state by .abandon command which could be used to reattach 
	
	
### Crashing and rebooting the target computer 
- when perform kernel debugging, you can cause the target computer to stop responding (crash or bug check) by .crash (force system crash) command. the debugger will write a kernel mode dump file 

use .reboot command to restart the target 

in the early stage of boot process the connection is lost, if use cdb or kd all breakpoint will lost. if use windbg could use save current workspace to save all the breakpoint information 

end debugging session by Ctrl+B or Exit menu 

- support automatic break into debugger by 
	+ first kernel module is loaded 
	+ kernel initializes 
	
	+ set automatic breakpoint by -d 
	
- change break state 
	+ break with event happen 
	+ use ctrl+k or ctrl+alt+k in kd to change break state will switch three states 
	no automatic break 
	break upon kernel 
	break on first kernel load 
	
### Synchronizing with the target computer 
- in kd press ctrl+r to synchronize with target. in windbg use ctrl+alt+r 
- .restart(restart kernel connection) will provide a more powerful resynchronization 


### Finding a memory leak 
- launching performance monitor and add following counters 
Memory-> Pool nonpaged bytes 
Memory -> Pool Paged bytes 
Paging File -> % Usage 

change update to 6000 seconds to capture a graph. start the application. 

use-mode memory leaks are always located in pageable pool and cause both the pool paged bytes counter and the page file useage counter to increase steadily 

kernel mode memory leaks usually deplete nonpaged pool causing the pool nonpaged bytes counter to increase 

#### Finding a kernel mode memory leak 
#####Using Poolmon to find a kernel-mode memory leak 
#####Using the kernel debugger to find a kernel-mode memory leak 
#####Using driver verfier to find a kernel-mode memory leak 

#### Finding a user mode memory leak 
##### Using performance monitor to find a user-mode memory leak 
- add following counter 
Process -> private bytes(for each process you want to examine)
Process -> virtual bytes 

change update time to 600s

##### Usig umdh to find a user-mode memory leak 
- user-mode dump heap(umdh) utility for analyze window heap allocation for a specific process 
- umdh is included in the debugging tools 
- have following model 
	+ analyze a running process("mode 1"). umdh displays the size of the allocation the size of the overhead the pointer allocation and the allocation stack 
	
	+ mode 2, udmh log 
- preparing to use udmh, not know which process is leaking then first use performance monitor to find out the process. the most important data in the umdh log are the stack trace of the heap allocations
to determine whether a process is leaking then check the trace 

before using umdh, configure the GFlags which is for debugging tools for windows #GFlag which contain registry debugger. use the glags tool 
	+ execute glags.exe GUI swith to Image File tab. type the process name and select create user mode stack trace database and then click apply 
	
	or use command line 
	$ gflags /i ImageName +ust 
	
	+ default x86 is 32mb for stack strace data 64mb for x64 
	
	+ if change any flags required to reboot to take effect. changes to kernel falgs tab are effective immediately which will lost in the reboot 
	
- udmh use the symbol path specify by the environment variables. to ensure accurate results, must disable BSTR caching set the OANOCACHE environment variable equal to 1 

if need to trace a server then required to set as system environment variable and reboot 

- detecting increases in heap allocation with umdh  
	+ determine process id 
	+ analyze the heap memory 
	$ umdh -p:pid -f:log.txt 
	
	+ use open log 
	+ compare log files recored at different times to determine which allocations are growing 
	
	umdh can compare two different log files and display the change in their respective allocation size. 
	$ umdh log1.txt log2.txt > report.txt 
	
	output content maybe: 
	+ 5320 ( f110 - 9df0) 3a allocs BackTrace00B53 
	Total increase == 5320 
	
	search the keyword BackTrace in the log will get call stack 

    
### Debugging a time out 
- a resource timeou, during a resource timeout the thread waiting for the resource will break into kd 
- use !thread extension 
$ !thread <id> 
to get the thread call stack, either the ExpWaitForResourceExclusive and ExpWaitForResourceShared function will be on the stack for that thread 

if you get to a thread that is not waiting for another resource, it is probably the resource of the problem. 

- critical section time outs, RtlpWaitForCriticalSection near the top of the stack 
$ !ntsdexts.locks will give a list of locks currently held and the current theads that own them. find the critical section 

ExpWaitForResourceXxx the lock identifier is the first parameter to RtlpWaitForCriticalSection 


#### Resource time outs(kernel mode)
#### Critical section time outs(user mode)
- this can be identified by the stack trace that shows the routine RtlpWaitForCriticalSection near the top of the stack 
- as with resource time outs the !ntsdexts.locks extension will give a list of locks currently held 
- with ExpWaitForResourceXxx, the lock identifier is the first parameter to RtlpWaitForCriticalSection 
- example 
$ kb 

use the !ntsdexts.locks extension to find the critical section 
$ !locks 

now search for the thread id number 
$ ~ 
which own the critical section 

switch to a thread from the list of ~ command by the index 
$ ~<index>s 

$ kb 
check the call stack again 


### Debugging a stalled system 
- computer stop responding without initiating a bug. this "freeze" in variety of forms 
	+ mouse can move 
	+ screen is still mouse does not move, and continues paging memory and disk 
	+ screen is still disk is silent 
	
- mouse pointer moves or paging disk is usually due to a problem with the client server run-time (RSRSS)

- if NTSD is running on CSRSS, press f12 to dump out each thread to #Debugging CSRSS for more info 
- if CSRSS is ok then it's the kernel problem 
- no mouse move then certainly a kernel issue 


#### Finding a failed process 
- determine the accepting processor, use !pcr extension on each processor and looking for the processor for which an extention handler has been loaded 
0: kd> !pcr 
PCR Processor 0 @ffdff000
 NtTib.ExceptionList: ffffffff
			NtTib.StackBase: 80470650
...

the address of NtTib.ExceptionList on this processor			

the most interesting parts of the process dump are 
	+ the times 
	+ the handle count 
	+ the thread status 
	
- using the !process 0 7 extension is the best way to find the probelm on a hung system. use !process 0 0 then a !process on the process handle for CSRSS. get more information by .cache decodeptes before call !process 0  
unresponsive computer 

extension,	  effect 
!ready		  identifies 
!kdext*.locks   identifies 
!vm			 check the virtual memory usage 
!poolused	   determines wheter one type of pool allocation is disproportionately large 
!memusage	   check the physical memory status 
!heap		   check the validity of the heap 
!irpfind		search nonpaged pool for active IRPs 

ntoskrnl!KiSwapThread 
NtReadFile 


#### Debugging an interrupt storm 
- interrupt storm, is a level-triggered interrupt signal that remains in the asserted state. causes 
	+ a hardware device does not relese its interrupt signal after being directed to do so by the device driver 
	+ a device driver does not instruct its hardware to release the interrupt signal 
	+ a device driver claims the interrupt even though the interrupt was not initiated form its hardware 
	+ the edge level control register(elcr) IS NOT CORRECTLY 
	+ edge and level interrupt-triggerred devices share an IRQ
	
- use !irpfind extension command to look for pending IRPs, use !irp to obtain the details 
- use kb command to request a stack trace 
- use !arbiter 4 extension to determine which devices are on IRQ 0xB 
- r command to examine the registers 


#### Debugging multiple target 
- debug multiple dump files or live user-mode application at the same time. each target contains one ore more processes
- targets are also grouped into systems 
	+ each dump file is a separate system 
	+ debugging live user-mode applications on different computer then each application is a separate system 
	+ debugging user-mode applications on the local, the applications are combined into a single system 
	
- debugging addtional user-mode application by .attach or .create command followed by g 
- debug addtional dump files by using the .opendump command followed by g
- use command line option z to open multiple dump files 
- to close one target and contitnue to debug other by .kill command. xp+ support .detach command 

- control the debugging of multiple systems you can use 
	+ || system status command display one or more systems 
	+ ||s set currnt system command enable you to select the current system 
	+ windbg Processes and Threads window enables you display or select systems, processes and threads 
	
    
#### Tracking down a processor hog 
- one application is consuming all the processor's attention, other processes will end up "starving"
- use this following process to correct 
	+ identify which application is causing this problem, use task manager or perfmon 
	+ attach debugger 
	+ identify which thread is causing the problem. use !runaway 3 extension to take a snapshot of where all the CPU time is going. use g(go) and wait a few seconds then break in and use !runaway 3 again 
	 
	0:002> !runaway 3
	 User Mode Time
	 Thread	Time
	 4e0		0:12:16.0312
	 268		0:00:00.0000
	 22c		0:00:00.0000
	 Kernel Mode Time
	 Thread	Time
	 4e0		0:00:05.0312
	 268		0:00:00.0000
	 22c		0:00:00.0000

	0:002> g

	0:001> !runaway 3
	 User Mode Time
	 Thread	Time
	 4e0		0:12:37.0609
	 3d4		0:00:00.0000
	 22c		0:00:00.0000
	 Kernel Mode Time
	 Thread	Time
	 4e0		0:00:07.0421
	 3d4		0:00:00.0000
	 22c		0:00:00.0000
	 
in this case the thread 0x4e0 cause the problem 

use ~ and ~s command to make this the current thread 
$ ~ 
$ ~2s

use kb to obtain stack trace 
$ kb 
 
0:002> kb
FramePtr  RetAddr   Param1   Param2   Param3   Function Name
0b4ffce4  01836060  0184f440 00000001 0b4ffe20 BuggyProgram!OpenDestFileStream+0xb3
0b4ffd20  01843eba  02b5b920 00000102 02b1e0e0 BuggyProgram!SaveMsgToDestFolder+0xb3
0b4ffe20  01855924  0b4ffef0 00145970 0b4ffef0 BuggyProgram!DispatchToConn+0xa4
0b4ffe5c  77e112e6  01843e16 0b4ffef0 0b4fff34 RPCRT4!DispatchToStubInC+0x34
0b4ffeb0  77e11215  0b4ffef0 00000000 0b4fff34 RPCRT4!?DispatchToStubWorker@RPC_INTERFACE@@AAEJPAU_RPC_MESSAGE@@IPAJ@Z+0xb0
0b4ffed0  77e1a3b1  0b4ffef0 00000000 0b4fff34 RPCRT4!?DispatchToStub@RPC_INTERFACE@@QAEJPAU_RPC_MESSAGE@Z+0x41
0b4fff40  77e181e4  02b1e0b0 00000074 0b4fff90 RPCRT4!?ReceiveOriginalCall@OSF_SCONNECTION@Z+0x14b
0b4fff60  77e1a5df  02b1e0b0 00000074 00149210 RPCRT4!?DispatchPacket@OSF_SCONNECTION@+0x91
0b4fff90  77e1ac1c  77e15eaf 00149210 0b4fffec RPCRT4!?ReceiveLotsaCalls@OSF_ADDRESS@@QAEXXZ+0x76

use g with address to run and stop at the given address 
0:002> g BuggyProgram!SaveMsgToDestFolder+0xb3

use kb again 
0:002> kb
FramePtr  RetAddr   Param1   Param2   Param3   Function Name
0b4ffd20  01843eba  02b5b920 00000102 02b1e0e0 BuggyProgram!SaveMsgToDestFolder+0xb3
0b4ffe20  01855924  0b4ffef0 00145970 0b4ffef0 BuggyProgram!DispatchToConn+0xa4
0b4ffe5c  77e112e6  01843e16 0b4ffef0 0b4fff34 RPCRT4!DispatchToStubInC+0x34
0b4ffeb0  77e11215  0b4ffef0 00000000 0b4fff34 RPCRT4!?DispatchToStubWorker@RPC_INTERFACE@@AAEJPAU_RPC_MESSAGE@@IPAJ@Z+0xb0
0b4ffed0  77e1a3b1  0b4ffef0 00000000 0b4fff34 RPCRT4!?DispatchToStub@RPC_INTERFACE@@QAEJPAU_RPC_MESSAGE@Z+0x41
0b4fff40  77e181e4  02b1e0b0 00000074 0b4fff90 RPCRT4!?ReceiveOriginalCall@OSF_SCONNECTION@Z+0x14b
0b4fff60  77e1a5df  02b1e0b0 00000074 00149210 RPCRT4!?DispatchPacket@OSF_SCONNECTION@+0x91
0b4fff90  77e1ac1c  77e15eaf 00149210 0b4fffec RPCRT4!?ReceiveLotsaCalls@OSF_ADDRESS@@QAEXXZ+0x76

0:002> g BuggyProgram!DispatchToConn+0xa4

finally you will find a breakpiong that is not hit. set breakpoint at the last g command. then use g command repeatedly this this breakpoint hit immediately. regardless of how many times you have executed the target. 

finally you have found the buggy function 
	
#### determing the ACL of an object
- use debugger to examine the access control list(ACL) of an object. to use it while you are performing user-mode debugging, you need to redirect control to a kernel debugger, #Controlling the User-Mode Debugger from the Kernel Debugger

- use !object debugger extension command with the name of the object will show the object header 
- dt command display the address with structure name nt!_OBJECT_HEADER 
$ dt nt!_OBJECT_HEADER ffbb8a80
   +0x000 PointerCount	 : 3
   +0x004 HandleCount	  : 2
   +0x004 NextToFree	   : 0x00000002
 +0x008 Type			 : 0x80e30e70
   +0x00c NameInfoOffset   : 0x10 ''
 +0x00d HandleInfoOffset : 0 ''
   +0x00e QuotaInfoOffset  : 0 ''
   +0x00f Flags			: 0x20 ' '
   +0x010 ObjectCreateInfo : 0x8016b460
   +0x010 QuotaBlockCharged : 0x8016b460
   +0x014 SecurityDescriptor : 0xe11f08b6
   +0x018 Body			 : _QUAD
   
SECURITY_DESCRIPTOR structure actually begins at 0xE11F08B6 & ~0x7. Use the !sd extension on this address

will displays the security information for this object 

#### displaying a critical section 
- can be displayed by the !ntsdexts.locks extension, the !critsec, !cs and dt command 
!ntsdexts.locks will display a list of critical section 
!critsec will display the address 
!cs olly available in xp+ 
dt can be used to display the literal contents of RTL_CRITICAL_SECTION structure 

- fields of critical section 
LockCount 
EnterCriticalSection
LeaveCriticalSection 
RecursionCount, the number of times that owning thread has called EnterCriticalSection 
EntryCount field indicates the number of times that a thread other than the owning thread has called EnterCriticalSection 

#### Debugging a deadlock 
- deadlock raise when two or more threads have requested locks on two or more resources in an incompatible sequence. 
- debugging a user-mode deadlock 
	+ issue the !ntsdexts.locks, you can just type !locks at the debugger 
	
	+ kd and ~
	
	check the thread has a call to the WaitForCriticalSection function 

#### Debugging a failed driver unload 
- driver will no unload if there is a leaked reference to DeviceObject 
- apart from IoCreateDevice there are several functions that take reference to DriverObject and DeviceObject. you need to follow the guidelines for using the functions 
- fixing a driver that fails to unload 
	+ set breakpoint at IoCreateDevice get the DeviceObject address 
	+ find object header by !object extension 
	
	+ put a breakpoint on the pointer count using ObjectHeader's address 
	
#### reading bug check callback data 
- many drivers supply bug check callback routines when windows issue a bug check it calls these routines before shutting down the system. the routine can specify and write to areas of memory known as callback and secondary callback data 

- BugCheckCallback, data written by this routine becauses part of callback data and not included in the crash dump file 
- BugCheckSecondaryDumpDataCallback, the data is inculded in the crash dump 
- BugCheckAddPagesCallback, data is included in the crash dump 

- displaying callback data 
!bugdump extension 
!bugdump component 

KeRegisterBugCheckCallback 

- Display secondary callback data 


#### Debugging a user-mode failure with kd 
- debug user-mode need cdb or windbg. sometimes a user mode exception will break into kd because no user-mode debugger is present 
- kernel debugger will attempts to load the first user-mode symbol that matches the address specified k, u or ln command 
- add symbol 
.sympath  and then .reload, if wrong symbol is loaded you can explicitly load a symbol by a .reload <binary.ext> 

.sys file loaded that can be identified by using a !drivers extension 
ntdll.dll and kernel32.dll are two of the most common symbols that would be required.


#### Crashing and rebooting the target computer 
- cause the target computer stop responding by issuing the .crash command the debugger writes a kernel-mode dump file 
- restart the target computer use the .reboot 
- automatic breakpoint in kernel mode by -d commandline option 
- ctrl+k in kd ctrl+alt+k in windbg to cahnge break state 


#### Mapping driver files 
- replacing driver files can be difficult. frequently you have to boot to the safe build relace the driver binary and then boot again. xp+ support another way when windbg or kd is attached as kernel debugger, it also could be used on boot driver, display drivers, subsystem driver, kernel-mode module ... 

- steps 
	+ crreate a driver replacement map file. it is a text file that lists the drivers on the target computer and their replacement drivers on the host computer 
	
	create a file named mymap.ini in d:\ with content 
	
	map
	\Systemroot\system32\drivers\videoprt.sys
	\\myserver\myshare\new_drivers\videoprt.sys
  
	+ syntax could be found at #Driver replacement map file format 
	
	+ set up a kernel debuggin connection to the target 
	
	+ load the driver replacement map by 
		* set _NT_KD_FILES environment variable before you start the kernel debugger 
		D:\Debugging Tools for Windows> set _NT_KD_FILES=d:\Map_Files\mymap.ini
		D:\Debugging Tools for Windows> kd
		
		* use the .kdfiles(set driver replacement map) command after you start the kernel debugger 
		D:\Debugging Tools for Windows> kd
		kd> .kdfiles d:\mymap.ini
		KD file associations loaded from 'd:\Map_Files\mymap.ini'
		
- Driver Replacement Map File Format
Each driver file replacement is indicated by three lines in the driver replacement map file. 
The first line consists of the word "map". 
The second line specifies the path and file name of the old driver on the target computer. 
The third line specifies the full path of the new driver. This driver can be located on the host computer or on some other server.
You can repeat this pattern of information any number of times.

- If you use CTRL+D (in KD) or CTRL+ALT+D (in WinDbg), you see verbose information about the replacement request. 

- If you want to replace a boot driver file by using this driver replacement method, you must connect the kernel debugger to the Windows boot loader (Ntldr), not to the Windows kernel. Before you can make this connection, you must install a special debugger-enabled version of Ntldr. You can find this version of Ntldr in the Windows Driver Kit (WDK), in the %DDKROOT%\debug directory. 

because targe tcomputer bypass its boot.ini you must make the connection through the COM1 port on the target computer. The baud rate is 115200. Therefore, the kernel debugger on the host computer should be configured to use a COM connection at the 115200 speed.


#### messages from the target 
- breaking in to the debugger 
	+ user-mode break routines, use, debugbreak routine, see the window sdk 
	
	+ user-mode program calls DebugBreak 
	
		* if a user-mode debugger is attached the program will break into the debugger 
		* no user-mode debugger is attacher, kernel-mode debugging is enabled then break into kd 
		* no then app terminated 
		
- kernel mode break routines 
	+ DbgBreakPoint routine works in kernel-mode code 
	+ DbgBreakPointWithStatus also causes a break but it additionally send a 32 bit status code to the debugger 
	
- kernel-mode conditional break routines, the assert macro causes the debugger to display the fail expression and its location 

- sending output to the debugger 
OutputDebugString sends a null-terminated string to the debugger

- kernel mode output routines, DbgPrint displays output in the debugger window only kernel mode code can call DbgPrint, DbgPrintEx allows you tag your message. KdPrint and KdPrintEx are identical to DbgPrint...

- reading and filtering debugging messages 
	+ in DbgPrintEx and KdPrintEx  pass appropriate component name to the componentId parameter and pass a value to the level 
	+ set the value of appropriate component filter mask 
	
	+ attach a kernel debugger to the computer
	
	+ get more detail from the function document 
	
- identifying the component name Each component is referred to in different ways, depending on the context. In the ComponentId parameter of DbgPrintEx, the component name is prefixed with "DPFLTR_" and suffixed with "_ID". In the registry, the component filter mask has the same name as the component itself

- choosing the correct level The Level parameter of the DbgPrintEx routine is of type DWORD. It is used to determine the importance bit field. 0 to 31. They are defined in the Microsoft Windows Driver Kit (WDK) header ntddk.h

- setting the component filter mask 
	+ The component filter mask can be accessed in the registry key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter. Using a registry editor, create or open this key
	+ If a kernel debugger is active, it can access the component filter mask value by dereferencing the address stored in the symbol Kd_XXXX_Mask, where XXXX is the desired component name. 
	
- determining if a debugger is attached 
Windows XP and later) The KD_DEBUGGER_ENABLED global kernel variable indicates whether kernel debugging is enabled.

(Windows XP and later) The KD_DEBUGGER_NOT_PRESENT global kernel variable indicates whether a kernel debugger is currently attached.

(Windows Server 2003 and later) The KdRefreshDebuggerNotPresent routine refreshes the value of KD_DEBUGGER_NOT_PRESENT.


## Specialized debugging techniques 


# Symbols for window debugging 
- microsoft symbol server location 
https://msdl.microsoft.com/download/symbols


## Introduction to symbols 
### Symbol path for windows debuggers 
- some compilers such as VS put symbols in the same directory as the binary. If you are debugging a user-mode process on the computer where the executable was built, if the symbol files are still in their original location the debugger can locate the symbols files without you setting the symbol path 

- syntax uri separated by semicolons. relative path are supported 
- compensating for symbol matching problems to fit for the symbol timestamp is not math the binary. Because the MS-DOS compatitility 8.3 short names for files may lead to symbol match problems if copy the similar named symbol to the same location 
the long name are automatic generate 8.3 short names and the names are saved in the image's debug record. The name could be OS dependent

- caching symbols location 
	+ recommend cache symbols locally use 
	cache* or cache*localsymbolcache; in symbol path 

	$ .sympath cache*c:\MySymbols;\\someshare
	
	+ if you use srv* in symbol path, the debugger use a symbol server to get symbols from the default symbol store 
	$ .sympath srv*[local-symbol-store*]http://msdl.microsoft.com/download/symbols
	
	+ seperate the save location for the symbol server and manually putted symbols 
	
- combining cache* and srv* 
$ .sympath cache*;srv*http://msdl.microsoft.com/download/symbols

- using #ageStore to reduce the cache size 
- lazy symbol loading, if symbol path is changed, all ready loaded symbols are immediately reloaded. 
	+ turn off lazy load by -s commandline options 
	+ .reload /f 
	
- controlling symbol path 
	+ use .sympath 
	+ .symfix (set symbol store path) is similar to .sympath but saves you some typing 
	+ use _NT_SYMBOL_PATH and _NT_ALT_SYMBOL_PATH 
	+ start debugger with -y to set path 
	
- use -sins option then debgger will ignore the environment variables 
- symbols and symbol files each symbol will contain 
	+ global variables 
	+ local variables 
	+ function names and addresses of their entry points 
	+ frame pointer omission FPO records 
	+ source-line numbers 
	
- each pdb will contain thousands of symbols 
- window symbols, win2000 keeps its symbols in files with extensions .pdb and .dbg. VC6+ linkers put all symbols into .pdb files. in standard window symbols will contain these directories 
ACM, microsoft audio compression manager files 
COM, executable files 
CPL, control panel progra 
DLL, 
DRV, driver files 
EXE
SCR, screen saver files 
SYS, driver files 


### public and private symbols 
- private symbol data includes 
	+ functions 
	+ global variables 
	+ local variables 
	+ information about user-defined structures, classes and data types 
	+ the name of the source file and the line number in that file corresponding to each binary instruction 
	
- public symbol table contains fewer items 
	+ functions(except for functions declared static)
	+ global varibles specifie as extern 
	
- many of the public symbol table ahve names that are decorated with a prefix a suffix or both. prefixes include __imp__(imported function). suffixes include (@) followed by addresses 

- full symbol files and stripped symbol files 
full symbol contain both private and public symbol data 

a stripped symbol is smaller files only contain the public symbol table or subset of the public symbol 

- creating full and stripped symbol files 
	+ debug build will create a full symbol 
	+ retail build will creates no symbols 
	
	+ build with build utility will create full symbol 
	+ binplace tool create a stripped symbol from full symbol 
	+ PDBCopy tool can create a stripped symbol from a full symbol 
	+ using symChk tool can determine wheter a symbol file is private or public 
	
- viewing public and private symbols in the debugger, behavior depends on certain symbol options 
	+ SYMBOPT_UNDNAME option is default debugger option decorations are not included when the name of a public symbol is displayed 
	+ SYMBOPT_PUBLICS_ONLY is on private symbol data is ignored 
	+ SYMBOpt_NO_PUBLICS, public symbol data is ignored this is option is default off 
	+ SYMBOPT_AUTO_PUBLICS the first symbol search is performed in the private symbol data if not found then search the public symbol table 
	
- example, command x(examine symbols) is used three times
$ x /t /d *!*typingstring* 
$ .symopt+ 4000
$ x /t /d *!*typingstring* 
$ .symopt- 2

- viewing public and private symbols with the DBH tool 


### Accessing symbols for debugging 
- the symbol files can be gathered into a symbol store which is then accessed by a symbol server. debugging tools for windows contains a symbol store creation tool called SymStore 

- symbol server enables the debugger to automatically retrieve the correct symbol files from a symbol store without the user needing to know product ames releases, or build numbers. 

Window contains a symbol server called SymSrv 

microsoft products store their symbols on internet to load this use .symfix command 


#### Installing window symbol files 
- use symfix command for full details check the microsoft public symbols 
	+ required 1gb spaces 
- install symbol files sequence 
	+ install os symbol 
	+ install symbols for the currently installed service pack 
	+ install the symbo files for any hot fixes that were installed after the current service pack 
	
    
#### Symbol stores and symbol servers 
- SymSrv (symsrv.dll) is a symbol server 
- microsoft public symbol server 
set _NT_SYMBOL_PATH=srv*DownstreamStore*http://msdl.microsoft.com/download/symbols

DownLoadStremStore must be specify a directory on your local computer or network that will be used to cache symbols 

shortcut command is 
$ .symfix+ DownstreamStore

- MS provied compressed version of symbol files, have a uderstore at the end of the filename's extension ntdll.pd_ 

- advanced SymSrv use 
	+ symsrv can also be used to separate a large symbol store into a smaller subset 
	
	+ use this symbol server, symsrv.dll must be installed in the same directory as debugger 
set _NT_SYMBOL_PATH = symsrv*ServerDLL*DownstreamStore*\\Server\Share 

set _NT_SYMBOL_PATH = symsrv*ServerDLL*\\Server\Share 

set _NT_SYMBOL_PATH = srv*DownstreamStore*\\Server\Share 

set _NT_SYMBOL_PATH = srv*\\Server\Share 

- SymSrv create a fully qualified unc path to the desired symbol file, this path begins with the path to the symbol store recorded in the _NT_SYMBOL_PATH environment variable 

the symbolServer routine is then used to identify the name of the desired file; 

- firewalls and proxy servers, SymProxy or use any other proxy server 
	+ allow authentication requests by 
	$ !sym prompts 
	$ .symopt-0x80000 use either !sym prompts off or .symopt+0x80000 
	
	must use .reload after making any changes to the authentication permission status 
- choosing a proxy server 
set _NT_SYMBOL_PROXY=myproxyserver:80
 
- http symbol stores
	+ use srv protocol supported through symsrv.dll the symbol store can be accessed using http instead of just UNC/SMB 
	
- configuring IIS 
	+ must be configured to serve the symbols by creating a virtual directory and configuring MIME types 
	
	+ option make the symbol files browseable 
	+ configure MIME 
	+ using web.config to configure mime type 
	+ configure authentication 
	+ Kerberos support must be disable when use SymSrv.dll connect to iis 
	
	+ open a cmd 
	$ appcmd.exe set config -section:system.webServer/security/authentication/windowsAuthentication /+"providers.[value='NTLM']" /commit:apphost
	
	enable 
	$ appcmd.exe set config -section:system.webServer/security/authentication/windowsAuthentication /+"providers.[value='Negotiate,NTLM']" /commit:apphost
	
- configure SymSrv client authentication prompts 
!sym prompts on 

- File Share symbol server running a SMB symbol server is simple a matter of creating a file share and granting users access to that file share 
srv*C:\Symbols*\\MachineName\Symbols

- symbol store folder tree 

- symbol store single tier or two-tier structure 
D:\SymStore\Symbols\ntdll.dll\...\
D:\SymStore\Symbols\ntdll.pdb\...\

if a large number of files are to be stored a two tier structure can be used at the root of the symbol store the first 2 letters of the filename are used as an intermediate folder name 

symbol store can be extremely big 

#### SymProxy 

- other symbol stores, since symStore transactions are all logged in csv-format text 
- other symbol servers, customize symbol server, the server must expose SymbolServer function 
- defferred symbol loading, load symbol when debugger is needed 
Resolve Unqualified Symbols, from the Debug menu of windbg to resolve symbols that have no module prefix 

overwrite deferred symbol loading by using ld command or .reload command with /f 

this option can be turned on or off by using .symopt+0x4 or .symopt-0x4

- avoiding debugger searches for unneded symbols 
	+ prevent automatic loading for unqualified symbols 
The SYMOPT_NO_UNQUALIFIED_LOADS option disables or enables 

SYMOPT_NO_UNQUALIFIED_LOADS is off by default. To activate this option

	+ suggested 
	use qualified name for symbol in debugger to speed up search 
	activate noisy symbol loading (SYMOPT_DEBUG) by using the -n command-line option or, if the debugger is already running, by using .symopt+0x80000000 or the !sym noisy debugger extension command.
	activate SYMOPT_NO_UNQUALIFIED_LOADS by using the -snul command-line option or, if the debugger is already running, by using .symopt+0x100. to prevent debugger from searching for unqualified symbol 
	explicit load modules with command .reload or ld 

    
#### SymStore is a tool for creating symbol stores 
- symstore enable debugger to look up symbols base on the time stamp and size of the image. multple versions of .pdb cannot be stored on the same server be cause they contain same signature and age 


#### how the debugger recognizes symbols 
- command bp main or display the inteer variable MyInt withe commadn dd MyInt L1 
- general symbol syntax rules
	+ symble name consist of one or more characters, but always begins with a letter, underscore, question mark, or doller sign 
		* an exclamation mark separates the module name and the symbol. use a exclamation mark with no module name can be useful for tell the debugger that a parameter is a name and not a hexadecimal number 
		
		to specify a symbol is local precede it with a dollar sign and an exclamation point like $!symbol_name 
		
- symbol syntax in numberical expressions, debugger understand two different kinds of expression, MASM and c++ 
	+ MASM each symbol is interpreted as an address 
	+ c++ expression, each symbol is interpreted according to its type
	
	check #Evaluating Expression for more detail 
	
	ss(set symbol suffix) command can be used to set the symbol suffix 
	
- symbol syntax in text expression 
bm(set breakpoint) and x (examine symbols). text parameters support whildcards. a text expression used to spedify a symbol can be prefixed with a leading underscore. Symbol suffix is not used when matching symbols in text expressions 

- symbol options, control how symbols are loaded and used 

Flag			Option Name			 Default in debugger		 Default in DBH 
0x1			 SYMOPT_CASE_INSENSITIVE  On						 On 
0x2			 SYMOPT_UNDNAME		   On						 On 
...

	+ changing symbol option setting by command .symopt (set symbol options)
	
	control all the settings at once with the -sflag command-line option. Because in using this method, since it sets the entire bitfield and will override all the symbol handler defaults. 
	-sflags 0x401 will not only turn on SYMOPT_EXACT_SYMBOLS and SYMOPT_CASE_ISNENSITVIE but also turn off all the other options that normally are on by default 
	
	symbol option can be turn on and off by -sflags+/- 0x80 
	
- symbol status abbreviations 
	+ check symbol file types and loading status by lm(list loaded modules) command. or !lmi extension or windbg's Debug|Modules menu command 
	
	+ displays generated by these command 
	Abbreviation			meaning 
	deferred				has been loaded but debugger has not attempted to load the symbols 
	#					   there is a mismatch between symbol and executable 
	T					   timestamp is missing 
	C					   checksum is missing 
	DIA					 symbol files were laoded through debug interface 
	Export				  no actual symbol files where found, so symbol information was extracted from the binary file's export table 
	M					   there is a mismatch between the symbol file and the executable 
	PERF					binary contains performance-optimized code 
	Stripped				Debug information was stripped from the image file 
	PDB					 the symbols are in .pdb format 
	COFF					symbols are in common object file format 
	
    
### Symbol Problems while debugging 
- Verifying symbols 
	+ use lm command 
	$ lm 
	+ most useful command form is 
	$ lml 
	
	use windbg Debug|Modules menu command will let you see this information as well 
	
	+ if don't see proper symbol file then fist check the symbol path 
	$ .sympath 
	
	if you are using the kernel debugger make sure your local %windir% IS NOT on your symbol path 
	
	+ reload symbol with command .reload 
	$ .reload ModuleName 
	
	you should active noisy mode so you can see which symbol file dbghelp is loading check #Symbol Options to active noisy mode 
	$ !sym noisy 
	$ .reload nt 
	
	+ diagnosing symbol loading errors 
	in noisy mode the debugger may print out error codes when it cannot load a symbol file. error codes define in winerror.h are 
	0xB ERROR_BAD_FORMAT
	
	+ verify your search path and symbols 
	
	+ mismatched builds. pointing at symbols for the wrong build HAL hardware abstraction level 
	
	use the vertarget command (show target computer version) in kd 
	
	+ testing symbols, try verify stack trace 
	+ useful commands and extensions 
	lm, list loaded modules 
	!dh image-header-base 
	.reload /n, reload all kernel modules 
	.reload [image-name], not image name then reload symbol for all images. it is necessary to reload symbols after symbol path is changed 
	!sym noisy, turn on verbose mode for symbol loads 
	.sympath [new-symbol-path]
	X *!, this will list the modules with current have symbols loaded 
	.reload /user 
	attempt to reload all user-mode symbols 
	X wdmaud!*start*, this will list only the symbols in the wdmaud module whose names contain the "start" string 
	
	+ network and port problems 
	determine which com port the debug cable is connected 
	check boot.ini setting of test system 
	.dll and .sys with the same name 
	.reload misbehaving symbol and check the !dlls command 
	
- matching symbol names problems 
	+ public vs private symbol matching 
	+ ms-dos compatibility short name symbol matching 
	
- reading symbols from paged-out headers, if a module's header is paged out to disk then this is a critical problem for kd 

	+ acquire symbols for paged-out headers 
	make a second copy of the kernel itself 
	append root directory of this share to the symbol path 
	use .reload command 
	use !sym noisy extension command 
	
	this is only works with kernel debugging 
	
	check symbols from one of these files 
	$ x fs_rec!* 
	
- mapping symbols whe the PEB is paged out, process environment block (PEB). reclaim memory. 
	+ suppose a module is mapped into a virtual address range that contains the address 7f78e9e000F enter the following command 
	$ !vad 7f78e9e000F 1 
	
	load the symbols enter the command that was given in the reload command string 
	$ .reload notepad.exe=000007f7`8e9e0000,32000
	
	+ use !process command to obtain the virtual address descriptor root address 
	
- debugging user-mode processes without symbols 
	+ to figure out what the addresses mean, you'll need a computer with matches the one with the error. same platform(x86 or x64) and be loaded with the same version of windows 
	+ copy use-mode symbols and the binaries you want to debug onto the new machine 
	+ start cdb or windbg on the symbol-less machine 
	+ issue an | command to check which process need to debug do a !process 0 0 looking for the process id given by the cdb command 
	+ use k command on symbol-less machine 
	+ with the symbol machine use u command for each address gien on the symbol-less stack will give you the stack trace for the error on the symbol less machine 

- debugging performance optimized code, re-arrange compiled and linked code so that it executes with more efficiency. these techniques optimize the component for memory hierarchies 
	+ function plus an offset will not necessarily have the same meaning it would have in non-optimized code 
	+ see if a module has been performance-optimized by use the !lmi extension command 
	
$ !lmi ntdll 
Loaded Module Info: [ntdll]
		 Module: ntdll
   Base Address: 77f80000
	 Image Name: ntdll.dll
   Machine Type: 332 (I386)
	 Time Stamp: 394193d2 Fri Jun 09 18:03:14 2000
	   CheckSum: 861b1
Characteristics: 230e stripped perf
Debug Data Dirs: Type Size	 VA  Pointer
				 MISC  110,	 0,   76c00 [Data not mapped]
	 Image Type: DBG	  - Image read successfully from symbol server.
				 c:\symbols\dll\ntdll.dbg
	Symbol Type: DIA PDB  - Symbols loaded successfully from symbol server.
				 c:\symbols\dll\ntdll.pdb
				 
the perf in the characteristics which means optimization 

	+ you cannot perform reliable address arithmetic on optimized code 
	
    
### AgeStore 
- agestore tool delete files in a directory or directory three based on their last access dates. 
- agestore can delete all files in a single directory or in all directories within a tree

$ agestore -date=month-day-year command deletes all files that where last accessed prior to the specied date 
$ agestore -size=size-remaining beginning with the least-recently accessed files until the total size of the remaining fiels is less than or equal to sizeremaining 

delete all files in the directory tree subordinate to c:\symbols\downstreamstore that were last accessed over thirty days ago 
$ agestore c:\symbols\downstreamstore -days=30 -s

$ agestore c:\mydir -date=01-07-2008

	+ running agestore on vista+, last access time (LAT) data could be enable or disable in ntfs vista+ it is disable by default 
	
	use fsutil.exe tool to enable the gathering of LAT data from a command promp 
$ fsutil behavior set disablelastaccess 0 

disable lat data 
$ fsutil behavior set disablelastaccess 1 

	+ the changes take effect on the next restart 

- dbh.exe is a command-line tool that displays information about the content of the symbol file 

the source code of DBH is available in the SDK for window 8 

the function is similar the x command in debugger 

display private symbol and public symbol 

- PDBCopy removes private symbol ifnormation from a symbol file 
...

- symChk, compares executable files to symbol files to verify that the correct symbols are available 
$ symChk [/r] filenames /s symbolPath 

filenames is the needed symbols, will try to find symbols for the filename/directory from the given symbol path 

determine the symbol is private or public 
$ symchk /v c:\sym\*.exe /s c:\sym 


# Crash dump analysis using the windows debugger(windbg)
## Kernel-mode dump files 
## User-mode dump files 
### Varieties of user-mode dump files 
- full dump file, the entire memory space of a process, the program's executable image itself, the handle table
.dump /f 

despite their names, the largets miidump file actually contain more information than the full user-mode dump. 
$ .dump /mf and .dump /ma will create a larger and more complete file thant .dump /f 

- minidumps, includes oly selected parts of the memory asociated with a process is called a minidump 

/ma, create a minidump with all optional addtions equivalent to /mfFhut full memory data, handle data, unloaded module information, basic memory information, and thread time information to the minidump.

/mf, adds full memory data to the minidump, all accessible committed pages owned by the target application 

/mF, adds all basic memory information to the minidump 
...

the command .dump /mfiu can be used to create a fairly large minidump, or the command .dump /mrR can be used to create a minidump that preserves the user's privacy.


### Create a user mode dump 
- choose the best tool
Feature				 Adplus	  Window Error Reporting	  CDB and Windbg	  User Dump  
postmortem debugging,   y		   y						   y				   y 
hangs				   y		   n						   y				   y 
encounter an exception  y		   y						   y				   y 
running normally		n		   n						   y				   n		  
fails during startup	n		   n						   y				   y 
shrink dump			 n		   n						   y				   n 

- cdb and windbg
	+ automatically dump check #Enable postmortem debugging 
	+ create dump while debugging .dump 
	+ shrinking an existing dump use .dump command 
- UserDump tool, userdump.exe are part of OEM support tools package (old)

- analyzing a user-mode dump file 
	+ cdb 
		* install symbol files 
		* start cdb 
		$ .opendump 
		command 
		
	+ windbg 
	
- extracting information from a dump file 
	+ finding the computer name in a kernel model dump file 
	$ !peb 
	
	$ x srv!SrvComputerName 
	
	finding ip address 
	find a thread stack shows some send/receive activity. open one of the send packets 
	
	find process id in a user-mode dump 
	$ | 
	the process mark with (.) is the current process id is hexadecimal after the id: notation 
	
- CAB files that contain paging files along with a memory dump. a memory dump file can be placed in a cabinet file 

	+ suppose a cab file contain 
	Memory.dmp 
	Cabmanifest.xml 
	Pagefile.sys 
	
	//Cabmanifest.xml contain 
	XML 
	<?xml version="1.0" encoding="UTF-8"?>
	<WatsonPageFileManifest>
	  <Pagefiles>
		<Pagefile Name="pagefile.sys"></Pagefile>
	  </Pagefiles>
	</WatsonPageFileManifest>
	 
	open the cab file in debugger by 
	$ windbg /z MyCab.cab 
	$ kd /z MyCab.cab 

The memory dump file that you put in the CAB file must be a complete memory dump. You can use Control Panel to configure Windows to create a complete memory dump when there is a crash. For example, in Windows 8 you can go to Control Panel > System and Security > System > Advanced System Settings > Startup and Recovery. As an alternative to using Control Panel, you can set the value of this registry entry to 1.
HKLM\SYSTEM\CurrentControlSet\Control\CrashControl\CrashDumpEnabled

Starting in Windows 8.1, you can configure Windows to preserve the contents of paging files when Windows restarts.To specify that you want paging files to be saved when Windows restarts, set the value of this registry entry to 1.
HKLM\SYSTEM\CurrentControlSet\Control\CrashControl\SavePageFileContents

- debugging oca minidump files, online crash analysis is the reporting facility for window error reproting information 
...


# Debugger Reference 
## cdb comandline options and ntsd is identical to cdb 
cdb  [ -server ServerTransport | -remote ClientTransport ] 
[ -premote SmartClientTransport ] [-log{a|au|o|ou} LogFile]
[-2] [-d] [-ddefer] [-g] [-G] [-hd] [-lines] [-myob] [-bonc]
[-n] [-o] [-s] [-v] [-w] [-cf "filename"] [-cfr "filename"] [-c "command"] 
[-robp] [-r BreakErrorLevel]  [-t PrintErrorLevel] 
[ -x{e|d|n|i} Exception ] [-x] [-clines lines] 
[-i ImagePath]  [-y SymbolPath] [-srcpath SourcePath] 
[-aExtension] [-failinc] [-noio] [-noinh] [-noshell] [-nosqm]
[-sdce] [-ses] [-sicv] [-sins] [-snc] [-snul] [-zp PageFile] 
[-sup] [-sflags 0xNumber] [-ee {masm|c++}]
[-e Event] [-pb] [-pd] [-pe] [-pr] [-pt Seconds] [-pv] 
[ -- | -p PID | -pn Name | -psn ServiceName | -z DumpFile | executable ] 
[-cimp] [-isd] [-kqm] [-pvr] [-version] [-vf] [-vf:<opts>] 

cdb -iae 

cdb -iaec KeyString 

cdb -iu KeyString

cdb -QR Server 

cdb -wake pid 

cdb -?

## KD command line options and ntkd 


##windbg commandline options 
windbg [ -server ServerTransport | -remote ClientTransport ] [-lsrcpath ]
   [ -premote SmartClientTransport ] [-?] [-ee {masm|c++}] 
   [-clines lines] [-b] [-d] [-a Extension] [-e Event] 
   [-failinc] [-g] [-G] [-hd] [-j] [-n] [-noshell] [-o] 
   [-Q | -QY] [-QS | -QSY] [-robp] [-secure] [-ses] [-sdce] 
   [-sicv] [-sins] [-snc] [-snul] [-sup] [-sflags 0xNumber] 
   [-T Title] [-v] [-log{o|a} LogFile] [-noinh] 
   [-i ImagePath] [-y SymbolPath] [-srcpath SourcePath] 
   [-k [ConnectType] | -kl | -kx ExdiOptions] [-c "command"] 
   [-pb] [-pd] [-pe] [-pr] [-pt Seconds] [-pv]
   [-W Workspace] [-WF Filename] [-WX] [-zp PageFile] 
   [ -p PID | -pn Name | -psn ServiceName | -z DumpFile | executable ] 

windbg -I[S] 

windbg -IU KeyString

windbg -IA[S] 

All command-line options are case-sensitive except for -j. The initial hyphen can be replaced with a forward-slash (/).

If the -remote or -server option is used, it must appear before any other options on the command line. If an executable is specified, it must appear last on the command line; any text after is passed to the executable program as its own command-line parameters.

[-b] is abandoned
[-c " command "] specifies the initial debugger command to run at start-up, commands can be separated with semicolons
[-clines lines] set the approximate number of commands in the command history which can be accessed during remote debugging 
[-d], after a reboot the debugger will break into the target computer as soon as a kernel module is loaded 
[-e] signals the debugger that the specified event has occurred 
[-ee {masm|c++}] sets the default expression evaluator, masm is the default 
[-failinc] cause the debugger to ignore any questionable symbols 
[-g] user mode only ignores the initial breakpoint in target application which will cause the target application to contitnue running after it is started or windbg attach to it 
[-G] user mode only ignores the final break point. the same effect is command sxd epr 
[-hd] window xp+ user mode specifies that the debug heap should not be used 
[-I[S]] installs windbg as the postmortem debugger 
[-IA[S]] associates windbg with the file .dmp, .mdmp and .wew in the registry 
[-IU KeyString] registers debugger remoting as an URL type so that users can ato-launch a debugger remote client with a URL KeyString format remdbgeng://RemotingOption
[-i image-path] specifies the location of the executables that generated the fault 
[-j] allow journaling 
[-k connect-type] starts a kernel debugging session 
[-kl] window xp+ starts a kernel debugging session on the same machine as the debgger 
[-kx ExdiOptions] start a kernel debug uses a EXDI driver 
[-log{o|a} LogFile] begins logging info into a log file 
[-lsrcpath] sets the local source path for a remote client 
[-n] noisy symbol load 
[-noinh]user mode only prevents processes created by the debugger from inheriting handles from the debugger 
[-noprio] prevents any priority changes from windbg 
[-o] debugs all processes launches by the target application
[-p pid]
[-pb] (Windows XP and later, user mode only) Prevents the debugger from requesting an initial break-in when attaching to a target process. This can be useful if the application is already suspended
[-pd ]
(Windows XP and later, user mode only) Causes the target application not to be terminated at the end of the debugging session. See Ending a Debugging Session in WinDbg for details.

[-pe ]
(Windows XP and later, user mode only) Indicates that the target application is already being debugged. See Re-attaching to the Target Application for details.

[-pn Name ]
Specifies the name of the process to be debugged. (This name must be unique.) This is used to debug a process that is already running.

[-pr ]
(Windows XP and later, user mode only) Causes the debugger to start the target process running when it attaches to it. This can be useful if the application is already suspended and you wish it to resume execution.

[-psn ServiceName ]
Specifies the name of a service contained in the process to be debugged. This is used to debug a process that is already running.

[-pt Seconds ]
Specifies the break timeout, in seconds. The default is 30. See Controlling the Target for details. 

[-pv ]
(User mode only) Specifies that the debugger should attach to the target process noninvasively. For details, see Noninvasive Debugging (User Mode).

[-Q ]
Suppresses the "Save Workspace?" dialog box. Workspaces are not automatically saved. See Using Workspaces for details.

[-QS ]
Suppresses the "Reload Source?" dialog box. Source files are not automatically reloaded.

[-QSY ]
Suppresses the "Reload Source?" dialog box and automatically reloads source files.

[-QY ]
Suppresses the "Save Workspace?" dialog box and automatically saves workspaces. See Using Workspaces for details.

[-robp ]
This allows CDB to set a breakpoint on a read-only memory page. (The default is for such an operation to fail.) 

[-sdce ]
Causes the debugger to display File access error messages during symbol load. For details and for other methods of controlling this, see SYMOPT_FAIL_CRITICAL_ERRORS.

[-secure ]
Activates Secure Mode.

[-ses ]
Causes the debugger to perform a strict evaluation of all symbol files and ignore any questionable symbols. For details and for other methods of controlling this, see SYMOPT_EXACT_SYMBOLS.

[-sflags 0x Number] 
Sets all the symbol handler options at once. Number should be a hexadecimal number prefixed with 0x -- a decimal without the 0x is permitted, but the symbol options are binary flags and therefore hexadecimal is recommended. This option should be used with care, since it will override all the symbol handler defaults. For details, see Setting Symbol Options.

[-sicv ]
Causes the symbol handler to ignore the CV record. For details and for other methods of controlling this, see SYMOPT_IGNORE_CVREC.

[-sins ]
Causes the debugger to ignore the symbol path and executable image path environment variables. For details, see SYMOPT_IGNORE_NT_SYMPATH.

[-snc ]
Causes the debugger to turn off C++ translation. For details and for other methods of controlling this, see SYMOPT_NO_CPP.

[-snul ]
Disables automatic symbol loading for unqualified names. For details and for other methods of controlling this, see SYMOPT_NO_UNQUALIFIED_LOADS.

[-srcpath SourcePath ]
Specifies the source file search path. Separate multiple paths with a semicolon (;). If the path contains spaces, it should be enclosed in quotation marks. For details, and for other ways to change this path, see Source Path.

[-sup ]
Causes the symbol handler to search the public symbol table during every symbol search. For details and for other methods of controlling this, see SYMOPT_AUTO_PUBLICS. 

[-T Title ]
Sets WinDbg window title.

[-v ]
Enables verbose output from debugger.

[-W Workspace ]
Loads the given named workspace. If the workspace name contains spaces, enclose it in quotation marks. If no workspace of this name exists, you will be given the option of creating a new workspace with this name or abandoning the load attempt. For details, see Using Workspaces.

[-WF Filename ]
Loads the workspace from the given file. Filename should include the file and the extension (usually .wew). If the workspace name contains spaces, enclose it in quotation marks. If no workspace file with this name exists, you will be given the option of creating a new workspace file with this name or abandoning the load attempt. For details, see Using Workspaces.

[-WX ]
Disables automatic workspace loading. For details, see Using Workspaces.

[-y SymbolPath ]
Specifies the symbol search path. Separate multiple paths with a semicolon (;). If the path contains spaces, it should be enclosed in quotation marks. For details, and for other ways to change this path, see Symbol Path.

[-z DumpFile ]
Specifies the name of a crash dump file to debug. If the path and file name contain spaces, this must be surrounded by quotation marks. It is possible to open several dump files at once by including multiple -z options, each followed by a different DumpFile value. For details, see Analyzing a User-Mode Dump File with WinDbg or Analyzing a Kernel-Mode Dump File with WinDbg.

[-zp PageFile ]
Specifies the name of a modified page file. This is useful if you are debugging a dump file and want to use the .pagein (Page In Memory) command. You cannot use -zp with a standard Windows page file -- only specially-modified page files can be used. 

executable 
Specifies the command line of an executable process. This is used to launch a new process and debug it. This has to be the final item on the command line. All text after the executable name is passed to the executable as its argument string. For details, see Debugging a User-Mode Process Using WinDbg.

[-? ]
Pops up this HTML Help window.
	
## DebgSrv command line options 
## KdSrv command line options 
## DbEngPrx command line options 
## KDbgCtrl command line options 
## DbgRpc command line options 
## SymStore command line options 

## Environment variables 
- general environment variables 
_NT_DEBUGGER_EXTENSION_PATH 
_NT_EXECUTABLE_IMAGE_PATH
_NT_SOURCE_PATH 
_NT_SYMBOL_PATH
_NT_ALT_SYMBOL_PATH
_NT_SYMBOL_PROXY 
_NT_DEBUG_HISTORY_SIZE
_NT_DEBUG_LOG_FILE_OPEN 
_NT_DEBUG_LOG_FILE_APPEND
_NT_EXPR_EVAL = {masm | c++} 
_NO_DEBUG_HEAP, xp + debug heap will not be used 
DBGENG_NO_DEBUG_PRIVILEGE, prevents processes spawned by the debugger from the inheriting SeDebugPrivilege 
DBGHELP_HOMEDIR, specifies the path for the root of the default downstream store used by SymSrv and SrcSrv 
SRCSRV_INI_FILE 

- kernel mode environment variables 
...


## Debugger commands 
### Syntax rules 
- obey the general syntax rules 
	+ use any combination of uppercase and lowercase letters in commands and arguments 
	+ multipel command parameters split by space or comma(,)
	+ omit the space between a command and its first parameter, you can omit others if not cause any ambiguity 
	
- command reference topics 
	+ blod font indicate items that you must literally type 
	+ character italic font will explained in parameters section 
	+ [xxx] optional 
	+ {xx|yy} must select one 
	
#### Numberical expression syntax 
- MASM nubmers and operators 
base in 16, 10, 8, or 2 

use n command to set 
0x, 0n, 0t octal, 0y binary 

	+ symbol in masm expression, numeric value of any symbol is its memory address 
	
	specify which module the address is associated with by exclamation point (!) before the name of the symbol 
	
	use two colons(::) or two underscores(__) to indicate the member of a class 
	
	use a grave accent(`) or an apostrophe(') to indicate the member of a class 
	
	+ numeric operators in MASM expressions 
	modify any component of an expression by using a unary operator 
	
	if part of an masm expression is enclosed in parenthese and two at signs(@@) appear before the expression the expression is interpreted according to c++ expression rules also specify with @@c++(...) or @@masm(...)
	
	+ unary operators 
	+ 
	- 
	not 
	hi, high 16 bits 
	low, low 16 bits 
	by, low-order byte from the specified address 
	$pby, same as by except that it takes a physical address 
	wo, low-order word from the specified address 
	$pwo, same as wo except it takes a physical address 
	dwo, double-word from the specify adress
	qwo, quad-word from the specified address 
	$pqwo, physical address of qwo 
	poi, pointer-size data from the specified address 
	$ppoi, same as poi except it takes a physical address 
	
	+ binary operators 
	* 
	/
	+
	-
	<<
	>>
	>>>, arithmetic right shift 
	= or == 
	< 
	>
	<=
	>= 
	!= 
	and or &
	xor or ^ 
	or or |
	
	+ non-numeric operators in masm 
	$fnsucc(FnAddress, RetVal, Flag, interprets the retval value as return value for the function that is located at the FnAddress 
	
	$iment(address), return the address of the image entry point in the loaded module list 
	$scmp("string1", "string2"), evaluates to -1, 0, or 1 like str cmp 
	$sicmp("string1", "string2"), equal to stricmp 
	$scmp 
	$sicmp 
	$spat("string", "pattern"), string matches pattern 
	$vvalid(address, length), check whether the memory range that begins at address and extends for length bytes is valid 
	
	+ register and pseudo registers in masm, add an at sign @ before all registers and pseudo-registers. 
	use a period(.) to indicate teh current instruction pointers. you cannot use period as first parameter for r command 
	
	+ source line number must enclose by using `
	
- c++ numbers and operators 
hexadecimal 64-bit value in the xxxxxxxx`xxxxxxxx format

L, U, and I64 suffixes with integer values

	+ characters and strings in c++ similar to normal c++ expression 
	
	+ When you add the < and > delimiters after a template name, you can add spaces between these delimiters. 

	+ operators in expression 
	two at signs (@@) before the expression, the expression is interpreted according to MASM expression 
	The symbols that indicate arrays ( [ ] ), pointer members ( -> ), UDT members ( . ), and members of classes ( :: )
	cannot use new, delete and throw cannot call function 
	you cannot shift a non-integer value.
	
	+ operators 
	// comment 
	class::member 
	class::~member, destructor 
	::name, global 
	
	struct.field 
	pointer->field 
	name[integer]
	lvalue ++ 
	lvalue -- 
	dynamic_cast<type>(value)
	static_cast<type>(value)
	reinterpret_cast<type>(value)
	const_cast<type>(value)
	
	(type)value 
	sizeof value 
	sizeof(type)
	++ lvalue 
	--lvalue 
	~value 
	!value 
	value 
	+value 
	&lvalue 
	*value 
	
	struct.* pointer, pointer to member of structure 
	pointer->*pointer,pointer to member of referenced structure
	
	value*value 
	value/value 
	value+value 
	value-value 
	value<<value 
	value>>value 
	...
	
	+ registers and pseudo register in c++ expression 
	must add @ before the register or pseudo-register 
	
	all address are cast to puchar 
	$thread is cast to ETHREAD* 
	$proc is cast to EPROCESS*
	$teb is cast to TEB* 
	$peb is cast to PEB* 
	
	use r command to edit these values 
	
	+ macros in c++, must add a number sign before the macros 
	#CONTAINING_RECORD(Address, Type, Field), base address of an instance of a structure 
	#FIELD_OFFSET(Type, Field), byte offset of a named field 
	#RTL_CONTAINS_FIELD (Struct, Size, Field), byte size includes the desired field 
	#RTL_FIELD_SIZE(Type, Field), the size of a field in a structure of known tye 
	#RTL_NUMBER_OF(Array), number of elements in a statically sized array 
	#RTL_SIZEOF_THROUGH_FIELD(Type, Field), size of a structure of known type 
	
- MASM expression VS C++ EXPRESSION
    + In an MASM expression, the numeric value of any symbol is its memory address. In a C++ expression, the numeric value of a variable is its actual value, not its address
    + The MASM expression evaluator treats all numbers as ULONG64 values. The C++ expression evaluator casts numbers to ULONG64 and preserves type information of all data types.
    + The MASM expression evaluator lets you to use any operator together with any number. The C++ expression evaluator generates an error if you use an operator together with an incorrect data type.
    + In the MASM expression evaluator, all arithmetic is performed literally. In the C++ expression evaluator, pointer arithmetic is scaled properly and is not permitted when inappropriate.
    + An MASM expression can use two underscores ( __ ) or two colons ( :: ) to indicate members of a class. The C++ expression evaluator uses only the two-colon syntax. Debugger output always uses two colons.
    + In an MASM expression, you should add an at sign (@) before all except the most common registers. If you omit this at sign, the register name might be interpreted as a hexadecimal number or as a symbol. In a C++ expression, this prefix is required for all registers.
    + MASM expressions might contain references to source lines. These references are indicated by grave accents ( ` ). You cannot reference source line numbers in a C++ expression.

- Sign Extension, When a 32-bit signed integer is negative, its highest bit is equal to one. When this 32-bit signed integer is cast to a 64-bit number, the high bits can be set to zero (preserving the unsigned integer and hexadecimal value of the number) or the high bits can be set to one (preserving the signed value of the number). The latter situation is called sign extension.

number from 0x80000000 through 0xFFFFFFFF is sign extended based on the following criteria:

    1. Numeric constants are never sign extended in user mode. In kernel mode, a numeric constant is sign extended unless it contains a grave accent ( ` ) before the low bytes. For example, in kernel mode, the hexadecimal numbers EEAA1122 and 00000000EEAA1122 are sign extended, but 00000000`EEAA1122 and 0`EEAA1122 are not.
    + A 32-bit register is sign extended in both modes.

    + Pseudo-registers are always stored as 64-bit values. They are not sign extended when they are evaluated. Assigned expression will be evaluated according to C++ criteria 

    + Sign Extension in C++ Expressions
    When the debugger evaluates a C++ expression, the following rules apply:

    Registers and pseudo-registers are never sign extended.

    All other values are treated exactly like C++ would treat values of their type.

    + number displayed as a 32-bit number from 0x80000000 through 0xFFFFFFFF, you cannot confirm whether the high 32 bits are all ones or all zeros. To distinguish between these two cases, you must perform an additional computation on the number 

- String Wildcard Syntax for string parameters 
    + * zero or more 
    + ? any one 
    + [], list of any 
    + # zero or more preceding characters 
    + + one or more of the preceding characters 
    + use backslash \ to escape upper characters 
    
- Register Syntax, add an at sign ( @ ) before the register. always add @
On x86-based systems, you can omit the at sign for the eax, ebx, ecx, edx, esi, edi, ebp, eip, and efl registers. 

The r (Registers) command is an exception to this rule. The debugger always interprets its first argument as a register. 

copy the ebx register to the eax register. 
0:000> r eax = @ebx
 
In user mode, any reference to a register is interpreted as the register that is associated with the current thread. For more information about the current thread, see Controlling Processes and Threads.

In kernel mode, any reference to a register is interpreted as the register that is associated with the current register context. You can set the register context to match a specific thread, context record, or trap frame

- Pseudo-Register Syntax, User-defined pseudo-registers are integer variables that you can write to or read.

all pseudo-register begin with a dollar sign($). if you are using MASM syntax you can add an at sign(@) before the dollar sign 

    + automatci Pseudo-registers 
    $ea, the effective address of the last instruction that was executed  
    $ea2, the second effective address 
    $exp, last expression that was evaluated 
    $ra, the return address that is curerntly on stack 
    $ip, the instruction pointer register 
        x86 same as eip 
        itanium-based related to iip 
        x64 based same as rip 
    
    $eventip, instruction pointer at the time of the current event. typically matches $ip 
    $previp, previous event 
    $relip, instruction pointer related to the current event 
    $scopeip, instruction pointer for the current local context 
    $exentry, the address of the entry point of the first executable of the current process 
    $retreg, the primary return value register 
        x86, same as eax 
        itanium, same as ret0 
        x64, same as rax 
        
    $retreg64, the primary return value register in 64 
        x86 same as edx:eax pair 
        
    $csp, current call stack pointer 
       
    $p,  The value that the last d* (Display Memory) command printed.
    $proc, address of current process 
    $thread, address of the current thread, in kernel-mode it's the ETHREAD block. in user mode it's the TEB 
    $peb, the address of the process environment block address
    $teb, thread environment block address
    $tpid, the process ID 
    $tid, the thread id 
    $dtid 
    $dpid 
    $dsid 
    
    $bpNumber, the address of the corresponding breakpoing 
    $frame, the current frame index 
    $dbgtime, current time 
    $callret, return value of the last function, that .call(call function) called or that is used in an .fnret /s command. the data type of $callret is the data type of this return value 
    $extret 
    $extin 
    $clrex 
    $lastclrex, managed debugging only, address of last encountered common language runtime(CLR) exception 
    $ptrsize, size of a pointer
    $pagesize, number of bytes in one page of memory 
    $pcr 
    $pcrb 
    $argreg 
    $exr_chance, the chance of the current exception record 
    $exr_code, the exception code for the current exception record 
    $exr_numparam, number of parameter in the current exception record 
    $exr_param#, from 0to 14 
    $bug_code, a bug check has occurred, applied to kernel debugging and crash dumps 
    $bug_param#, from 1 to 4 
    
    + For example, the command ? $teb displays the address of the TEB, while the command ?? @$teb displays the entire TEB structure
    
    + You can use the r command to change the value of $ip. This change also automatically changes the corresponding register. When execution resumes, it resumes at the new instruction pointer address. This register is the only automatic pseudo-register that you can change manually.
    
    In MASM syntax, you can indicate the $ip pseudo-register with a period ( . ). You do not add an at sign (@) before this period, and do not use the period as the first parameter of the r command. This syntax is not permitted within a C++ expression.
    
    + Automatic pseudo-registers are similar to automatic aliases. But you can use automatic aliases together with alias-related tokens (such as ${ }),
    
    + User defined Pseudo-Registers, There are 20 user-defined pseudo-registers ($t0, $t1, ..., $t19). These pseudo-register are variables that you can read and write through the debugger. You can store any integer value in these pseudo-registers


- Source Line Syntax, `[[Module!]Filename][:LineNumber]`

source line expressions are not evaluated in CDB unless you issue a .lines command 
- Address and Address Range Syntax 
addresses are always virtual address, except when the documentation specifically indicates another kind of address 
in user mode, the debugger interprets virtual address according to the page directory of the process 
in kernel mode the debugger interprets virtual addresses according to the page directory of the process specifies 

check .context 
    + address modes and segment support, x86 based, CDB and KD support 
    flat %
    32-bit addresses (also 16-bit selectors that point to 32-bit segments) and 64-bit addresses on 64-bit systems.
     
    virtual 86 &
    Real-mode addresses. x86-based only.
     
    plain #
    Real-mode addresses. x86-based only.
 
difference between the plain and virtual 86 modes is that a plain 16-bit address uses the segment value as a selector and looks up the segment descriptor. But a virtual 86 address does not use selectors and instead maps directly into the lower 1 MB.

    + address arguments, specify the location of variables and functions 
offset, The absolute address in virtual memory space
&[[ segment:]]offset, The real address. x86-based and x64-based.
%segment:[[ offset]], A segmented 32-bit or 64-bit address. x86-based and x64-based.
%[[ offset]], An absolute address (32-bit or 64-bit) in virtual memory space. x86-based and x64-based
name[[ +|− ]]offset, A flat 32-bit or 64-bit address. name can be any symbol. offset specifies the offset. 
 
    + use dg(display selector) to view segment descriptor information 
    + in MASM use poi operator to dereference any pointer 
pointer at address 0x00123456 points to address location 0x00420000, the following two commands are equivalent.

0:000> dd 420000 
0:000> dd poi(123456) 

    + pointers in C++. However, numbers are interpreted as integers. If you have to deference an actual number, you must cast it first, as the following example shows.

0:000> dd *( (long*) 0x123456 ) 

    + address range 
        * a range by a pair of addresses,
        0x00001000  0x00001007
        
        * To specify an address range by an address and object count, the letter L could be uppercase or lowercase 
        0x00001000  L8
        
        * The size of the object depends on the command, There are two other ways to specify the value (the LSize range specifier):
        
        L? Size (with a question mark) means the same as LSize, except that L? Size removes the debugger's automatic range limit. Typically, there is a range limit of 256 MB, because larger ranges are typographic errors.
        
        L- Size (with a hyphen) specifies a range of length Size that ends at the given address. For example, 80000000 L20 specifies the range from 0x80000000 through 0x8000001F
        

- Thread Syntax 
~. The current thread.
 
~#  The thread that caused the current exception or debug event.
 
~*  All threads in the process.
 
~Number The thread whose index is Number. 
 
~~[TID] The thread whose thread ID is TID. (The brackets are required And you cannot add a space between the second tilde and the opening bracket.)
 
~[Expression] The thread whose thread ID is the integer to which the numerical Expression resolves.

this number differs from the thread ID that the Microsoft Windows operating system uses.

thread remains the current thread until you specify a new one by using a ~s (Set Current Thread) 
    + controlling threads in kernel mode, In kernel mode, you cannot control threads by using thread identifiers. For more information about how to access thread-specific information in kernel mode, see Changing Contexts.


- Process Syntax 
|. The current process.
 
|# The process that caused the current exception or debug event.
 
|* All processes.
 
|Number The process whose ordinal is Number. 
 
|~[PID] The process whose process ID is PID. (The brackets are required and you cannot add a space between the tilde (~) and the opening bracket.)
 
|[Expression] The process whose process ID is the integer to which the numerical Expression resolves.

    + example, [|@$t0]. In this example, the process changes depending on the value of a user-defined pseudo-register. This syntax allows debugger scripts to programmatically select a process
 
- System Syntax 
||. The current system
 
||# The system that caused the current exception or debug event.
 
||* All systems.
 
||ddd The system whose ordinal is ddd. 
 
- Multiprocessor Syntax, KD and kernel-mode WinDbg support multiple processor debugging. 
::TO_BE_CONTINUE::


# Force symbol loading by .symopt
0:000> .symopt+ 0x40
Symbol options are 0x30377:
0x00000001 – SYMOPT_CASE_INSENSITIVE
0x00000002 – SYMOPT_UNDNAME
0x00000004 – SYMOPT_DEFERRED_LOADS
0x00000010 – SYMOPT_LOAD_LINES
0x00000020 – SYMOPT_OMAP_FIND_NEAREST
0x00000040 – SYMOPT_LOAD_ANYTHING <———– Prevents validation of .pdb file
0x00000100 – SYMOPT_NO_UNQUALIFIED_LOADS
0x00000200 – SYMOPT_FAIL_CRITICAL_ERRORS
0x00010000 – SYMOPT_AUTO_PUBLICS
0x00020000 – SYMOPT_NO_IMAGE_SEARCH


# Get last error for the current thread 
$ !gle
https://msdn.microsoft.com/en-us/library/ff563177(v=vs.85).aspx
https://blogs.msdn.microsoft.com/marcelolr/2010/04/22/getlasterror-on-windbg/

$ !teb
display a format view of information for the current thread 
https://msdn.microsoft.com/en-us/library/ff565433(VS.85).aspx


# Debug a process as soon as it starts 
- attach to the parent process and use command 
$ .childdbg 1 
to recursive debug the process 

    + set attach to child processes and also skip the first breakpoint and the extra breakpoint on process exit 
$ sxn ibp
$ sxn epr
$ .childdbg 1
$ g


get information from a process  
$ !peb 

- the real way, configure GFlags to start Windbg
choose image file, type the executable name and press TAB 
check debugger and assign the debugger windbg path 

this is equal to assign the registry key 
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
with debugger path 

we could also use gflags to use visual studio debugger. vsjitdebugger.exe 

- reference 
https://bugslasher.net/2011/03/26/how-to-debug-a-process-as-soon-as-it-starts-with-windbg-or-visual-studio-2010/


# step symbol proxy 
- reference 
https://msdn.microsoft.com/en-us/library/windows/desktop/ms680692(v=vs.85).aspx
set _NT_SYMBOL_PROXY=myproxyserver:80


# window debugging tools 
https://blogs.msdn.microsoft.com/ntdebugging/2006/12/15/getting-ready-for-windows-debugging/


# windbg common commands 
http://windbg.info/doc/1-common-cmds.html


# Tips and tricks 
- add watcher 
start with $! for local variable 
start with mode! for global name 


# PE file format 
https://docs.microsoft.com/en-us/windows/win32/debug/pe-format









