COM+ Unleaded=Richard Leinecker;Note=Erxin


# Windows DNA and COM+ 
- COM/DCOM/COM+, and there are no DNA-logo requirements or rules for regulating DNA compliance.

DCOM, or server-side, product-specific security (like MTS/MSMQ), depending on the communication medium.

- In-Memory Database (IMDB) offers a boost in performance to enterprise applications

- Other COM development tool, Microfocus COBOL can do a good job of creating COM components (although at this writing, they don't support COM+).

- With the ATL present in VC++, and COM support from MFC, COM and COM+ programming in C++ has become much easier.


# Multitiered Component Architectures
- three tier design 

presentation 

business logic 

data service 

- real world n tiered architecture 

win32   + html 
data validation/shaping 
number crunching and processing 
security 
transaction management 
relational stores, file system stores 

- local or distributed 

- creating COM components that transparently access mainframe resources. Chapter 19, "The COM Transaction Integrator," of

- most important ones:

Maintainability

Reliability

Availability

Scalability

Portability

Security

Reusability

Locality (distributed or local; ties closely with performance)

- design tool, UML 


# Advanced COM programming techniques 
- COM+ architecture and administration 
- Component Load Balancing (CLB).
- with COM+ are In Memory Database (IMDB) support
- evolution of COM+ 

COM is a direct outgrowth of OLE, or, more specifically, out of OLE 2. The central idea behind the technology is that applications are built around component objects. 

a contract between COM interfaces and applications. The implicit understanding is that interfaces, once they are introduced, will not change. New interfaces can be added, whereas the old interfaces are constant.

COM+ follows in the traditional COM footsteps. It adds services through new interfaces, and does not change existing interfaces and services.

COM+ implements a system of interception and does transparently what is necessary for COM to work.

Dynamic load balancing is an integral part of COM+.

Microsoft has maintained that MSMQ was a good solution to the need for load balancing.

- COM+ architecture 

- COM+ introduces additional object construction hooks

- This means that you can create a new object using 

CoCreateInstanceEx() without losing context. MTS developers must use the IObjectContext::CreateInstance() method in order to construct new objects within the current context. 

The CreateInstance() approach works in COM+ as well

A COM+ class can choose to support the IObjectConstructor interface that supports parameterized construction. 

A COM+ class can choose to support the IObjectConstructor interface that supports parameterized construction. Component Services Manager (equivalent to the MTS Explorer) shown in Figure 3.1 can be used to configure a string parameter for object construction of any given COM+ class

COM+ 1.0 allows classes to be associated with only one application at a time. This restricts administrators to one construction string per class. 

- Monikers

Monikers are objects that are capable of reconstituting some other type of object through a simple string name (see Chapter 5).

COM+ provides a "new moniker" that enables you to construct new objects from a simple string name, such as "new:OrderEntry.Order.1". 

monikers are interface-based COM objects that anyone can create and are therefore much more flexible than strict API calls such as CoCreateInstance()

- the neutral threaded apartment, direct resopnse to the specific performance requirements of transaction based application servers (MTS and COM+)

MTS threading mode, single threaded apartment(STA). any calls to STA objects from outside the apartment must be marshaled by the calling thread and dispatched by the target STA thread. disadvantage is the performance bottle neck.

Current COM support one Multithreaded apartment, MTA per process.

neutral threaded components are always created in the neutral apartment. it contains objects but not threads. Neutral-threaded components are always created in the neutral apartment. The neutral apartment ensuring that no single object receives more than one method call at a time.

- object pooling 

pooled objects cannot be single threaded or apartment threaded. Objects created in an STA live in the same STA for their entire lifetime

Component Services Manager (the functional equivalent of the MTS Explorer) is used to enable pooling on the class in question. 

- dynamic load balance 

take full advantage of the COM+ deployment services, a component should be fully self-describing. This means that components should supply a complete type library. Configured attributes and other component-centric information are stored in a component library

DllRegisterServer() is still required in order to support non–COM+ environments. 

run on NT 4, you should stick to the guidelines presented with MTS 2.0. Your components will still work just fine under COM+

- queue components 
MSMQ enables applications to uncouple themselves from external services they might require.

The queued component recorder running on the client queues the COM method calls for later delivery. When the server network is once again available, the queued COM calls are delivered to the target queue

- Queued components are created using a queue moniker such as queue:/new:OrderEntry.Order.1.

- loose coupled events 

There are several important aspects of the loosely coupled event system. The LCE system provides a broadcast-style mechanism at the native COM level

- IMDB is a smart in-memory database caching system optimized for read operations. IMDB allows static data to be loaded once and queried against many times. 

- COM+ security 

ISecurityCallContext interface. The ISecurityCallContext interface supercedes the MTS ISecurityProperty interface 

- base COM features, These are as follows:

StgCreateStorageEx()

StgOpenStorageEx()

COM+ creates and manages Cancel objects for all calls that use standard marshaling by calling CoSetCancelObject() before and after each method call. 

IID_ICancelMethodCalls interface ID. 

- IPersist interface 

IStorage 	The IStorage interface supports the creation and management of structured storage objects
IStream 	The IStream interface supports reading and writing data to stream objects
IPersist 	The IPersist interface defines the single method GetClassID, which is designed to supply the CLSID of an object that can be stored persistently in the system 
IPersistStorage 	The IPersistStorage interface defines methods that enable a container application to pass a storage object to one of its contained objects
IPersistStream 	The IPersistStream interface provides methods for saving and loading objects that use a simple serial stream
IPersistFile 	The IPersistFile interface provides methods that permit an object to be loaded from or saved to a disk file

- creating an ATL object that implements IPersistStreamInit

With Visual C++ running, create a new ATL project. For simplicity, use the default settings.

From the Insert menu, select New ATL Object. Then, insert a full control into the ATL project. If you want persistent storage, the reason to use a full control is that a full control inherits from the IPersistStreamInit interface. 

```
// IPersistStream
HRESULT __stdcall IsDirty( void );
HRESULT __stdcall Load( IStream * );
HRESULT __stdcall Save( IStream *, BOOL );
HRESULT __stdcall GetSizeMax( ULARGE_INTEGER * );

// IPersistStreamInit
HRESULT __stdcall InitNew( void );

// IPersist
HRESULT __stdcall GetClassID( CLSID* pClassID );


HRESULT CPersistClass1::InitNew( void )
{
    return S_OK;
}

HRESULT CPersistClass1::GetClassID( CLSID* pClassID )
{
    return S_OK;
}

HRESULT CPersistClass1::IsDirty( void )
{
    return S_OK;
}

HRESULT CPersistClass1::Load( IStream *pStm )
{
    return S_OK;
}

HRESULT CPersistClass1::Save( IStream *pStm, BOOL bClearDirty )
{
    return S_OK;
}

HRESULT CPersistClass1::GetSizeMax( ULARGE_INTEGER *pcbSize )
{
    return S_OK;
}

class ATL_NO_VTABLE CMyClass :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMyClass, &CLSID_MyClass>,
    public IDispatchImpl<IMyClass, &IID_IMyClass, &LIBID_TEST132Lib>,
    public IPersistStreamInitImpl<CMyClass>,
    public IPersistStorageImpl<CMyClass>

{
public:
    CMyClass()
    {
    }

    BOOL m_bRequiresSave;

    static ATL_PROPMAP_ENTRY *GetPropertyMap()
    {
        return( NULL );
    }

DECLARE_REGISTRY_RESOURCEID(IDR_MYCLASS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMyClass)
    COM_INTERFACE_ENTRY(IMyClass)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMyClass
public:
};
```

    + use the new component 
```
const CLSID CLSID_PersistClass1 =
    {0×33733D5B, 0×d350, 0×11d3, {  0×8d, 0×44, 0×0, 0×10, 0×5a, 0×a7, 0×21,
 0×be }};
CPersistClient1View::CPersistClient1View()
{
    HRESULT hRes;

    m_bCoInitialized = TRUE;
    m_pUnknown = NULL;
    m_pPersistStreamInit = NULL;
    m_pStream = NULL;

    // Initialize.
    hRes = CoInitialize( NULL );

    // Return if initialization failed.
    if( FAILED( hRes ) ){
        m_bCoInitialized = FALSE;
        return;
        }

    // Create the object.
    hRes = CoCreateInstance( CLSID_PersistClass1, NULL,
        CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &m_pUnknown );

    // Return if object creation failed.
    if( FAILED( hRes ) ){
        m_pUnknown = NULL;
        return;
        }

    // Attempt to get the IPersistStreamInit interface object.
    hRes = m_pUnknown->QueryInterface( IID_IPersistStreamInit,
        (void **) &m_pPersistStreamInit );

    // If we didn't get the IPersistStreamInit interface
    // object, return.
    if( FAILED( hRes ) ){
        m_pPersistStreamInit = NULL;
        return;
        }

    // Create a memory-based stream.
    hRes = CreateStreamOnHGlobal( NULL, TRUE, &m_pStream );

    // If the creation of the memory-based stream failed, return.
    if( FAILED( hRes ) ){
        m_pStream = NULL;
        return;
        }
// Initialize the object to its default state.
    hRes = m_pPersistStreamInit->InitNew();

    // Return if the InitNew() method failed.
    if( FAILED( hRes ) )
        return;

    // Save the object to the stream.
    hRes = m_pPersistStreamInit->Save( m_pStream, TRUE );

}

CPersistClient1View::~CPersistClient1View()
{

    // Release the IStream object.
    if( m_pStream != NULL )
        m_pStream->Release();

    // Release the IPersistStreamInit object.
    if( m_pPersistStreamInit != NULL )
        m_pPersistStreamInit->Release();

    // Release the object.
    if( m_pUnknown != NULL )
        m_pUnknown->Release();

    // Uninitialize.
    if( m_bCoInitialized )
        CoUninitialize();

}
```

- Monikers

encapsulated using monikers and a COM+ object that implements the necessary business logic.

The IMoniker::BindToObject() method creates an instance of the implementation COM object associated with the moniker

- The IMoniker::ComposeWith() method creates a new composite moniker from this moniker and another moniker. 

- Moniker types 

The Running Object Table (ROT) is a globally accessible table on each computer that keeps track of all COM+ objects in the running state that can be identified by a moniker.

One of the most useful features of monikers is that you can concatenate or compose monikers together. 

Class monikers bind to the class object of the class for which they are created. Class monikers are therefore most useful in composition with other types of monikers, such as file monikers or item monikers.

A pointer moniker identifies an object that can exist only in the active or running state. This differs from other classes of monikers, which identify objects that can exist either in the passive or active state.

CreatePointerMoniker() API function if you need to use a pointer moniker.

- Connectable objects 

COM+ provides direct support for COM+ classes having both properties and methods, but no COM+ structure is the equivalent of an event.

{Event provider                         {Event Consumer

{ActiveX Control 

{IConnectionPoint Container -------------> 
IConnectionPoint 
IConnectionPoint    <--------------------{Event Sink Object}
}
}
}                                       }

You can think of the event sink as a callback class, that is, a class whose methods are invoked to provide for event notification. The event server (or source) is the server that will provide notification

- Connection points 

The connection point class is an implementation of the IConnectionPoint interface
```
interface IConnectionPoint : IUnknown
{
  HRESULT GetConnectionInterface([out] IID * piid);
  HRESULT GetConnectionPointContainer(
    [out] IConnectionPointContainer ** ppCPC)
  HRESULT Advise([in] IUnknown * pUnkSink,
    [out] DWORD * pdwCookie);
  HRESULT Unadvise([in] DWORD dwCookie);
  HRESULT EnumConnections(
    [out] IEnumConnections ** ppEnum);
}
```

The IConnectionPoint::GetConnectionInterface() method returns the interface identifier (IID) of the event sink interface. 

The IUnknown interface pointer can be used by the connection point to query the event sink interface and call methods on the event sink object

```
// MyEventTrigger.h : Declaration of the CMyEventTrigger

#ifndef __MYEVENTTRIGGER_H_
#define __MYEVENTTRIGGER_H_
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMyEventTrigger
class ATL_NO_VTABLE CMyEventTrigger :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CMyEventTrigger, &CLSID_MyEventTrigger>,
  public IConnectionPointContainerImpl<CMyEventTrigger>,
  public IDispatchImpl<IMyEventTrigger, &IID_IMyEventTrigger,
                       &LIBID_EVENTSERVERLib>,
  public IConnectionPointImpl<CMyEventTrigger,
                              &IID_IMyEventSink>
{
public:
  CMyEventTrigger()
  {
  }

DECLARE_REGISTRY_RESOURCEID(IDR_MYEVENTTRIGGER)

BEGIN_COM_MAP(CMyEventTrigger)
  COM_INTERFACE_ENTRY(IMyEventTrigger)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMyEventTrigger)
  CONNECTION_POINT_ENTRY(IID_IMyEventSink)
END_CONNECTION_POINT_MAP()

// IMyEventTrigger
public:
  STDMETHOD(Fire)();
};

#endif //__MYEVENTTRIGGER_H_
```

In the class declaration, note that I've implemented the IMyEventTrigger interface. This interface will be called later in order to trigger the event. I've inherited from both the IConnectionPointImpl and IConnectionPointContainerImpl 

```
// MyEventTrigger.cpp : Implementation of CMyEventTrigger
#include "stdafx.h"
#include "EventServer.h"
#include "MyEventTrigger.h"

////////////////////////////////////////////////////////////////////////
// CMyEventTrigger


STDMETHODIMP CMyEventTrigger::Fire()
{
  // TODO: Add your implementation code here
  IUnknown ** ppunknown = m_vec.begin();
  if (*ppunknown != NULL)
  {
    IMyEventSink * pmyeventsink = (IMyEventSink *)*ppunknown;
    pmyeventsink->Hello();
  }

  return S_OK;
}

IUnknown** ppunknown = m_vec.begin();
while (ppunknown < m_vec.end())
{
  if (*ppunknown != NULL)
  {
    IMyEventSink * pmyeventsink = (IMyEventSink *)*ppunknown;
    (*pmyeventsink)->Hello();
  }
  ppunknown++;
}
```

IConnectionPointContainer interface, I can now call the method IConnectionPointContainer::FindConnection() to retrieve the IConnectionPoint object.

the IConnectionPoint interface, I can call IConnectionPoint::Advise() to set up the event notification. Note that I pass a pointer to a DWORD to the IConnectionPoint::Advise() method. 

- events and visual basic 

call the IDispatch::Invoke method in order to fire the event in a Visual Basic client.

```
VARIANTARG* pvars = new VARIANTARG[1];
for (int i = 0; i < 1; i++)
{
  VariantInit(&pvars[i]);
}
IUnknown** pp = m_vec.begin();
while (pp < m_vec.end())
{
  if (*pp != NULL)
  {
    pvars[0].vt = VT_I4;
    pvars[0].lVal= lFlags;
    DISPPARAMS disp = {  pvars, NULL, 1, 0 } ;
    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT,
                    DISPATCH_METHOD, &disp, NULL, NULL, NULL);
  }
  pp++;
}
delete[] pvars;
```

the background task is the CMyEventSource::ThreadStart static method that simply waits for the selected amount of seconds

- COM+ threading 

    +  types of threads 

worker threads 
message queue threads 
window threads 
apartment threads 

    + The worker thread is commonly used to simulate background processing.

    + The advantage of the message queue thread is that you can post Windows messages to the thread
    
```
class MessageQueue
{
public:
  static DWORD WINAPI ThreadProc(void *p);
  int DoWork();
  MessageQueue();
  virtual ~MessageQueue();

private:
  DWORD m_idThread;
};

#define MYMESSAGE (WM_USER+1000)

MessageQueue::MessageQueue()
{
  HANDLE thread = ::CreateThread(NULL, 0, ThreadProc, NULL, 0,
                                 &m_idThread);
  ::CloseHandle(thread);
}

MessageQueue::~MessageQueue()
{
  ::PostThreadMessage(m_idThread, WM_QUIT, 0, 0);
}

DWORD WINAPI MessageQueue::ThreadProc(void *p)
{
  MSG msg;
  while (::GetMessage(&msg, NULL, 0, 0))
  {
    switch (msg.message)
    {
      case MYMESSAGE:
        //////////////////////////////////////
        // TODO
        // Add background processing code here
        //
        std::cout << "Hello World!" << std::endl;
        Sleep(1000);
        std::cout << "Goodbye World!" << std::endl;
      default:
      break;
    };
  };
  return 0;
}

int MessageQueue::DoWork()
{
  ::PostThreadMessage(m_idThread, MYMESSAGE, 0, 0);
  return 0;
}
```
    + windows threads, The window thread type has a window in addition to a message queue. The window thread type also uses the GetMessage() function to retrieve message from its message queue; but to retrieve the message, the thread specifies a window's handle rather than a thread ID

```
class Window
{
public:
  static LRESULT CALLBACK WndProc(HWND hwnd, UINT idMessage,
                                  WPARAM wParam, LPARAM lParam);
  static DWORD WINAPI ThreadProc(void * p);
  int DoWork();
  Window();
  virtual ~Window();

private:
  DWORD m_idThread;
  HWND m_hwnd;
};
#define MYMESSAGE (WM_USER+1000)

Window::Window()
{
  HANDLE thread = ::CreateThread(NULL, 0, ThreadProc, &m_hwnd, 0,
                                 &m_idThread);
  ::CloseHandle(thread);
}

Window::~Window()
{
  ::PostMessage(m_hwnd, WM_QUIT, 0, 0);
}

LRESULT CALLBACK Window::WndProc(HWND hwnd, UINT idMessage,
                                 WPARAM wParam, LPARAM lParam)
{
  HDC hDC;
  PAINTSTRUCT ps;
  RECT rect;
  switch (idMessage)
  {
    case WM_PAINT:
      hDC = BeginPaint (hwnd, &ps);
      GetClientRect (hwnd, &rect);
      DrawText (hDC, "Hello Thread", -1, &rect,
          DT_SINGLELINE | DT_CENTER | DT_VCENTER);
      EndPaint (hwnd, &ps);
      break;
    case WM_DESTROY:
      PostQuitMessage(0);
      break;
    case MYMESSAGE:
        //////////////////////////////////////
        // TODO
        // Add background processing code here
        //
        std::cout << "Hello World!" << std::endl;
        Sleep(1000);
        std::cout << "Goodbye World!" << std::endl;
      break;
    default:
      return DefWindowProc (hwnd, idMessage, wParam, lParam);
  }
  return (0L);
}

DWORD WINAPI Window::ThreadProc(void *p)
{
  WNDCLASSEX wndclass;
  static char  szWndClassName[] = "Threading Example";

  wndclass.cbSize = sizeof (wndclass);
  wndclass.style=CS_HREDRAW | CS_VREDRAW;
  wndclass.lpfnWndProc = WndProc;
  wndclass.cbClsExtra = 0;
  wndclass.cbWndExtra = 0;
  wndclass.hInstance = ::GetModuleHandle(NULL);
  wndclass.hIcon = ::LoadIcon(NULL,IDI_APPLICATION);
  wndclass.hCursor = ::LoadCursor(NULL, IDC_ARROW);
  wndclass.hbrBackground = (HBRUSH) ::GetStockObject(WHITE_BRUSH);
  wndclass.lpszMenuName = NULL;
  wndclass.lpszClassName = szWndClassName;
  wndclass.hIconSm = ::LoadIcon(NULL,IDI_APPLICATION);

  RegisterClassEx (&wndclass);

  HWND hwnd;
  MSG msg;

  hwnd = CreateWindow (
    szWndClassName,
    "The Hello Program",
    WS_OVERLAPPEDWINDOW,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    NULL,
    NULL,
    GetModuleHandle(NULL),
    NULL);

  *(HWND *)p = hwnd;
  ShowWindow(hwnd, SW_SHOWNORMAL);
  UpdateWindow(hwnd);

  while (GetMessage(&msg,hwnd,0,0))
  {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
  return msg.wParam;
}

int Window::DoWork()
{
  ::PostMessage(m_hwnd, MYMESSAGE, 0, 0);
  return 0;
}
```

    + The last basic thread type is the apartment thread. Any thread used to execute calls to component objects is configured as "apartment threaded." 

```
class Apartment
{
public:
  static DWORD WINAPI ThreadProc(void * p);
  int DoWork();
  Apartment();
  virtual ~Apartment();

};

Apartment::Apartment() {}

Apartment::~Apartment() {}

DWORD WINAPI Apartment::ThreadProc(void *p)
{
  ::CoInitialize(NULL);
  //////////////////////////////////////
  // TODO
  // Add background processing code here
  //
  std::cout << "Hello World!" << std::endl;
  Sleep(1000);
  std::cout << "Goodbye World!" << std::endl;

  ::CoUninitialize();
  return 0;
}

int Apartment::DoWork()
{
  DWORD dw;
  HANDLE thread = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, &dw);
  ::CloseHandle(thread);
  return 0;
}
```

- thread pools 

Thread pools are not a thread type, but rather an implementation option. In other words, COM is using a thread pool to implement how COM calls to single- and multithreaded apartments. 

Any of the previous four thread types could be extended to provide for a thread pool.

```
class Pool
{
public:
  static DWORD WINAPI ThreadProc(void * p);
  int DoWork();
  Pool();
  virtual ~Pool();

private:
  std::queue<DWORD> m_qidThread;

};

#define MYMESSAGE (WM_USER+1000)
#define NUMTHREADS 10

Pool::Pool()
{
  for (int i=0;i<10;i++)
  {
    DWORD dw;
    HANDLE thread = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, &dw);
    ::CloseHandle(thread);
    m_qidThread.push(dw);
  }
}

Pool::~Pool()
{
  while (!m_qidThread.empty())
  {
    ::PostThreadMessage(m_qidThread.front(), WM_QUIT, 0, 0);
    m_qidThread.pop();
  }
}

DWORD WINAPI Pool::ThreadProc(void *p)
{
  MSG msg;
  while (::GetMessage(&msg, NULL, 0, 0))
  {
    switch (msg.message)
    {
      case MYMESSAGE:
        //////////////////////////////////////
        // TODO
        // Add background processing code here
        //
        std::cout << "Hello World!" << std::endl;
        std::cout << "From Thread Number: " << ::GetCurrentThreadId()
                  << std::endl;
      default:
      break;
    };
  };
  return 0;
}

int Pool::DoWork()
{
  DWORD dw = m_qidThread.front();
  ::PostThreadMessage(dw, MYMESSAGE, 0, 0);
  m_qidThread.pop();
  m_qidThread.push(dw);
  return 0;
}
```

COM+ allocates several apartment threads where COM+ objects can be created. This type of model can provide for a multithreaded server where each individual object is single-threaded

- COM+ threading models 

    + threading models 
    single-threaded 
    apartment-threaded 
    neutral-threaded 
    free-threaded 
    
    + the single threaded server 

The single thread has one apartment where out-of-process calls to the COM+ server are serialized. Each out-of-process COM+ call is placed on the apartment's message queue. 

Creating an ATL server that uses the single-threaded model is simple. Create the ATL executable application using the ATL AppWizard. From the menu bar, select Insert, New ATL Object. Select Simple Object in theATL Object Wizard and click the Next button

        * eliminate the bottleneck 
        
You can create additional apartment threads so that individual objects can run simultaneously (apartment-threaded model) or you can allow multiple threads to exist in an apartment (free-threaded model).

- apartment threaded server 

This server type differs from the single-threaded server in that the COM+ server has one or more apartment threads (STAs).

Each object exists in only one apartment thread (STA), and incoming calls are still serialized on the apartment thread's message queue

objects running in separate apartment threads can share global data and run concurrently, global data may still have concurrent problem 

```
class CExeModule
  : public CComAutoThreadModule<CComSimpleThreadAllocator>
{
public:
  LONG Unlock();
  DWORD dwThreadID;
  HANDLE hEventShutdown;
  void MonitorShutdown();
  bool StartMonitor();
  bool bActivity;
};

LONG CExeModule::Unlock()
{
    LONG l = CComAutoThreadModule<CComSimpleThreadAllocator>::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown);
        // tell monitor that we transitioned to zero
    }

    return l;
}

class ATL_NO_VTABLE CATObject :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CATObject, &CLSID_ATObject>,
  public IDispatchImpl<IATObject, &IID_IATObject,
                       &LIBID_APARTMENTTHREADEDLib>
{
public:
  CATObject()
  {
  }

DECLARE_REGISTRY_RESOURCEID(IDR_ATOBJECT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

DECLARE_CLASSFACTORY_AUTO_THREAD()

BEGIN_COM_MAP(CATObject)
  COM_INTERFACE_ENTRY(IATObject)
  COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IATObject
public:
  STDMETHOD(get_Thread)(/*[out, retval]*/ long *pVal);
};
```

The apartment-threaded server exists so that legacy thread-unsafe COM+ objects can continue to exist without causing concurrency issues

- make your COM+ object thread-safe, I suggest you create your COM+ servers using the free-threaded threading model.

- the neutral-threaded server 

The neutral model supports execution of objects on any thread type. The benefit of neutral apartment threading is that it does not require the developer of objects running in a neutral apartment to make the object thread safe.

Activities span more than a single context and object, each context in a process belongs to just one activity. if the context does not belong to any activity, any thread in the apartment can enter the context. the apartment can be single thread or multithreaded.

- The free-threaded model does not use an apartment message queue to serialize incoming COM+ calls. This type of server enables incoming COM+ calls to call the methods directly on the incoming RPC thread

A free-threaded server is in the Freethreaded project. Each has one object that has one read-only property that returns the thread ID of the executing server thread. 

```
CRITICAL_SECTION cs;

DWORD WINAPI ThreadProc(void *p)
{
  Automation * object = (Automation *) p;
  long l = object->Get(L"Thread").lVal;
  ::EnterCriticalSection(&cs);
  std::cout << "Thread ID = " << l << "\t";
  ::LeaveCriticalSection(&cs);
  return 0;
}

int main(int argc, char* argv[])
{
  ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
  {
    std::vector<Automation> v;
    int i=0;
    for (i=0;i<10;i++)
    {
      Automation object;
      object.CreateObject(L"Singlethreaded.STObject");
      v.push_back(object);
    }
    for (i=0;i<10;i++)
    {
      Automation object;
      object.CreateObject(L"Apartmentthreaded.ATObject");
      v.push_back(object);
    }
    for (i=0;i<10;i++)
    {
      Automation object;
      object.CreateObject(L"Freethreaded.FTObject");
      v.push_back(object);
    }

    ::InitializeCriticalSection(&cs);
    std::vector<Automation>::iterator j = v.begin();
    for (;j!=v.end();j++)
    {
      DWORD dw;
      HANDLE thread = ::CreateThread(NULL, 0, ThreadProc,
                                     (void *)(Automation *)j, 0, &dw);
      ::CloseHandle(thread);
    }

    j = v.begin();
    for (;j!=v.end();j++)
    {
      DWORD dw;
      HANDLE thread = ::CreateThread(NULL, 0, ThreadProc,
                                     (void *)(Automation *)j, 0, &dw);
      ::CloseHandle(thread);
    }
    Sleep(10000);
    ::DeleteCriticalSection(&cs);
  }
  ::CoUninitialize();
  return 0;
}
```

All the objects in the single-threaded server are returning the same thread ID. Each individual object in the apartment-threaded server always returns the same thread ID; but distinct objects usually, although not always, have distinct thread IDs. The objects in the free-threaded server return random thread IDs.

Free-threaded objects do not exist in a single-threaded apartment. They exist in the multithreaded apartment (MTA) of the process. In an MTA, one or more threads share a common apartment, but there may only be one MTA in any process. the object in MTA need to resolve these concurrency issues.

a process that has an MTA can also have one or more STAs. This enables the programmer to create new thread-safe COM classes in an MTA 

- Thread synchronization 

    + Thread local storage (TLS) is a special storage type that limits access to one current thread.

    + a critical section object.

If you inherit from the CComCriticalSection or CComAutoCriticalSection class, ATL automatically implements a critical section object in your class

```
template <class ThreadModel> class CComObjectRootEx : public CComObjectRootBase
{
public:
  typedef ThreadModel _ThreadModel;
  typedef _ThreadModel::AutoCriticalSection _CritSec;
  typedef CComObjectLockT<_ThreadModel> ObjectLock;

  ULONG InternalAddRef()
  {
    ATLASSERT(m_dwRef != -1L);
    return _ThreadModel::Increment(&m_dwRef);
  }
  ULONG InternalRelease()
  {
    ATLASSERT(m_dwRef > 0);
    return _ThreadModel::Decrement(&m_dwRef);
  }

  void Lock() { m_critsec.Lock();}
  void Unlock() { m_critsec.Unlock();}
private:
  _CritSec m_critsec;
};
```

Microsoft has created multiple levels of typedefs to confuse the rest of us. This type of overdesign is sometimes called the Swiss Army Knife design pattern. 

    + The mutex kernel object enables you to create and manage access to a resource that cannot be guarded by critical sections. Resources that span process boundaries cannot be guarded by a critical section
    
```
class Pool
{
public:
  static DWORD WINAPI ThreadProc(void * p);
  int DoWork();
  Pool();
  virtual ~Pool();

private:
  static HANDLE sm_mutex;
  std::queue<DWORD> m_qidThread;

};

#define MYMESSAGE (WM_USER+1000)
#define NUMTHREADS 10

HANDLE Pool::sm_mutex;

Pool::Pool()
{
  sm_mutex = ::CreateMutex(NULL, FALSE, "MYMUTEX");
  for (int i=0;i<10;i++)
  {
    DWORD dw;
    HANDLE thread = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, &dw);
    ::CloseHandle(thread);
    m_qidThread.push(dw);
  }
}

Pool::~Pool()
{
  while (!m_qidThread.empty())
  {
    ::PostThreadMessage(m_qidThread.front(), WM_QUIT, 0, 0);
    m_qidThread.pop();
  }
  ::WaitForSingleObject(m_qidThread.front(), 5000 );
  ::CloseHandle(sm_mutex);
}

DWORD WINAPI Pool::ThreadProc(void *p)
{
  MSG msg;
  while (::GetMessage(&msg, NULL, 0, 0))
  {
    switch (msg.message)
    {
      case MYMESSAGE:
        //////////////////////////////////////
        // TODO
        // Add background processing code here
        //
        ::WaitForSingleObject(sm_mutex, INFINITE);
        std::cout << "Hello World! from Thread Number: "
                  << ::GetCurrentThreadId() << std::endl;
        ::ReleaseMutex(sm_mutex);
      default:
      break;
    };
  };
  return 0;
}

int Pool::DoWork()
{
  DWORD dw = m_qidThread.front();
  ::PostThreadMessage(dw, MYMESSAGE, 0, 0);
  m_qidThread.pop();
  m_qidThread.push(dw);
  return 0;
}
```
    
    + Semaphores and events are more complex kernel objects that limit access to resources. Semaphores are actually a more generalized implementation that enables the programmer to specify how many threads can have simultaneous access to a resource.

- COM and the registry 
```
class CRegistry
{

public:
    CRegistry();
    CRegistry( HKEY, const char * );
    ~CRegistry();

    BOOL Open( HKEY, const char * );
    BOOL Close( void );

    BOOL ReadDWORD( const char *, DWORD *, DWORD *pdwLastError = NULL );
    BOOL ReadString( const char *, LPVOID, int, DWORD *pdwLastError = NULL );

    BOOL WriteDWORD( const char *, DWORD, DWORD *pdwLastError = NULL );
    BOOL WriteString( const char *, LPVOID, DWORD *pdwLastError = NULL );
    BOOL Write( const char *, LPVOID, DWORD, int );

    void BuildList( const char *, CStringArray& );
    void StoreList( const char *, CStringArray& );

protected:
    HKEY m_hKey;
     DWORD m_dwLastError;

     BOOL Read( const char *, LPVOID );

     DWORD m_dwSize;

};
```

- regedit and regedit 32, two different editor 

regedit 

- com registry structure, use HKEY_CLASSES_ROOT  Six categories of information are included in this key:


    + File extensions, subkeys of the HKEY_CLASSES_ROOT key. 
HKEY_CLASSES_ROOT
     { .extension } = { prog-id }
     
COM should look to find the ProgID for the COM object type. After the ProgID is located, COM can determine the object CLSID. With the CLSID, COM can start an instance of the object and bind the file to the object.
 
int BuildFileExtensionKey(LPSTR szExtension,
                      LPSTR szProgId)
{
    CRegistry key(HKEY_CLASSES_ROOT, szExtension);
    key.SetValue(NULL, szProgId);
    return 0;
}
    + ProgIDs, are also subkeys of the HKEY_CLASSES_ROOT key. Because both file extensions and ProgIDs are subkeys of the same root key, it makes for quite a messy key. 
    
HKEY_CLASSES_ROOT
     { ModuleName.ObjectName } = Description
          CLSID = { class-id-as-guid }
          CurVer = { version-dependent-prog-id }
     { ModuleName.ObjectName.VersionNumber } = Description
          CLSID = { class-id-as-guid }

This listing uses two new APIs called StringFromCLSID() and WideCharToMultiByte(). StringFromCLSID() takes a GUID structure and converts it into a human-readable string. WideCharToMultiByte() 

COM provides two APIs that translate between ProgIDs and CLSIDs:
```
WINOLEAPI ProgIDFromCLSID (REFCLSID clsid, LPOLESTR FAR* lpszProgID);

WINOLEAPI CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);
```

        * ProgIDs syntax 

ModuleName.ObjectName.VersionNumber

        * Version-Independent ProgIDs, don't need to check the version 
ModuleName.ObjectName

    + AppIDs, subkeys of the key HKEY_CLASSES_ROOT\AppID.
    
HKEY_CLASSES_ROOT
APPID
{ app-id-as-guid }
    RemoteServerName = { DNS or UNC of server } // client machine only
    DLLSurrogate = { path\surrogate.exe or NULL for DllHost.exe }
    // server machine only
    LaunchPermission = REG_BINARY { self-relative security descriptor }
    AccessPermission = REG_BINARY { self-relative security descriptor }
    ActivateAtStorage = { Y or N }
    LocalService =
        ServiceParameters =
        RunAs = { none | "Interactive User" | user account }
            AuthenticationLevel =    


The AppID provides information on how to launch the COM server. COM servers can be configured to run remotely, with security, permissions, and as services.

        * Remote in-process servers 
        
        In order to launch in-process servers on remote machines, you must use a surrogate. DLLSurrogate value name is the executable that will serve as the surrogate. If empty, DCOM will use the default surrogate (DLLHost.exe). 
        
        set up an in-process server to run remotely, you must specify the DLLSurrogate value name on the server (remote) machine and the RemoteServerName value on the client (local) machine.
        
        * Remote out-of-process server 
        
        If the object has a RemoteServerName value name in the CLSID key, the object can be launched and accessed as a remote out-of-process server. The value is the location of the server where the server will be launched.
        
        * permission and security 
        
        COM enables you to set permissions for launching (LaunchPermission) and accessing (AccessPermission) objects on the local computer. 
        
```
/--------------------------
// RegSaveSecurityDescriptor
//--------------------------
int RegSaveSecurityDescriptor(PSECURITY_DESCRIPTOR pSD,
                              HKEY hkey, LPSTR szValueName)
{
    // convert the security descriptor to
    // self-relative security description
    PSECURITY_DESCRIPTOR pSRSD = NULL;
    DWORD cbSD = 0;
    if (!::MakeSelfRelativeSD(pSD, pSRSD, &cbSD))
    {
        DWORD dw = ::GetLastError();
        if( dw != ERROR_INSUFFICIENT_BUFFER )
        {
            std::cout << "Error ::MakeSelfRelativeSD "
                      << dw << endl;
            return 0;
        }
    }
     pSRSD = (PSECURITY_DESCRIPTOR) ::LocalAlloc(LPTR, cbSD);
     if (!::MakeSelfRelativeSD(pSD, pSRSD, &cbSD))
     {
         std::cout << "Error ::MakeSelfRelativeSD "
                   << ::GetLastError() << endl;
         return 0;
     }

     // save the self-relative security description
     // in the registry
     if (::RegSetValueEx(hkey, szValueName, 0, REG_BINARY,
                         (BYTE *)pSRSD, cbSD)!=ERROR_SUCCESS)
     {
         std::cout << "Error ::RegSetValueEx "
                   << ::GetLastError() << endl;
         g::LocalFree((HLOCAL) pSRSD);
         return 0;
     }

     if(pSRSD != NULL)
     {
         ::LocalFree((HLOCAL) pSRSD);
     }

     return 0;
}
```

save the security descriptor, you must call MakeSelfRelativeSD() to convert the absolute security descriptor into a self-relative security descriptor

        * Authentication
        
        * Remote activation 

Normally when you call IMoniker::BindToObject(), the object is created and loaded locally. 

When the ActivateAtStorage value is missing or set to N, the object will be created and loaded locally. 

If the ActivateAtStorage value is set to Y, however, COM will attempt to load the object on the machine on which it resides

        * objects as services, 

If a COM object wants to install itself as an NT service, it must set the LocalService registry entry with the service name. 
by setting ServiceParameters registry entry, the value will be passed as a parameter to the service.

        * identity 
        
Using the RunAs value, it is possible to launch an object's module into a process with the security context of another user.


        
    + CLSIDs, are subkeys of the key HKEY_CLASSES_ROOT\CLSID.
    
KEY_CLASSES_ROOT
    CLSID
    { class-id-as-guid } = Description
            AppID = { app-id-as-guid }
            ProgID = { ModuleName.ObjectName.VersionNumber }
            VersionIndependentProgID = { ModuleName.ObjectName }
            InprocServer32 = { mypath\mymodule.dll }
                ThreadingModel = { [no value] | Apartment | Free | Both }
            InprocHandler32 = { mypath\myhandler.dll }
            LocalServer32 = { mypath\mymodule.exe }
            DefaultIcon = { mypath\mymodule, resource id
            TypeLib = { type-library-id-as-guid }
}

configuring the CLSID system registry key 
```
int BuildCLSIDKey(CLSID clsid, LPSTR szDescription,
              LPSTR szProgID, LPSTR szProgIDVersionIndependent)
{
    // build the CLSID
    LPOLESTR olestr = NULL;
    LPSTR str = NULL;
    ::StringFromCLSID(clsid, &olestr);
    int i = ::WideCharToMultiByte(CP_ACP, 0, olestr, -1, str,
                                  0, NULL, NULL);
    str = new char[i+1];
    ::WideCharToMultiByte(CP_ACP, 0, olestr, -1, str,
                          i, NULL, NULL);

    // build the subkey
    LPSTR str2 = NULL;
    LPSTR strCLSID = "CLSID";
    str2 = new char[::lstrlen(strCLSID)+::lstrlen(str)+2];
    ::lstrcpy(str2, strCLSID);
    ::lstrcat(str2, "\\");
    ::lstrcat(str2, str);

    // set description
    CRegistry key(HKEY_CLASSES_ROOT, str2);
    key.SetValue(NULL, szDescription);
    delete[] str2;

    // build CLSID{ CLSID}\ProgID string
    LPSTR strProgID = "ProgID";
    str2 = new char[::lstrlen(strCLSID)+::lstrlen(str)
                   +::lstrlen(strProgID)+3];
    ::lstrcpy(str2, strCLSID);
    ::lstrcat(str2, "\\");
    ::lstrcat(str2, str);
    ::lstrcat(str2, "\\");
    ::lstrcat(str2, strProgID);
     // set progid
     CRegistry key2(HKEY_CLASSES_ROOT, str2);
     key2.SetValue(NULL, szProgID);
     delete[] str2;

     // build CLSID{ CLSID}\VersionIndependentProgID string
     LPSTR strProgIDV = "VersionIndependentProgID";
     str2 = new char[::lstrlen(strCLSID)+::lstrlen(str)
                    +::lstrlen(strProgIDV)+3];
     ::lstrcpy(str2, strCLSID);
     ::lstrcat(str2, "\\");
     ::lstrcat(str2, str);
     ::lstrcat(str2, "\\");
     ::lstrcat(str2, strProgIDV);

     // set version independent progid
     CRegistry key3(HKEY_CLASSES_ROOT, str2);
     key3.SetValue (NULL, szProgIDVersionIndependent);
     delete[] str2;

     delete[] str;

     return 0;
}
```

The CLSID key provides information as to how to launch the COM class. most important information in this key is the location values

        * location 

If the object has an InprocServer32 value name in the CLSID key, the object can be launched and accessed as an in-process server. The value is the location of the DLL (dynamic link library).

If the object has an InprocHandler32 value name in the CLSID key, the object uses the custom object handler (custom IMarshall interface). The value is the file location of the custom handler module. To use standard marshaling, set this value to OLE32.DLL.

If the object has a LocalServer32 value name in the CLSID key, the object can be launched and accessed as a local out-of-process server. 

The in-process handlers are used to register custom marshaling. The custom marshaling handler (the DLL) is loaded in-process in both the client and server processes

        * TypeLib setting, is the CLSID of the type library. The CLSID in turn can be found in the HKEY_CLASSES_ROOT\TypeLib key.

    + Interfaces are subkeys of the key HKEY_CLASSES_ROOT\Interface
    
HKEY_CLASSES_ROOT
    Interface
        { interface-as-guid } = Description
            ProxyStubClsid32 = { class-id-as-guid }
            TypeLib = { type-library-id-as-guid }

The DLLRegisterServer and DLLUnregisterServer functions in your marshaler should be coded to add and remove this registry key and its values. 

For standard or custom marshaling, we are interested in the CLSID of proxy-stub that implements the marshaling for this interface. For type library marshaling, we are interested in the CLSID of the type library.

        * Proxy-Stub

The ProxyStubClsid32 is the CLSID for the proxy-stub pair that will perform marshaling of the interface. 

        * type Library

The TypeLib is the CLSID for the type library that is registered in the TypeLib key.

    + TypeLibs are subkeys of the key HKEY_CLASSES_ROOT\TypeLib. 
    
HKEY_CLASSES_ROOT
    TypeLib
        { type-library-id-as-guid } = Description
            { major.minor } = Description
                { locale-id }
                     { platform } = { module }
                FLAGS = 0
                HELPDIR = { helppath }
                
The locale-id is a one- to four-digit hex string denoting the locale ID. A value of zero denotes the LANG_SYSTEM_DEFAULT(0) setting 

The platform is a string that can be win16, win32, mac, or other. 

The module can be a TLB (type library), a DLL, or an EXE.

        * RegisterTypeLib

The function RegisterTypeLib() will automatically create the TypeLib key. To invoke the function, you must first acquire a pointer to the ITypeLib object for the type library.

```
int MyRegisterTypeLib(LPOLESTR lpszModule,
                      LPOLESTR lpszHelpDir)
{
    ITypeLib* pTypeLib;
    HRESULT hr = ::LoadTypeLib(lpszModule, &pTypeLib);
     if (SUCCEEDED(hr))
     {
         ::RegisterTypeLib(pTypeLib, lpszModule, lpszHelpDir);
     }
     if (pTypeLib != NULL)
     {
         pTypeLib->Release();
     }
     return 0;
}
```

        * Flags

The following flags are available in the TypeLib structure:

    1—Restricted. You cannot view or use the type library.

    2—Control. Contains description of controls.

    4—Hidden. Users cannot view this type library, but it can be used by controls.

- HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Ole

HKEY_LOCAL_MACHINE
    SOFTWARE
        Microsoft
        Ole
                EnableDCOM = { Y or N }
            DefaultAccessPermission = REG_BINARY
                                 { self-relative security descriptor }
            DefaultLaunchPermission = REG_BINARY
                                 { self-relative security descriptor }
            LegacyAuthentication =
            LegacyImpersonation =
LegacySecureReferences = { Y or N }

    + Enabling and Disabling DCOM
    
    The DefaultLaunchPermission and DefaultAccessPermission values are used when a COM server does not provide values in its AppID key for the LaunchPermission and AccessPermission
    
    + Legacy security 
    
    COM+ provides values to set default security settings that apply to components that do not implement specific security in these areas.
   
    RPC_C_AUTHN_LEVEL_DEFAULT—Uses the authentication service's default authentication level.

    RPC_C_AUTHN_LEVEL_NONE—No authentication.

    RPC_C_AUTHN_LEVEL_CONNECT—Authenticates only at connection.

    RPC_C_AUTHN_LEVEL_CALL—Authenticates every call.

    RPC_C_AUTHN_LEVEL_PKT—Authenticates every packet.

    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY—Same as RPC_C_AUTHN_LEVEL_PKT and verifies that the data was not modified during transit.

    RPC_C_AUTHN_LEVEL_PKT_PRIVACY—Same as RPC_C_AUTHN_LEVEL_PKT_INTEGRITY and encrypts the packet.


    COM+ provides the capability for servers to take on the security context of other users by impersonating those users.  The LegacyImpersonation value enables you to limit the kinds of impersonation that servers can use. levels 
    
    Anonymous—No impersonation is allowed.

    Identify—No impersonation is allowed, except for checking client permissions.

    Impersonate—Impersonation is allowed, except when calling other objects.

    Delegate—Impersonation is allowed, even when calling other objects.

    LegacySecureReferences has the value Y, calls to AddRef() and Release() by objects that do not call CoInitializeSecurity() are secured.

- registering a COM+ server 

    + Regsvr32

The DllUnregisterServer and DllRegister functions are exported from the DLL.

    + steps

Calls LoadLibrary to load the module

Calls GetProcAddress to retrieve a function pointer for DllRegister or DllUnregister

Calls the DllRegister or DllUnregister function

Calls FreeLibrary

    + in-process servers use the DLLRegisterServer and DLLUnregisterServer to perform self-registration 
    
    Self-registering DLLs should include the string "OLESelfRegister" in its VERSIONINFO resource.

VS_VERSION_INFO VERSIONINFO
    ...
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4" // Lang=US English, CharSet=Windows Multilingual
        BEGIN
            ...
            VALUE "OLESelfRegister", "\0"
        END
        ...
    END
    ...
END

    + frameworks 

If you look at the MFC source code, you'll notice two functions called AfxOleRegisterServerClass() and AfxOleUnregisterServerClass() that provide some of the necessary functionality of registering and unregistering your COM servers. 

In ATL, you have two similar functions called AtlModuleRegisterServer() and AtlModuleUnregisterServer().

MFC has two functions to register type libraries, AfxOleRegisterTypeLib() and AfxOleUnregisterTypeLib(). 

ATL has a function, AtlModuleRegisterTypeLib(), that also helps in registering type libraries.

ATL also provides several mechanisms for embedding your .REG files as a resource in your module (DLL or EXE) and a function to invoke this functionality: AtlModuleUpdateRegistryFromResourceD().

- COM+ optimization, inheritance and aggregation 

in process c++ is fast than DCOM. So, why is DCOM six times or 20 microseconds slower? Y

the object server have to be remote or local to the client machine? Remember that in-process servers are about six times slower than equivalent C++. 

DCOM out-of-process servers are 2,000 times slower than equivalent C++.

Out-of-process servers are slow. But remote servers are even slower. 

- network cycles 

- mixed threading model 

COM+ classes didn't have to be thread-safe because all COM+ method calls were serialized through a Windows message queue. Because these legacy COM+ classes have no requirement to be thread-safe, COM+ must continue serializing calls to these legacy COM+ classes.

A problem does arise when the COM+ class is part of an in-process server. Because in-process COM+ objects exist in the apartment of the thread that created the object, the COM+ object might be created in a single-threaded or in a multithreaded apartment. The choice of threading model is determined by the calling client. 

COM+ resolve this problem by using registry value. If the threading model of the in-process COM+ server does not match that of the client, COM+ creates the object in a new apartment, thus forcing COM+ method calls to be marshaled between the apartments. This causes another performance problem when COM+ method calls are serialized on a message queue.

```
// controller.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "../cpp/cpp.h"
#include "../dcom/dcom.h"
#include "../dcom/dcom_i.c"
#include "../dcomserver/dcomserver.h"
#include "../dcomserver/dcomserver_i.c"

CRITICAL_SECTION cs;

DWORD WINAPI CppThread(void * p)
{
  DWORD dw = ::GetTickCount();
  for (int j=0;j<(int)((DWORD *)p)[0];j++)
  {
    CCpp * i = new CCpp();
    i->Hello();
    delete i;
  }
  dw = ::GetTickCount() - dw;
  ::EnterCriticalSection(&cs);
  std::cout << "\nCppThread ticks " << dw << std::endl;
  ::LeaveCriticalSection(&cs);
  return 0;
};

static IClassFactory * pclassfactory = NULL;
HRESULT GetUnknown(CLSID clsid, REFIID riid, IUnknown ** ppUnknown)
{
  if (pclassfactory==NULL)
  {
    ::CoGetClassObject(clsid, CLSCTX_ALL, NULL, IID_IClassFactory,
                       (void **)&pclassfactory);
    if( pclassfactory == NULL )
        return( -1 );
  }
  pclassfactory->CreateInstance(NULL, riid, (void **)ppUnknown);

  return S_OK;
};
DWORD WINAPI DComThreadServer(void * p)
{
  ::CoInitialize(NULL);
  DWORD dw = ::GetTickCount();
  for (int j=0;j<(*((DWORD *)p));j++)
  {
    ITestServer * i;
    GetUnknown (CLSID_TestServer, IID_ITestServer, (IUnknown **)&i);
    i->Hello();
    i->Release();
  }
  pclassfactory->Release();
  pclassfactory=NULL;
  dw = ::GetTickCount() - dw;
  ::EnterCriticalSection(&cs);
  std::cout << "\nDComThread server ticks " << dw << std::endl;
  ::LeaveCriticalSection(&cs);
  ::CoUninitialize();
  return 0;
};

DWORD WINAPI DComThread(void * p)
{
  ::CoInitialize(NULL);
  DWORD dw = ::GetTickCount();
  for (int j=0;j<(*((DWORD *)p));j++)
  {
    ITestObject * i;
    GetUnknown(CLSID_TestObject, IID_ITestObject, (IUnknown **)&i);
    i->Hello();
    i->Release();
  }
  pclassfactory ->Release();
  pclassfactory=NULL;
  dw = ::GetTickCount() - dw;
  ::EnterCriticalSection(&cs);
  std::cout << "\nDComThread ticks " << dw << std::endl;
  ::LeaveCriticalSection(&cs);
  ::CoUninitialize();
  return 0;
};

DWORD WINAPI DComThreadServer2(void * p)
{
  ::CoInitialize(NULL);
  DWORD dw = ::GetTickCount();
  for (int j=0;j<(*((DWORD *)p));j++)
  {
    ITestServer * i;
    GetUnknown(CLSID_TestServer, IID_ITestServer, (IUnknown **)&i);
    i->Hello();
    i->Release();
  }
  pclassfactory->Release();
  pclassfactory=NULL;
  dw = ::GetTickCount() - dw;
  ::EnterCriticalSection(&cs);
  std::cout << "\nOld DComThread server ticks " << dw << std::endl;
  ::LeaveCriticalSection(&cs);
  ::CoUninitialize();
  return 0;
};

DWORD WINAPI DComThread2(void * p)
{
  ::CoInitialize(NULL);
  DWORD dw = ::GetTickCount();
  for (int j=0;j<(*((DWORD *)p));j++)
  {
    ITestObject * i;
    GetUnknown (CLSID_TestObject, IID_ITestObject, (IUnknown **)&i);
    i->Hello();
    i->Release();
  }
  pclassfactory->Release();
  pclassfactory=NULL;
  dw = ::GetTickCount() - dw;
  ::EnterCriticalSection(&cs);
  std::cout << "\nOld DComThread ticks " << dw << std::endl;
  ::LeaveCriticalSection(&cs);
  ::CoUninitialize();
  return 0;
};

int main(int argc, char* argv[])
{

  ::InitializeCriticalSection(&cs);
  DWORD dw=0;
  DWORD times=10000;
  HANDLE handle;

  handle = ::CreateThread(NULL, 0, DComThread2, &times, 0, &dw);
  ::WaitForSingleObject(handle, INFINITE);
  ::CloseHandle (handle);

  handle = ::CreateThread(NULL, 0, DComThreadServer2, &times, 0, &dw);
  ::WaitForSingleObject(handle, INFINITE);
  ::CloseHandle(handle);

  handle = ::CreateThread(NULL, 0, DComThread, &times, 0, &dw);
  ::WaitForSingleObject(handle, INFINITE);
  ::CloseHandle(handle);

  handle = ::CreateThread(NULL, 0, DComThreadServer, &times, 0, &dw);
  ::WaitForSingleObject(handle, INFINITE);
  ::CloseHandle(handle);

  handle = ::CreateThread(NULL, 0, CppThread, &times, 0, &dw);
  ::WaitForSingleObject(handle, INFINITE);
  ::CloseHandle(handle);

  ::DeleteCriticalSection(&cs);


  return 0;
}
```

The five objects are native C++ objects (CppThread), in-process one-threading model (DComThread), out-of-process one-threading model (DComThreadServer), in-process mixed-threading model (DComThread2), and out-of-process mixed-threading model (DComThreadServer2).

- Remote activation 

The Service Control Manager (SCM) is responsible for launching local and remote COM+ servers. The SCM launches remote COM+ servers using the IRemoteActivation interface

```
interface IRemoteActivation
{
    HRESULT RemoteActivation(
     [in] handle_t                               hRpc,
     [in] ORPCTHIS                              *ORPCthis,
     [out] ORPCTHAT                             *ORPCthat,
     [in] GUID                                  *Clsid,
     [in, string, unique] WCHAR                 *pwszObjectName,
     [in, unique] MInterfacePointer             *pObjectStorage,
     [in] DWORD                                  ClientImpLevel,
     [in] DWORD                                  Mode,
     [in] DWORD                                  Interfaces,
     [in,unique,size_is(Interfaces)] IID        *pIIDs,
     [in] unsigned short                         cRequestedProtseqs,
     [in, size_is(cRequestedProtseqs)]
          unsigned short                         RequestedProtseqs[],
     [out] OXID                                 *pOxid,
     [out] DUALSTRINGARRAY                     **ppdsaOxidBindings,
     [out] IPID                                 *pipidRemUnknown,
     [out] DWORD                                *pAuthnHint,
     [out] COMVERSION                           *pServerVersion,
     [out] HRESULT                              *phr,
     [out,size_is(Interfaces)] MInterfacePointer **ppInterfaceData,
     [out,size_is(Interfaces)] HRESULT          *pResults
     );
}
```

The SCM on the client machine calls the SCM on the server machine by using this RemoteActivate() RPC function. The server SCM reads the Clsid parameter and creates a local COM object with the CLSID. The local COM object is queried for all the interfaces matching in the pIIDs array parameter. The server SCM returns an array of marshaled interfaces (ppInterfaceData).

The RemoteActivate() RPC function also returns an interface pointer identifier (IPID). 

The returned pipidRemUnknown parameter is the IPID of the IRemUnknown interface of the object.

The MInterfacePointer structure contains the marshaled interface pointers that are returned to the client machine. The SCM on the client machine can now refer to the remote object.

- Remote reference counting 

```
interface IRemUnknown : IUnknown
{
  HRESULT RemQueryInterface(
    [in] REFIPID ripid,
    [in] unsigned long cRefs,
    [in] unsigned short cIids,
    [in, size_is(cIids)] IID * iids,
    [out, size_is(cIids) REMQIRESULT ** ppQIResults);
  HRESULT RemAddRef(
    [in] unsigned short cInterfaceRefs,
    [in, size_is(cInterfaceRefs)] REMINTERFACEREF InterfaceRefs[],
    [out, size_is(cInterfaceRefs)] HRESULT * pResults);
  HRESULT RemRelease(
    [in] unsigned short cInterfaceRefs,
    [in, size_is(cInterfaceRefs)] REMINTERFACEREF InterfaceRefs[]);
}
```

Calls to IUnknown::AddRef() and IUnknown::Release() do not translate directly into calls to the IRemUnknown::RemAddRef() and IRemUnknown::RemRelease() methods. The standard proxy implementation does not issue a call to IRemUnknown::RemRelease() until all local references to all the objects IPIDs have been released.

Eventually, the COM+ server object will be released. The COM+ attempts to ping the client, and after a determined number of failed attempts, all references to the COM+ server object are released. 

how COM+ implements remote in-process servers. Remote in-process servers are implemented using surrogate processes.

- surrogate processes 

The surrogate process is started on the remote machine, and the in-process object is loaded into the surrogate's process space. 


The process can have a process and security context that are different from the caller process. Damage caused by bad and malicious programming that occurs in the in-process server is limited to the process space of the surrogate and can be prevented by limiting the security context of the surrogate.


The biggest disadvantages are speed (because out-of-process calls are slower than in-process calls) and the inability to share process memory space. Although in-process servers can be programmed to share process memory space with their caller, this is not possible when a surrogate is involved.


When using surrogates, you can use the standard surrogate or you can create a custom surrogate. 

    + To configure an in-process server to use a surrogate, set the RemoteServerName value in the AppID registry key on the client machine to the address or name of the remote server. 
    
    + To use the standard surrogate, set the DllSurrogate value in the AppID registry key on the server machine's registry to empty. 
    
    + To use a custom surrogate, set this same registry value to the path of your custom surrogate module


[HKEY_CLASSES_ROOT \ AppID \ { E7523002-4382-11D2-BEA2-00C04F8B72E7} ]
  = s 'inprocess'
[HKEY_CLASSES_ROOT \ AppID \ { E7523002-4382-11D2-BEA2-00C04F8B72E7} ]
  DllSurrogate = s ''
[HKEY_CLASSES_ROOT \ CLSID \ { E7523002-4382-11D2-BEA2-00C04F8B72E7} ]
  AppID = { E7523002-4382-11D2-BEA2-00C04F8B72E7}

- The default surrogate (DllHost.exe) is adequate for most object implementations. 

The default surrogate is not adequate when your in-process server requires access to global memory that is normally available only in the client process.

```
interface ISurrogate : IUnknown
{
  HRESULT LoadDllServer([in] REFCLSID clsid);
  HRESULT FreeSurrogate();
}
```

- IClassFactory

Most COM+ frameworks implement a class's IClassFactory class with boilerplate code hidden behind layers of macros

When you create COM+ objects, as with calls to the CoCreateInstance() or CoCreateInstanceEx() functions, you are in essence calling the IClassFactory::CreateInstance() method.

```
HRESULT CoCreateInstance(REFCLSID clsid, IUnknown * pUnkOuter,
  DWORD grfContext, REFIID iid, void * ppvObj)
{
  IClassFactory * pCF;
  HRESULT         hr = ::CoGetClassObject(clsid, grfContext,
                      NULL, IID_IClassFactory, (void **)&pCF);

  if (FAILED(hr))
  {
    return hr;
  }

  hr=pCF->CreateInstance(pUnkOuter, iid, (void **)ppv);
  pCF->Release();

  if (FAILED(hr))
  {
    *ppv = 0;
  }

  return hr;
}
```

With the class factory object, you can perform something that most believe is not possible in COM: implementation inheritance.

- inheritance 

interface inheritance is the IDispatch interface, which inherits the QueryInterface(), AddRef(), and Release() methods from the IUnknown interface.

COM+ classes that inherit an implementation from another COM+ class do not have access to the implementation data of the inherited class. COM does not support implementation inheritance.

    + Containment inheritance, a COM+ class reimplement the methods of the inherited class. These implementations would simply redirect calls to the contained COM+ class
    
    + Aggregation, Aggregation inheritance enables clients to call inherited methods directly. One disadvantage of this method is that the aggregated object's IUnknown methods must be integrated with the aggregator's IUnknown methods

    Another disadvantage is that only in-process servers can implement aggregation inheritance.
    
    Aggregation inheritance is accomplished using the IClassFactory interface. 
    
    All COM+ objects are created by calling this IClassFactory::CreateInstance() method. If the first parameter of the call to the IClassFactory::CreateInstance() method is NULL, the object being created will not be aggregated. If this same parameter is a pointer to an IUnknown, the object being created will be aggregated and delegate all calls to IUnknown methods to the alternate IUnknown interface.
    
    
```
interface IClassFactory : IUnknown
{
  HRESULT CreateInstance(IUnknown * punk,
    REFIID iid, void * * ppvobj);
  HRESULT LockServer(BOOL fLock);
}
```
    ATL classes can serve as aggregates as long as they do not define the DECLARE_NOT_AGGREGATABLE macro.
```
// MyAggregate.h : Declaration of the CMyAggregate

#ifndef __MYAGGREGATE_H_
#define __MYAGGREGATE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////
// CMyAggregate
class ATL_NO_VTABLE CMyAggregate :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CMyAggregate, &CLSID_MyAggregate>,
  public IDispatchImpl<IMyAggregate, &IID_IMyAggregate,
                       &LIBID_AGGREGATELib>
{
public:
  CMyAggregate()
  {
  }

DECLARE_REGISTRY_RESOURCEID(IDR_MYAGGREGATE)

BEGIN_COM_MAP(CMyAggregate)
  COM_INTERFACE_ENTRY(IMyAggregate)
  COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMyAggregate
public:
  STDMETHOD(Hello)();
};

#endif //__MYAGGREGATE _H_

//declare aggregate class 
// MyAggregator.h : Declaration of the CMyAggregator

#ifndef __MYAGGREGATOR_H_
#define __MYAGGREGATOR_H_

#include "resource.h"       // main symbols
#include "..\\aggregate\\aggregate.h"
/////////////////////////////////////////////////////////////////////////
// CMyAggregator
class ATL_NO_VTABLE CMyAggregator :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CMyAggregator, &CLSID_MyAggregator>,
  public IDispatchImpl<IMyAggregator, &IID_IMyAggregator,
                       &LIBID_AGGREGATORLib>
{
public:
  CMyAggregator()
  {
  }
  void FinalRelease()
  {
    m_pAggregateUnknown.Release();
  };

DECLARE_REGISTRY_RESOURCEID(IDR_MYAGGREGATOR)

BEGIN_COM_MAP(CMyAggregator)
  COM_INTERFACE_ENTRY(IMyAggregator)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(m_pAggregateUnknown.p,
                                          CLSID_MyAggregate)
END_COM_MAP()

CComPtr<IUnknown> m_pAggregateUnknown;

DECLARE_GET_CONTROLLING_UNKNOWN()

// IMyAggregator
public:
  STDMETHOD(MyHello)();
};

#endif //__ MYAGGREGATOR_H_
```

had to implement the CComObjectRootEx::FinalRelease() method to release the IUnknown of the aggregate. I added the COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND macro that automatically creates the aggregate object and interface pointers. I added a member variable for the aggregate IUnknown interface pointer. I added the DECLARE_GET_CONTROLLING_UNKNOWN macro to my aggregator's declaration. Finally, I included the aggregate_i.c source file to my aggregator implementation 
```
// MyAggregator.cpp : Implementation of CMyAggregator
#include "stdafx.h"
#include "aggregator.h"
#include "MyAggregator.h"
#include <iostream>

#include "..\\aggregate\\aggregate_i.c"

/////////////////////////////////////////////////////////////////////////
// CMyAggregator

STDMETHODIMP CMyAggregator::Hello()
{
  // TODO: Add your implementation code here
  std::cout << "This is the aggregator being called" << std::endl;

  return S_OK;
}
```

    + call the aggregate class 
```
#include <windows.h>
#include <iostream>
#include "aggregator\\aggregator.h"
#include "aggregator\\aggregator_i.c"
#include "aggregate\\aggregate.h"
#include "aggregate\\aggregate_i.c"

char s[1024];

HRESULT GetUnknown(WCHAR * strProgID, IUnknown ** ppUnknown)
{
  CLSID clsid;
  HRESULT hRes = ::CLSIDFromProgID(strProgID, &clsid);
  if (FAILED(hRes))
  {
    // CLSIDFromProgID failed
    std::cout << "CLSIDFromProgID failed = " << _ltoa(hRes, s, 16)
              << std::endl;
    ATLASSERT(FALSE);
    return hRes;
  }
  hRes = ::CoCreateInstance(clsid, NULL, CLSCTX_SERVER,
                              IID_IUnknown, (void **)ppUnknown);
  if (FAILED(hRes))
  {
    // CoCreateInstance failed
    std::cout << "CoCreateInstance failed = " << _ltoa(hRes, s, 16)
              << std::endl;
    ATLASSERT(FALSE);
    return hRes;
  }

  return S_OK;
};

HRESULT GetInterface(IUnknown * pUnknown, REFIID riid,
                     IUnknown ** ppUnknown)
{
  HRESULT hRes = pUnknown->QueryInterface(riid, (void **)ppUnknown);
  if (FAILED(hRes))
  {
    // QueryInterface failed
    std::cout << "QueryInterface failed = " << _ltoa(hRes, s, 16)
              << std::endl;
    ATLASSERT(FALSE);
    return hRes;
  }

  return S_OK;
};

int main ()
{
  CoInitialize(NULL);
  std::cout << "Start" << std::endl;

  IUnknown * pUnknown;
  HRESULT hRes = GetUnknown(L"MyAggregator.MyAggregator.1",
                               &pUnknown);
  if (FAILED(hRes))
  {


    CoUninitialize();

    // GetUnknown failed
    return hRes;
  }
IMyAggregator * p_tor;
  hRes = GetInterface(pUnknown, IID_IMyAggregator,
                                         (IUnknown **)&p_tor);
  if (FAILED(hRes))
  {
    pUnknown->Release();
    CoUninitialize();
    // GetInterface failed
    return hRes;
  }
  p_tor->Hello();

  IMyAggregate * p_te;
  hRes = GetInterface(pUnknown, IID_IMyAggregate, (IUnknown **)&p_te);
  if (FAILED(hRes))
  {
    // GetInterface failed
    return hRes;
  }
  p_te->Hello();

  std::cout << "End" << std::endl;
  p->Release();
  pUnknown->Release();
  CoUninitialize();
  return 0;
}
```
it acquires a pointer to its IMyAggregate object. This interface was acquired just as any nonaggregate interface would have been acquired.

COM actually acquired that interface pointer from the aggregated object.

- object create is much expensive than method calls 
- Using NT services 

    + example, switch desktop 
#include <windows.h>

HDESK hDesktopOrig = NULL;
HDESK hDesktop = NULL;
DWORD WINAPI ThreadProc(void * p)
{
  ::MessageBox(NULL, "This is on the desktop", "Hey", MB_OK);
  return 0;
}
DWORD WINAPI AlternateDesktopThreadProc(void * p)
{
  ::SetThreadDesktop(hDesktop);
  ::MessageBox(NULL, "This is on an alternate desktop", "Hey", MB_OK);
  ::MessageBox(NULL, "To switch desktops", "Click OK", MB_OK);
  ::SwitchDesktop(hDesktopOrig);
  return 0;
}
int main()
{
  hDesktopOrig = ::GetThreadDesktop(::GetCurrentThreadId());
  DWORD dw;
  HANDLE hThread = ::CreateThread(NULL, 0, ThreadProc, NULL, NULL, &dw);
  hDesktop = ::CreateDesktop("MyDesktop", NULL, NULL, 0,
    DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_SWITCHDESKTOP, NULL);
  HANDLE hAltThread = ::CreateThread(NULL, 0, AlternateDesktopThreadProc,
                                     NULL, NULL, &dw);
  ::MessageBox(NULL, "To switch desktops", "Click OK", MB_OK);
  ::SwitchDesktop(hDesktop);
  ::MessageBox(NULL, "To shutdown this app", "Click OK", MB_OK);
  ::CloseHandle(hAltThread);
  ::CloseHandle(hThread);
  ::CloseDesktop (hDesktop);
  return 0;
}

    + A server application running as a service can do so using a unique service account for remote administration and control. 
    
    In the Win32 API, a service is an executable object about which information is installed in a registry database maintained by the service control manager. 
    
    + The only other method of communicating with a process is using IPC (Inter-Process Communication). Creating an IPC protocol tends to be more difficult than creating a GUI front end, and that is why services have been more difficult to communicate with than most processes. 
    
- Service anatomy 

how to initializate a service, is how to register the service's ServiceMain

```
void WINAPI ServiceMain(DWORD argc, LPTSTR * argv);
int WINAPI main(int argc, char * arg[])
{
  if ((argc==2) && (::strcmp(arg[1]+1, "Service")==0))
  {
    InstallAService(_T("MyBigService"));
    return 0;
  }
  SERVICE_TABLE_ENTRY servicetableentry[] =
  {
    { _T("MyBigService"), ServiceMain },
    { NULL, NULL }
  };
  ::StartServiceCtrlDispatcher(servicetableentry);
  return 0;
}

typedef struct _SERVICE_TABLE_ENTRY
{
  LPTSTR lpServiceName;
  LPSERVICE_MAIN_FUNCTION lpServiceProc;
} SERVICE_TABLE_ENTRY, *LPSERVICE_TABLE_ENTRY;
```

The StartServiceCtrlDispatcher() function registers the ServiceMain() routine with the SCM. The SCM then calls this ServiceMain() function to start the service.

This structure _SERVICE_TABLE_ENTRY is the input parameter to the StartServiceCtrlDispatcher() function. 

how the ServiceMain() function might be implemented

```
SERVICE_STATUS servicestatus;
SERVICE_STATUS_HANDLE servicestatushandle;
void WINAPI ServiceCtrlHandler(DWORD dwControl);
void WINAPI ServiceMain(DWORD argc, LPTSTR * argv)
{
  servicestatus.dwServiceType = SERVICE_WIN32;
  servicestatus.dwCurrentState = SERVICE_START_PENDING;
  servicestatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
  servicestatus.dwWin32ExitCode = 0;
  servicestatus.dwServiceSpecificExitCode = 0;
  servicestatus.dwCheckPoint = 0;
  servicestatus.dwWaitHint = 0;

  servicestatushandle =
    ::RegisterServiceCtrlHandler(_T("MyBigService"), ServiceCtrlHandler);
  if (servicestatushandle == (SERVICE_STATUS_HANDLE)0)
  {
    // If RegisterServiceCtrlHandler fails, the
    // handle does not have to be closed.
    return;
  }

  BOOL bInitialized = false;
  // Initialize the service
  // ...
  // In this section, if initialization
  // is successful then bInitialized = true;

  servicestatus.dwCheckPoint = 0;
  servicestatus.dwWaitHint = 0;
  if (!bInitialized)
  {
    servicestatus.dwCurrentState = SERVICE_STOPPED;
    servicestatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    servicestatus.dwServiceSpecificExitCode = 1;
  }
  else
  {
    servicestatus.dwCurrentState = SERVICE_RUNNING;
  }
  ::SetServiceStatus(servicestatushandle, &servicestatus);
  return;
}
```

- service type member can have the following values 
typedef struct _SERVICE_STATUS
{
  DWORD dwServiceType;
  DWORD dwCurrentState;
  DWORD dwControlsAccepted;
  DWORD dwWin32ExitCode;
  DWORD dwServiceSpecificExitCode;
  DWORD dwCheckPoint;
  DWORD dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;


- service dwServiceType can have following values 

SERVICE_WIN32_OWN_PROCESS—There is one service in this process.

SERVICE_WIN32_SHARE_PROCESS—There are more than one services in this process.

SERVICE_KERNEL_DRIVER—The process is a device driver.

SERVICE_FILE_SYSTEM_DRIVER—The process is a file system driver.

SERVICE_INTERACTIVE_PROCESS—The process will interact with the desktop (should the process become active).







# Component Management and Transactions 


# Asynchronous Component Programming 





















































