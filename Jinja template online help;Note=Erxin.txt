Jinja template online help;Note=Erxin

# introduction
- jinja is a modern designer-friendly templating language for python. modelled after django's templates. 

https://jinja.palletsprojects.com/en/2.11.x/

- features 

sandboxed execution

powerful automatic HTML escaping system for XSS prevention

template inheritance

compiles down to the optimal python code just in time

optional ahead-of-time template compilation

easy to debug. Line numbers of exceptions directly point to the correct line in the template.

configurable syntax

- version 2.11.2 


# introduction 
- prerequisties 
- installation 
- basic API usage 


# API 

# Sandbox 
- The Jinja sandbox can be used to render untrusted templates.

```
from jinja2.sandbox import SandboxedEnvironment
env = SandboxedEnvironment()
func = lambda: "Hello, Sandbox!"
env.from_string("{{ func() }}").render(func=func)
'Hello, Sandbox!'
env.from_string("{{ func.__code__.co_code }}").render(func=func)
Traceback (most recent call last):
  ...
SecurityError: access to attribute '__code__' of 'function' object is unsafe.
```


# Native python types 
- The default Environment renders templates to strings. With NativeEnvironment, rendering a template produces a native Python types

```
env = NativeEnvironment()
t = env.from_string('{{ x + y }}')
result = t.render(x=4, y=2)
print(result)
6
print(type(result))
int


t = env.from_string('[{% for item in data %}{{ item + 1 }},{% endfor %}]')
result = t.render(data=range(5))
print(result)
[1, 2, 3, 4, 5]
print(type(result))


class Foo:
    def __init__(self, value):
        self.value = value

result = env.from_string('{{ x }}').render(x=Foo(15))
print(type(result).__name__)
Foo
print(result.value)
15
```

- reference 
https://jinja.palletsprojects.com/en/3.1.x/nativetypes/#api



# Template designer document 
- synopsis, Jinja can generate any text-based format (HTML, XML, CSV, LaTeX, etc.). A Jinja template doesn’t need to have a specific extension: .html, .xml, or any other extension is just fine

- delimiters 
```
{% ... %} for Statements

{{ ... }} for Expressions to print to the template output

{# ... #} for Comments not included in the template output

#  ... ## for Line Statements
```

- example 

<!DOCTYPE html>
<html lang="en">
<head>
    <title>My Webpage</title>
</head>
<body>
    <ul id="navigation">
    {% for item in navigation %}
        <li><a href="{{ item.href }}">{{ item.caption }}</a></li>
    {% endfor %}
    </ul>

    <h1>My Webpage</h1>
    {{ a_variable }}

    {# a comment #}
</body>
</html>

- variable 
{{ foo.bar }}
{{ foo['bar'] }}

- implementation 
    + foo.bar does following things on python layer 
    
check for an attribute called bar on foo (getattr(foo, 'bar'))

if there is not, check for an item 'bar' in foo (foo.__getitem__('bar'))

if there is not, return an undefined object.

    + foo['bar'] works mostly the same with a small difference in sequence 
    
check for an item 'bar' in foo. (foo.__getitem__('bar'))

if there is not, check for an attribute called bar on foo. (getattr(foo, 'bar'))

if there is not, return an undefined object.

- filters, pipe symbol (|) and may have optional arguments in parentheses

 {{ name|striptags|title }} will remove all HTML Tags from variable name and title-case the output (title(striptags(name)))
 
 {{ listx|join(', ') }} will join a list with commas (str.join(', ', listx)).
 
    + built in filters, https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters
    
abs()

float()

lower()

round()

tojson()

attr()

forceescape()

map()

safe()

trim()

batch()

format()

max()

select()

truncate()

capitalize()

groupby()

min()

selectattr()

unique()

center()

indent()

pprint()

slice()

upper()

default()

int()

random()

sort()

urlencode()

dictsort()

join()

reject()

string()

urlize()

escape()

last()

rejectattr()

striptags()

wordcount()

filesizeformat()

length()

replace()

sum()

wordwrap()

first()

list()

reverse()

title()

xmlattr()

- tests, add is plus the name, return true/false, If the test only takes one argument, you can leave out the parentheses

{% if loop.index is divisibleby 3 %}
{% if loop.index is divisibleby(3) %}

- comments {# ... #}

- white control

    + default 
    
a single trailing newline is stripped if present

other whitespace (spaces, tabs, newlines etc.) is returned unchanged

    + configures Jinja to trim_blocks, the first newline after a template tag is removed automatically (like in PHP).
    
    + manually disable the lstrip_blocks behavior by putting a plus sign (+) at the start of a block

<div>
        {%+ if something %}yay{% endif %}
</div>

    + manually trip whitespaces, add a minus sign (-) %- to the start or end of a block (e.g. a For tag), a comment, or a variable expression, the whitespaces before or after that block will be removed 
    
{% for item in seq -%}
    {{ item }}
{%- endfor %}

- escaping 

The easiest way to output a literal variable delimiter ({{) is by using a variable expression:

{{ '{{' }}

raw syntax 

{% raw %}
    <ul>
    {% for item in seq %}
        <li>{{ item }}</li>
    {% endfor %}
    </ul>
{% endraw %}

- line statements, If line statements are enabled by the application, it’s possible to mark a line as a statement. 
<ul>
# for item in seq
    <li>{{ item }}</li>
# endfor
</ul>

<ul>
{% for item in seq %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

Line statements can span multiple lines if there are open parentheses, braces or brackets

line-comment prefix is configured to be ##

- template inheritance 
    + basic 
    
<!DOCTYPE html>
<html lang="en">
<head>
    {% block head %}
    <link rel="stylesheet" href="style.css" />
    <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
</head>
<body>
    <div id="content">{% block content %}{% endblock %}</div>
    <div id="footer">
        {% block footer %}
        &copy; Copyright 2008 by <a href="http://domain.invalid/">you</a>.
        {% endblock %}
    </div>
</body>
</html>

    + child template will fill the empty blocks 
    
A child template might look like this:

{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    <style type="text/css">
        .important { color: #336699; }
    </style>
{% endblock %}
{% block content %}
    <h1>Index</h1>
    <p class="important">
      Welcome to my awesome homepage.
    </p>
{% endblock %}

    + You can access templates in subdirectories with a slash:

{% extends "layout/default.html" %}

    + print a block multiple times 
    
<title>{% block title %}{% endblock %}</title>
<h1>{{ self.title() }}</h1>
{% block body %}{% endblock %}

    + render parent block at the child with calling super()
    
{% block sidebar %}
    <h3>Table Of Contents</h3>
    ...
    {{ super() }}
{% endblock %}

- nesting extends 

# parent.tmpl
body: {% block body %}Hi from parent.{% endblock %}

# child.tmpl
{% extends "parent.tmpl" %}
{% block body %}Hi from child. {{ super() }}{% endblock %}

# grandchild1.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild1.{% endblock %}

# grandchild2.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild2. {{ super.super() }} {% endblock %}

- named block end-tags 

{% block sidebar %}
    {% block inner_sidebar %}
        ...
    {% endblock inner_sidebar %}
{% endblock sidebar %}

- block nesting and scope, default blocks may not access variables from outer scopes 

{% for item in seq %}
    <li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}

explicitly specify that variables are available in a block by setting the block to “scoped”
{% for item in seq %}
    <li>{% block loop_item scoped %}{{ item }}{% endblock %}</li>
{% endfor %}
When overriding a block, the scoped modifier does not have to be provided.

- template objects passed in the template context, you can extend from that object as well. Assuming the calling code passes a layout template as layout_template to the environment, this code works:

{% extends layout_template %}

- html escaping 

manually escaping each variable; or

automatically escaping everything by default.

Escaping everything except for safe values will also mean that Jinja is escaping variables known to not include HTML

    + manual escaping 
    
{{ user.username|e }}

    + automatic escaping,  automatic escaping is enabled, everything is escaped by default except for values explicitly marked as safe
    
marked as safe either in:

The context dictionary by the application with markupsafe.Markup

The template, with the |safe filter.

- list of control structures, appear inside {% ... %} blocks.

    + for 
    
<h1>Members</h1>
<ul>
{% for user in users %}
  <li>{{ user.username|e }}</li>
{% endfor %}
</ul>

        * special variables for for-loop block 
        
loop.index, The current iteration of the loop. (1 indexed)

loop.index0, The current iteration of the loop. (0 indexed)

loop.revindex, The number of iterations from the end of the loop (1 indexed)

loop.revindex0, The number of iterations from the end of the loop (0 indexed)

loop.first, True if first iteration.

loop.last, True if last iteration.

loop.length, The number of items in the sequence.

loop.cycle, A helper function to cycle between a list of sequences. See the explanation below.

loop.depth, Indicates how deep in a recursive loop the rendering currently is. Starts at level 1

loop.depth0, Indicates how deep in a recursive loop the rendering currently is. Starts at level 0

loop.previtem, The item from the previous iteration of the loop. Undefined during the first iteration.

loop.nextitem, The item from the following iteration of the loop. Undefined during the last iteration.

loop.changed(*val), True if previously called with a different value (or not called at all).

        * recursive loop 
        
a sitemap with recursive loops:

<ul class="sitemap">
{%- for item in sitemap recursive %}
    <li><a href="{{ item.href|e }}">{{ item.title }}</a>
    {%- if item.children -%}
        <ul class="submenu">{{ loop(item.children) }}</ul>
    {%- endif %}</li>
{%- endfor %}
</ul>

    + if statement 
    
{% if users %}
<ul>
{% for user in users %}
    <li>{{ user.username|e }}</li>
{% endfor %}
</ul>
{% endif %}

    + macros are comparable with functions in regular programming 
    
{% macro input(name, value='', type='text', size=20) -%}
    <input type="{{ type }}" name="{{ name }}" value="{{
        value|e }}" size="{{ size }}">
{%- endmacro %}

The macro can then be called like a function in the namespace:

<p>{{ input('username') }}</p>
<p>{{ input('password', type='password') }}</p>
    
    + call,  pass a macro to another macro. 
{% macro render_dialog(title, class='dialog') -%}
    <div class="{{ class }}">
        <h2>{{ title }}</h2>
        <div class="contents">
            {{ caller() }}
        </div>
    </div>
{%- endmacro %}

{% call render_dialog('Hello World') %}
    This is a simple dialog rendered by using a macro and
    a call block.
{% endcall %}

    + filters, apply regular Jinja filters on a block of template data.

{% filter upper %}
    This text becomes uppercase
{% endfilter %}

    + assignments, assign values to variables 
    
Assignments use the set tag and can have multiple targets:

{% set navigation = [('index.html', 'Index'), ('about.html', 'About')] %}
{% set key, value = call_something() %}

    + scoping behavior, it is not possible to set variables inside a block and have them show up outside of it.

; not possible to do this 
{% set iterated = false %}
{% for item in seq %}
    {{ item }}
    {% set iterated = true %}
{% endfor %}
{% if not iterated %} did not iterate {% endif %}


Instead use alternative constructs like the loop else block or the special loop variable:

{% for item in seq %}
    {{ item }}
{% else %}
    did not iterate
{% endfor %}

- block assignments, 2.8+ support capture the contents of a block into a variable 

{% set navigation %}
    <li><a href="/">Index</a>
    <li><a href="/downloads">Downloads</a>
{% endset %}
The navigation variable then contains the navigation HTML source.

- extends, The extends tag can be used to extend one template from another.

- include is useful to include a template and return the rendered contents of that file into the current namespace:

{% include 'header.html' %}
    Body
{% include 'footer.html' %}

    + list of templates 
    
the templates exist, otherwise it will raise an exception.

Example:

{% include ['page_detailed.html', 'page.html'] %}
{% include ['special_sidebar.html', 'sidebar.html'] ignore missing %}

- import context behavior, included templates are passed the current context and imported templates are not. imports are different from include templates 

two examples:

{% from 'forms.html' import input with context %}
{% include 'header.html' without context %}

- expressions 

literals 
```
42 / 123_456
Integers are whole numbers without a decimal part. The ‘_’ character can be used to separate groups for legibility.
```

math 

comparisons 

logics 

other operators 

if expression 
```
{% extends layout_template if layout_template is defined else 'default.html' %}
```

python methods
```
{{ page.title.capitalize() }}
```
 

- builtin tests 

boolean()

even()

integer()

ne()

string()

callable()

false()

iterable()

none()

true()

defined()

float()

le()

number()

undefined()

divisibleby()

ge()

lower()

odd()

upper()

eq()

gt()

lt()

sameas()

escaped()

in()

mapping()

sequence()

- builtin filters 

abs()

forceescape()

map()

select()

unique()

attr()

format()

max()

selectattr()

upper()

batch()

groupby()

min()

slice()

urlencode()

capitalize()

indent()

pprint()

sort()

urlize()

center()

int()

random()

string()

wordcount()

default()

items()

reject()

striptags()

wordwrap()

dictsort()

join()

rejectattr()

sum()

xmlattr()

escape()

last()

replace()

title()

filesizeformat()

length()

reverse()

tojson()

first()

list()

round()

trim()

float()

lower()

safe()

truncate()

- builtin tests 

List of Builtin Tests
boolean()

even()

in()

mapping()

sequence()

callable()

false()

integer()

ne()

string()

defined()

filter()

iterable()

none()

test()

divisibleby()

float()

le()

number()

true()

eq()

ge()

lower()

odd()

undefined()

escaped()

gt()

lt()

sameas()

upper()

- list of global functions 

jinja-globals.range([start, ]stop[, step])

jinja-globals.lipsum(n=5, html=True, min=20, max=100)¶
Generates some lorem ipsum for the template. By default, five paragraphs of HTML are generated with each paragraph between 20 and 100 words. If html is False, regular text is returned.

jinja-globals.dict(\**items)
A convenient alternative to dict literals. {'foo': 'bar'} is the same as dict(foo='bar').

class jinja-globals.cycler(\*items)
Cycle through values by yielding them one at a time, then restarting once the end is reached.
```
{% set row_class = cycler("odd", "even") %}
<ul class="browser">
{% for folder in folders %}
  <li class="folder {{ row_class.next() }}">{{ folder }}
{% endfor %}
{% for file in files %}
  <li class="file {{ row_class.next() }}">{{ file }}
{% endfor %}
</ul>
```

class jinja-globals.joiner(sep=', ')
A tiny helper that can be used to “join” multiple sections.
```
{% set pipe = joiner("|") %}
{% if categories %} {{ pipe() }}
    Categories: {{ categories|join(", ") }}
{% endif %}
{% if author %} {{ pipe() }}
    Author: {{ author() }}
{% endif %}
{% if can_edit %} {{ pipe() }}
    <a href="?action=edit">Edit</a>
{% endif %}
```

class jinja-globals.namespace(...)
Creates a new container that allows attribute assignment using the {% set %} tag:
```
{% set ns = namespace() %}
{% set ns.foo = 'bar' %}
```

- Extensions 
i10n, If the i18n Extension is enabled, it’s possible to mark text in the template as translatable. To mark a section as translatable, use a trans block:

```
{% trans %}Hello, {{ user }}!{% endtrans %}

{% trans user=user.username %}Hello, {{ user }}!{% endtrans %}
```




# Extensions 
- reference 
https://jinja.palletsprojects.com/en/2.11.x/extensions/#adding-extensions

- i18n 

https://jinja.palletsprojects.com/en/2.11.x/extensions/#i18n-extension

mark a section as translatable, use a trans block:
```
{% trans %}Hello, {{ user }}!{% endtrans %}

{% trans book_title=book.title, author=author.name %}
This is {{ book_title }} by {{ author }}
{% endtrans %}

{% trans count=list|length %}
There is {{ count }} {{ name }} object.
{% pluralize %}
There are {{ count }} {{ name }} objects.
{% endtrans %}
```

context can be passed to the trans tag to use pgettext and npgettext.
```
_(message): Alias for gettext.

gettext(message): Translate a message.

ngettext(singluar, plural, n): Translate a singular or plural message based on a count variable.

pgettext(context, message): Like gettext(), but picks the translation based on the context string.

npgettext(context, singular, plural, n): Like npgettext(), but picks the translation based on the context string.
```

print a translated string like this:

{{ _("Hello, World!") }}

use the format filter.

{{ _("Hello, %(user)s!")|format(user=user.username) }}


- expression statement 

If the expression-statement extension is loaded, a tag called do is available that works exactly like the regular variable expression ({{ ... }}); except it doesn’t print anything. 
```
{% do navigation.append('a string') %}
```

- loop controls 

a loop that skips every second item:
```
{% for user in users %}
    {%- if loop.index is even %}{% continue %}{% endif %}
    ...
{% endfor %}
```

a loop that stops processing after the 10th iteration:
```
{% for user in users %}
    {%- if loop.index >= 10 %}{% break %}{% endif %}
{%- endfor %}
```
- debug statement 

<pre>{% debug %}</pre>

Debug Extension is enabled, a {% debug %} tag will be available to dump the current context as well as the available filters and tests. 


- with statement 

The with statement makes it possible to create a new inner scope. Variables set within this scope are not visible outside of the scope.

```
{% with %}
    {% set foo = 42 %}
    {{ foo }}           foo is 42 here
{% endwith %}
foo is not visible here any longer
```

In particular in newer Jinja versions the following code always refers to the variable a from outside the with block:
```
{% with a={}, b=a.attribute %}...{% endwith %}
```

- autoescape overrides, If you want you can activate and deactivate the autoescaping from within the templates.

{% autoescape true %}
    Autoescaping is active within this block
{% endautoescape %}

{% autoescape false %}
    Autoescaping is inactive within this block
{% endautoescape %}




# Integration 
Flask 
Django
Babel, https://babel.readthedocs.io/en/latest/intro.html 
```
the project needs a Jinja section in its Babel extraction method mapping file:

[jinja2: **/templates/**.html]
encoding = utf-8
```

Pylons, https://pylonsproject.org/



# Switching from other template engines 
Django
Mako



# Tips and tricks 
- Without a doubt you should try to remove as much logic from templates as possible. 
- Jinja provides a feature that can be enabled to escape HTML syntax in rendered templates. 
- Usually child templates extend from one template that adds a basic HTML skeleton. However it’s possible to put the extends tag into an if tag to only extend from the layout template 
```
{% if not standalone %}{% extends 'default.html' %}{% endif -%}
<!DOCTYPE html>
<title>{% block title %}The Page Title{% endblock %}</title>
<link rel="stylesheet" href="style.css" type="text/css">
{% block body %}
  <p>This is the page body.</p>
{% endblock %}
```

- alternating rows 
you can use the cycle method on the loop object:
```
<ul>
{% for row in rows %}
  <li class="{{ loop.cycle('odd', 'even') }}">{{ row }}</li>
{% endfor %}
</ul>
```

# Frequently asked questions 

```
{% set navigation_bar = [
    ('/', 'index', 'Index'),
    ('/downloads/', 'downloads', 'Downloads'),
    ('/about/', 'about', 'About')
] -%}
{% set active_page = active_page|default('index') -%}
...
<ul id="navigation">
{% for href, id, caption in navigation_bar %}
  <li{% if id == active_page %} class="active"{% endif %}>
  <a href="{{ href|e }}">{{ caption|e }}</a></li>
{% endfor %}
</ul>
...
```

- accessing the parent loop, have access to an outer loop it’s possible to alias it:

```
<table>
{% for row in table %}
  <tr>
  {% set rowloop = loop %}
  {% for cell in row %}
    <td id="cell-{{ rowloop.index }}-{{ loop.index }}">{{ cell }}</td>
  {% endfor %}
  </tr>
{% endfor %}
</table> 
```















