Professional C++, 4th Edition=Marc Gregoire;Note=Erxin

# Introduction
- recommend websites 

www.cppreference.com

www.cplusplus.com/reference/

- how to create a project with visual studio 

    + Visual C++ 2017 does not yet automatically enable C++17 features.
    
    right-click project and click Properties. go to Configuration Properties -> C/C++ -> Language and set the C++ Language Standard option to "ISO C++ 17 Standard" or "ISO C++ Latest Draft Standard"
    
    we can also change the C level standard too
    
    + enable or disable the precompile header base on your code base. Use it as much as possible 
    
    Project | Properties | C/C++ Precompiled Headers | "Not using precompiled headers"
    
- GCC, create your source files with any text editors and same them to a directory, open a terminal and run command 

$ gcc -lstdc++ -std=c++17 -o <executable_name> <source1.cpp> [source2.cpp …]

- source code used in this book is available for download at www.wiley.com/go/proc++4e.

- book list available at http://www.wrox.com/misc-pages/booklist.shtml.

- common preprocessor directives 

```
#include <file>

#define <key> [value]

#ifdef <key>

#endif 

# pragma <xyz>      //xyz is compiler dependent, often allows the programmer to display a warning or error 
```

avoid multiple include 
```
#ifndef MYHEADER_H
#define MYHEADER_H
// … the contents of this header file
#endif
```

equal to 
```
#pragma once
// … the contents of this header file
```

- the main() function 
```
int main(int argc, char* argv[])
```

- quoted string text 

\n 	new line
\r 	carriage return
\t 	tab
\\ 	backslash character
\" 	quotation mark 

    + i/o streams 

std::cout << "There are " << 219 << " ways I love you." << std::endl;

- namespaces 

namespace mycode {
    void foo();
}

```
#include "namespaces.h"

using namespace mycode;

int main()
{
    foo();  // Implies mycode::foo();
    return 0;
}
```

    + cpp17, nested namespace 
    
namespace MyLibraries {
    namespace Networking {
        namespace FTP {
            /* … */
        }
    }
}

to 

namespace MyLibraries::Networking::FTP {
    /* … */
}

- literals 

Decimal literal, 123
Octal literal, 0173
Hexadecimal literal, 0x7B
Binary literal, 0b1111011

A floating-point value (such as 3.14f)
A double floating-point value (such as 3.14)
A single character (such as 'a')
A zero-terminated array of characters (such as "character array")

A digits separator is a single quote character. For example,
23'456'789
0.123'456f

    + cpp17, hexadecimal floating point literals 
    
0x3.ABCp-10, 0Xb.cp12l.

- variables 
int uninitializedInt;
int initializedInt = 7;
cout << uninitializedInt << " is a random value" << endl;
cout << initializedInt << " was assigned an initial value" << endl;

    + cpp 17 std byte, before we have to use char, or unsigned char 
std::byte 

- operators 

```
=
!
+ 
- 
* 
/
% //mod
++ 
--
+=
-=
*=
/=
%=
|
|=
<<
>>
<<=
>>=
^ //exclusive or 
^=
```

- types 

enum PieceType { PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn };

    + strongly typed enumerations 
    
enum class PieceType
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};

enum class, the enumeration value names are not automatically exported to the enclosing scope

        * change default type 
enum class PieceType : unsigned long
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};

- structs 

struct Employee {
    char firstInitial;
    char lastInitial;
    int  employeeNumber;
    int  salary;
};

- conditional statements 

if (i > 4) {
    // Do something.
} else if (i > 2) {
    // Do something else.
} else {
    // Do something else.
}

    + cpp 17, initializers for if statements 
    
if (Employee employee = GetEmployee() ; employee.salary > 1000) { … }

- switch 

switch (menuItem) {
    case OpenMenuItem:
        // Code to open a file
        break;
    case SaveMenuItem:
        // Code to save a file
        break;
    default:
        // Code to give an error message
        break;
}

    + cpp 17, tell the compiler that a fallthrough is intentional using the [[fallthrough]] attribute

switch (backgroundColor) {
    case Color::DarkBlue:
        doSomethingForDarkBlue();
        [[fallthrough]];
    case Color::Black:
        // Code is executed for both a dark blue or black background color
        doSomethingForBlackOrDarkBlue();
        break;
    case Color::Red:
    case Color::Green:
        // Code to execute for a red or green background color
        break;
}

    + initializer for switch 
    
switch (<initializer> ; <expression>) { <body> }

- conditional operators 

std::cout << ((i > 2) ? "yes" : "no");

- logical evaluation operators 
< 
<=
>
>=
==
!=
&&
||

- functions 

void myFunction(int i, char c)
{
    std::cout << "the value of i is " << i << std::endl;
    std::cout << "the value of c is " << c << std::endl;
}

    + return type deduction 

auto addNumbers(int number1, int number2)
{
    return number1 + number2;
}

    + current function name 
    
int addNumbers(int number1, int number2)
{
    std::cout << "Entering function " << __func__ << std::endl;
    return number1 + number2;
}

- c-style array 

int myArray[3];
myArray[0] = 0;
myArray[1] = 0;
myArray[2] = 0;

    + initializer 
    
int myArray[3] = {0};
int myArray[] = {1, 2, 3, 4};

    + cpp17 array size 
    
unsigned int arraySize = std::size(myArray);

equal to 

unsigned int arraySize = sizeof(myArray) / sizeof(myArray[0]);

    + std::array 
    
fixed-size container called std::array, defined in the <array> header file. 
array<int, 3> arr = {9, 8, 7};

- std::vector 

// Create a vector of integers
vector<int> myVector = { 11, 22 };

// Add some more integers to the vector using push_back()
myVector.push_back(33);
myVector.push_back(44);

// Access elements
cout << "1st element: " << myVector[0] << endl;

    + cpp 17 structured bindings, Structured bindings allow you to declare multiple variables that are initialized with elements from an array
    
std::array<int, 3> values = { 11, 22, 33 };

auto [x, y, z] = values; 

struct Point { double mX, mY, mZ; };
Point point;
point.mX = 1.0; point.mY = 2.0; point.mZ = 3.0;
auto [x, y, z] = point;

- loops 
    + while 
    
int i = 0;
while (i < 5) {
    std::cout << "This is silly." << std::endl;
    ++i;
}

    + do while 
    
int i = 100;
do {
    std::cout << "This is silly." << std::endl;
    ++i;
} while (i < 5);

    + for loop 
    
for (int i = 0; i < 5; ++i) {
    std::cout << "This is silly." << std::endl;
}

    + range based for loop 
    
std::array<int, 4> arr = {1, 2, 3, 4};
for (int i : arr) {
    std::cout << i << std::endl;
}

- initializer lists 

#include <initializer_list>

using namespace std;

int makeSum(initializer_list<int> lst)
{
    int total = 0;
    for (int value : lst) {
        total += value;
    }
    return total;
}

int a = makeSum({1,2,3});
int b = makeSum({10,20,30,40,50,60});

- strings in C++ 

string myString = "Hello, World";
cout << "The value of myString is " << myString << endl;
cout << "The second letter is " << myString[1] << endl;

- stack and heaps 

- pointers 

int* myIntegerPointer;

Employee* anEmployee = getEmployee();
cout << (*anEmployee).salary << endl;

- dynamically allocated arrays 

int arraySize = 8;
int* myVariableSizedArray = new int[arraySize];

delete[] myVariableSizedArray;
myVariableSizedArray = nullptr;

Avoid using malloc() and free() from C. Instead, use new and delete, or new[] and delete[].

- null pointer constant 

NULL 

nullptr 

- smart pointers 

std::unique_ptr 

std::shared_ptr 

auto anEmployee = make_unique<Employee>();

    + make_unique() has been available since C++14. If your compiler is not yet C++14 compliant, you can make your unique_ptr as follows
    
unique_ptr<Employee> anEmployee(new Employee);

    + cpp17 
    
auto employees = make_unique<Employee[]>(10);
cout << "Salary: " << employees[0].salary << endl;

    + To create a shared_ptr, you should use std::make_shared<>()
    
auto anEmployee = make_shared<Employee>();
if (anEmployee) {
    cout << "Salary: " << anEmployee->salary << endl;
}

    + cpp17 support store an array in a shared_ptr
    
shared_ptr<Employee[]> employees(new Employee[10]);
cout << "Salary: " << employees[0].salary << endl;

shared_ptr<Employee[]> employees(new Employee[10]);
cout << "Salary: " << employees[0].salary << endl;

- auto_ptr, forget it; it was deprecated in C++11/14

- const constants 

const int versionNumberMajor = 2;
const int versionNumberMinor = 1;
const std::string productName = "Super Hyper Net Modulator";

- reference 

int x = 42;
int& xReference = x;

    + pass by reference 
    
void addOne(int& i)
{
    i++;  // Actually changes the original variable
}

    + pass by const reference, This prevents unnecessary copying. 
    
void printString(const std::string& myString)
{
    std::cout << myString << std::endl;
}

- Exceptions come with some new terminology. 

try {
    cout << divideNumbers(2.5, 0.5) << endl;
    cout << divideNumbers(2.3, 0) << endl;
    cout << divideNumbers(4.5, 2.5) << endl;
} catch (const invalid_argument& exception) {
    cout << "Exception caught: " << exception.what() << endl;
}

uses the built-in std::invalid_argument type, but it is preferable to write your own exception types

- type inference, auto and decltype 

    + auto keyword has a number of completely different uses:
    
Deducing a function’s return type, as explained earlier in this chapter.
Structured bindings, as explained earlier in this chapter.
Deducing the type of an expression, as discussed later in this section.
Deducing the type of non-type template parameters, see Chapter 12.
decltype(auto), see Chapter 12.
Alternative function syntax, see Chapter 12.
Generic lambda expressions, see Chapter 18.


const auto& f2 = foo();

    + decltype, takes an expression as argument and computes the type 
    
int x = 123;
decltype(x) y = 456;

decltype(foo()) f2 = foo();

- defining classes 

#include <string>

class AirlineTicket
{
    public:
        AirlineTicket();
        ~AirlineTicket();

        double calculatePriceInDollars() const;

        const std::string& getPassengerName() const;
        void setPassengerName(const std::string& name);

        int getNumberOfMiles() const;
        void setNumberOfMiles(int miles);

        bool hasEliteSuperRewardsStatus() const;
        void setHasEliteSuperRewardsStatus(bool status);
    private:
        std::string mPassengerName;
        int mNumberOfMiles;
        bool mHasEliteSuperRewardsStatus;
};

- using classes 

AirlineTicket myTicket;  // Stack-based AirlineTicket
myTicket.setPassengerName("Sherman T. Socketwrench");
myTicket.setNumberOfMiles(700);
double cost = myTicket.calculatePriceInDollars();
cout << "This ticket will cost $" << cost << endl;

// Heap-based AirlineTicket with smart pointer
auto myTicket2 = make_unique<AirlineTicket>();
myTicket2->setPassengerName("Laudimore M. Hallidue");
myTicket2->setNumberOfMiles(2000);
myTicket2->setHasEliteSuperRewardsStatus(true);
double cost2 = myTicket2->calculatePriceInDollars();
cout << "This other ticket will cost $" << cost2 << endl;
// No need to delete myTicket2, happens automatically

// Heap-based AirlineTicket without smart pointer (not recommended)
AirlineTicket* myTicket3 = new AirlineTicket();
// … Use ticket 3
delete myTicket3;  // delete the heap object!

- uniform initialization 

CircleStruct myCircle1 = {10, 10, 2.5};
CircleClass myCircle2(10, 10, 2.5);

- direct list initialization versus copy list initialization 

Copy list initialization. T obj = {arg1, arg2, …};
Direct list initialization. T obj {arg1, arg2, …};

- the standard library 

std::string, std::array, std::vector, std::unique_ptr, and std::shared_ptr



# Working with strings and string views 
- dynamic strings 

cout << "hello" << endl;

- the c++ std::string class 

string A("12");
string B("34");
string C;
C = A + B;    // C is "1234"

char* a = "12";
char b[] = "12";

if (strcmp(a, b) == 0){
}


string myString = "hello";
myString += ", there";
string myOtherString = myString;
if (myString == myOtherString) {
    myOtherString[0] = 'H';
}
cout << myString << endl;
cout << myOtherString << endl;

use the c_str() method on a string to get a const character pointer, representing a C-style string

   + cpp17 data() returns a char* when called on a non-const string.
   
auto string1 = "Hello World";    // string1 is a const char*
auto string2 = "Hello World"s;   // string2 is an std::string

- high level numeric conversions 

    string to_string(int val);
    string to_string(unsigned val);
    string to_string(long val);
    string to_string(unsigned long val);
    string to_string(long long val);
    string to_string(unsigned long long val);
    string to_string(float val);
    string to_string(double val);
    string to_string(long double val);
    

    int stoi(const string& str, size_t *idx=0, int base=10);
    long stol(const string& str, size_t *idx=0, int base=10);
    unsigned long stoul(const string& str, size_t *idx=0, int base=10);
    long long stoll(const string& str, size_t *idx=0, int base=10);
    unsigned long long stoull(const string& str, size_t *idx=0, int base=10);
    float stof(const string& str, size_t *idx=0);
    double stod(const string& str, size_t *idx=0);
    long double stold(const string& str, size_t *idx=0);

- C++17, all those problems are solved with the introduction of the std::string_view class, which is an instantiation of the std::basic_string_view class template, string_view a read-only string. 

    + string_view can not combined with string directly 
    
auto result = str + sv.data();

here is also a string_view constructor that accepts any raw buffer and a length. This can be used to construct a string_view out of a string buffer 

auto sv = "My string_view"sv;  //string_view literals 

- nonstandard strings 

CString class in the Microsoft MFC.



# Coding with style 
- prefix comment in file 

every file include the following:

    The last-modified date*
    The original author*
    A change-log (as described earlier)*
    The feature ID addressed by the file
    Copyright information
    A brief description of the file/class
    Incomplete features
    Known bugs

- a free tool called Doxygen (available at www.doxygen.org) parses comments to automatically build HTML documentation

- hoc comments 

Avoid offensive or derogatory language.

Liberal use of inside jokes is generally considered okay. 

Don’t put your initials in the code. 

- Decomposition is the practice of breaking up code into smaller pieces. decomposition through refactoring 

encapsulate field 

generalize type 

extract method 

extract class 

move method or move field 

pull up 

push down 


# Designing professional c++ program 
- design for c++ 

C++ has an immense feature set. It is almost a complete superset of the C language, plus classes and objects, operator overloading, exceptions, templates, and many other features. 

C++ is an object-oriented language.

C++ provides a useful Standard Library

- reuse design 

- big-o notation 

- opensource library 

few open-source portals where you can start your search, including the following:

    www.boost.org
    www.gnu.org
    github.com/open-source
    www.sourceforge.net
    
- chess game subsystems visualized as a UML use-case diagram 

ChessBoardView 

GamePlay 

Player 

ChessPieceView 

ChessBoard 

ChessPiece 

ErrorLogger 

- choosing thread model 



# Design with objects 
- object 
behavior 
property 

- mixins 

- abstraction 

- multi inheritance 

- utility class or library 

- component iterface 



# Design for reuse 
- provide document and comments 
- design general purpose interfaces 
- provide mutiple ways to perform the same functionality 
- solid principle 

single responsibility 

open/close 

liskov substitution principle 

interface segregation principle 

dependency inversion 


# C++ coding the professional way 
- memory management 
- allocation and deallocation 

int* ptr = new int;
delete ptr;
ptr = nullptr;

- array of objects 

Simple* mySimpleArray = new Simple[4];
// Use mySimpleArray …
delete [] mySimpleArray;
mySimpleArray = nullptr;

- leak 

void notLeaky()
{
    auto mySimpleSmartPtr = make_unique<Simple>();
    mySimpleSmartPtr->go();
}

auto mySimpleSmartPtr = make_unique<Simple>();
processData(mySimpleSmartPtr.get());

mySimpleSmartPtr.reset();             // Free resource and set to nullptr
mySimpleSmartPtr.reset(new Simple()); // Free resource and set to a new
                                   // Simple instance


- move 

class Foo
{
    public:
        Foo(unique_ptr<int> data) : mData(move(data)) { }
    private:
        unique_ptr<int> mData;
};

auto myIntSmartPtr = make_unique<int>(42);
Foo f(move(myIntSmartPtr));

- custom deleters 

By default, unique_ptr uses the standard new and delete operators to allocate and deallocate memory. You can change this behavior as follows: 

int* malloc_int(int value)
{
    int* p = (int*)malloc(sizeof(int));
    *p = value;
    return p;
}

int main()
{
    unique_ptr<int, decltype(free)*> myIntSmartPtr(malloc_int(42), free);
    return 0;
}

- shared_ptr 

uses a shared_ptr to store a file pointer. When the shared_ptr is reset (in this case when it goes out of scope), the file pointer is automatically closed with a call to CloseFile().

void CloseFile(FILE* filePtr)
{
    if (filePtr == nullptr)
        return;
    fclose(filePtr);
    cout << "File closed." << endl;
}
int main()
{
    FILE* f = fopen("data.txt", "w");
    shared_ptr<FILE> filePtr(f, CloseFile);
    if (filePtr == nullptr) {
        cerr << "Error opening file." << endl;
    } else {
        cout << "File opened." << endl;
        // Use filePtr
    }
    return 0;
}

- cast shared_ptrs are const_pointer_cast(), dynamic_pointer_cast(), and static_pointer_cast(). C++17 adds reinterpret_pointer_cast() to this list. T

- prevent double delete 

void noDoubleDelete()
{
    auto smartPtr1 = make_shared<Simple>();
    shared_ptr<Simple> smartPtr2(smartPtr1);
}

void doubleDelete()
{
    Simple* mySimple = new Simple();
    shared_ptr<Simple> smartPtr1(mySimple);
    shared_ptr<Simple> smartPtr2(mySimple); // double delete 
}

- aliasing 

A shared_ptr support so-called aliasing. This allows a shared_ptr to share ownership over a pointer (owned pointer) with another shared_ptr, but pointing to a different object (stored pointer). it be used to have a shared_ptr pointing to a member of an object while owning the object itself. Here’s an example:

```
class Foo
{
    public:
        Foo(int value) : mData(value) { }
        int mData;
};

auto foo = make_shared<Foo>(42);
auto aliasing = shared_ptr<int>(foo, &foo->mData);
```

- weak_ptr 

C++ that is related to shared_ptr, called weak_ptr. A weak_ptr can contain a reference to a resource managed by a shared_ptr. The weak_ptr does not own the resource

two ways to convert back to shared_ptr 
    + Use the lock() method on a weak_ptr instance, which returns a shared_ptr. The returned shared_ptr is nullptr if the shared_ptr associated with the weak_ptr has been deallocated in the meantime.
    
    + create a new shared_ptr instance and give a weak_ptr as argument to the shared_ptr constructor. This throws an std::bad_weak_ptr exception if the shared_ptr associated with the weak_ptr has been deallocated
    
    + example 
    
```
void useResource(weak_ptr<Simple>& weakSimple)
{
    auto resource = weakSimple.lock();
    if (resource) {
        cout << "Resource still alive." << endl;
    } else {
        cout << "Resource has been freed!" << endl;
    }
}

int main()
{
    auto sharedSimple = make_shared<Simple>();
    weak_ptr<Simple> weakSimple(sharedSimple);

    // Try to use the weak_ptr.
    useResource(weakSimple);

    // Reset the shared_ptr.
    // Since there is only 1 shared_ptr to the Simple resource, this will
    // free the resource, even though there is still a weak_ptr alive.
    sharedSimple.reset();

    // Try to use the weak_ptr a second time.
    useResource(weakSimple);

    return 0;
}
```

    + cpp17 weak_ptr also supports C-style arrays, just as shared_ptr supports C-style arrays since C++17.


- move semantics 

unique_ptr<Simple> create()
{
    auto ptr = make_unique<Simple>();
    // Do something with ptr…
    return ptr;
}

int main()
{
    unique_ptr<Simple> mySmartPtr1 = create();
    auto mySmartPtr2 = create();
    return 0;
}

- enable_shared_from_this 

The std::enable_shared_from_this mixin class allows a method on an object to safely return a shared_ptr or weak_ptr to itself.

shared_from_this(): returns a shared_ptr that shares ownership of the object.

weak_from_this(): returns a weak_ptr that tracks ownership of the object.

```
class Foo : public enable_shared_from_this<Foo>
{
    public:
        shared_ptr<Foo> getPointer() {
            return shared_from_this();
        }
};

int main()
{
    auto ptr1 = make_shared<Foo>();
    auto ptr2 = ptr1->getPointer();
}
```

- common memory pitfalls 
    + auto_ptr has some serious shortcomings. One of these shortcomings is that it does not work correctly when used inside Standard Library containers such as vectors. C++11 and C++14 officially deprecated auto_ptr
    
    cpp 17 complete removed it 
    
    + underallocating strings 
    
char buffer[1024] = {0};   // Allocate a whole bunch of memory.
while (true) {
    char* nextChunk = getMoreData();
    if (nextChunk == nullptr) {
        break;
    } else {
        strcat(buffer, nextChunk); // BUG! No guarantees against buffer overrun!
        delete [] nextChunk;
    }
}

- pointers can exist both on stack and on the heap 

int** handle = nullptr;
handle = new int*;
*handle = new int;

- The program exits when new fails because new throws an exception if there is not enough memory available for the request.

an alternative version of new, which will not throw an exception. 

```
int* ptr = new(nothrow) int;
```

    + array of objects, will be a pointer at stack and point to the elements on the heap 
    
    Simple* mySimpleArray = new Simple[4];
    // Use mySimpleArray …
    delete [] mySimpleArray;
    mySimpleArray = nullptr;

    + multi dimensional array 
    
    char board[3][3] = {};
    // Test code
    board[0][0] = 'X';   // X puts marker in position (0,0).
    board[2][1] = 'O';   // O puts marker in position (2,1).

    + multi dimensional heap array 
    
    char** allocateCharacterBoard(size_t xDimension, size_t yDimension)
    {
        char** myArray = new char*[xDimension]; // Allocate first dimension
        for (size_t i = 0; i < xDimension; i++) {
            myArray[i] = new char[yDimension];  // Allocate ith subarray
        }
        return myArray;
    }

    void releaseCharacterBoard(char** myArray, size_t xDimension)
    {
        for (size_t i = 0; i < xDimension; i++) {
            delete [] myArray[i];    // Delete ith subarray
        }
        delete [] myArray;           // Delete first dimension
    }

such as std::array, vector<vector<T>> for a two-dimensional dynamic array, and so on

you should consider writing (or reusing of course) a Matrix<T> or Table<T> class template which internally might use a vector<vector<T>>

- working with pointers 
    + pointer is created on the stack and safe the address to a heap etc. 

    + casting pointers 
    
    Document* documentPtr = getDocument();
    char* myCharPtr = (char*)documentPtr;

    Document* documentPtr = getDocument();
    char* myCharPtr = static_cast<char*>(documentPtr);   // BUG! Won't compile

    + arrays are pointers 
    
    int myIntArray[10] = {};
    int* myIntPtr = myIntArray;
    // Access the array through the pointer.
    myIntPtr[4] = 5;

- pointer arithmetic 

const wchar_t* myString = L"Hello, World";

wchar_t* toCaps(const wchar_t* inString);

- garbage collection 

Register all pointers with the garbage collector

Register all pointers with the garbage collector

Protect concurrent access to objects by making sure that no changes to pointers can occur while the garbage collector is running

I highly recommend you to research existing specialized garbage-collection libraries 

- Object pools are the equivalent of recycling. You buy a reasonable number of plates, and after using a plate, you clean it so that it can be reused later

- smart pointers 

Before C++17, you had to use make_unique() not only because you have to specify the type only once, but also because of safety reasons! 

unique_ptr<Simple> mySimpleSmartPtr(new Simple());

foo(make_unique<Simple>(), make_unique<Bar>(data()))

    + using unique pointer 
    
mySimpleSmartPtr->go();

(*mySimpleSmartPtr).go();

        * The get() method can be used to get direct access to the underlying pointer. 

auto mySimpleSmartPtr = make_unique<Simple>();
processData(mySimpleSmartPtr.get());

        *  optionally change it to another pointer using reset(). 

mySimpleSmartPtr.reset();             // Free resource and set to nullptr
mySimpleSmartPtr.reset(new Simple()); // Free resource and set to a new
                                   // Simple instance

        * release resource 
        
Simple* simple = mySimpleSmartPtr.release(); // Release ownership
// Use the simple pointer…
delete simple;
simple = nullptr;

        * a unique_ptr represents unique ownership, it cannot be copied! Using the std::move() utility
        
```
class Foo
{
    public:
        Foo(unique_ptr<int> data) : mData(move(data)) { }
    private:
        unique_ptr<int> mData;
};

auto myIntSmartPtr = make_unique<int>(42);
Foo f(move(myIntSmartPtr));
```       

        * unique_ptr and C-Style Arrays

auto myVariableSizedArray = make_unique<int[]>(10);

        * custom deleter 
        
By default, unique_ptr uses the standard new and delete operators to allocate and deallocate memory. You can change this behavior as follows: 

int* malloc_int(int value)
{
    int* p = (int*)malloc(sizeof(int));
    *p = value;
    return p;
}

int main()
{
    unique_ptr<int, decltype(free)*> myIntSmartPtr(malloc_int(42), free);
    return 0;
}

it can be used to automatically close a file or network socket or anything when the unique_ptr goes out of scope.

- shared_ptr

auto mySimpleSmartPtr = make_shared<Simple>();

- memory leak

Microsoft Visual C++*, its debug library has built-in support for memory leak detection.

```
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>
```

redefine the new operator 
```
#ifdef _DEBUG
    #ifndef DBG_NEW
        #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
        #define new DBG_NEW
    #endif
#endif  // _DEBUG
```

add line to the main() function 
```
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
```

instruct the debugger to break on the 147th allocation:
```
_CrtSetBreakAlloc(147);
```

- finding and fixing memory leaks in linux with Valgrind 

Valgrind finds the same two memory leaks—the first Simple object never deleted and the heap-based integer that it creates:

- double deleting and invalid pointers 

Many memory leak-detection programs, such as Microsoft Visual C++ and Valgrind, are capable of detecting double deletion and use of released objects.



# Gaining proficiency with classes and objects 
- access control 

class SpreadsheetCell
{
        void setValue(double inValue); // now has private access
    public:
        double getValue() const;
    private:
        double mValue;
};

    + repeat access list 
    
class SpreadsheetCell
{
    public:
        void setValue(double inValue);
    private:
        double mValue;
    public:
        double getValue() const;
};

- in class initializers

class SpreadsheetCell
{
    // Remainder of the class definition omitted for brevity
private:
    double mValue = 0;
};

- define methods 
```
#include "SpreadsheetCell.h"

void SpreadsheetCell::setValue(double inValue)
{
    mValue = inValue;
}

double SpreadsheetCell::getValue() const
{
    return mValue;
}
```

- calling other methods 
```
#include <string>
#include <string_view>
class SpreadsheetCell
{
    public:
        void setValue(double inValue);
        double getValue() const;

        void setString(std::string_view inString);
        std::string getString() const;
    private:
        std::string doubleToString(double inValue) const;
        double stringToDouble(std::string_view inString) const;
        double mValue;
};

```

C++17 compliant, you can replace std::string_view with const std::string&.

- this pointer 

void SpreadsheetCell::setValue(double value)
{
    value = value; // Ambiguous!
}

void SpreadsheetCell::setValue(double value)
{
    this->value = value;
}

- using objects 
    + object on the stack 
    
SpreadsheetCell myCell, anotherCell;
myCell.setValue(6);
anotherCell.setString("3.2");
cout << "cell 1: " << myCell.getValue() << endl;
cout << "cell 2: " << anotherCell.getValue() << endl;

    + object on the heap 
SpreadsheetCell* myCellp = new SpreadsheetCell();
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
        " " << myCellp->getString() << endl;
delete myCellp;
myCellp = nullptr;

    + smart pointers 
auto myCellp = make_unique<SpreadsheetCell>();
// Equivalent to:
// unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
        " " << myCellp->getString() << endl;
        
- default constructor, C++ fails to provide any syntax to tell the array creation code directly to call a different constructor. 

class SpreadsheetCell
{
    public:
        SpreadsheetCell();
        // Remainder of the class definition omitted for brevity
};

    + explicitly defaulted constructors 
    
class SpreadsheetCell
{
    public:
        SpreadsheetCell() = default;
        SpreadsheetCell(double initialValue);
        SpreadsheetCell(std::string_view initialValue);
        // Remainder of the class definition omitted for brevity
};

    + explicitly deleted contructors 
    
class MyClass
{
    public:
        MyClass() = delete;
};

    + constructor initializers 
    
SpreadsheetCell::SpreadsheetCell(double initialValue)
    : mValue(initialValue)
{
}

- copy constructor 
    
class SpreadsheetCell
{
    public:
        SpreadsheetCell(const SpreadsheetCell& src);
        // Remainder of the class definition omitted for brevity
};


explicitly call the copy constructor 

SpreadsheetCell myCell1(4);
SpreadsheetCell myCell2(myCell1); // myCell2 has the same values as myCell1

- initializer list contructors 

class EvenSequence
{
    public:
        EvenSequence(initializer_list<double> args)
        {
            if (args.size() % 2 != 0) {
                throw invalid_argument("initializer_list should "
                    "contain even number of elements.");
            }
            mSequence.reserve(args.size());
            for (const auto& value : args) {
                mSequence.push_back(value);
            }
        }

        void dump() const
        {
            for (const auto& value : mSequence) {
                cout << value << ", ";
            }
            cout << endl;
        }
    private:
        vector<double> mSequence;
};

EvenSequence p1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
p1.dump();

- delegating constructors 

SpreadsheetCell::SpreadsheetCell(string_view initialValue)
    : SpreadsheetCell(stringToDouble(initialValue))
{
}

- assign objects 

SpreadsheetCell myCell(5), anotherCell;
anotherCell = myCell;

class SpreadsheetCell
{
    public:
        SpreadsheetCell& operator=(const SpreadsheetCell& rhs);
        // Remainder of the class definition omitted for brevity
};


all assignment operators return *this, and the self-assignment case is no exception:

- explicitly defaulted and deleted assignment operator 

SpreadsheetCell& operator=(const SpreadsheetCell& rhs) = default;

- cpp11 has deprecated the compiler generation copy constructor. still can explicitly define 

MyClass(const MyClass& src) = default;

MyClass& operator=(const MyClass& rhs) = default;

- distinguishing copying from assignment 

    + copy 
SpreadsheetCell myCell(5);
SpreadsheetCell anotherCell(myCell);
SpreadsheetCell aThirdCell = myCell;
    
    + assignment 
anotherCell = myCell; // Calls operator= for anotherCell

- objects as return values 

string SpreadsheetCell::getString() const
{
    return doubleToString(mValue);
}

SpreadsheetCell myCell3(5);
string s2 = myCell3.getString();

When getString() returns the string, the compiler actually creates an unnamed temporary string object by calling a string copy constructor. When you assign this result to s1, the assignment operator is called for s1 with the temporary string as a parameter. Then, the temporary string object is destroyed. 

- copy constructors and object members 

SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src)
{
    mValue = src.mValue;
}

mValue is initialized using copy constructor 

SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src)
    : mValue(src.mValue)
{
}


# Mastering classes and objects 
- friends 

class Foo
{
    friend class Bar;
    // …
}; 

class Foo
{
    friend void Bar::processFoo(const Foo& foo);
    // …
     friend void dumpFoo(const Foo& foo);
}; 

void dumpFoo(const Foo& foo)
{
    // Dump all data of foo to the console, including
    // private and protected data members.
}

- implement destructor 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height);
        ~Spreadsheet();
        // Code omitted for brevity
};

Spreadsheet::~Spreadsheet()
{
    for (size_t i = 0; i < mWidth; i++) {
        delete [] mCells[i];
    }
    delete [] mCells;
    mCells = nullptr;
}

- handling moving with move semantics 

// lvalue reference parameter
void handleMessage(std::string& message)
{
    cout << "handleMessage with lvalue reference: " << message << endl;
}

// rvalue reference parameter
void handleMessage(std::string&& message)
{
    cout << "handleMessage with rvalue reference: " << message << endl;
}

std::string a = "Hello ";
std::string b = "World";
handleMessage(a);             // Calls handleMessage(string& value)

handleMessage(a + b);         // Calls handleMessage(string&& value)

handleMessage("Hello World"); // Calls handleMessage(string&& value)

handleMessage(std::move(b));  // Calls handleMessage(string&& value), force compiler call move with left value 

    + nested move moving semantics should follow the same rules 
    
void helper(std::string&& message)
{
}

void handleMessage(std::string&& message)
{
    helper(message); //not compile 
}

void handleMessage(std::string&& message)
{
    helper(std::move(message));
}

- rvalue reference 

int&& i = 2;
int a = 2, b = 3;
int&& j = a + b;

- implementing move semantics 

class Spreadsheet
{
    public:
        Spreadsheet(Spreadsheet&& src) noexcept; // Move constructor
        Spreadsheet& operator=(Spreadsheet&& rhs) noexcept; // Move assign
        // Remaining code omitted for brevity
    private:
        void cleanup() noexcept;
        void moveFrom(Spreadsheet& src) noexcept;
        // Remaining code omitted for brevity
};

- This is called a memory leak. That is why in assignment operators you must do a deep copy.

- disallowing assignment and pass-by-value 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height);
        Spreadsheet(const Spreadsheet& src) = delete;
        ~Spreadsheet();
        Spreadsheet& operator=(const Spreadsheet& rhs) = delete;
        // Code omitted for brevity
}

- function will not throw any exceptioni 

void myNonThrowingFunction() noexcept { /* … */ }

- dynamic allocation arrays 

C++, unlike in Java, it’s not possible to simply write new SpreadsheetCell[mWidth][mHeight].

Spreadsheet::Spreadsheet(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells = new SpreadsheetCell*[mWidth];
    for (size_t i = 0; i < mWidth; i++) {
        mCells[i] = new SpreadsheetCell[mHeight];
    }
}

the following verifyCoordinate() method is defined for the class:

- implementing move semantics 

Move constructors and move assignment operators should be marked with the noexcept

Two helper methods are introduced as well: cleanup(), which is used from the destructor and the move assignment operator, and moveFrom()

```
class Spreadsheet
{
    public:
        Spreadsheet(Spreadsheet&& src) noexcept; // Move constructor
        Spreadsheet& operator=(Spreadsheet&& rhs) noexcept; // Move assign
        // Remaining code omitted for brevity
    private:
        void cleanup() noexcept;
        void moveFrom(Spreadsheet& src) noexcept;
        // Remaining code omitted for brevity
};
```

void Spreadsheet::cleanup() noexcept
{
    for (size_t i = 0; i < mWidth; i++) {
        delete[] mCells[i];
    }
    delete[] mCells;
    mCells = nullptr;
    mWidth = mHeight = 0;
}

void Spreadsheet::moveFrom(Spreadsheet& src) noexcept
{
    // Shallow copy of data
    mWidth = src.mWidth;
    mHeight = src.mHeight;
    mCells = src.mCells;

    // Reset the source object, because ownership has been moved!
    src.mWidth = 0;
    src.mHeight = 0;
    src.mCells = nullptr;
}

// Move constructor
Spreadsheet::Spreadsheet(Spreadsheet&& src) noexcept
{
    moveFrom(src);
}

// Move assignment operator
Spreadsheet& Spreadsheet::operator=(Spreadsheet&& rhs) noexcept
{
    // check for self-assignment
    if (this == &rhs) {
        return *this;
    }

    // free the old memory
    cleanup();

    moveFrom(rhs);

    return *this;
}

Obviously, move semantics is useful only when you know that the source object will be destroyed.

    + moving object data members 
    
    using std::move(). Suppose the Spreadsheet class has an std::string data member called mName. 

void Spreadsheet::moveFrom(Spreadsheet& src) noexcept
{
    // Move object data members
    mName = std::move(src.mName);

    // Move primitives:
    // Shallow copy of data
    mWidth = src.mWidth;
    mHeight = src.mHeight;
    mCells = src.mCells;

    // Reset the source object, because ownership has been moved!
    src.mWidth = 0;
    src.mHeight = 0;
    src.mCells = nullptr;
}

- If the compiler finds a move constructor, the objects are moved instead of copied.

A vector grows dynamically in size to accommodate new objects. This is done by allocating a bigger chunk of memory and then copying or moving the objects from the old vector to the new and bigger vector. 

```
Spreadsheet createObject()
{
    return Spreadsheet(3, 2);
}

int main()
{
    vector<Spreadsheet> vec;
    for (int i = 0; i < 2; ++i) {
        cout << "Iteration " << i << endl;
        vec.push_back(Spreadsheet(100, 100));
        cout << endl;
    }

    Spreadsheet s(2,3);
    s = createObject();

    Spreadsheet s2(5,6);
    s2 = s;
    return 0;
}
```

- implementing swap with move semantics 

   + copy 
   
void swapCopy(T& a, T& b)
{
    T temp(a);
    a = b;
    b = temp;
}

    + move 
    
void swapMove(T& a, T& b)
{
    T temp(std::move(a));
    a = std::move(b);
    b = std::move(temp);
}

- The rule of zero states that you should design your classes in such a way that they do not require any of those five special member functions.

five special member functions: destructor, copy and move constructors, and copy and move assignment operators

se modern constructs such as Standard Library containers. For example, use a vector<vector<SpreadsheetCell>> instead of the SpreadsheetCell** data member

- static methods 

class SpreadsheetCell
{
    // Omitted for brevity
    private:
        static std::string doubleToString(double inValue);
        static double stringToDouble(std::string_view inString);
        // Omitted for brevity
};

In fact, a static method is just like a regular function. The only difference is that it can access private and protected static members of the class.

- const methods 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        double getValue() const;
        std::string getString() const;
        // Omitted for brevity
};

Marking a method as const signs a contract with client code guaranteeing that you will not change the internal values of the object within the method

destructor is not allowed to be declared const 

- mutable data members, new counter variable mutable, which tells the compiler that it’s okay to change it in a const method.

class SpreadsheetCell
{
    // Omitted for brevity
    private:
        double mValue = 0;
        mutable size_t mNumAccesses = 0;
};

double SpreadsheetCell::getValue() const
{
    mNumAccesses++;
    return mValue;
}

std::string SpreadsheetCell::getString() const
{
    mNumAccesses++;
    return doubleToString(mValue);
}

- method overloading 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        void set(double inValue);
        void set(std::string_view inString);
        // Omitted for brevity
};

- overloading based on const 

const_cast() pattern. For example, the Spreadsheet class has a method called getCellAt() returning a non-const reference to a SpreadsheetCell

class Spreadsheet
{
    public:
        SpreadsheetCell& getCellAt(size_t x, size_t y);
        const SpreadsheetCell& getCellAt(size_t x, size_t y) const;
        // Code omitted for brevity.
};

const SpreadsheetCell& Spreadsheet::getCellAt(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

SpreadsheetCell& Spreadsheet::getCellAt(size_t x, size_t y)
{
    return const_cast<SpreadsheetCell&>(std::as_const(*this).getCellAt(x, y));
}
    + cpp17 
using std::as_const() (defined in <utility>), call the const version of getCellAt(), and then remove the const from the result by using a const_cast():

    + older versions 
return const_cast<SpreadsheetCell&>(static_cast<const Spreadsheet&>(*this).getCellAt(x, y));

- explicitly delete overload 

- inline method, inline methods. Inlining is safer than using #define macros.

inline double SpreadsheetCell::getValue() const
{
    mNumAccesses++;
    return mValue;
}

inline std::string SpreadsheetCell::getString() const
{
    mNumAccesses++;
    return doubleToString(mValue);
}

- Microsoft Visual C++ supports Link-Time Code Generation (LTCG), which automatically inlines small function bodies, even if they are not declared as inline and even if they are not defined in a header file. GCC and Clang have similar features. 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        double getValue() const { mNumAccesses++; return mValue; }

        std::string getString() const
        {
            mNumAccesses++;
            return doubleToString(mValue);
        }
        // Omitted for brevity
};

- default arguments 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width = 100, size_t height = 100);
        // Omitted for brevity
};

- static data members, they are initialized to 0 by default. Static pointers are initialized to nullptr.

- inline data members, Starting with C++17, you can declare your static data members as inline. The benefit of this is that you do not have to allocate space for them in a source file

- accessing static data members outside methods 

int c = Spreadsheet::sCounter;

- const static data members 

class Spreadsheet
{
    public:
        // Omitted for brevity
        static const size_t kMaxHeight = 100;
        static const size_t kMaxWidth = 100;
};

- reference data members 

class SpreadsheetApplication; // forward declaration

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height,
            SpreadsheetApplication& theApp);
        // Code omitted for brevity.
    private:
        // Code omitted for brevity.
        SpreadsheetApplication& mTheApp;
};

Spreadsheet::Spreadsheet(size_t width, size_t height,
    SpreadsheetApplication& theApp)
    : mId(sCounter++)
    , mWidth(std::min(width, kMaxWidth))
    , mHeight(std::min(height, kMaxHeight))
    , mTheApp(theApp)
{
    // Code omitted for brevity.
}

- const reference data members 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height,
            const SpreadsheetApplication& theApp);
            // Code omitted for brevity.
    private:
            // Code omitted for brevity.
            const SpreadsheetApplication& mTheApp;
};

The const reference SpreadsheetApplication data member can only be used to call const methods on the SpreadsheetApplication object. 

- nested classes 

access it outside the class by scoping it with the ClassName:: scope resolution syntax.

class Spreadsheet
{
    public:
        class Cell
        {
            public:
                Cell() = default;
                Cell(double initialValue);
                // Omitted for brevity
        };

        Spreadsheet(size_t width, size_t height,
            const SpreadsheetApplication& theApp);
        // Remainder of Spreadsheet declarations omitted for brevity
};

Spreadsheet::Cell::Cell(double initialValue)
    : mValue(initialValue)
{
}

    + another way 
    
class Spreadsheet
{
    public:
        class Cell;

        Spreadsheet(size_t width, size_t height,
            const SpreadsheetApplication& theApp);
        // Remainder of Spreadsheet declarations omitted for brevity
};

class Spreadsheet::Cell
{
    public:
        Cell() = default;
        Cell(double initialValue);
        // Omitted for brevity
};

declare a private or protected nested class, you can only use it inside the outer class. A nested class has access to all protected and private members of the outer class. 

- enumerated types inside classes 
class SpreadsheetCell
{
    public:
        // Omitted for brevity
        enum class Color { Red = 1, Green, Blue, Yellow };
        void setColor(Color color);
        Color getColor() const;
    private:
        // Omitted for brevity
        Color mColor = Color::Red;
};

- operator overloading 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
         SpreadsheetCell operator+(const SpreadsheetCell& cell) const;
        // Omitted for brevity
};

- explict convertor 
class SpreadsheetCell
{
    public:
        SpreadsheetCell() = default;
        SpreadsheetCell(double initialValue);
        explicit SpreadsheetCell(std::string_view initialValue);
    // Remainder omitted for brevity
};

- global operator+ 

class SpreadsheetCell
{
    //Omitted for brevity
};

SpreadsheetCell operator+(const SpreadsheetCell& lhs,
    const SpreadsheetCell& rhs)
{
    return SpreadsheetCell(lhs.getValue() + rhs.getValue());    
}

SpreadsheetCell operator+(const SpreadsheetCell& lhs,
    const SpreadsheetCell& rhs);

- overloading arithmetic operators 

class SpreadsheetCell
{
    // Omitted for brevity
};

SpreadsheetCell operator<op>(const SpreadsheetCell& lhs,
    const SpreadsheetCell& rhs);                     

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        SpreadsheetCell& operator+=(const SpreadsheetCell& rhs);
        SpreadsheetCell& operator-=(const SpreadsheetCell& rhs);
        SpreadsheetCell& operator*=(const SpreadsheetCell& rhs);
        SpreadsheetCell& operator/=(const SpreadsheetCell& rhs);
        // Omitted for brevity
};
                
- using interface and implementation classes 

This is called the pimpl idiom, private implementation idiom, or bridge pattern. The interface class method implementations simply call the equivalent methods on the implementation class object. 

```
#include "SpreadsheetCell.h"
#include <memory>

// Forward declarations
class SpreadsheetApplication;

class Spreadsheet
{
    public:
        Spreadsheet(const SpreadsheetApplication& theApp,
            size_t width = kMaxWidth, size_t height = kMaxHeight);
        Spreadsheet(const Spreadsheet& src);
        ~Spreadsheet();

        Spreadsheet& operator=(const Spreadsheet& rhs);

        void setCellAt(size_t x, size_t y, const SpreadsheetCell& cell);
        SpreadsheetCell& getCellAt(size_t x, size_t y);

        size_t getId() const;

        static const size_t kMaxHeight = 100;
        static const size_t kMaxWidth = 100;

        friend void swap(Spreadsheet& first, Spreadsheet& second) noexcept;

    private:
        class Impl;
        std::unique_ptr<Impl> mImpl;
};                
```

With stable interface classes, build times can be reduced.
                

# Discovering inheritance techniques 
- extending classes 

class Base
{
    public:
        void someMethod();
    protected:
        int mProtectedInt;
    private:
        int mPrivateInt;
};

class Derived : public Base
{
    public:
        void someOtherMethod();
};

- preventing inheritance 

class Base final
{
    // Omitted for brevity
};

- overriding methods 

class Base
{
    public:
        virtual void someMethod();
    protected:
        int mProtectedInt;
    private:
        int mPrivateInt;
};

class Derived : public Base
{
    public:
        virtual void someMethod() override; // Overrides Base's someMethod()
        virtual void someOtherMethod();
};

Derived myDerived;
Base& ref = myDerived;
myDerived.someOtherMethod();  // This is fine.
ref.someOtherMethod();        // Error

only use the virtual keyword can  not prevent future miss updated overwrite methods 

However, because the method is not virtual, it is not actually overridden. Rather, the Derived class creates a new method, also called go(), that is completely unrelated to the Base class’s method called go().

the vtable, or “virtual table.” Each class that has one or more virtual methods, has a vtable, and every object of such a class contains a pointer to said vtable. 


class Base
{
    public:
        virtual void func1() {}
        virtual void func2() {}
        void nonVirtualFunc() {}
};

class Derived : public Base
{
    public:
        virtual void func2() override {}
        void nonVirtualFunc() {}
};

-  the class is destroyed, such as std::unique_ptrs, then those members will not get deleted either if the destructor is never called.

- preventing overriding 

class Base
{
    public:
        virtual ~Base() = default;
        virtual void someMethod() final;
};

- class construction 
If the class has a base class, the default constructor of the base class is executed, unless there is a call to a base class constructor in the ctor-initializer

Non-static data members of the class are constructed in the order in which they are declared.

The body of the class’s constructor is executed.

- class destruction 

The body of the class’s destructor is called.

Any data members of the class are destroyed in the reverse order of their construction.

The parent class, if any, is destructed.

- casting up and down 

Base myBase = myDerived;  // Slicing! 

Base& myBase = myDerived; // No slicing!

This is why it’s always a good idea to make your methods and functions take references to classes instead of directly using objects of those classes

void presumptuous(Base* base)
{
    Derived* myDerived = static_cast<Derived*>(base);    //bad
    // Proceed to access Derived methods on myDerived.
}

void lessPresumptuous(Base* base) 
{
    Derived* myDerived = dynamic_cast<Derived*>(base);
    if (myDerived != nullptr) {
        // Proceed to access Derived methods on myDerived.
    }
}

- pure virtual methods and abstract base classes 

class SpreadsheetCell
{
    public:
        virtual ~SpreadsheetCell() = default;
        virtual void set(std::string_view inString) = 0;
        virtual std::string getString() const = 0;
};

class StringSpreadsheetCell : public SpreadsheetCell
{
    public:
        virtual void set(std::string_view inString) override;
        virtual std::string getString() const override;

    private:
        std::optional<std::string> mValue;
};

- multiple inheritance 

class Baz : public Foo, public Bar 
{
    // Etc.
};

    + name colliction 
    
class DogBird : public Dog, public Bird
{
    public:
        using Dog::eat;  // Explicitly inherit Dog's version of eat()
};

    + ambiguous base class, should not do this 
    
class Dog {};
class Bird : public Dog {};
class DogBird : public Bird, public Dog {}; // Error!

- inherite constructors 

class Base
{
    public:
        virtual ~Base() = default;
        Base() = default;
        Base(std::string_view str);
};

class Derived : public Base
{
    public:
        Derived(int i);
};


//explicitly inherit the Base constructors in the Derived class as follows:
class Derived : public Base
{
    public:
        using Base::Base;
        Derived(int i);
};

- base class members may have different access levels 

- virtual base class, C++ has another mechanism, called virtual base classes, for addressing this problem if you do want the shared parent to have its own functionality.

Without the virtual keyword, a call to sleep() on a DogBird object would be ambiguous and would generate a compiler error because DogBird would have two subobjects of class Animal

```
class Animal
{
    public:
        virtual void eat() = 0;
        virtual void sleep() { cout << "zzzzz...." << endl; }
};

class Dog : public virtual Animal
{
    public:
        virtual void bark() { cout << "Woof!" << endl; }
        virtual void eat() override { cout << "The dog ate." << endl; }
};

class Bird : public virtual Animal
{
    public:
        virtual void chirp() { cout << "Chirp!" << endl; }
        virtual void eat() override { cout << "The bird ate." << endl; }
};

class DogBird : public Dog, public Bird
{
    public:
        virtual void eat() override { Dog::eat(); }
};

int main()
{
    DogBird myConfusedAnimal;
    myConfusedAnimal.sleep();  // Not ambiguous because of virtual base class
    return 0;
}
```


# C++ quirks, oddities and incidentals 
- reference to pointer 

int* intP;
int*& ptrRef = intP;
ptrRef = new int;
*ptrRef = 5;


int x = 3;
int& xRef = x;
int* xPtr = &xRef; // Address of a reference is pointer to value
*xPtr = 100;

- reference data member 

class MyClass
{
    public:
        MyClass(int& ref) : mRef(ref) {}
    private:
        int& mRef;
};

- reference parameter 

void swap(int& first, int& second)
{
    int temp = first;
    first = second;
    second = temp;
}

int x = 5, y = 6;
int *xp = &x, *yp = &y;
swap(*xp, *yp);

- rvalue reference 

handleMessage("Hello World"); // A literal is not an lvalue.

std::string a = "Hello ";
std::string b = "World";
handleMessage(a + b);         // A temporary is not an lvalue.

// rvalue reference parameter
void handleMessage(std::string&& message)
{
    cout << "handleMessage with rvalue reference: " << message << endl;
}

- The version using vectors is already much better than the versions using pointers or references, but it’s usually recommended to avoid output parameters as much as possible. 

- In order to prevent the pointed-to values from being modified (as in the third line), you can add the keyword const to the declaration of ip like this:

const int* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!

semantically equivalent way to write this is as follows:

int const* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!

const before or after the int makes no difference in its functionality.

    + mark both pointer and values to const 
    
int const* const ip = nullptr;

//equal to 

const int* const ip = nullptr;

    + const keyword applies to whatever is directly to its left. Consider this line again
    
From left to right, the first const is directly to the right of the word int. Thus, it applies to the int to which ip points. Therefore, it specifies that you cannot change the values to which ip points. The second const is directly to the right of the *. Thus, it applies to the pointer to the int, which is the ip variable. Therefore, it specifies that you cannot change ip (the pointer) itself.

int const* const ip = nullptr;

//other syntax     
const int* const ip = nullptr;
    
const int * const * const * const ip = nullptr;
    
- const reference 

C++ programmers refer to a “const reference,” they mean something like this:
    
int z;
const int& zRef = z;
zRef = 4; // DOES NOT COMPILE

const int& zRef is equivalent to int const& zRef
    
const references are used most commonly as parameters
    
- const methods 

    + const expression 
    
const int getArraySize() { return 32; }

int main()
{
    int myArray[getArraySize()];    // Invalid in C++
    return 0;
}

    + Declaring a function as constexpr imposes quite a lot of restrictions
    
    The function body shall not contain any goto statements, try catch blocks, uninitialized variables, or variable definitions that are not literal types,1 and shall not throw any exceptions.

    The return type of the function shall be a literal type.

    the function cannot be virtual.

    All the function parameters shall be literal types.
    
    dynamic_cast() and reinterpret_cast() are not allowed.
    
    new and delete expressions are not allowed.
    
    + A constexpr constructor also has a lot of restrictions. Here are some of them:
    
    The class cannot have any virtual base classes.
    
    The constructor body either shall be explicitly defaulted, or shall satisfy the same requirements as the body of a constexpr function.
    
    All data members shall be initialized with constant expressions.
    
- static keyword 

“overloading” the keyword was attempting to avoid having to introduce new keywords into the language.

static methods are similarly at the class level instead of the object level. 

A static method does not execute in the context of a specific object.

External linkage means that the name is available from other source files. Internal linkage (also called static linkage) means that it is not. By default, functions and global variables have external linkage. 

specify internal (or static) linkage by prefixing the declaration with the keyword static. 

    + example 
    
#include <iostream>

static void f();

void f()
{
    std::cout << "f\n";
}
    
    + alternative, An alternative to using static for internal linkage is to employ anonymous namespaces. Instead of marking a variable or function static, wrap it in an unnamed namespace

#include <iostream>

namespace {
    void f();

    void f()
    {
        std::cout << "f\n";
    }
}

- static variables in functions 

```
void performTask()
{
    static bool initialized = false;
    if (!initialized) {
        cout << "initializing" << endl;
        // Perform initialization.
        initialized = true;
    }
    // Perform the desired task.
}
```

- All global variables and static class data members in a program are initialized before main() begins. The variables in a given source file are initialized in the order they appear in the source file.

two different source files, you cannot count on one being constructed before the other, and you cannot control the order of initialization. 

- types and casts 

    + type aliases 
    
using StringVector = std::vector<std::string>;

void processVector(const StringVector& vec) { /* omitted */ }

int main()
{
    StringVector myVector;
    processVector(myVector);
    return 0;
}

using string = basic_string<char>;

    + types for function pointers 
    
    take the address of a function and use it like you use a variable.
    
    ```
    using MatchFunction = bool(*)(int, int);
    
    void findMatches(int values1[], int values2[], size_t numValues,
                 MatchFunction matcher)
    {
        for (size_t i = 0; i < numValues; i++) {
            if (matcher(values1[i], values2[i])) {
                cout << "Match found at position " << i <<
                    " (" << values1[i] << ", " << values2[i] << ")" << endl;
            }
        }
    }
    ```
    MatchFunction that represents a pointer to any function that has two int parameters and returns a bool:

    Suppose the following is the prototype for Connect(), which returns an integer and accepts three parameters: a Boolean, an integer, and a C-style string.
    ```
    int __stdcall Connect(bool b, int n, const char* p);
    using ConnectFunction = int(__stdcall*)(bool, int, const char*);
    
    //Loading the library at run-time is done with the Windows LoadLibrary() kernel function:
    HMODULE lib = ::LoadLibrary("hardware.dll");
    
    //get a pointer to the function 
    ConnectFunction connect = (ConnectFunction)::GetProcAddress(lib, "Connect");
    connect(true, 3, "Hello world");
    ```

    + type aliases for pointers to methods and data members 
```
Employee employee;
using PtrToGet = int (Employee::*) () const;
PtrToGet methodPtr = &Employee::getSalary;
cout << (employee.*methodPtr)() << endl;

Employee employee;
auto methodPtr = &Employee::getSalary;
cout << (employee.*methodPtr)() << endl;
```

- typedefs 

Type aliases were introduced in C++11, Before C++11, you had to use typedef

typedef int* IntPtr;

typedef int (*FunctionType)(char, double);

equal to 

using FunctionType = int (*)(char, double);

Compared to typedefs, type aliases are more powerful when used with templates

- casts 

const_cast(), static_cast(), reinterpret_cast(), and dynamic_cast().


extern void ThirdPartyLibraryMethod(char* str);

void f(const char* str)
{
    ThirdPartyLibraryMethod(const_cast<char*>(str));
}

    + C++17, there is a helper method called std::as_const(), defined in <utility>, that returns a const reference version of its reference parameter. 
    
as_const(obj) is equivalent to const_cast<const T&>(obj), where T is the type of obj. As you can see, using as_const() is shorter than using const_cast(). 

```
std::string str = "C++";
const std::string& constStr = std::as_const(str);
```

//auto strips away reference and const qualifiers
//the result variable is type std::string, not const std::string&:
auto result = std::as_const(str);

- static_cast() 

```
int i = 3;
int j = 4;
double result = static_cast<double>(i) / j;
```

static_cast() is to perform downcasts in an inheritance hierarchy, as in this example:

```
class Base
{
    public:
        virtual ~Base() = default;
};

class Derived : public Base
{
    public:
        virtual ~Derived() = default;
};

int main()
{
    Base* b;
    Derived* d = new Derived();
    b = d; // Don't need a cast to go up the inheritance hierarchy
    d = static_cast<Derived*>(b); // Need a cast to go down the hierarchy

```

using static_cast() do not perform run-time type checking. They allow you to convert any Base pointer to a Derived pointer, or Base reference to a Derived reference

- reinterpret_cast() is a bit more powerful

```
class X {};
class Y {};

int main()
{
    X x;
    Y y;
    X* xp = &x;
    Y* yp = &y;
    // Need reinterpret cast for pointer conversion from unrelated classes
    // static_cast doesn't work.
    xp = reinterpret_cast<X*>(yp);
    // No cast required for conversion from pointer to void*
    void* p = xp;
    // Need reinterpret cast for pointer conversion from void*
    xp = reinterpret_cast<X*>(p);
    // Need reinterpret cast for reference conversion from unrelated classes
    // static_cast doesn't work.
    X& xr = x;
    Y& yr = reinterpret_cast<Y&>(x);
    return 0;
}
```
One use-case for reinterpret_cast() is with binary I/O of trivially copyable types.2 For example, you can write the individual bytes of such types to a file. When you read the file back into memory, you can use reinterpret_cast() to correctly interpret the bytes read from the file.

without performing any type checking.

- dynamic_cast() provides a run-time check on casts within an inheritance hierarchy. You can use it to cast pointers or references.

dynamic_cast() returns a null pointer (for the pointer version), or throws an std::bad_cast exception (for the reference version).

```
class Base
{
    public:
        virtual ~Base() = default;
};

class Derived : public Base
{
    public:
        virtual ~Derived() = default;
};
```

correct use of dynamic_cast()
```
Base* b;
Derived* d = new Derived();
b = d;
d = dynamic_cast<Derived*>(b);
```

dynamic_cast() on a reference will cause a exception to be thrown 
```
Base base;
Derived derived;
Base& br = base;
try {
    Derived& dr = dynamic_cast<Derived&>(br);
} catch (const bad_cast&) {
    cout << "Bad cast!" << endl;
}
```

The difference with dynamic_cast() is that it performs run-time (dynamic) type checking, while static_cast() and reinterpret_cast() perform the casting even if they are erroneous.

- scope resolution 
Variables that are initialized in the initialization statement of for loops are scoped to that for loop and are not visible outside that for loop

The global scope is unnamed, but you can access it specifically by using the scope resolution operator by itself
```
class Demo
{
    public:
        static int get() { return 5; }
};

int get() { return 10; }

namespace NS
{
    int get() { return 20; }
}

int main()
{
    auto pd = std::make_unique<Demo>();
    Demo d;
    std::cout << pd->get() << std::endl;    // prints 5
    std::cout << d.get() << std::endl;      // prints 5
    std::cout << NS::get() << std::endl;    // prints 20
    std::cout << Demo::get() << std::endl;  // prints 5
    std::cout << ::get() << std::endl;      // prints 10
    std::cout << get() << std::endl;        // prints 10
    return 0;
}
```

change default scope 
``` 
using namespace NS;
```
- Attributes are a mechanism to add optional and/or vendor-specific information into source code. 

Examples are __attribute__, __declspec, and so on. Since C++11, there is standardized support for attributes by using the double square brackets syntax [[attribute]].

[[noreturn]]means that a function never returns control to the call site. 

```
[[noreturn]] void forceProgramTermination()
{
    std::exit(1);
}

[[deprecated("Unsafe method, please use xyz")]] void func();
```

[[noreturn]] attribute, the compiler generates the following warning (output from Visual C++):


Starting with C++17, you can tell the compiler that a fallthrough in a switch statement is intentional using the [[fallthrough]] attribute. 
```
switch (backgroundColor) {
    case Color::DarkBlue:
        doSomethingForDarkBlue();
        [[fallthrough]];
    case Color::Black:
        // Code is executed for both a dark blue or black background color
        doSomethingForBlackOrDarkBlue();
        break;
    case Color::Red:
    case Color::Green:
        // Code to execute for a red or green background color
        break;
}
```

The [[nodiscard]] attribute can be used on a function returning a value to let the compiler issue a warning when that function is used without doing something with the returned value. 
```
[[nodiscard]] int func()
{
    return 42;
}

int main()
{
    func();
    return 0;
}
```

The [[maybe_unused]] attribute can be used to suppress the compiler from issuing a warning when something is unused
```
int func(int param1, [[maybe_unused]] int param2)
{
    return 42;
}
```

    + vendor-specific attributes 
[[clang::noduplicate]]

different vendors could clash, vendors are recommended to qualify them

- user defined literals 

'a': character
"character array": zero-terminated array of characters, C-style string
3.14f: float floating point value
0xabc: hexadecimal value

C++ also allows you to define your own literals. User-defined literals should start with an underscore. The first character following the underscore must be a lowercase letter. Some examples are: _i, _s, _km, _miles, and so on. 

- A cooked-mode literal operator should have either of the following

one parameter of type unsigned long long, long double, char, wchar_t, char16_t, or char32_t to process numeric values

two parameters where the first is a character array and the second is the length of the character array, to process strings

use _i to define a complex number, following implements a cooked literal operator for the user-defined literal _i to define a complex number literal:
```
std::complex<long double> operator"" _i(long double d)
{
    return std::complex<long double>(0, d);
}

std::complex<long double> c1 = 9.634_i;
auto c2 = 1.23_i;       // c2 has as type std::complex<long double>
```

implements a cooked literal operator for a user-defined literal _s to define std::string literals:
```
std::string operator"" _s(const char* str, size_t len)
{
    return std::string(str, len);
}

std::string str1 = "Hello World"_s;
auto str2 = "Hello World"_s;   // str2 has as type std::string
```

- standard user-defined literals 

“s” for creating std::strings
For example: auto myString = "Hello World"s;
Requires a using namespace std::string_literals;

    + cpp17 

“sv” for creating std::string_views
For example: auto myStringView = "Hello World"sv;
Requires a using namespace std::string_view_literals;
“h”, “min”, “s”, “ms”, “us”, “ns”, for creating std::chrono::duration time intervals, discussed in Chapter 20
For example: auto myDuration = 42min;
Requires a using namespace std::chrono_literals;
“i”, “il”, “if” for creating complex numbers, complex<double>, complex<long double>, and complex<float>, respectively
For example: auto myComplexNumber = 1.3i;
Requires a using namespace std::complex_literals;

using namespace std; also makes these standard user-defined literals avail

- header files 

    + include guard 

avoided with a mechanism known as include guards. The following code snippet shows the Logger.h header
```
#ifndef LOGGER_H
#define LOGGER_H

class Logger
{
    // ...
};

#endif // LOGGER_H
```

Nearly all compilers these days support the #pragma once directive 
```
#pragma once

class Logger
{
    // ...
};
```

    + forward-declared classes 
```
#pragma once

#include <string_view>

class Preferences;  // forward declaration

class Logger
{
    public:
        static void setPreferences(const Preferences& prefs);
        static void logError(std::string_view error);
};
```

    + cpp17 adds the __has_include("filename") and __has_include(<filename>) preprocessor constants. 

#if __has_include(<optional>)
    #include <optional>
#elif __has_include(<experimental/optional>)
    #include <experimental/optional>
#endif

- variable length argument list 

arbitrary types of arguments. A simple implementation looks like this

```
#include <cstdio>
#include <cstdarg>

bool debug = false;

void debugOut(const char* str, ...)
{
    va_list ap;
    if (debug) {
        va_start(ap, str);
        vfprintf(stderr, str, ap);
        va_end(ap);
    }
}
```

you must use macros defined in <cstdarg>. You declare a variable of type va_list, and initialize it with a call to va_start. The second parameter to va_start() must be the rightmost named variable in the parameter list. All functions with variable-length argumen  lists require at least one named parameter. 

    + accessing the arguments 
    
access the actual arguments yourself, you can use va_arg() to do so. It accepts a va_list as first argument, and the type of the argument to interpret. 
```
void printInts(size_t num, ...)
{
    int temp;
    va_list ap;
    va_start(ap, num);
    for (size_t i = 0; i < num; ++i) {
        temp = va_arg(ap, int);
        cout << temp << " ";
    }
    va_end(ap);
    cout << endl;
}
```
Avoid using C-style variable-length argument lists.

- preprocessor macros 
```
#define SQUARE(x) ((x) * (x)) // No semicolon after the macro definition!

int main()
{
    cout << SQUARE(5) << endl;
    return 0;
}
```

Macros also cause problems for debugging because the code you write is not the code that the compiler sees



# Writing generic code with template 
- cdoe with template 

```
class ChessPiece : public GamePiece
{
    public:
        virtual std::unique_ptr<GamePiece> clone() const override;
};

std::unique_ptr<GamePiece> ChessPiece::clone() const
{
    // Call the copy constructor to copy this instance
    return std::make_unique<ChessPiece>(*this);
}
```

```
template <typename T>
class Grid
{
    public:
        explicit Grid(size_t width = kDefaultWidth,
            size_t height = kDefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<T>& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and assignment operator.
        Grid(Grid&& src) = default;
        Grid<T>& operator=(Grid&& rhs) = default;

        std::optional<T>& at(size_t x, size_t y);
        const std::optional<T>& at(size_t x, size_t y) const;

        size_t getHeight() const { return mHeight; }
        size_t getWidth() const { return mWidth; }

        static const size_t kDefaultWidth = 10;
        static const size_t kDefaultHeight = 10;

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::vector<std::vector<std::optional<T>>> mCells;
        size_t mWidth, mHeight;
};

template <typename T>
Grid<T>::Grid(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
    // Equivalent to:
    //for (std::vector<std::optional<T>>& column : mCells) {
        column.resize(mHeight);
    }
}

template <typename T>
void Grid<T>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= mWidth || y >= mHeight) {
        throw std::out_of_range("");
    }
}

template <typename T>
const std::optional<T>& Grid<T>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

template <typename T>
std::optional<T>& Grid<T>::at(size_t x, size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}


Grid<int> myIntGrid; // declares a grid that stores ints,
                     // using default arguments for the constructor
Grid<double> myDoubleGrid(11, 11); // declares an 11x11 Grid of doubles

myIntGrid.at(0, 0) = 10;
int x = myIntGrid.at(0, 0).value_or(0);

Grid<int> grid2(myIntGrid);  // Copy constructor
Grid<int> anotherIntGrid;
anotherIntGrid = grid2;      // Assignment operator

Grid test;   // WILL NOT COMPILE
Grid<> test; // WILL NOT COMPILE


//declare a function or method that takes a Grid object, you must specify the type stored in that grid as part of the Grid type
void processIntGrid(Grid<int>& grid)
{
   // Body omitted for brevity
}

using IntGrid = Grid<int>;
void processIntGrid(IntGrid& grid) { }
```

- angle brackets 

    + old 
std::vector<std::vector<T> > mCells;
    
    + new style 
std::vector<std::vector<T> > mCells;

- distributing template code between files 

Templates don’t work that way. Because they are “templates” for the compiler to generate the actual methods for the instantiated types, both class template definitions and method definitions must be available to the compiler in any source file that uses them

```
template <typename T>
class Grid
{
    // Class definition omitted for brevity
};

#include "GridDefinitions.h"
```

you don’t add the Grid.cpp file to your project compiled separately; it should be #included only in a header file!


```
template <typename T>
class Grid
{
    // Class definition omitted for brevity
};

#include "Grid.h"
#include <utility>

template <typename T>
Grid<T>::Grid(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
        column.resize(mHeight);
    }
}
// Other method definitions omitted for brevity...

// Explicit instantiations for the types you want to allow.
template class Grid<int>;
template class Grid<double>;
template class Grid<std::vector<int>>;
```

- non-type template parameters

```
template <typename T, size_t WIDTH, size_t HEIGHT>
class Grid
{
    public:
        Grid() = default;
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<T, WIDTH, HEIGHT>& operator=(const Grid& rhs) = default;

        std::optional<T>& at(size_t x, size_t y);
        const std::optional<T>& at(size_t x, size_t y) const;

        size_t getHeight() const { return HEIGHT; }
        size_t getWidth() const { return WIDTH; }

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::optional<T> mCells[WIDTH][HEIGHT];
};

template <typename T, size_t WIDTH, size_t HEIGHT>
void Grid<T, WIDTH, HEIGHT>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= WIDTH || y >= HEIGHT) {
        throw std::out_of_range("");
    }
}

template <typename T, size_t WIDTH, size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

template <typename T, size_t WIDTH, size_t HEIGHT>
std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}
```

- default values for type parameters 

```
template <typename T = int, size_t WIDTH = 10, size_t HEIGHT = 10>
class Grid
{
    // Remainder is identical to the previous version
};

template <typename T, size_t WIDTH, size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

Grid<> myIntGrid;
Grid<int> myGrid;
Grid<int, 5> anotherGrid;
Grid<int, 5, 5> aFourthGrid;
```

    + C++17 adds support to automatically deduce the template parameters from the arguments passed to a class template constructor. 
std::pair<int, double> pair1(1, 2.3);
auto pair2 = std::make_pair(1, 2.3);

- write your own user-defined deduction guides. 

```
template<typename T>
class SpreadsheetCell
{
    public:
        SpreadsheetCell(const T& t) : mContent(t) { }

        const T& getContent() const { return mContent; }

    private:
        T mContent;
};

std::string myString = "Hello World!";
SpreadsheetCell cell(myString);

SpreadsheetCell(const char*) -> SpreadsheetCell<std::string>;
explicit TemplateName(Parameters) -> DeducedTemplate;
```

- method template 

Consider the original Grid template with only one template parameter
```
Grid<int> myIntGrid;
Grid<double> myDoubleGrid;

myDoubleGrid = myIntGrid;              // DOES NOT COMPILE
Grid<double> newDoubleGrid(myIntGrid); // DOES NOT COMPILE

Grid(const Grid& src);
Grid<T>& operator=(const Grid& rhs);

Grid(const Grid<T>& src);
Grid<T>& operator=(const Grid<T>& rhs);

template <typename T>
class Grid
{
    public:
        // Omitted for brevity

        template <typename E>
        Grid(const Grid<E>& src);

        template <typename E, size_t WIDTH2, size_t HEIGHT2>
        Grid(const Grid<E, WIDTH2, HEIGHT2>& src);

        void swap(Grid& other) noexcept;

        // Omitted for brevity
};

template <typename E>
Grid(const Grid<E>& src);

template <typename T, size_t WIDTH, size_t HEIGHT>
template <typename E, size_t WIDTH2, size_t HEIGHT2>
Grid<T, WIDTH, HEIGHT>::Grid(const Grid<E, WIDTH2, HEIGHT2>& src)
{
    for (size_t i = 0; i < WIDTH; i++) {
        for (size_t j = 0; j < HEIGHT; j++) {
            if (i < WIDTH2 && j < HEIGHT2) {
                mCells[i][j] = src.at(i, j);
            } else {
                mCells[i][j].reset();
            }
        }
    }
}

template <typename T>
template <typename E>
Grid<T>& Grid<T>::operator=(const Grid<E>& rhs)
{
    // no need to check for self-assignment because this version of
    // assignment is never called when T and E are the same

    // Copy-and-swap idiom
    Grid<T> temp(rhs); // Do all the work in a temporary instance
    swap(temp); // Commit the work with only non-throwing operations
    return *this;
}

template <typename T>
void Grid<T>::swap(Grid<T>& other) noexcept
{
    using std::swap;

    swap(mWidth, other.mWidth);
    swap(mHeight, other.mHeight);
    swap(mCells, other.mCells);
}

template <typename T, typename E> // Wrong for nested template constructor!
Grid<T>::Grid(const Grid<E>& src)
```

- class template specification 

```
// When the template specialization is used, the original template must be
// visible too. Including it here ensures that it will always be visible
// when this specialization is visible.
#include "Grid.h"

template <>
class Grid<const char*>
{
    public:
        explicit Grid(size_t width = kDefaultWidth,
            size_t height = kDefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<const char*>& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and assignment operator.
        Grid(Grid&& src) = default;
        Grid<const char*>& operator=(Grid&& rhs) = default;

        std::optional<std::string>& at(size_t x, size_t y);
        const std::optional<std::string>& at(size_t x, size_t y) const;

        size_t getHeight() const { return mHeight; }
        size_t getWidth() const { return mWidth; }

        static const size_t kDefaultWidth = 10;
        static const size_t kDefaultHeight = 10;

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::vector<std::vector<std::optional<std::string>>> mCells;
        size_t mWidth, mHeight;
};

Grid<int> myIntGrid;                 // Uses original Grid template
Grid<const char*> stringGrid1(2, 2); // Uses const char* specialization

const char* dummy = "dummy";
stringGrid1.at(0, 0) = "hello";
stringGrid1.at(0, 1) = dummy;
stringGrid1.at(1, 0) = dummy;
stringGrid1.at(1, 1) = "there";

Grid<const char*> stringGrid2(stringGrid1);

//This syntax tells the compiler that this class is a const char* specialization of the Grid class
template <>
class Grid<const char*>
//the template definitions, you do not repeat the template<> syntax before each method definition.
Grid<const char*>::Grid(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
        column.resize(mHeight);
    }
}

void Grid<const char*>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= mWidth || y >= mHeight) {
        throw std::out_of_range("");
    }
}

const std::optional<std::string>& Grid<const char*>::at(
    size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

std::optional<std::string>& Grid<const char*>::at(size_t x, size_t y)
{
    return const_cast<std::optional<std::string>&>(
        std::as_const(*this).at(x, y));
}
```

- deriving from class templates 

```
#include "Grid.h"

template <typename T>
class GameBoard : public Grid<T>
{
    public:
        explicit GameBoard(size_t width = Grid<T>::kDefaultWidth,
            size_t height = Grid<T>::kDefaultHeight);
        void move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest);
};

template <typename T>
GameBoard<T>::GameBoard(size_t width, size_t height)
    : Grid<T>(width, height)
{
}

template <typename T>
void GameBoard<T>::move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest)
{
    Grid<T>::at(xDest, yDest) = std::move(Grid<T>::at(xSrc, ySrc));
    Grid<T>::at(xSrc, ySrc).reset();  // Reset source cell
    // Or:
    // this->at(xDest, yDest) = std::move(this->at(xSrc, ySrc));
    // this->at(xSrc, ySrc).reset();
}

GameBoard<ChessPiece> chessboard(8, 8);
ChessPiece pawn;
chessBoard.at(0, 0) = pawn;
chessBoard.move(0, 0, 0, 1);
```

- alias templates 

```
using MyInt = int;

template<typename T1, typename T2>
class MyTemplateClass { /* ... */ };

using OtherName = MyTemplateClass<int, double>;

//alias template, This is something you cannot do with a typedef.
template<typename T1>
using OtherName = MyTemplateClass<T1, double>;

```

- function templates 

```
static const size_t NOT_FOUND = static_cast<size_t>(-1);

template <typename T>
size_t Find(const T& value, const T* arr, size_t size)
{
    for (size_t i = 0; i < size; i++) {
        if (arr[i] == value) {
            return i; // Found it; return the index
        }
    }
    return NOT_FOUND; // Failed to find it; return NOT_FOUND
}

template <typename T, size_t N>
size_t Find(const T& value, const T(&arr)[N])
{
    return Find(value, arr, N);
}

int myInt = 3, intArray[] = {1, 2, 3, 4};
size_t res = Find(myInt, intArray);
```

The C++ Standard Library provides a templatized std::find() function that is more powerful than the Find() function template

- function template specialization 

//C-style strings that compares them with strcmp() instead of operator==. Here is a specialization of the Find() 
```
template<>
size_t Find<const char*>(const char* const& value,
    const char* const* arr, size_t size)
{
    for (size_t i = 0; i < size; i++) {
        if (strcmp(arr[i], value) == 0) {
            return i; // Found it; return the index
        }
    }
    return NOT_FOUND; // Failed to find it; return NOT_FOUND
}

template<>
size_t Find(const char* const& value, const char* const* arr, size_t size)

const char* word = "two";
const char* words[] = {"one", "two", "three", "four"};
const size_t sizeWords = std::size(words);
size_t res;
// Calls const char* specialization
res = Find<const char*>(word, words, sizeWords);
// Calls const char* specialization
res = Find(word, words, sizeWords);
```

- function template overloading 

//write a non-template Find() function that works on const char*s
```
size_t Find(const char* const& value, const char* const* arr, size_t size)
{
    for (size_t i = 0; i < size; i++) {
        if (strcmp(arr[i], value) == 0) {
            return i; // Found it; return the index
        }
    }
    return NOT_FOUND; // Failed to find it; return NOT_FOUND
}
```

- Suppose you want to make your operator+ a stand-alone function template. 
```
template <typename T>
Grid<T> operator+(const Grid<T>& lhs, const Grid<T>& rhs)
{
    size_t minWidth = std::min(lhs.getWidth(), rhs.getWidth());
    size_t minHeight = std::min(lhs.getHeight(), rhs.getHeight());

    Grid<T> result(minWidth, minHeight);
    for (size_t y = 0; y < minHeight; ++y) {
        for (size_t x = 0; x < minWidth; ++x) {
            const auto& leftElement = lhs.mCells[x][y];
            const auto& rightElement = rhs.mCells[x][y];
            if (leftElement.has_value() && rightElement.has_value())
                result.at(x, y) = leftElement.value() + rightElement.value();
        }
    }
    return result;
}

// Forward declare Grid template.
template <typename T> class Grid;

// Prototype for templatized operator+.
template<typename T>
Grid<T> operator+(const Grid<T>& lhs, const Grid<T>& rhs);

template <typename T>
class Grid
{
    public:
         // Omitted for brevity
        friend Grid<T> operator+ <T>(const Grid<T>& lhs, const Grid<T>& rhs);
        // Omitted for brevity
};
```

To query whether an std::optional contains an actual value, you use the has_value() method, while value() is used to retrieve this value

particularly the explicit template specification <T> on operator+ (the space after operator+ is optional). This syntax tells the compiler that operator+ is itself a template.

- template parameter deduction 

```
template<typename RetType, typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

auto result = add<long, int, int>(1, 2);
auto result = add<long long>(1, 2);

template<typename RetType = long long, typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }
...
auto result = add(1, 2);
```

- return type of function templates 

```
template<typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

template<typename T1, typename T2>
auto add(const T1& t1, const T2& t2)
{
    return t1 + t2;
}

//auto strips reference and const qualifiers, s1 is of type string
auto s1 = getString();
const auto& s2 = getString();

//decltype will not strips const and reference 
decltype(getString()) s3 = getString();
decltype(auto) s4 = getString();

//now that C++ supports auto return type deduction and decltype(auto)
template<typename T1, typename T2>
decltype(auto) add(const T1& t1, const T2& t2)
{
    return t1 + t2;
}
```

    + cpp11 
```
template<typename T1, typename T2>
decltype(t1+t2) add(const T1& t1, const T2& t2) { return t1 + t2; }
```

- variable templates 

    + cpp14 support
```
template <typename T>
constexpr T pi = T(3.141592653589793238462643383279502884);

//This is a variable template for the value of pi
float piFloat = pi<float>;
long double piLongDouble = pi<long double>;
```


# Demystifying c++ i/o 
- book’s website at www.wrox.com/go/proc++4e on the Download Code tab.

cin 	An input stream, reads data from the “input console.”
cout 	A buffered output stream, writes data to the “output console.”
cerr 	An unbuffered output stream, writes data to the “error console,” which is often the same as the “output console.”
clog 	A buffered version of cerr.

- In C++, there are three common sources and destinations for streams: console, file, and string.

- put() and write()

put() and write() are raw output methods. Instead of taking an object or variable that has some defined behavior for output, put() accepts a single character, while write() accepts a character array

const char* test = "hello there\n";
cout.write(test, strlen(test));

- flush()

When you write to an output stream, the stream does not necessarily write the data to its destination right away. Most output streams buffer, or accumulate data instead of writing it out as soon as it comes in

- handle errors, The good() method provides an easy way to obtain basic information about the validity of the stream

cout.flush();
if (cout.fail()) {
    cerr << "Unable to flush to standard out" << endl;
}

cout.flush();
if (!cout) {
    cerr << "Unable to flush to standard out" << endl;
}
    + You can also tell the streams to throw exceptions when a failure occurs. 
cout.exceptions(ios::failbit | ios::badbit | ios::eofbit);
try {
    cout << "Hello World." << endl;
} catch (const ios_base::failure& ex) {
    cerr << "Caught exception: " << ex.what()
         << ", error code = " << ex.code() << endl;
}

//clear error 
cout.clear();

- output manipulators 

boolalpha and noboolalpha: Tells the stream to output bool values as true and false (boolalpha) or 1 and 0 (noboolalpha). The default is noboolalpha.
hex, oct, and dec: Outputs numbers in hexadecimal, octal, and base 10, respectively.
setprecision: Sets the number of decimal places that are output for fractional numbers. This is a parameterized manipulator (meaning that it takes an argument).
setw: Sets the field width for outputting numerical data. This is a parameterized manipulator.
setfill: Specifies the character that is used to pad numbers that are smaller than the specified width. This is a parameterized manipulator.
showpoint and noshowpoint: Forces the stream to always or never show the decimal point for floating point numbers with no fractional part.
put_money: A parameterized manipulator that writes a formatted monetary value to a stream.
put_time: A parameterized manipulator that writes a formatted time to a stream.
quoted: A parameterized manipulator that encloses a given string with quotes and escapes embedded quotes.

    + example 
// Boolean values
bool myBool = true;
cout << "This is the default: " << myBool << endl;
cout << "This should be true: " << boolalpha << myBool << endl;
cout << "This should be 1: " << noboolalpha << myBool << endl;

// Simulate "%6d" with streams
int i = 123;
printf("This should be '   123': %6d\n", i);
cout << "This should be '   123': " << setw(6) << i << endl;

// Simulate "%06d" with streams
printf("This should be '000123': %06d\n", i);
cout << "This should be '000123': " << setfill('0') << setw(6) << i << endl;

// Fill with *
cout << "This should be '***123': " << setfill('*') << setw(6) << i << endl;
// Reset fill character
cout << setfill(' ');

// Floating point values
double dbl = 1.452;
double dbl2 = 5;
cout << "This should be ' 5': " << setw(2) << noshowpoint << dbl2 << endl;
cout << "This should be @@1.452: " << setw(7) << setfill('@') << dbl << endl;
// Reset fill character
cout << setfill(' ');

// Instructs cout to start formatting numbers according to your location.
// Chapter 19 explains the details of the imbue call and the locale object.
cout.imbue(locale(""));

// Format numbers according to your location
cout << "This is 1234567 formatted according to your location: " << 1234567 
     << endl;

// Monetary value. What exactly a monetary value means depends on your
// location. For example, in the USA, a monetary value of 120000 means 120000
// dollar cents, which is 1200.00 dollars.
cout << "This should be a monetary value of 120000, "
     << "formatted according to your location: "
     << put_money("120000") << endl;

// Date and time
time_t t_t = time(nullptr);  // Get current system time
tm* t = localtime(&t_t);     // Convert to local time
cout << "This should be the current date and time "
     << "formatted according to your location: "
     << put_time(t, "%c") << endl;
     
// Quoted string
cout << "This should be: \"Quoted string with \\\"embedded quotes\\\".\": "
     << quoted("Quoted string with \"embedded quotes\".") << endl;

- the book C++ Standard Library Quick Reference, or online references http://www.cppreference.com/ or http://www.cplusplus.com/reference/.

- input streams 

string userInput;
cin >> userInput;

- handling input error 

while (cin >> ch) { ... }

The relation is again as follows: good() == (!fail() && !eof()).

```
cout << "Enter numbers on separate lines to add. "
     << "Use Control+D to finish (Control+Z in Windows)." << endl;
int sum = 0; 

if (!cin.good()) { 
    cerr << "Standard input is in a bad state!" << endl; 
    return 1; 
} 

int number;
while (!cin.bad()) { 
    cin >> number;
    if (cin.good()) {
        sum += number; 
    } else if (cin.eof()) {
        break; // Reached end of file
    } else if (cin.fail()) {
        // Failure!
        cin.clear(); // Clear the failure state.
        string badToken;
        cin >> badToken; // Consume the bad input.
        cerr << "WARNING: Bad input encountered: " << badToken << endl;
    }
} 
cout << "The sum is " << sum << endl;
```

- input methods 

get()

The get() method allows raw input of data from a stream.

unget()

For most purposes, the correct way to think of an input stream is as a one-way chute. 

putback()

The putback() method, like unget(), lets you move backward by one character in an input stream.

peek ()

The peek() method allows you to preview the next value that would be returned if you were to call get().

getline()

Obtaining a single line of data from an input stream is so common that a method exists to do it for you. The getline() method fills a character buffer with a line of data up to the specified size. 

- string streams 

closing the input stream with Control+D (Unix) or Control+Z (Windows).

```
cout << "Enter tokens. Control+D (Unix) or Control+Z (Windows) to end" << endl;
ostringstream outStream;
while (cin) {
    string nextToken;
    cout << "Next token: ";
    cin >> nextToken;
    if (!cin || nextToken == "done")
        break;
    outStream << nextToken << "\t";
}
cout << "The end result is: " << outStream.str();
```

- file streams, Marshalling is useful for saving objects to disk or sending them across a network.

std::ofstream and std::ifstream classes provide output and input functionality for files. defined in the <fstream> header file

    + different constants 
    
ios_base::app 	Open, and go to the end before each write operation.
ios_base::ate 	Open, and go to the end once immediately after opening.
ios_base::binary 	Perform input and output in binary mode as opposed to text mode. See the next section.
ios_base::in 	Open for input, start reading at the beginning.
ios_base::out 	Open for output, start writing at the beginning, overwriting existing data.
ios_base::trunc 	Open for output, and delete all existing data (truncate).


specify the open mode as follows:

ios_base::out | ios_base::binary  | ios_base::trunc

//The ifstream and ofstream destructors automatically close the underlying file, so there is no need to explicitly call close().
```
int main(int argc, char* argv[])
{
    ofstream outFile("test.txt", ios_base::trunc);
    if (!outFile.good()) {
        cerr << "Error while opening output file!" << endl;
        return -1;
    }
    outFile << "There were " << argc << " arguments to this program." << endl;
    outFile << "They are: " << endl;
    for (int i = 0; i < argc; i++) {
        outFile << argv[i] << endl;
    }
    return 0;
}
```

- text mode versus binary mode 

each line you write to, or read from a file ends with a \n. However, it is operating-system dependent how the end of a line is encoded in a file

on Windows, a line ends with \r\n instead of with a single \n character, a file is opened in text mode and you write a line ending with \n to it, the underlying implementation automatically converts the \n to \r\n before writing it to the file.

- jumping around with seek() and tell() 

The seek() and tell() methods are present on all input and output streams.

are several forms of seek(). The methods of seek() within an input stream are actually called seekg() (the g is for get), and the versions of seek() in an output stream are called seekp() (the p is for put).

    + three predefined position 
    
ios_base::beg 	The beginning of the stream
ios_base::end 	The end of the stream
ios_base::cur 	The current position in the stream

```
outStream.seekp(ios_base::beg);

std::streampos curPos = inStream.tellg();
if (ios_base::beg == curPos) {
    cout << "We're at the beginning." << endl;
}
```

- linking streams together 

ifstream inFile("input.txt");  // Note: input.txt must exist.
ofstream outFile("output.txt");
// Set up a link between inFile and outFile.
inFile.tie(&outFile);
// Output some text to outFile. Normally, this would
// not flush because std::endl is not sent.
outFile << "Hello there!";
// outFile has NOT been flushed.
// Read some text from inFile. This will trigger flush()
// on outFile.
string nextToken;
inFile >> nextToken;
// outFile HAS been flushed.

outFile.tie(&anotherOutputFile);


# Handling errors 
- the errno macro to signify errors. Each thread has its own errno value. errno acts as a thread-local integer variable
```
try {
    // ... code which may result in an exception being thrown
} catch (exception-type1 exception-name) {
    // ... code which responds to the exception of type 1
} catch (exception-type2 exception-name) {
    // ... code which responds to the exception of type 2
} catch (const exception& e) {
} catch (...) {
    cerr << "Error reading or opening file " << fileName << endl;
    terminate();
   
}
//


ifstream inputStream(fileName.data());
if (inputStream.fail()) {
    // We failed to open the file: throw an exception
    throw exception();
}

throw runtime_error("Error reading the file.");

```

- mark a function do not allowed throw exception 

vector<int> readIntegerFile(string_view fileName) noexcept;

- Because C++17 has officially removed support for exception specifications,

C++ runtime called std::unexpected() which by default called std::terminate() to terminate the application.

- writing your own exception classes 

writing your own exception classes.

The number of exceptions in the C++ Standard Library is limited. Instead of using an exception class with a generic name

```
class FileError : public exception
{
    public:
        FileError(string_view fileName) : mFileName(fileName) {}

        virtual const char* what() const noexcept override {
            return mMessage.c_str();
        }

        string_view getFileName() const noexcept { return mFileName; }

    protected:
        void setMessage(string_view message) { mMessage = message; }

    private:
        string mFileName;
        string mMessage;
};
```

- nested exceptions

You use std::throw_with_nested() to throw an exception with another exception nested inside it

```
class MyException : public std::exception
{
    public:
        MyException(string_view message) : mMessage(message) {}
        virtual const char* what() const noexcept override {
            return mMessage.c_str();
        }
    private:
        string mMessage;
};

void doSomething()
{
    try {
        throw runtime_error("Throwing a runtime_error exception");
    } catch (const runtime_error& e) {
        cout << __func__ << " caught a runtime_error" << endl;
        cout << __func__ << " throwing MyException" << endl;
        throw_with_nested(
            MyException("MyException with nested runtime_error"));
    }
}

int main()
{
    try {
        doSomething();
    } catch (const MyException& e) {
        cout << __func__ << " caught MyException: " << e.what() << endl;

        const auto* pNested = dynamic_cast<const nested_exception*>(&e);
        if (pNested) {
            try {
                pNested->rethrow_nested();
            } catch (const runtime_error& e) {
                // Handle nested exception
                cout << "  Nested exception: " << e.what() << endl;
            }
        }
    }
    return 0;
}

//with helper function in the standard provides a small helper function called std::rethrow_if_nested() that does it for you. 

int main()
{
    try {
        doSomething();
    } catch (const MyException& e) {
        cout << __func__ << " caught MyException: " << e.what() << endl;
        try {
            rethrow_if_nested(e);
        } catch (const runtime_error& e) {
            // Handle nested exception
            cout << "  Nested exception: " << e.what() << endl;
        }
    }
    return 0;
}
```

- rethrow exception 
```
void g() { throw invalid_argument("Some exception"); }

void f()
{
    try {
        g();
    } catch (const invalid_argument& e) {
        cout << "caught in f: " << e.what() << endl;
        throw;  // rethrow
    }
}

int main()
{
    try {
        f();
    } catch (const invalid_argument& e) {
        cout << "caught in main: " << e.what() << endl;
    }
    return 0;
}
```
- use smart pointers 

```
void funcOne() 
{
    string str1;
    auto str2 = make_unique<string>("hello");
    funcTwo();
}
```

- catch, clean up and rethrow 
```
void funcOne()
{
    string str1;
    string* str2 = new string();
    try {
        funcTwo();
    } catch (...) {
        delete str2;
        throw; // Rethrow the exception.
    }
    delete str2;
}
```

- memory allocate errors 

The default behaviors of new and new[] are to throw an exception of type bad_alloc, defined in the <new> header file

```
int* ptr = nullptr;
size_t integerCount = numeric_limits<size_t>::max();
try {
    ptr = new int[integerCount];
} catch (const bad_alloc& e) {
    cerr << __FILE__ << "(" << __LINE__
         << "): Unable to allocate memory: " << e.what() << endl;
    // Handle memory allocation failure.
    return;
}
// Proceed with function that assumes memory has been allocated.
```

- non-throwing new which return nullptr instead of throwing an exception 
```
int* ptr = new(nothrow) int[integerCount];
if (ptr == nullptr) {
    cerr << __FILE__ << "(" << __LINE__
         << "): Unable to allocate memory!" << endl;
    // Handle memory allocation failure.
    return;
}
// Proceed with function that assumes memory has been allocated.
```
- custom memory location error behavior, You set the new handler with a call to set_new_handler(), declared in the <new> header file.

new_handler is a typedef for the type of function pointer that set_new_handler() takes.
```
class please_terminate_me : public bad_alloc { };

void myNewHandler()
{
    cerr << "Unable to allocate memory." << endl;
    throw please_terminate_me();
}

int main()
{
    try {
        // Set the new new_handler and save the old one.
        new_handler oldHandler = set_new_handler(myNewHandler);

        // Generate allocation error
        size_t numInts = numeric_limits<size_t>::max();
        int* ptr = new int[numInts];

        // Reset the old new_handler
        set_new_handler(oldHandler);
    } catch (const please_terminate_me&) {
        cerr << __FILE__ << "(" << __LINE__
             << "): Terminating program." << endl;
        return 1;
    }
    return 0;
}
```

- errors in constructors 

Constructors don’t have a return value, so the standard pre-exception error-handling mechanism doesn’t work. Without exceptions, the best you can do is to set a flag in the object specifying that it is not constructed properly. You can provide a method, with a name like checkConstructionStatus()

You can throw an exception from a constructor, even though you can’t return a value. if an exception leaves a constructor, the destructor for that object will never be called!

If a derived class constructor throws an exception, C++ will execute the destructor of the fully constructed base class

In production-quality code, you should avoid using raw pointers

    + example handle errors in constructor 
```
template <typename T>
class Matrix
{
    public:
        Matrix(size_t width, size_t height);
        virtual ~Matrix();
    private:
        void cleanup();

        size_t mWidth = 0;
        size_t mHeight = 0;
        T** mMatrix = nullptr;
};


template <typename T>
Matrix<T>::Matrix(size_t width, size_t height)
{
    mMatrix = new T*[width] {};    // Array is zero-initialized!

    // Don't initialize the mWidth and mHeight members in the ctor-
    // initializer. These should only be initialized when the above
    // mMatrix allocation succeeds!
    mWidth = width;
    mHeight = height;

    try {
        for (size_t i = 0; i < width; ++i) {
            mMatrix[i] = new T[height];
        }
    } catch (...) {
        std::cerr << "Exception caught in constructor, cleaning up..."
            << std::endl;
        cleanup();
        // Nest any caught exception inside a bad_alloc exception.
        std::throw_with_nested(std::bad_alloc());
    }
}

template <typename T>
Matrix<T>::~Matrix()
{
    cleanup();
}

template <typename T>
void Matrix<T>::cleanup()
{
    for (size_t i = 0; i < mWidth; ++i)
        delete[] mMatrix[i];
    delete[] mMatrix;
    mMatrix = nullptr;
    mWidth = mHeight = 0;
}

//test 
class Element
{
    // Kept to a bare minimum, but in practice, this Element class
    // could throw exceptions in its constructor.
    private:
        int mValue;
};

int main()
{
    Matrix<Element> m(10, 10);
    return 0;
}
```

- function-try-blocks for constructors, Function-try-blocks work for normal functions as well as for constructors. 

```
MyClass::MyClass()
try
    : <ctor-initializer>
{
     /* ... constructor body ... */
}
catch (const exception& e)
{
     /* ... */
}
```
The catch statements catch any exception thrown either directly or indirectly by the ctor-initializer
The catch statements have to rethrow the current exception or throw a new exception.
The catch statements can access arguments passed to the constructor.
When a catch statement catches an exception in a function-try-block, all fully constructed base classes and members of the object are destroyed
Inside catch statements you should not access member variables that are objects because these are destroyed prior to executing the catch statements 
The catch statements in a function-try-block cannot use the return keyword to return a value from the function enclosed by it

    + function-try-blocks for constructors are useful only
To convert an exception thrown by the ctor-initializer to another exception.
To log a message to a log file.
To free naked resources that have been allocated in the ctor-initializer prior to the exception being thrown.

```
class SubObject
{
    public:
        SubObject(int i);
};

SubObject::SubObject(int i)
{
    throw std::runtime_error("Exception by SubObject ctor");
}
```

The constructor of MyClass uses a function-try-block to catch exceptions thrown in its ctor-initializer:
```
class MyClass
{
    public:
        MyClass();
    private:
        int* mData = nullptr;
        SubObject mSubObject;
};


MyClass::MyClass() 
try
    : mData(new int[42]{ 1, 2, 3 }), mSubObject(42)
{
    /* ... constructor body ... */
}
catch (const std::exception& e)
{
    // Cleanup memory.
    delete[] mData;
    mData = nullptr;
    cout << "function-try-block caught: '" << e.what() << "'" << endl;
}

int main()
{
    try {
        MyClass m;
    } catch (const std::exception& e) {
        cout << "main() caught: '" << e.what() << "'" << endl;
    }
    return 0;
}
```

the code in the example can be dangerous. Depending on the order of initialization, it could be that mData contains garbage when entering the catch statement.

The solution in this example’s case is to use a smart pointer for the mData member, for example std::unique_ptr, and to remove the function-try-block. Therefore:

    + Avoid using function-try-blocks!

Function-try-blocks are usually only necessary when you have naked resources as data members

- errors in destructors, You should not let any exceptions be thrown from destructors, for a couple of reasons:

Destructors are implicitly marked as noexcept, unless they are marked with noexcept(false)

Destructors can run while there is another pending exception, in the process of stack unwinding

What action would clients take? Clients don’t call destructors explicitly: they call delete, which calls the destructor.

The destructor is your one chance to free memory and resources used in the object.


# Overloading c++ operators 
- define what +, -, *, and / mean when applied to objects of that class.
- cannot do when you overload operators:

You cannot add new operator symbols.

cannot overload, such as . (member access in an object), :: (scope resolution operator), sizeof, ?: (the conditional operator), and a few others

The arity describes the number of arguments, or operands, associated with the operator. Unary operators, such as ++, work on only one operand. Binary operators, such as /, work on two operands. 

You cannot redefine operators for built-in types.

- three different types of operators:

Operators that must be methods. The C++ language requires some operators to be methods of a class because they don’t make sense outside of a class.

Operators that must be global functions. operator<< and operator>>, where the left-hand side is an iostream object, not an object of your class. 

Operators that can be either methods or global functions. 

- summary of overloadable operators 

operator+
operator-
operator*
operator/
operator%

operator-
operator+
operator~

operator++
operator--

operator=

operator+=
operator-=
operator*=
operator/=
operator%=

operator<<
operator>>
operator&
operator|
operator^

operator<<=
operator>>=
operator&=
operator|=
operator^=

operator<
operator>
operator<=
operator>=
operator==
operator!=

operator<<
operator>>

operator!

operator&&
operator||

operator[]

operator()

operator type(), Conversion, or cast, operators 

operator new
operator new[]

operator delete
operator delete[]

operator*
operator->

operator&

operator->*

operator,

- rvalue references 

    + defining move assignment operators, which are used by the compiler in cases where the second object is a temporary object that will be destroyed after the assignment. 

T& operator=(const T&);

    + The move assignment operator has almost the same prototype, but uses an rvalue reference.

T& operator=(T&&);

    + The std::string class from the Standard Library, for example, implements an operator+ using rvalue references as follows

string operator+(string&& lhs, string&& rhs);

return std::move(lhs.append(rhs));

- overloading the function call operator 

```
class FunctionObject
{
    public:
        int operator() (int param); // Function call operator
        int doSquare(int param);    // Normal method
};

// Implementation of overloaded function call operator
int FunctionObject::operator() (int param)
{
    return doSquare(param);
}

// Implementation of normal method
int FunctionObject::doSquare(int param)
{
    return param * param;
}

int x = 3, xSquared, xSquaredAgain;
FunctionObject square;
xSquared = square(x);               // Call the function call operator
xSquaredAgain = square.doSquare(x); // Call the normal method
```

Objects can retain information in their data members between repeated calls to their function call operators.

You can customize the behavior of a function object by setting data members. 

- solving ambiguity problmes with explicit conversion operators 

explicit operator double() const;

- new operator 
void* operator new(size_t size, void* p) noexcept;
void* operator new[](size_t size, void* p) noexcept;

void operator delete(void* ptr) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* p, void*) noexcept;
void operator delete[](void* p, void*) noexcept;

```
#include <cstddef>
#include <new>

class MemoryDemo
{
    public:
        virtual ~MemoryDemo() = default;

        void* operator new(size_t size);
        void operator delete(void* ptr) noexcept;

        void* operator new[](size_t size);
        void operator delete[](void* ptr) noexcept;

        void* operator new(size_t size, const std::nothrow_t&) noexcept;
        void operator delete(void* ptr, const std::nothrow_t&) noexcept;

        void* operator new[](size_t size, const std::nothrow_t&) noexcept;
        void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
};


void* MemoryDemo::operator new(size_t size)
{
    cout << "operator new" << endl;
    return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr) noexcept
{
    cout << "operator delete" << endl;
    ::operator delete(ptr);
}
void* MemoryDemo::operator new[](size_t size)
{
    cout << "operator new[]" << endl;
    return ::operator new[](size);
}
void MemoryDemo::operator delete[](void* ptr) noexcept
{
    cout << "operator delete[]" << endl;
    ::operator delete[](ptr);
}
void* MemoryDemo::operator new(size_t size, const nothrow_t&) noexcept
{
    cout << "operator new nothrow" << endl;
    return ::operator new(size, nothrow);
}
void MemoryDemo::operator delete(void* ptr, const nothrow_t&) noexcept
{
    cout << "operator delete nothrow" << endl;
    ::operator delete(ptr, nothrow);
}
void* MemoryDemo::operator new[](size_t size, const nothrow_t&) noexcept
{
    cout << "operator new[] nothrow" << endl;
    return ::operator new[](size, nothrow);
}
void MemoryDemo::operator delete[](void* ptr, const nothrow_t&) noexcept
{
    cout << "operator delete[] nothrow" << endl;
    ::operator delete[](ptr, nothrow);
}
```

- overloading delete with size of memory as parameter 

```
class MemoryDemo
{
    public:
        // Omitted for brevity 
        void* operator new(size_t size);
        void operator delete(void* ptr, size_t size) noexcept;
        // Omitted for brevity
};
```


# Overview of the C++ standard library 
- class MemoryDemo
{
    public:
        // Omitted for brevity 
        void* operator new(size_t size);
        void operator delete(void* ptr, size_t size) noexcept;
        // Omitted for brevity
};

- strings, std::string 

std::string is a type alias for a char instantiation of the std::basic_string

- Regular expressions are available through the <regex> header file

- i/o streams, The I/O functionality is defined in several header files: <fstream>, <iomanip>, <ios>, <iosfwd>, <iostream>, <istream>, <ostream>, <sstream>, <streambuf>, and <strstream>

- smart pointers 

unique_ptr, shared_ptr, and weak_ptr. shared_ptr and weak_ptr are thread-safe. They are all defined in the <memory> header. 

Before C++11, the functionality of unique_ptr was handled by a type called auto_ptr, which has been removed from C++17

- exceptions 

Exception support is defined in a couple of header files: <exception>, <stdexcept>, and <system_error>

- mathematical utility classes and functions.

A whole range of common mathematical functions is available, such as abs(), remainder(), fma(), exp(), log(), pow(), sqrt(), sin(), atan2(), sinh(), erf(), tgamma(), ceil(), floor(), and more. C++17 adds a number of special mathematical functions

There is a complex number class called complex, defined in <complex>, which provides an abstraction for working with numbers 

The compile-time rational arithmetic library provides a ratio class template, defined in the <ratio> header file. This ratio class template can exactly represent any finite rational number

The Standard Library also contains a class called valarray, defined in <valarray>, which is similar to the vector class but is more optimized for high-performance numerical applications. 

In C, you could access #defines, such as INT_MAX. While those are still available in C++, it’s recommended to use the numeric_limits class template defined in the <limits> header file. 

```
cout << "int:" << endl;
cout << "Max int value: " << numeric_limits<int>::max() << endl;
cout << "Min int value: " << numeric_limits<int>::min() << endl;
cout << "Lowest int value: " << numeric_limits<int>::lowest() << endl;

cout << endl << "double:" << endl;
cout << "Max double value: " << numeric_limits<double>::max() << endl;
cout << "Min double value: " << numeric_limits<double>::min() << endl;
cout << "Lowest double value: " << numeric_limits<double>::lowest() << endl;
```

- time utilities 

C++ includes the chrono library, defined in the <chrono> header file. This library makes it easy to work with time;

 Other time and date utilities are provided in the <ctime> header.

- Random Numbers

C++ already has support for generating pseudo-random numbers for a long time with the srand() and rand() functions. 

ince C++11, a random number library has been added to the standard, which is much more powerful. The new library is defined in <random>

- Initializer Lists

Initializer lists are defined in the <initializer_list> header file. They make it easy to write functions that can accept a variable number of arguments 

- pair and tuple 

Pair and Tuple

The <utility> header defines the pair template, which can store two elements with two different types

tuple, defined in <tuple>, is a generalization of pair. It is a sequence with a fixed size that can have heterogeneous elements. 

- optional, variant, and any

C++17 introduces the following new classes:

optional, defined in <optional>, holds a value of a specific type, or nothing. 
    
variant, defined in <variant>, can hold a single value of one of a given set of types, or nothing.

any, defined in <any>, is a class that can contain a single value of any type.

- Function Objects

A class that implements a function call operator is called a function object. 

certain Standard Library algorithms. The <functional> header file defines a number of predefined function objects

- Filesystem

C++17 introduces a filesystem support library. Everything is defined in the <filesystem> header, and lives in the std::filesystem namespace. It allows you to write portable code to work with a filesystem. 

- Multithreading

All major CPU vendors are selling processors with multiple cores. 

individual threads can be created using the thread class from the <thread> header.

take care that several threads are not reading and writing to the same piece of data at the same time. To prevent this, you can use atomics, defined in <atomic>, which give you thread-safe atomic access to a piece of data

thread synchronization mechanisms are provided by <condition_variable> and <mutex>.

you can use async and future. These are defined in the <future> header, and are easier to use than directly using the thread class.

- type traits 

Type traits are defined in the <type_traits> header file and provide information about types at compile time. 

- Standard Integer Types

The <cstdint> header file defines a number of standard integer types such as int8_t, int64_t and so on. 

- Containers, Both any and variant are introduced with C++17

The Standard Library provides implementations of commonly used data structures such as linked lists and queues.

If you need non-fixed-sized heterogeneous collections, you can wrap each element in an std::any instance and store those any instances in a container.

Alternatively, you can store std::variant instances in a container. A variant can be used if the number of different required types is limited and known at compile time. 

vector

The <vector> header file defines vector, The reason is that a vector is stored contiguously in memory, while a linked list is scattered around in memory. Computers are extremely efficient to work with contiguous data

list

A Standard Library list is a doubly linked list structure and is defined in <list>. Like an array or vector, it stores a sequence of elements. 

forward_list

The forward_list, defined in <forward_list>, is a singly linked list, compared to the list container, which is doubly linked. 

deque

The name deque is an abbreviation for a double-ended queue. A deque, defined in <deque>, provides quick (constant time) element access.

array

The <array> header defines array, which is a replacement for standard C-style arrays. Sometimes you know the exact number of elements in your container up front and you don’t need the flexibility of a vector or a list

queue

The name queue comes directly from the definition of the English word queue, which means a line of people or objects. The queue container is defined in <queue> and provides standard first in, first out (or FIFO) semantics. 

priority_queue

A priority_queue, also defined in <queue>, provides queue functionality in which each element has a priority. Elements are removed from the queue in priority order.

stack

The <stack> header defines the stack class, which provides standard first-in, last-out (FILO) semantics, also known as last-in, first-out (LIFO).

set and multiset

The set class template is defined in the <set> header file, and, as the name suggests, it is a set of elements, loosely analogous to the notion of a mathematical set: each element is unique, and there is at most one instance of the element in the set. Each element in a set must be unique. If you want to store duplicate elements, you must use a multiset

map and multimap

The <map> header defines the map class template, which is an associative array. You can use it as an array in which the index can be any type; for example, a string.

    + unordered associative containers/hash tables 
    
There are four unordered associative containers:

unordered_map
unordered_multimap
unordered_set
unordered_multiset

The first two containers are defined in <unordered_map>, and the other two containers in <unordered_set>.

bitset

C and C++ programmers commonly store a set of flags in a single int or long, using one bit for each flag. The <bitset> header file defines the bitset container, but this is not a container in the normal sense, in that it does not implement a specific data structure in which you insert and remove elements. A bitset has a fixed size and does not support iterators. its with the bitwise operators: &, |, ^, ~, <<, and >>. The C++ Standard Library provides a bitset class that abstracts this bit field manipulation

- algorithms 

For example, sets provide their own find() algorithm that is faster than the generic find() algorithm. 

begin()
end() 	Returns a non-const iterator to the first, and one past the last, element in a sequence.
cbegin()
cend() 	Returns a const iterator to the first, and one past the last, element in a sequence.
rbegin()
rend() 	Returns a non-const reverse iterator to the last, and one before the first, element in a sequence.
crbegin()
crend() 	Returns a const reverse iterator to the last, and one before the first, element in a sequence.

There are approximately 100 algorithms in the Standard Library, depending on how you count them

    + non-modifying sequence algorithms 

adjacent_find() 	Finds the first instance of two consecutive elements that are equal to each other or are equivalent to each other as specified by a predicate. 	O(N)
find()
find_if() 	Finds the first element that matches a value or causes a predicate to return true. 	O(N)
find_first_of() 	Like find, but searches for one of several elements at the same time. 	O(NM)
find_if_not() 	Finds the first element that causes a predicate to return false. 	O(N)
find_end() 	Finds the last subsequence in a sequence that matches another sequence or whose elements are equivalent, as specified by a predicate. 	O(M*(N-M))
search() 	Finds the first subsequence in a sequence that matches another sequence or whose elements are equivalent, as specified by a predicate.* 	O(NM)*
search_n() 	Finds the first instance of n consecutive elements that are equal to a given value or relate to that value according to a predicate.

Since C++17, search() accepts an optional extra parameter to specify the searching algorithm to use (default_searcher, boyer_moore_searcher, or boyer_moore_horspool_searcher). With the Boyer-Moore searchers. the worst case complexity is O(N+M) when the pattern is not found, and O(NM) when the pattern is found.

    + comparison algorithms 

equal() 	Determines if two sequences are equal by checking if parallel elements are equal or match a predicate.

mismatch() 	Returns the first element in each sequence that does not match the element in the same location in the other sequence.

lexicographical_compare() 	Compares two sequences to determine their “lexicographical” ordering. This algorithm compares each element of the first sequence with its equivalent element in the second. If one element is less than the other, that sequence is lexicographically first. If the elements are equal, it compares the next elements in order.

    + counting 
all_of() 	Returns true if the predicate returns true for all the elements in the sequence or if the sequence is empty; false otherwise.
any_of() 	Returns true if the predicate returns true for at least one element in the sequence; false otherwise.
none_of() 	Returns true if the predicate returns false for all the elements in the sequence or if the sequence is empty; false otherwise.
count()
count_if() 	Counts the number of elements matching a value or that cause a predicate to return true.

    + modifying sequence 
    
copy()
copy_backward() 	Copies elements from one sequence to another.
copy_if() 	Copies elements for which a predicate returns true from one sequence to another.
copy_n() 	Copies n elements from one sequence to another.
fill() 	Sets all elements in the sequence to a new value.
fill_n() 	Sets the first n elements in the sequence to a new value.
generate() 	Calls a specified function to generate a new value for each element in the sequence.
generate_n() 	Calls a specified function to generate a new value for the first n elements in the sequence.
move()
move_backward() 	Moves elements from one sequence to another. This uses efficient move semantics (see Chapter 9).
remove()
remove_if()
remove_copy()
remove_copy_if() 	Removes elements that match a given value or that cause a predicate to return true, either in place or by copying the results to a different sequence.
replace()
replace_if()
replace_copy()
replace_copy_if() 	Replaces all elements matching a value or that cause a predicate to return true with a new element, either in place or by copying the results to a different sequence.
reverse()
reverse_copy() 	Reverses the order of the elements in the sequence, either in place or by copying the results to a different sequence.
rotate()
rotate_copy() 	Swaps the first and second “halves” of the sequence, either in place or by copying the results to a different sequence. The two subsequences to be swapped need not be equal in size.

        * cpp17 avaliable 
sample() 	Selects n random elements from the sequence.
shuffle()
random_shuffle() 	Shuffles the sequence by randomly reordering the elements. It is possible to specify the properties of the random number generator used for shuffling. random_shuffle() is deprecated since C++14, and is removed from C++17.
transform() 	Calls a unary function on each element of a sequence or a binary function on parallel elements of two sequences. This is an in-place transformation.
unique()
unique_copy() 	Removes consecutive duplicates from the sequence, either in place or by copying results to a different sequence.

    + optional algorithm 

for_each() 	Executes a function on each element in the sequence. The sequence is specified with a begin and end iterator.

image for_each_n() 	Similar to for_each() but only processes the first n elements in the sequence. The sequence is specified by a begin iterator and a number of elements (n).

    + swap and exchange algorithms 
    
iter_swap()
swap_ranges() 	Swaps two elements or sequences of elements.
swap() 	Swaps two values, defined in the <utility> header.
image exchange() 	Replaces a given value with a new value and returns the old value. Defined in the <utility> header.

    + partition algorithm, A sequence is partitioned on a certain predicate, if all elements for which the predicate returns true are before all elements for which it returns false
    
is_partitioned() 	Returns true if all elements for which a predicate returns true are before all elements for which it returns false. 	Linear
partition() 	Sorts the sequence such that all elements for which a predicate returns true are before all elements for which it returns false, without preserving the original order of the elements within each partition. 	Linear
stable_partition() 	Sorts the sequence such that all elements for which a predicate returns true are before all elements for which it returns false, while preserving the original order of the elements within each partition. 	Linear logarithmic
partition_copy() 	Copies elements from one sequence to two different sequences. The target sequence is selected based on the result of a predicate, either true or false. 	Linear
partition_point() 	Returns an iterator such that all elements before this iterator return true for a predicate and all elements after this iterator return false for that predicate. 	

    + sorting algorithm 
    
is_sorted()
is_sorted_until() 	Checks if a sequence is sorted or which subsequence is sorted. 	Linear
nth_element() 	Relocates the nth element of the sequence such that the element in the position pointed to by nth is the element that would be in that position if the whole range were sorted, and it rearranges all elements such that all elements preceding the nth element are less than the new nth element, and the ones following it are greater than the new nth element. 	Linear
partial_sort()
partial_sort_copy() 	Partially sorts the sequence: the first n elements (specified by iterators) are sorted; the rest are not. They are sorted either in place or by copying them to a new sequence. 	Linear logarithmic
sort()
stable_sort() 	Sorts elements in place, either preserving the order of duplicate elements or not.

    + binary search algorithm 
lower_bound() 	Finds the first element in a sequence not less than (that is greater or equal to) a given value.
upper_bound() 	Finds the first element in a sequence greater than a given value.
equal_range() 	Returns a pair containing the result of both lower_bound() and upper_bound().
binary_search() 	Returns true if a given value is found in a sequence; false otherwise.

    + set algorithms 
inplace_merge() 	Merges two sorted sequences in place. 	Linear logarithmic
merge() 	Merges two sorted sequences by copying them to a new sequence. 	Linear
includes() 	Determines if every element from one sorted sequence is in another sorted sequence. 	Linear
set_union()
set_intersection()
set_difference()
set_symmetric_difference() 	Performs the specified set operation on two sorted sequences, copying results to a third sorted sequence.

    + heap algorithm, A heap is a standard data structure in which the elements of an array or sequence are ordered in a semi-sorted fashion, so that finding the “top” element is quick. 
    
is_heap() 	Checks if a range of elements is a heap. 	Linear
is_heap_until() 	Finds the largest subrange in the given range of elements that is a heap. 	Linear
make_heap() 	Creates a heap from a range of elements. 	Linear
push_heap()
pop_heap() 	Adds an element to, or removes an element from a heap. 	Logarithmic
sort_heap() 	Converts a heap into a range of ascending sorted elements. 	Linear logarithmic

    + minimum/maximum algorithm 
    
clamp() 	Makes sure a value (v) is between a given minimum (lo) and maximum (hi). Returns a reference to lo if v < lo; returns a reference to hi if v > hi; otherwise returns a reference to v.
min()
max() 	Returns the minimum or maximum of two or more values.
minmax() 	Returns the minimum and maximum of two or more values as a pair.
min_element()
max_element() 	Returns the minimum or maximum element in a sequence.
minmax_element() 	Returns the minimum and maximum element in a sequence as a pair.

    + numerical processing algorithms 

iota() 	Fills a sequence with successively incrementing values starting with a given value.
        * cpp17 
gcd() 	Returns the greatest common divisor of two integer types.
lcm() 	Returns the least common multiple of two integer types.
adjacent_difference() 	Generates a new sequence in which each element is the difference (or other binary operation) of the second and first of each adjacent pair of elements in the source sequence.
partial_sum() 	Generates a new sequence in which each element is the sum (or other binary operation) of an element and all its preceding elements in the source sequence.
exclusive_scan()
inclusive_scan() 	These are similar to partial_sum(). An inclusive scan is identical to a partial sum if the given summation operation is associative. However, inclusive_scan() sums in a non-deterministic order, while partial_sum() left to right, so for non-associative summation operations the result of the former is non-deterministic. The exclusive_scan() algorithm also sums in a non-deterministic order.
For inclusive_scan(), the ith element is included in the ith sum, just as for partial_sum(). For exclusive_scan(), the ith element is not included in the ith sum.
transform_exclusive_scan()
transform_inclusive_scan() 	Applies a transformation to each element in a sequence, then performs an exclusive/inclusive scan.
accumulate() 	“Accumulates” the values of all the elements in a sequence. The default behavior is to sum the elements, but the caller can supply a different binary function instead.
inner_product() 	Similar to accumulate(), but works on two sequences. This algorithm calls a binary function (multiplication by default) on parallel elements in the sequences, accumulating the result using another binary function (addition by default). If the sequences represent mathematical vectors, the algorithm calculates the dot product of the vectors.
reduce() 	Similar to accumulate(), but supports parallel execution. The order of evaluation for reduce() is non-deterministic, while it’s from left to right for accumulate(). This means that the behavior of the former is non-deterministic if the given binary operation is not associative or not commutative.
transform_reduce() 	Applies a transformation to each element in a sequence, then performs a reduce().

    + permutation algorithms, A permutation of a sequence contains the same elements but in a different order. 

is_permutation() 	Returns true if the elements in one range are a permutation of the elements in another range. 	Quadratic
next_permutation()
prev_permutation() 	Modifies the sequence by transforming it into its “next” or “previous” lexicographical permutation. Successive calls to one or the other will permute the sequence into all possible permutations of its elements, if you start with a properly sorted sequence. This algorithm returns false if no more permutations exist.

- two examples of missing functionality in STL 

The Standard Library does not guarantee any thread safety for accessing containers simultaneously from multiple threads.
The Standard Library does not provide any generic tree or graph structures. 


# Understanding containers and iterators 
- 





