Groovy Online Document;Note=Erxin

# Reference 
http://groovy-lang.org/syntax.html

# Sytax
- comments 
// 

/**/

- Shebang line, provided you have installed the Groovy distribution and the groovy command is available on the PATH
#!/usr/bin/env groovy 

- keywords 
as, assert, break, case, catch, class, const, continue, def, default, do, else, enum, extends, false, finally, for, goto, if, implements, import, in, instanceof, interface, new, null, pacakge, return, super, switch, this, throw, throws, trait, true, try, while

- identifiers 
    + normal 
def name
def item3
def with_underscore
def $dollarStart

character ranges 

'a' to 'z' (lowercase ascii letter)

'A' to 'Z' (uppercase ascii letter)

'\u00C0' to '\u00D6'

'\u00D8' to '\u00F6'

'\u00F8' to '\u00FF'

'\u0100' to '\uFFFE'

    + quoted identifiers appear after the dot of a dotted expression allowed characters like a dash, a space, an exclamation mark
person.name, person.'name', person."name"

map."an identifier with a space and double quotes" = "ALLOWED"

- string
java.lang.String objects, as well as GStrings (groovy.lang.GString) 

Double-quoted strings are plain java.lang.String

no interpolated expression, but are groovy.lang.GString instances if interpolation is present
- tripple string 
'''string'''

def name = 'Groovy'
def template = """
    Dear Mr ${name},

    You're the winner of the lottery!

    Yours sincerly,

    Dave
"""

assert template.toString().contains('Groovy')

- escaping special characters 
'an escaped escape character: \\ needs a double backslash'

- string interpolation 
def name = 'Guillaume' // a plain string
def greeting = "Hello ${name}"

assert greeting.toString() == 'Hello Guillaume'

- closure expression. When the placeholder contains an arrow, ${→}, the expression is actually a closure expression

def sParameterLessClosure = "1 + 2 == ${-> 3}" 
assert sParameterLessClosure == '1 + 2 == 3'

def sOneParamClosure = "1 + 2 == ${ w -> w << 3}" 
assert sOneParamClosure == '1 + 2 == 3'

//closure can accept parameters, append content with the << leftShift operator.

//compare to expression, closures are lazy evaluated 

def number = 1 
def eagerGString = "value == ${number}"
def lazyGString = "value == ${ -> number }"

assert eagerGString == "value == 1" 
assert lazyGString ==  "value == 1" 

number = 2 
assert eagerGString == "value == 1" 
assert lazyGString ==  "value == 2" 

- Interoperability with Java. Even for the same resulting string, GStrings and Strings don’t have the same hashCode. When a method (whether implemented in Java or Groovy) expects a java.lang.String, but we pass a groovy.lang.GString instance, the toString() will automatic convert it. 

assert "one: ${1}".hashCode() != "one: 1".hashCode()

def key = "a"
def m = ["${key}": "letter ${key}"]     

assert m["a"] == null  

- slashy string, Groovy offers slashy strings, which use / as the opening and closing delimiter. another way to define GString

def fooPattern = /.*foo.*/
assert fooPattern == '.*foo.*'

def color = 'blue'
def interpolatedSlashy = /a ${color} car/

assert interpolatedSlashy == 'a blue car'

assert '' == //

- Dollar slashy strings are multiline GStrings delimited with an opening $/ and and a closing /$. The escaping character is the dollar sign, and it can escape another dollar, or a forward slash.

def name = "Guillaume"
def date = "April, 1st"

def dollarSlashy = $/
    Hello $name,
    today we're ${date}.

    $ dollar sign
    $$ escaped dollar sign
    \ backslash
    / forward slash
    $/ escaped forward slash
    $$$/ escaped opening dollar slashy
    $/$$ escaped closing dollar slashy
/$

assert [
    'Guillaume',
    'April, 1st',
    '$ dollar sign',
    '$ escaped dollar sign',
    '\\ backslash',
    '/ forward slash',
    '/ escaped forward slash',
    '$/ escaped opening dollar slashy',
    '/$ escaped closing dollar slashy'
].every { dollarSlashy.contains(it) }

use doller to escape character 

- characters 
char c1 = 'A' 
assert c1 instanceof Character

def c2 = 'B' as char 
assert c2 instanceof Character

def c3 = (char)'C' 
assert c3 instanceof Character

- numbers 
byte 
char 
short 
int 
long 
java.lang.BigInteger 


// primitive types
byte  b = 1
char  c = 2
short s = 3
int   i = 4
long  l = 5

// infinite precision
BigInteger bi =  6

def a = 1
assert a instanceof Integer

// Integer.MAX_VALUE
def b = 2147483647
assert b instanceof Integer

// Integer.MAX_VALUE + 1
def c = 2147483648
assert c instanceof Long

// Long.MAX_VALUE
def d = 9223372036854775807
assert d instanceof Long

// Long.MAX_VALUE + 1
def e = 9223372036854775808
assert e instanceof BigInteger

- non-based 10 reprenstations 
    + binary literal 
int xInt = 0b10101111
assert xInt == 175

short xShort = 0b11001001
assert xShort == 201 as short

byte xByte = 0b11
assert xByte == 3 as byte

long xLong = 0b101101101101
assert xLong == 2925l

BigInteger xBigInteger = 0b111100100001
assert xBigInteger == 3873g

int xNegativeInt = -0b10101111
assert xNegativeInt == -175

    + Octal literal
int xInt = 077
assert xInt == 63

short xShort = 011
assert xShort == 9 as short

    + hex literal 
nt xInt = 0x77
assert xInt == 119

short xShort = 0xaa
assert xShort == 170 as short

byte xByte = 0x3a
assert xByte == 58 as byte
    + decimal literals 
// primitive types
float  f = 1.234
double d = 2.345

// infinite precision
BigDecimal bd =  3.456

- underscore in literals =,  eye to figure out how some numbers are grouped together
long creditCardNumber = 1234_5678_9012_3456L
long socialSecurityNumbers = 999_99_9999L
double monetaryAmount = 12_345_132.12
long hexBytes = 0xFF_EC_DE_5E
long hexWords = 0xFFEC_DE5E
long maxLong = 0x7fff_ffff_ffff_ffffL
long alsoMaxLong = 9_223_372_036_854_775_807L
long bytes = 0b11010010_01101001_10010100_10010010

- number of type suffixes 

Type	Suffix
BigInteger

G or g

Long

L or l

Integer

I or i

BigDecimal

G or g

Double

D or d

Float

F or f

- match operations 
- booleans 
def blFlag = true = false 

- list, Use the << leftShift operator to append an element at the end of the list
def numbers [1,2,3]

def heterogeneous = [1, "a", true]
def arrayList = [1, 2, 3]
assert arrayList instanceof java.util.ArrayList

def linkedList = [2, 3, 4] as LinkedList    
assert linkedList instanceof java.util.LinkedLis

- arrays need to explicity define type 
String[] arrStr = ['Ananas', 'Banana', 'Kiwi']  

assert arrStr instanceof String[]    
assert !(arrStr instanceof List)

def numArr = [1, 2, 3] as int[]      

assert numArr instanceof int[]       
assert numArr.size() == 3

- maps, . Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, and the whole keys and values surrounded by square brackets.
def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF'] 

assert colors['red'] == '#FF0000'    
assert colors.green  == '#00FF00'    

colors['pink'] = '#FF00FF'           
colors.yellow  = '#FFFF00'   

def key = 'name'
def person = [key: 'Guillaume']      

assert !person.containsKey('name')   
assert person.containsKey('key')  

Groovy creates maps that are actually instances of java.util.LinkedHashMap.


# Operators 
- arithmetic, similar to python 
- unary operators 
+3, -4, support ++x, x--

- logic operators 
&& 
||
!

- ternary operator to replace if else expression 
if (string!=null && string.length()>0) {
    result = 'Found'
} else {
    result = 'Not found'
}

equal to 
result = (string!=null && string.length()>0) ? 'Found' : 'Not found'

- elvis operator 
displayName = user.name ? user.name : 'Anonymous'   
displayName = user.name ?: 'Anonymous'    

- object operators 

def person = Person.find { it.id == 123 }    
def name = person?.name                      
assert name == null 

null-safe operator prevents from a NullPointerException  

- direct field access operator 
class User {
    public final String name                 
    User(String name) { this.name = name}
    String getName() { "Name: $name" }       
}
def user = new User('Bob')
assert user.name == 'Name: Bob'  

- method pointer, (.&) call be used to store a reference to a method in a variable
def str = 'example of method reference'            
def fun = str.&toUpperCase                         
def upper = fun()                                  
assert upper == str.toUpperCase()    

    + First of all, the type of such a method pointer is a groovy.lang.Closure, so it can be used in any place a closure would be used.

    + for example to create strategy pattern
def transform(List elements, Closure action) {                    
    def result = []
    elements.each {
        result << action(it)
    }
    result
}
String describe(Person p) {                                       
    "$p.name is $p.age"
}
def action = this.&describe                                       
def list = [
    new Person(name: 'Bob',   age: 42),
    new Person(name: 'Julia', age: 35)]                           
assert transform(list, action) == ['Bob is 42', 'Julia is 35'] 

    + Method pointers are bound by the receiver and a method name. Arguments are resolved at runtime

def doSomething(String str) { str.toUpperCase() }    
def doSomething(Integer x) { 2*x }                   
def reference = this.&doSomething                    
assert reference('foo') == 'FOO'                     
assert reference(123)   == 246                       

- regular expression operators 

    + The pattern operator (~) provides a simple way to create a java.util.regex.Pattern instance, ~ is follow a string expression 
def p = ~/foo/
assert p instanceof Pattern
    
p = ~'foo'                                                        
p = ~"foo"                                                        
p = ~$/dollar/slashy $ string/$                                   
p = ~"${pattern}"  

- find operator, find operator =~ to build a java.util.regex.Matcher instance. 	=~ creates a matcher against the text variable, using the pattern on the right hand side

def text = "some text to match"
def m = text =~ /match/                                           
assert m instanceof Matcher         

//equivalent to calling if(!m.find()                                   
if (!m) {                          
    throw new RuntimeException("Oops, text not found!")
}

- match operator, The match operator (==~) it return a boolean 

m = text ==~ /match/                                              
assert m instanceof Boolean  
                                     
equivalent to calling if (text ==~ /match/)
if (m) {                                                          
    throw new RuntimeException("Should not reach that point!")
}

- other operators 

    + Spread operator,  invoke an action on all items of an aggregate object. It is equivalent to calling the action on each item and collecting the result into a list

class Car {
    String make
    String model
}
def cars = [
       new Car(make: 'Peugeot', model: '508'),
       new Car(make: 'Renault', model: 'Clio')]       
def makes = cars*.make    //is equivalent to cars.collect{ it.make }                             
assert makes == ['Peugeot', 'Renault']  

    The spread operator is null-safe, meaning that if an element of the collection is null, it will return null instead of throwing a NullPointerException

    can be used on any class which implements the Iterable interface

class Component {
    Long id
    String name
}
class CompositeObject implements Iterable<Component> {
    def components = [
        new Component(id: 1, name: 'Foo'),
        new Component(id: 2, name: 'Bar')]

    @Override
    Iterator<Component> iterator() {
        components.iterator()
    }
}
def composite = new CompositeObject()
assert composite*.id == [1,2]
assert composite*.name == ['Foo','Bar']

    + Spreading method arguments

int function(int x, int y, int z) {
    x*y+z
}

def args = [4,5,6]

assert function(*args) == 26

    + Spread list elements
def items = [4,5]                      
def list = [1,2,3,*items,6]            
assert list == [1,2,3,4,5,6]  

    + Spread map elements
def m1 = [c:3, d:4]                   
def map = [a:1, b:2, *:m1]            
assert map == [a:1, b:2, c:3, d:4] 

def m1 = [c:3, d:4]                   
def map = [a:1, b:2, *:m1, d: 8]      
assert map == [a:1, b:2, c:3, d:8] 
//d is redefined to 8

    + Range operator, provides a notation (..) to create ranges of objects
def range = 0..5                                    
assert (0..5).collect() == [0, 1, 2, 3, 4, 5]       
assert (0..<5).collect() == [0, 1, 2, 3, 4]         
assert (0..5) instanceof List                       
assert (0..5).size() == 6  

assert ('a'..'d').collect() == ['a','b','c','d']

    + Spaceship operator, delegates to the compareTo
assert (1 <=> 1) == 0
assert (1 <=> 2) == -1
assert (2 <=> 1) == 1
assert ('a' <=> 'z') == -1

    + Subscript operator, The subscript operator is a short hand notation for getAt or putAt
def list = [0,1,2,3,4]
assert list[2] == 2                         
list[2] = 4                                 
assert list[0..2] == [0,1,4]                
list[0..2] = [6,6,6]                        
assert list == [6,6,6,3,4]  

//a custom implementation of getAt/putAt is a convenient way for destructuring objects
class User {
    Long id
    String name
    def getAt(int i) {                                             
        switch (i) {
            case 0: return id
            case 1: return name
        }
        throw new IllegalArgumentException("No such element $i")
    }
    void putAt(int i, def value) {                                 
        switch (i) {
            case 0: id = value; return
            case 1: name = value; return
        }
        throw new IllegalArgumentException("No such element $i")
    }
}
def user = new User(id: 1, name: 'Alex')                           
assert user[0] == 1                                                
assert user[1] == 'Alex'                                           
user[1] = 'Bob'                                                    
assert user.name == 'Bob' 

    + Membership operator
def list = ['Grace','Rob','Emmy']
assert ('Emmy' in list)   

    + Identity operator

In Groovy, using == to test equality is different from using the same operator in Java.

compare reference equality, you should use is

def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        
def list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        
assert list1 == list2                                       
assert !list1.is(list2) 

    + Coercion operator, The coercion operator (as) is a variant of casting
Integer x = 123
String s = x as String  

//Custom conversion rules may be implemented thanks to the asType method
class Identifiable {
    String name
}
class User {
    Long id
    String name
    def asType(Class target) {                                              
        if (target == Identifiable) {
            return new Identifiable(name: name)
        }
        throw new ClassCastException("User cannot be coerced into $target")
    }
}
def u = new User(name: 'Xavier')                                            
def p = u as Identifiable                                                   
assert p instanceof Identifiable                                            
assert !(p instanceof User)        
    
    + Diamond operator. no use in groovy 
indicate that generic types should be inferred from the declaration
    
List<String> strings = new LinkedList<>()
    
In dynamic Groovy, this is totally unused.  In statically type checked Groovy, it is also optional since the Groovy type checker performs type inference whether this operator is present or not
    
    + call operator, The call operator () is used to call a method named call implicitly.
class MyCallable {
    int call(int x) {           
        2*x
    }
}

def mc = new MyCallable()
assert mc.call(2) == 4          
assert mc(2) == 4  
    
- operator overloading 

class Bucket {
    int size

    Bucket(int size) { this.size = size }

    Bucket plus(Bucket other) {                     
        return new Bucket(this.size + other.size)
    }
}

def b1 = new Bucket(4)
def b2 = new Bucket(11)
assert (b1 + b2).size == 15

    + supported

Operator	Method	Operator	Method
+           a.plus(b)   a[b]    a.getAt(b)
-           a.minus(b)  a[b] = c    a.putAt(b, c)
*           a.multiply(b)   a in b  b.isCase(a)
/           a.div(b)    <<  a.leftShift(b)
%           a.mod(b)    >>  a.rightShift(b)
**          a.power(b)  >>> a.rightShiftUnsigned(b)
|           a.or(b)     ++  a.next()    
&           a.and(b)    --          a.previous()
^           a.xor(b)    +a  a.positive()
as          a.asType(b) -a  a.negative()
a()         a.call()    ~a  a.bitwiseNegate()




# Program structure 
- package names 

// defining a package named com.yoursite
package com.yoursite

class Foo in the com.yoursite.com package you will need to use the fully qualified name com.yoursite.com.Foo

- imports, import statement to resolve class references
// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null

- Default imports, below imports are added by groovy for you
import java.lang.*
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal

- Simple import
// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null

- import all classes from a package using *
import groovy.xml.MarkupBuilder
import groovy.xml.StreamingMarkupBuilder

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null

- static import,  reference imported classes as if they were static methods, Static imports with the as keyword provide an elegant solution to namespace problems

import static Boolean.FALSE as F

assert !FALSE //use directly, without Boolean prefix!

- Static star import
- Import aliasing with keyword as 
- Scripts versus classes
    + Main.groovy, public static void main vs script 
class Main {                                    
    static void main(String... args) {          
        println 'Groovy world!'                 
    }
}

    + A script can be considered as a class without needing to declare it. a script is always compiled to a class 
    The Groovy compiler will compile the class for you, with the body of the script copied into a run method.
    
- methods 
int fib(int n) {
    n < 2 ? 1 : fib(n-1) + fib(n-2)
}
assert fib(10)==89

The generated script class will carry all methods into the script class, and assemble all script bodies into the run method

- variables 
int x = 1
int y = 2
assert x+y == 3

it is a local variable. It will be declared in the run method
 
if the variable is undeclared, it goes into the script binding. The binding is visible from the methods

want a variable to become a field of the class without going into the Binding, you can use the @Field annotation




# Object orientation 
- primitive types 
boolean
char
short
int
long
float
double

- generics 

List<String> roles = ['Trinity', 'Morpheus']

- class, Classes and class members can have the same modifiers (public, protected, private, static, etc)

    + Classes or methods with no visibility modifier are automatically public

    + Fields with no visibility modifier are turned into properties automatically

    + Classes do not need to have the same base name as their source file definitions

    + One source file may contain one or more classes 
    
class Person {                       

    String name                      
    Integer age

    def increaseAge(Integer years) { 
        this.age += years
    }
}

    + Classes are instantiated by calling their constructors, using the new keyword
    
def p = new Person()

- Inner classes are defined within another classes. The enclosing class can use the inner class as usual
class Outer2 {
    private String privateStr = 'some string'

    def startThread() {
       new Thread(new Inner2()).start()
    }

    class Inner2 implements Runnable {
        void run() {
            println "${privateStr}."
        }
    }
}

- anonymous inner class 
class Outer3 {
    private String privateStr = 'some string'

    def startThread() {
        new Thread(new Runnable() {      
            void run() {
                println "${privateStr}."
            }
        }).start()                       
    }
}

 the new Inner2() was replaced by new Runnable() along with all its implementation
 
- abstract class 
abstract class Abstract {         
    String name

    abstract def abstractMethod() 

    def concreteMethod() {
        println 'concrete'
    }
}

- interface 
interface Greeter {                                         
    void greet(String name)                                 
}

class SystemGreeter implements Greeter {                    
    void greet(String name) {                               
        println "Hello $name"
    }
}

- constructors 
    + positional parameters are used in a similar to how you would use Java
    
class PersonConstructor {
    String name
    Integer age

    PersonConstructor(name, age) {          
        this.name = name
        this.age = age
    }
}

    + named parameters, If no (or a no-arg) constructor is declared, it is possible to create objects by passing parameters in the form of a map

class PersonWOConstructor {                                  
    String name
    Integer age
}

def person4 = new PersonWOConstructor()                      
def person5 = new PersonWOConstructor(name: 'Marie') 
def person7 = new PersonWOConstructor(name: 'Marie', age: 2)

When the first argument is a Map, Groovy combines all named parameters into a Map (regardless of ordering) and supplies the map as the first parameter

- methods 
    + definition, A method is defined with a return type or with the def keyword. If no return statement is provided, the value evaluated in the last line executed will be returned. 

def someMethod() { 'method called' }                           
String anotherMethod() { 'another method called' }             
def thirdMethod(param1) { "$param1 passed" }                   
static String fourthMethod(String param1) { "$param1 passed" } 

    + named parameters
def foo(Map args) { "${args.name}: ${args.age}" }
foo(name: 'Marie', age: 1)

    + mixing named and positional parameters
def foo(Map args, Integer number) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  
foo(23, name: 'Marie', age: 1)  

    + default arguments
def foo(String par1, Integer par2 = 1) { [name: par1, age: par2] }
assert foo('Marie').age == 1

    + varargs, Groovy supports methods with a variable number of arguments
def foo(Object... args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2

    + method selection algorithm 
    
interface I1 {}
interface I2 extends I1 {}
interface I3 {}
class Clazz implements I3, I2 {}

def method(I1 i1) { 'I1' }
def method(I3 i3) { 'I3' }
    
    
    + exception delcaration, Groovy automatically allows you to treat checked exceptions like unchecked exceptions. 
def badRead() throws FileNotFoundException {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}

- fields and properties 
    + fields 
class Data {
    private int id                                  
    protected String description                    
    public static final boolean DEBUG = false       
}

    + properties, A property is an externally visible feature of a class. 
    
    an absent access modifier, no public, protected or privatre 
    
    one or more optional modifiers (static, final, synchronized)
    
    a name 
    
    
class Person {
    String name                             
    int age                                 
}

creates a backing private String name field, a getName and a setName method
creates a backing private int age field, a getAge and a setAge method

declared final, no setter is generated
class Person {
    final String name                   
    final int age                       
    Person(String name, int age) {
        this.name = name                
        this.age = age                  
    }
}

class Person {
    String name
    int age
}
def p = new Person()
assert p.properties.keySet().containsAll(['name','age'])

    + Groovy will recognize properties even if there is no backing field provided there are getters or setters that follow the Java Beans specification
class PseudoProperties {
    // a pseudo property "name"
    void setName(String name) {}
    String getName() {}

    // a pseudo read-only property "age"
    int getAge() { 42 }

    // a pseudo write-only property "groovy"
    void setGroovy(boolean groovy) {  }
}
def p = new PseudoProperties()
p.name = 'Foo'                      
assert p.age == 42                  
p.groovy = true 

- property naming conventions

- annotation, ce. Annotations are declared in a very similar way to interfaces, using the @interface keyword

@interface SomeAnnotation {}

An annotation may define members in the form of methods without bodies and an optional default value

@interface SomeAnnotation {
    String value()                          
}
@interface SomeAnnotation {
    String value() default 'something'      
}
@interface SomeAnnotation {
    int step()                              
}
@interface SomeAnnotation {
    Class appliesTo()                       
}
@interface SomeAnnotation {}
@interface SomeAnnotations {
    SomeAnnotation[] value()                
}
enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun }
@interface Scheduled {
    DayOfWeek dayOfWeek()                   
}

@SomeAnnotation                 
void someMethod() {
    // ...
}

@SomeAnnotation                 
class SomeClass {}

@SomeAnnotation String var 

    + use target specification for annotation 
import java.lang.annotation.ElementType
import java.lang.annotation.Target

@Target([ElementType.METHOD, ElementType.TYPE])     
@interface SomeAnnotation {}  

    + annotation member values 
@interface Page {
    String value()
    int statusCode() default 200
}

@Page(value='/home')                    
void home() {
    // ...
}

@Page('/users')                         
void userList() {
    // ...
}

@Page(value='error',statusCode=404)     
void notFound() {
    // ...
}

- retention policy,  The retention policy of an annotation is set using the Retention annotation

import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy

@Retention(RetentionPolicy.SOURCE)                   
@interface SomeAnnotation {}  

the @Retention annotation annotates the @SomeAnnotation annotation
so @SomeAnnotation will have a SOURCE retention

    + reference retension policy 
    https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/RetentionPolicy.html
    
    CLASS, RUNTIME, SOURCE 
    
    used to control the annotation to be visible at compile time or runtime 
    
- closure annotation parameters
class Tasks {
    Set result = []
    void alwaysExecuted() {
        result << 1
    }
    @OnlyIf({ jdk>=6 })
    void supportedOnlyInJDK6() {
        result << 'JDK 6'
    }
    @OnlyIf({ jdk>=7 && windows })
    void requiresJDK7AndWindows() {
        result << 'JDK 7 Windows'
    }
}

you only have to declare the value as a Class
@Retention(RetentionPolicy.RUNTIME)
@interface OnlyIf {
    Class value()                    
}


runner to use that information 
class Runner {
    static <T> T run(Class<T> taskClass) {
        def tasks = taskClass.newInstance()                                         
        def params = [jdk:6, windows: false]                                        
        tasks.class.declaredMethods.each { m ->                                     
            if (Modifier.isPublic(m.modifiers) && m.parameterTypes.length == 0) {   
                def onlyIf = m.getAnnotation(OnlyIf)                                
                if (onlyIf) {
                    Closure cl = onlyIf.value().newInstance(tasks,tasks)            
                    cl.delegate = params                                            
                    if (cl()) {                                                     
                        m.invoke(tasks)                                             
                    }
                } else {
                    m.invoke(tasks)                                                 
                }
            }
        }
        tasks                                                                       
    }
}

- meta-annotations, Meta-annotations, also known as annotation aliases are annotations that are replaced at compile time by other annotations

Given the multiplication of annotations that you could add to the same class, a meta-annotation could help by reducing the two annotations with a single one

@Service
@Transactional
class MyTransactionalService {}

//equal to 
@TransactionalService                           
class MyTransactionalService {}

//defined by 
import groovy.transform.AnnotationCollector

//meta annotation 
@Service                                        
@Transactional                                  
@AnnotationCollector                            
@interface TransactionalService {
}

- meta-annotation, Groovy supports both precompiled and source form meta-annotations. It only support in groovy 

- meta-annotation parameters 
@Timeout(after=3600)
@Dangerous(type='explosive')

//define meta 
@Timeout(after=3600)
@Dangerous(type='explosive')
@AnnotationCollector
public @interface Explosive {}

//add parameter
@Explosive(after=0)                 
class Bomb {}

- handling duplicate annotations, AnnotationCollectorMode enum value
- custom annotation processors 

@AnnotationCollector(processor = "org.codehaus.groovy.transform.CompileDynamicProcessor")
public @interface CompileDynamic {
}

// custom processor has to extend AnnotationCollectorTransform
@CompileStatic                                                                  
class CompileDynamicProcessor extends AnnotationCollectorTransform {            
    private static final ClassNode CS_NODE = ClassHelper.make(CompileStatic)    
    private static final ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) 

    List<AnnotationNode> visit(AnnotationNode collector,                        
                               AnnotationNode aliasAnnotationUsage,             
                               AnnotatedNode aliasAnnotated,                    
                               SourceUnit source) {                             
        def node = new AnnotationNode(CS_NODE)                                  
        def enumRef = new PropertyExpression(
            new ClassExpression(TC_NODE), "SKIP")                               
        node.addMember("value", enumRef)                                        
        Collections.singletonList(node)                                         
    }
}

- traits a structural construct of the language which allows 
    + composition behaviors 
    + runtime implementation of interfaces 
    + behavior overriding 
    + compatibility with static type checking/compilation 
    
trait FlyingAbility {      
    abstract String name()                          
    String fly() { "I'm flying!" }     
    private String greetingMessage() {}
    def whoAmI() { this }
    
    String titleProperty  //property 
    private int countField = 0 //private field 
}

class Bird implements FlyingAbility {
    String name() { 'Bob' }   
}          
def b = new Bird()                              
assert b.fly() == "I'm flying!"    

used like a normal interface using the implements keyword:

this represents the implementing instance. 

- interfaces, Traits may implement interfaces

interface Named {                                       
    String name()
}
trait Greetable implements Named {                      
    String greeting() { "Hello, ${name()}!" }
    //define property 
    String name 
    
    //fields 
     private int count = 0  
}

- composition of behaviors 
trait FlyingAbility {                           
        String fly() { "I'm flying!" }          
}
trait SpeakingAbility {
    String speak() { "I'm speaking!" }
}

class Duck implements FlyingAbility, SpeakingAbility {}

- override default methods 
class Duck implements FlyingAbility, SpeakingAbility {
    String quack() { "Quack!" }                         
    String speak() { quack() }                          
}

- extending traits 

trait Named {
    String name                                     
}
trait Polite extends Named {                        
    String introduce() { "Hello, I am $name" }      
}

class Person implements Polite {}
def p = new Person(name: 'Alice')                   
assert p.introduce() == 'Hello, I am Alice'   

    + multiple inheritance
trait WithId {                                      
    Long id
}
trait WithName {                                    
    String name
}
trait Identified implements WithId, WithName {}  

- duck typing and traits 

```
trait SpeakingDuck {
    String speak() { quack() }                      
}
class Duck implements SpeakingDuck {
    String methodMissing(String name, args) {
        "${name.capitalize()}!"                     
    }
}
def d = new Duck()
assert d.speak() == 'Quack!' 
```

the Duck class does implement the method using methodMissing

- dynamic methods in a trait, It is also possible for a trait to implement MOP methods like methodMissing or propertyMissing, in which case implementing classes will inherit the behavior from the trait

```
trait DynamicObject {                               
    private Map props = [:]
    def methodMissing(String name, args) {
        name.toUpperCase()
    }
    def propertyMissing(String name) {
        props.get(name)
    }
    void setProperty(String name, Object value) {
        props.put(name, value)
    }
}

class Dynamic implements DynamicObject {
    String existingProperty = 'ok'                  
    String existingMethod() { 'ok' }                
}
def d = new Dynamic()
assert d.existingProperty == 'ok'                   
assert d.foo == null                                
d.foo = 'bar'                                       
assert d.foo == 'bar'                               
assert d.existingMethod() == 'ok'                   
assert d.someMethod() == 'SOMEMETHOD'   
```

- multiple inherits conflict, the last win 

trait A {
    String exec() { 'A' }               
}
trait B {
    String exec() { 'B' }               
}
class C implements A,B {} 

    + explicit specify the confict resolution 
    
class C implements A,B {
    String exec() { A.super.exec() }    
}
def c = new C()
assert c.exec() == 'A'

- runtime implementation of traits 

```
trait Extra {
    String extra() { "I'm an extra method" }            
}
class Something {                                       
    String doSomething() { 'Something' }                
}

def s = new Something() as Extra                        
s.extra()                                               
s.doSomething() 
```

- implenting multiple traits at once 
```
trait A { void methodFromA() {} }
trait B { void methodFromB() {} }

class C {}

def c = new C()
c.methodFromA()                     
c.methodFromB()                     
def d = c.withTraits A, B           
d.methodFromA()                     
d.methodFromB()
```

- chaining behavior, stackable traits 

interface MessageHandler {
    void on(String message, Map payload)
} 

trait DefaultHandler implements MessageHandler {
    void on(String message, Map payload) {
        println "Received $message with payload $payload"
    }
}

trait LoggingHandler implements MessageHandler {                            
    void on(String message, Map payload) {
        println "Seeing $message with payload $payload"                     
        super.on(message, payload)                                          
    }
}

class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
def loggingHandler = new HandlerWithLogger()
loggingHandler.on('test logging', [:])

- semantics of super inside a trait

if the class implements another trait, the call delegates to the next trait in the chain

if there isn’t any trait left in the chain, super refers to the super class of the implementing class (this)

``` 

trait Filtering {                                       
    StringBuilder append(String str) {                  
        def subst = str.replace('o','')                 
        super.append(subst)                             
    }
    String toString() { super.toString() }              
}
def sb = new StringBuilder().withTraits Filtering       
sb.append('Groovy')
assert sb.toString() == 'Grvy'   

```

- Advanced features, SAM type coercion, If a trait defines a single abstract method, it is candidate for SAM (Single Abstract Method) type coercion.

trait Greeter {
    String greet() { "Hello $name" }        
    abstract String getName()               
}

Greeter greeter = { 'Alice' }  

void greet(Greeter g) { println g.greet() } 
greet { 'Alice' }   

- different with interface default, trait is always used if the class declares the trait in its interface list and that it doesn’t provide an implementation even if a super class does. The interface default method will only be used when not class implement the method 

- different with mixins, methods defined in a trait are visible in bytecode and visible for java  

- static methods in a trait with limitations 

cannot be compiled statically or type checking 

do not appear within the generated interfaces 

trait is interpreted as a template for the implementating class. the static method will be generated for each implement classes 

not mix static and instance methods of the same signature. 

- fields and properties in traits will also priorit than the subclass. It has to use the property getter to get or set the fields with the same name. 
```
trait IntCouple {
    int x = 1
    int y = 2
    int sum() { getX()+getY() }
}

class Elem implements IntCouple {
    int x = 3
    int y = 4
    int f() { sum() }
}
def elem = new Elem()
assert elem.f() == 7
```

- type constraints, @SelfType annotation, a class that implements this trait must inherit or implement. Both @Sealed and @SelfType restrict classes which use a trait but in orthogonal ways

@SelfType(Device)
@CompileStatic
trait Communicating {
    void sendMessage(Device to, String message) {
        SecurityService.check(this)
        CommunicationService.sendMessage(id, to.id, message)
    }
}

- limitation, Traits are not officially compatible with AST transformations. 

    + prefix and post fix operations are not allowed on traits 
    
    trait Counting {
        int x
        void inc() { //error 
            x++                             
        }
        void dec() { //error 
            --x                             
        }
    }
 
- Record classes, or records for short, are a special kind of class useful for modelling plain data aggregates

```
record Message(String from, String to, String body) { }

def msg = new Message('me@myhost.com', 'you@yourhost.net', 'Hello!')
assert msg.toString() == 'Message[from=me@myhost.com, to=you@yourhost.net, body=Hello!]'
```

The term component is typically used for records.

- Groovy enhancements

    + argument defaults 
    
record ColoredPoint(int x, int y = 0, String color = 'white') {}    
@TupleConstructor(defaultsMode=DefaultsMode.OFF)
record ColoredPoint2(int x, int y, String color) {}
assert new ColoredPoint2(4, 5, 'red').toString() == 'ColoredPoint2[x=4, y=5, color=red]'

- diving deeper with class keyword and an accompanying @RecordType annotation

@RecordType
class Message {
    String from
    String to
    String body
}

    + customize a record’s toString method by writing your own.
```
package threed

import groovy.transform.ToString

@ToString(ignoreNulls=true, cache=true, includeNames=true,
          leftDelimiter='[', rightDelimiter=']', nameValueSeparator='=')
record Point(Integer x, Integer y, Integer z=null) { }

assert new Point(10, 20).toString() == 'threed.Point[x=10, y=20]'
```

    + obtain a list of record component values 

    ```
    record Point(int x, int y, String color) { }

    def p = new Point(100, 200, 'green')
    def (x, y, c) = p.toList()
    ```    
    
    + obtaining a map of the record component values 
    
    ```
    record Point(int x, int y, String color) { }

    def p = new Point(100, 200, 'green')
    assert p.toMap() == [x: 100, y: 200, color: 'green']
    ```

    + record support methods 
    
records.toList()
records.toMap() 
records[index]
records.copyWith(propertyName:newValue)
records.components instanceof Tuple#

    + make a copy of a record with some components changed. This can be done using an optional copyWith method

@RecordOptions(copyWith=true)
record Fruit(String name, double price) {}
def apple = new Fruit('Apple', 11.6)
assert 'Apple' == apple.name()
assert 11.6 == apple.price()

def orange = apple.copyWith(name: 'Orange')
assert orange.toString() == 'Fruit[name=Orange, price=11.6]'

    + Groovy’s @Immutable transform performs defensive copying for a range of mutable data types
    
@ImmutableProperties
record Shopping(List items) {}

def items = ['bread', 'milk']
def shop = new Shopping(items)
items << 'chocolate'
assert shop.items() == ['bread', 'milk']

- Sealed classes, interfaces and traits restrict which subclasses can extend/implement them. Sealed hierarchies provide full inheritance within a known hierarchy of classes

sealed interface ShapeI permits Circle,Square { }
final class Circle implements ShapeI { }
final class Square implements ShapeI { }

The @SealedOptions annotation supports a mode annotation attribute which can take one of three values (with AUTO being the default)





# Closure 
- define a closure, A closure in Groovy is an open, anonymous, block of code that can take arguments, return a value and be assigned to a variable 

{ [closureParameters -> ] statements }

- examples 

{ item++ }                                          

{ -> item++ }                                       

{ println it }                                      

{ it -> println it }                                

{ name -> println name }                            

{ String x, int y ->                                
    println "hey ${x} the value is ${y}"
}

{ reader ->                                         
    def line = reader.readLine()
    line.trim()
}    

- closure as an object 
```
def listener = { e -> println "Clicked on $e.source" }      
assert listener instanceof Closure
Closure callback = { println 'Done!' }                      
Closure<Boolean> isTextFile = {
    File it -> it.name.endsWith('.txt')                     
}

isTextFile(file)
```

- parameter is as same as function, optional type, name, optional default value  
- implicit parameter a closure always defines an implicit parameter, named it. This means that this code

```
def greeting = { "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'

//equal to 

def greeting = { it -> "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'
```
- varargs, can acccept a variable number of arguments 

```
def concat1 = { String... args -> args.join('') }           
assert concat1('abc','def') == 'abcdef'                     
def concat2 = { String[] args -> args.join('') }            
assert concat2('abc', 'def') == 'abcdef'
```

- delegation strategy, property is accessed without explicitly setting a receiver object, the property will be resolved transparently on the delegate object. By default is the owner first then delegate. 

```
class Person {
    String name
    def pretty = { "My name is $name" }             
    String toString() {
        pretty()
    }
}
class Thing {
    String name                                     
}

def p = new Person(name: 'Sarah')
def t = new Thing(name: 'Teapot')

assert p.toString() == 'My name is Sarah'           
p.pretty.delegate = t  
assert p.toString() == 'My name is Sarah'    

//change the resolution strategy of the closure:

p.pretty.resolveStrategy = Closure.DELEGATE_FIRST
assert p.toString() == 'My name is Teapot'                          
```

- Closures in GStrings 

 two reasons for this:

a GString only evaluates lazily the toString representation of values

the syntax ${x} in a GString does not represent a closure but an expression to $x. Evaluated when the GString is created 

    + a closure in a GString to enforce lazy evaluation 
    
def x = 1
def gs = "x = ${-> x}"
assert gs == 'x = 1'

x = 2
assert gs == 'x = 2'

- functional programming

    + left currying, Groovy will let you set the value of one parameter of a closure
    
    ```
    def nCopies = { int n, String str -> str*n }    
    def twice = nCopies.curry(2)                    
    assert twice('bla') == 'blabla'  
    ```

    + right currying 
    ```
    def nCopies = { int n, String str -> str*n }    
    def blah = nCopies.rcurry('bla')                
    assert blah(2) == 'blabla'                      
    assert blah(2) == nCopies(2, 'bla')   
    ```
    
    + index based currying,  accepts more than 2 parameters, it is possible to set an arbitrary parameter using ncurry
    
    ```
    def volume = { double l, double w, double h -> l*w*h }      
    def fixedWidthVolume = volume.ncurry(1, 2d)                 
    assert volume(3d, 2d, 4d) == fixedWidthVolume(3d, 4d)
    ```
    
    + memorize 
    ```
    fib = { long n -> n<2?n:fib(n-1)+fib(n-2) }.memoize()
    assert fib(25) == 75025 // fast!
    ```
    
    + composition, creating a new function by composing two or more functions (chaining calls), as illustrated in this example:
    
    ```
    def plus2  = { it + 2 }
    def times3 = { it * 3 }

    def times3plus2 = plus2 << times3
    assert times3plus2(3) == 11    
    ```
    
- trampoline Closures are wrapped in a TrampolineClosure. Upon calling, a trampolined Closure will call the original Closure waiting for its result to prevent stackoverflow  

```
trampoline() to implement the factorial function:

def factorial
factorial = { int n, def accu = 1G ->
    if (n < 2) return accu
    factorial.trampoline(n - 1, n * accu)
}
factorial = factorial.trampoline()

assert factorial(1)    == 1
assert factorial(3)    == 1 * 2 * 3
```

- method pointer operator (.&) can be used to store a reference to a method in a variable

def str = 'example of method reference'            
def fun = str.&toUpperCase                         
def upper = fun()                                  
assert upper == str.toUpperCase()  

- The method reference operator (::) can be used to reference a method or constructor in contexts expecting a functional interface.

```
import groovy.transform.CompileStatic
import static java.util.stream.Collectors.toList

@CompileStatic
void methodRefs() {
    assert 6G == [1G, 2G, 3G].stream().reduce(0G, BigInteger::add)                           

    assert [4G, 5G, 6G] == [1G, 2G, 3G].stream().map(3G::add).collect(toList())              

    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(BigInteger::valueOf).collect(toList())  

    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(3G::valueOf).collect(toList())          
}

methodRefs()
```
    
    

# Processing yaml 
- YamlSlurper is a class that parses YAML text or reader content into Groovy data structures (objects) such as maps, lists and primitive types like Integer, Double, Boolean and String.

- read 

```
        def ys = new YamlSlurper()
        def yaml = ys.parseText '''
language: groovy
sudo: required
dist: trusty

matrix:
  include:
    - jdk: openjdk10
    - jdk: oraclejdk9
    - jdk: oraclejdk8

before_script:
  - |
    unset _JAVA_OPTIONS

        '''

        assert 'groovy' == yaml.language
        assert 'required' == yaml.sudo
        assert 'trusty' == yaml.dist
        assert ['openjdk10', 'oraclejdk9', 'oraclejdk8'] ==  yaml.matrix.include.jdk
        assert ['unset _JAVA_OPTIONS'] == yaml.before_script*.trim()
```

- write 

```
        def builder = new YamlBuilder()
        builder.records {
            car {
                name 'HSV Maloo'
                make 'Holden'
                year 2006
                country 'Australia'
                homepage new URL('http://example.org')
                record {
                    type 'speed'
                    description 'production pickup truck with speed of 271kph'
                }
            }
        }

        assert builder.toString() == '''---
records:
  car:
    name: "HSV Maloo"
    make: "Holden"
    year: 2006
    country: "Australia"
    homepage: "http://example.org"
    record:
      type: "speed"
      description: "production pickup truck with speed of 271kph"
```



# Template engine 
- Groovy supports multiple ways to generate text dynamically including GStrings, printf and MarkupBuilder

- template framework 

SimpleTemplateEngine
StreamingTemplateEngine 
GStringTemplateEngine 
XmlTemplateEngine 
MarkupTemplateEngine 

- SimpleTemplateEngine, similar to jsp 
```
def text = 'Dear "$firstname $lastname",\nSo nice to meet you in <% print city %>.\nSee you in ${month},\n${signed}'

def engine = new groovy.text.SimpleTemplateEngine()
def template = engine.createTemplate(text).make(binding)
template.toString()
```

escape <% print city == "New York" ? "\\"The Big Apple\\"" : city %>

- StreamTemplateEngine similar to SimpleTemplateEngine but can handle strings large than 64k 

- GStringTemplateEngine

in file test.template 
```
Dear "$firstname $lastname",
So nice to meet you in <% out << (city == "New York" ? "\\"The Big Apple\\"" : city) %>.
See you in ${month},
${signed}
```

```
def f = new File('test.template')
def engine = new groovy.text.GStringTemplateEngine()
def template = engine.createTemplate(f).make(binding)
println template.toString()
```

- XmlTemplateEngine for template and output are all expect to xml 

```
def binding = [firstname: 'Jochen', lastname: 'Theodorou', nickname: 'blackdrag', salutation: 'Dear']
def engine = new groovy.text.XmlTemplateEngine()
def text = '''\
    <document xmlns:gsp='http://groovy.codehaus.org/2005/gsp' xmlns:foo='baz' type='letter'>
        <gsp:scriptlet>def greeting = "${salutation}est"</gsp:scriptlet>
        <gsp:expression>greeting</gsp:expression>
        <foo:to>$firstname "$nickname" $lastname</foo:to>
        How are you today?
    </document>
'''
def template = engine.createTemplate(text).make(binding)
println template.toString()
```

- markup template 

```
xmlDeclaration()
cars {
   cars.each {
       car(make: it.make, model: it.model)
   }
}
```

- custom template class, By default, templates created inherit the groovy.text.markup.BaseTemplate class. It may be interesting for an application to provide a different template clas

- type checking, The MarkupTemplateEngine provides such a facility. Templates can be optionally type checked




# Servlet support  
- There is also a GroovyServlet.

This feature will automatically compile your .groovy source files, turn them into bytecode, load the Class and cache it until you change the source file.

- setup groovylets 

<servlet>
    <servlet-name>Groovy</servlet-name>
    <servlet-class>groovy.servlet.GroovyServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>Groovy</servlet-name>
    <url-pattern>*.groovy</url-pattern>
</servlet-mapping>

the .groovy files in, say, the root directory  and let GroovyServlet to take care of the .groovy files 



# Groovyc the groovy compiler 
- groovyc MyClass.groovy
- Gant is a tool for scripting Ant tasks using Groovy instead of XML to specify the logic. 
- gradle is a build tool to leverage the flexibility of ant 
- maven integration 





# Meta programming 
-reference 
http://docs.groovy-lang.org/latest/html/documentation/core-metaprogramming.html#xform-Field


# self introduction 
Welcome onboard
Name 
Location Shanghai
Main task, works on tensorflow windows with Mayank, Jerry and Ben
Join time, on July in this year
Welcome to the team.







