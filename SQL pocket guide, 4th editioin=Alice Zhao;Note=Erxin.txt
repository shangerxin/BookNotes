SQL pocket guide, 4th editioin=Alice Zhao;Note=Erxin


# What is database 
- sql, structured query lanaguage

SELECT * FROM birthdays WHERE person = 'husband';

- NoSQL stands for not only SQL. 

- NoSQL database is MongoDB, which is more specifically a document database

- PostgreSQL or SQLite, and be wondering how they are different from SQL. They are two types of Database Management Systems (DBMS)

5 different RDBMSs:

	+ MySQL, PostgreSQL, and SQLite

    SELECT * FROM birthdays LIMIT 10;
	
	+ Microsoft SQL Server

    SELECT TOP 10 * FROM birthdays;
	+ Oracle Database

    SELECT * FROM birthdays WHERE ROWNUM <= 10;

- select 
	
filter data and sort data 

- order of execution 

FROM

WHERE

GROUP BY

HAVING

SELECT

ORDER BY

- database model 

database 
table 
column 
primary key 
foreign key 
relationship 

- write sql code 

rdbms software 

database tool 

program language 

- SQLite is free and the most lightweight install

show databases, show tables, and exit:
sqlite> CREATE TABLE test (id int, num int);
sqlite> INSERT INTO test VALUES (1, 100), (2, 200);
sqlite> SELECT * FROM test LIMIT 1;
sqlite> .databases
sqlite> .tables
sqlite> .quit

- workflow 

Connect Python or R to a database.

Write SQL queries within Python or R.

Continue doing analysis in Python or R.

- Python code to set up a database connectionRDBMS	Code

	+ SQLite
	
```
import sqlite3 conn = sqlite3.connect('my_new_db.db')
```

	+ MySQL
	
```
import mysql.connector conn = mysql.connector.connect( host='localhost', database='my_new_db', user='alice', password='password')
```

	+ Oracle
	
```
# Connecting to Oracle Express Edition import cx_Oracle conn = cx_Oracle.connect(dsn='localhost/XE', user='alice', password='password')
```

	+ PostgreSQL
	
```
import psycopg2 conn = psycopg2.connect(host='localhost', database='my_new_db', user='alice', password='password')
```

	+ SQL Server
	
```
# Connecting to SQL Server Express import pyodbc conn = pyodbc.connect(driver='{SQL Server}', host='localhost\SQLEXPRESS', database='my_new_db', user='alice', password='password')
```

-  db_config.py values instead of hardcoded user and password values (changes are bolded):

```
import cx_Oracle
import db_config

conn = cx_Oracle.connect(dsn='localhost/XE',
user=db_config.usr,
password=db_config.pwd)
```

- write sql in python 
```
cursor = conn.cursor()
cursor.execute('SELECT * FROM test;')
result = cursor.fetchall()
print(result)
```



# The sql language 
- The American National Standards Institute (ANSI) is an organization based in the United States that documents standards on everything from drinking water to nuts and bolts.

- A function is a special type of keyword. It takes in zero or more inputs, does something to the inputs, and returns an output.

A keyword is text that already has some meaning in SQL.

- An identifier is the name of a database object, such as a table or a column. All identifiers in the code block are bolded 

- An alias renames a column or a table temporarily

```
SELECT e.name, COUNT(s.sale_id) AS num_sales
FROM employee e
  LEFT JOIN sales s ON e.emp_id = s.emp_id
WHERE YEAR(s.sale_date) = 2021
  AND s.closed IS NOT NULL
GROUP BY e.name;
```
- A statement starts with a keyword and ends with a semicolon.

- A clause is a way to refer to a particular section of a statement. 

```
SELECT clause

SELECT e.name, COUNT(s.sale_id) AS num_sales
```

- Quotes

There are two types of quotes you can use in SQL


```
A single line of text:

-- These are my comments

Multiple lines of text:

/* These are
my comments */
```

- Whitespace

SQL does not care about the number of spaces between terms. 

- sublanguages 

DQL, data query language 
select

DDL, data define lanauge 
create 
alter
drop 


DML, data manipulation lanaguage 
insert 
update 
delete 

DCL, data control language 
grant 
revoke

DTC, transaction control language 


# query basics 
- cover clauses 
select 
from 
where 
group by 
having 
order by 

```
-- Tours with 2 or more public waterfalls
SELECT   t.name AS tour_name,
         COUNT(*) AS num_waterfalls
FROM     tour t LEFT JOIN waterfall w
         ON t.stop = w.id
WHERE    w.open_to_public = 'y'
GROUP BY t.name
HAVING   COUNT(*) >= 2
ORDER BY tour_name;

tour_name  num_waterfalls
---------- ---------------
M-28                     6
Munising                 6
US-2                     4
```

- select all column 

SELECT *
FROM owner;

SELECT name, ROUND(population * 0.9, 0)
from county 

- selecting functions 
```
SELECT CURRENT_DATE;

CURRENT_DATE
-------------
2021-12-01
```

- aliasing, The purpose of a column alias is to give a temporary name to any column or expression listed in the SELECT clause. 

```
-- AS alias_name
SELECT id AS county_id, name,
       ROUND(population * 0.90, 0) AS estimated_pop
FROM county;

county_id  name       estimated_pop
---------- ---------- --------------
         2 Alger                8876
         6 Baraga               7871
         7 Ontonagon            7036
```

- correlated subqueries 

```
SELECT o.id, o.name,
       (SELECT COUNT(*) FROM waterfall w
       WHERE o.id = w.owner_id) AS num_waterfalls
FROM owner o;
```

```
SELECT   o.id, o.name,
         COUNT(w.id) AS num_waterfalls
FROM     owner o LEFT JOIN waterfalls w
         ON o.id = w.owner_id
GROUP BY o.id, o.name

```

- distinct 

- To count the number of unique values within a single column, you can combine the COUNT and DISTINCT keywords within the SELECT clause

```
SELECT COUNT(DISTINCT type) AS unique
FROM owner;

unique
-------
      2
```

- join on 

```
table names that need to be referenced within the ON and SELECT clauses.
JOIN … ON …

waterfall w JOIN tour t
ON w.id = t.stop

These two tables are pulled together with the JOIN keyword. A JOIN clause is always followed by an ON clause,
```

INNER JOIN, meaning that only records that are in both tables are returned

- Results table

A query always results in a single table. The waterfall table has 12 columns and the tour table has 3 columns. 

- from subqueries 

A subquery is a query that is nested inside another query. Subqueries within the FROM clause should be standalone SELECT statements, meaning that they do not reference the outer query at all 

```

SELECT w.name AS waterfall_name,
       o.name AS owner_name
FROM (SELECT * FROM owner WHERE type = 'public') o
     JOIN waterfall w
     ON o.id = w.owner_id;

waterfall_name  owner_name
--------------- ---------------
Little Miners   Pictured Rocks
Miners Falls    Pictured Rocks
Munising Falls  Pictured Rocks
Wagner Falls    MI DNR
```

- with clause subqueries, The advantage of the WITH clause is that the subquery is named up front, which makes for cleaner code and also the ability to reference the subquery multiple times.

```
WITH o AS (SELECT * FROM owner
           WHERE type = 'public')

SELECT w.name AS waterfall_name,
       o.name AS owner_name
FROM o JOIN waterfall w
     ON o.id = w.owner_id;
```

- The WHERE clause is used to restrict query results to only rows of interest, or simply put, it is the place to filter data.

	+ filtering on subqueries 

```	
SELECT w.name
FROM   waterfall w
WHERE  w.open_to_public = 'y'
       AND w.county_id IN (
           SELECT c.id FROM county c
           WHERE c.name = 'Alger');

name
---------------
Munising Falls
Tannery Falls
Alger Falls
```

The two queries produce the same results. The advantage of the first approach is that subqueries are often easier to understand than joins.
```
-- JOIN clause
SELECT w.name
FROM   waterfall w INNER JOIN county c
       ON w.county_id = c.id
WHERE  w.open_to_public = 'y'
       AND c.name = 'Alger';

name
---------------
Munising Falls
Tannery Falls
Alger Falls
...
```

- multiple predicates 

multiple predicates with operators like AND or OR. The following example shows waterfalls without Falls

```
SELECT id, name
FROM waterfall
WHERE name NOT LIKE '%Falls%'
      AND owner_id IS NULL;

id    name
----- ----------------
   14 Rapid River Fls
```

- other way to filter data 
FROM clause: When joining together tables, the ON clause specifies how they should be linked together. 
HAVING clause: If there are aggregations within the SELECT statement, the HAVING clause is where you specify how the aggregations should be filtered.
LIMIT clause: To display a specific number of rows, you can use the LIMIT clause. In Oracle, this is done with WHERE ROWNUM and in SQL Server, this is done with SELECT TOP

- Group by, The purpose of the GROUP BY clause is to collect rows into groups and summarize the rows within the groups in some way

```
SELECT   t.name AS tour_name,
         COUNT(*) AS num_waterfalls
FROM     waterfall w INNER JOIN tour t
         ON w.id = t.stop
GROUP BY t.name;

tour_name  num_waterfalls
---------- ---------------
M-28                     6
Munising                 6
US-2                     4
```

In this example, COUNT(*) returns the number of waterfalls along each tour. 

- The HAVING Clause

```
SELECT   t.name AS tour_name,
         COUNT(*) AS num_waterfalls
FROM     waterfall w INNER JOIN tour t
         ON w.id = t.stop
GROUP BY t.name
HAVING   COUNT(*) = 6;

tour_name  num_waterfalls
---------- ---------------
M-28                     6
Munising                 6
```

- The ORDER BY clause is used to specify how you want the results of a query to be sorted.

```
SELECT COALESCE(o.name, 'Unknown') AS owner,
       w.name AS waterfall_name
FROM   waterfall w
       LEFT JOIN owner o ON w.owner_id = o.id;

owner            waterfall_name
---------------- ---------------
Pictured Rocks   Munising Falls
Michigan Nature  Tannery Falls
AF LLC           Alger Falls
MI DNR           Wagner Falls
Unknown          Horseshoe Falls
...
```

- MySQL, PostgreSQL, and SQLite support the LIMIT clause. Oracle and SQL Server use different syntax with the same functionality:

```

-- MySQL, PostgreSQL, and SQLite
SELECT *
FROM owner
LIMIT 3;

-- Oracle
SELECT *
FROM owner
WHERE ROWNUM <= 3;

-- SQL Server
SELECT TOP 3 *
FROM owner;

id  name             phone         type
--- ---------------- ------------- --------
  1 Pictured Rocks   906.387.2607  public
  2 Michigan Nature  517.655.5655  private
  3 AF LLC                         private
```


# Creating, updating and deleting 
- create database 

MySQL, Oracle, PostgreSQL,SQL Server
	
```
CREATE DATABASE my_new_db;
```

SQLite
	

> sqlite3 my_new_db.db

- delete database 

DROP DATABASE my_new_db; 

- create table 

```
CREATE TABLE my_simple_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15)
);
```

- insert rows 

```
INSERT INTO my_simple_table (id, country, name)
VALUES (1, 'US', 'Sam');
```

```
CREATE TABLE IF NOT EXISTS my_simple_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15)
);
```

- create table with constraint 

```
CREATE TABLE another_table (
   country VARCHAR(2) NOT NULL,
   name VARCHAR(15) NOT NULL,
   description VARCHAR(50),
   CONSTRAINT pk_another_table
      PRIMARY KEY (country, name)
);

CREATE TABLE my_table (
   id INTEGER NOT NULL,
   country VARCHAR(2) DEFAULT 'CA'
      CONSTRAINT chk_country
      CHECK (country IN ('CA','US')),
   name VARCHAR(15),
   cap_name VARCHAR(15),
   CONSTRAINT pk
      PRIMARY KEY (id),
   CONSTRAINT fk1
      FOREIGN KEY (country, name)
      REFERENCES another_table (country, name),
   CONSTRAINT unq_country_name
      UNIQUE (country, name),
   CONSTRAINT chk_upper_name
      CHECK (cap_name = UPPER(name))
);

CREATE TABLE my_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15),
   CONSTRAINT chk_id_country
   CHECK (id > 100 AND country IN ('CA','US'))
);
```

- foreign key 

```
  CREATE TABLE customers (
   id INTEGER PRIMARY KEY,
   order_id INTEGER,
   name VARCHAR(15),
   location VARCHAR(20),
   FOREIGN KEY (order_id)
   REFERENCES orders (o_id)
);

CREATE TABLE orders (
   o_id INTEGER,
   o_location VARCHAR(20),
   o_price DECIMAL(6,2),
   PRIMARY KEY (o_id, o_location)
);

CREATE TABLE customers (
   id INTEGER PRIMARY KEY,
   order_id INTEGER,
   name VARCHAR(15),
   location VARCHAR(20),
   CONSTRAINT fk_id_name
   FOREIGN KEY (order_id, location)
   REFERENCES orders (o_id, o_location)
);
```

- auto generate 

```
CREATE TABLE my_table (
   u_id INTEGER PRIMARY KEY AUTO_INCREMENT,
   country VARCHAR(2),
   name VARCHAR(15)
);
```

- Insert the results from a query into the new table:

```
INSERT INTO new_table_two_columns
            (id, name)
SELECT id, name
FROM   my_simple_table
WHERE  id < 3;

INSERT INTO new_table_four_columns
       (id, name, new_num_column, new_text_column)
SELECT 3, name, 2017, 'wolves'
FROM   my_simple_table
WHERE  id = 2;
```

- insert from text file 
mysql 
```
LOAD DATA LOCAL INFILE '<file_path>/my_data.csv' INTO TABLE new_table FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' IGNORE 1 ROWS;
```

SQL Server
```
BULK INSERT new_table FROM '<file_path>/my_data.csv' WITH ( FORMAT = 'CSV', FIELDTERMINATOR = ',', FIELDQUOTE = '"', ROWTERMINATOR = '\n', FIRSTROW = 2, TABLOCK );
```


SQLite
```
.mode csv .import <file_path>/my_data.csv new_table --skip 1
```

- missing data and null values 
A NULL value in PostgreSQL and SQL Server

An empty string ('') in MySQL and SQLite

- alter table 

MySQL, Oracle, PostgreSQL, SQLite
```
ALTER TABLE old_table_name RENAME TO new_table_name;
```

SQL Server
```
EXEC sp_rename 'old_table_name', 'new_table_name';
```

- display add modify and delete constraints 

```
-- List constraints (except default ones) 
SELECT table_name, constraint_name, constraint_type FROM information_schema.table_constraints WHERE table_name = 'my_table';

-- List all default constraints 
SELECT OBJECT_NAME(parent_object_id), COL_NAME(parent_object_id, parent_column_id), definition FROM sys.default_constraints WHERE OBJECT_NAME(parent_object_id) = 'my_table';
```

- insert contsraints

```
ALTER TABLE my_table ADD CONSTRAINT chk_lower_name CHECK (lower_name = LOWER(name));
```

- delete a constraint 
Oracle,

PostgreSQL,

SQL Server
	
```
ALTER TABLE my_table DROP CONSTRAINT chk_lower_name;
```

- update a column of data 
```
UPDATE my_table
SET name = LOWER(name);

SELECT * FROM my_table;
```

- update a row 

```
UPDATE my_table
SET awards = awards + 1
WHERE country = 'CA';

SELECT * FROM my_table;
```

- update from a result table 

```
UPDATE my_table
SET awards = (SELECT MIN(awards) FROM my_table)
WHERE country = 'CA';

SELECT * FROM my_table;

```


- delete a table 

```
DROP TABLE my_table;
DROP TABLE IF EXISTS my_table;
```

- delete a talbe with foreign key reference 

If other tables have foreign keys that reference the table you are dropping, you will need to delete the foreign key constraints in the other tables along with the table
```
DROP TABLE my_table CASCADE;
```

- create indexes 

CREATE INDEX my_index ON my_table (log_date);
CREATE INDEX my_index ON my_table (log_date, team);

- delete indexes 
	
DROP INDEX my_index ON my_table;
DROP INDEX my_index;

- views

Imagine you have a long and complex SQL query that includes many joins, filters, aggregations, etc. The results of the query are useful to you and something that you want to reference again

```
-- Number of waterfalls owned by each owner
SELECT o.id, o.name,
       COUNT(w.id) AS num_waterfalls
FROM owner o LEFT JOIN waterfall w
     ON o.id = w.owner_id
GROUP BY o.id, o.name;

id    name             num_waterfalls
----- ---------------- ---------------
    1 Pictured Rocks                 3
    2 Michigan Nature                3
    3 AF LLC                         1
    4 MI DNR                         1
    5 Horseshoe Falls                0
	
	
	
-- Subquery Approach
SELECT AVG(num_waterfalls) FROM
(SELECT o.id, o.name,
        COUNT(w.id) AS num_waterfalls
FROM owner o LEFT JOIN waterfall w
     ON o.id = w.owner_id
GROUP BY o.id, o.name) my_subquery;

AVG(num_waterfalls)
--------------------
                 1.6
				 
				 
				 
-- View Approach
CREATE VIEW owner_waterfalls_vw AS
SELECT o.id, o.name,
       COUNT(w.id) AS num_waterfalls
FROM owner o LEFT JOIN waterfall w
     ON o.id = w.owner_id
GROUP BY o.id, o.name;

SELECT AVG(num_waterfalls)
  FROM owner_waterfalls_vw;

AVG(num_waterfalls)
--------------------
                 1.6
```

- create view to save the results of a query 
```
CREATE VIEW my_view AS
SELECT *
FROM my_table
WHERE country = 'US';

SELECT * FROM my_view;

id  country  name
--- -------- ------
  1 US       Anna
  2 US       Emily
  3 US       Molly
```

- A transaction allows you to more safely update a database. It consists of a sequence of operations that are executed as a single unit.

```

START TRANSACTION;

INSERT INTO page_views (user_id, page)
   VALUES (525, 'home');
INSERT INTO page_views (user_id, page)
   VALUES (525, 'contact us');
DELETE FROM new_users WHERE user_id = 525;
UPDATE page_views SET page = 'request info'
   WHERE page = 'contact us';

COMMIT;
```

```
-- MySQL and PostgreSQL
START TRANSACTION;
or
BEGIN;

-- SQL Server and SQLite
BEGIN TRANSACTION;
```

- Use COMMIT to lock in the changes. After this step, you are no longer in transaction mode.

- Instead of COMMIT, ROLLBACK the changes. The table will not be deleted. 

```
ROLLBACK;
```



# Data types
- data types in sql 

Numeric	String	Datetime	Other

Integer (123)

Decimal (1.23)

Floating Point (1.23e10)
	

Character ('hello')

Unicode ('西瓜')
	

Date ('2021-12–01')

Time ('2:21:00')

Datetime ('2021-12-01 2:21:00')
	

Boolean (TRUE)

Binary (images, documents, etc.)

- choose datatypes 

Data Type	Range of Values Allowed	Storage Size

INT		-2,147,483,648 to 2,147,483,647	4 bytes

SMALLINT	-32,768 to 32,767	2 bytes

TINYINT	0 to 255 1 byte

- integer 

```
CREATE TABLE my_table (
   my_integer_column INT
);

INSERT INTO my_table VALUES
   (25),
   (-525),
   (2500252);

SELECT * FROM my_table;
```

- Decimal numbers are also known as fixed point numbers. They include a decimal point and are stored as an exact value.

```
CREATE TABLE my_table (
   my_decimal_column DECIMAL(5,2)
);

INSERT INTO my_table VALUES
   (123.45),
   (-123),
   (12.3);

SELECT * FROM my_table;

```

- string data 

single quotes when you need to embed a single quote in a string:

'You''re welcome.'

oracle Q or q, followed by any character, then the string and finally the character again:
Q'[This is a string.]'
q'[This is a string.]'
Q'|This is a string.|'

- character data types, varchar, char, text TEXT requires no inputs, meaning you do not have to specify a length for the text.
```
CREATE TABLE my_table (
   my_character_column VARCHAR(50)
);

INSERT INTO my_table VALUES
   ('Here is some text.'),
   ('And some numbers - 1 2 3 4 5'),
   ('And some punctuation! :)');

SELECT * FROM my_table;
```

- unicode data types 

difference between the VARCHAR and NVARCHAR (Unicode) data types:

```
CREATE TABLE my_table (
   ascii_text VARCHAR(10),
   unicode_text NVARCHAR(10)
);

INSERT INTO my_table VALUES
   ('abc', 'abc'),
   (N'赵欣婉', N'赵欣婉');

SELECT * FROM my_table;
```

- data time 
```
REATE TABLE my_table (
   dt DATE,
   tm TIME,
   dttm DATETIME,
   ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
   yr YEAR
);

INSERT INTO my_table (dt, tm, dttm, yr)
   VALUES ('21-7-4', '6:30',
           2021, '2021-12-25 7:00:01');
```

- boolean data 

```
SELECT TRUE, True, FALSE, False;
```

- binary 

```
SELECT X'AF12', x'AF12', 0xAF12;


CREATE TABLE my_table (
   my_binary_column BLOB
);

INSERT INTO my_table VALUES
   ('a'),
   ('aaa'),
   ('ae$ iou');

SELECT * FROM my_table;
```



# Operators and functions 
-  five operators (+, =, OR, BETWEEN, AND) and two functions (UPPER, YEAR):

```
-- Pay increases for employees
SELECT name, pay_rate + 5 AS new_pay_rate
FROM employees
WHERE UPPER(title) = 'ANALYST'
      OR YEAR(start_date) BETWEEN 2016 AND 2018;
```

- common operators 

Logical Operators			
AND
OR
NOT
	
Comparison Operators (Symbols)
=
!=, <>
<
<=
>
v=
	
Comparison Operators (Keywords)
BETWEEN
EXISTS
IN
IS NULL
LIKE

Math Operators
+
-
*
/
%


Aggregate Functions			
COUNT()
SUM()
AVG()
MIN()
MAX()
	
Numeric Functions
ABS()
SQRT()
LOG()
ROUND()
CAST()
	
String Functions
LENGTH()
TRIM()
CONCAT()
SUBSTR()
REGEXP()
	
Datetime Functions	
CURRENT_ DATE
CURRENT_ TIME
DATEDIFF()
EXTRACT()
CONVERT()
	
Null Functions
COALESCE()

- logical operators 
```
SELECT *
FROM employees
WHERE start_date IS NOT NULL
      AND (title = 'analyst' OR pay_rate < 25);
```


# Advanced querying concepts 
- Case Statements

If a condition is met, return a particular value. Otherwise, return another value.

```
SELECT house_id,
  CASE WHEN flg = 1
  THEN 'for sale'
  ELSE 'sold' END
FROM houses;
```

- Grouping and Summarizing
	

Split data into groups, aggregate the data within each group, and return a value for each group.
	
```
SELECT zip, AVG(ft)
FROM houses
GROUP BY zip;
```

- Window Functions
Split data into groups, aggregate or order the data within each group, and return a value for each row.
```
SELECT zip,
  ROW_NUMBER() OVER
  (PARTITION BY zip
  ORDER BY price)
FROM houses;
```

- pivoting
	
Turn values in a column into multiple columns or consolidate multiple columns into a single column. Supported by Oracle and SQL Server.
```
-- Oracle syntax
SELECT *
FROM listing_info
PIVOT
  (COUNT(*) FOR
  room IN ('bd','br'));
```

- group by keywords 




# Working with multiple tables and queries 



















