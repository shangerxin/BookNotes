Go Programming language for dummies=Wei meng Lee;Note=Erxin


# Hello go 
- os environment 

$ go env

- first program 

```
package main
 
import (
    "fmt"
    "time"
)

func displayTime() {
    fmt.Println(time.Now())
}
```



# Works with different data type 
- define type 

var num1 = 5            // type inferred

- comment 
 double-slash (//) is a comment. 
 
- Explicitly typed variables

var num1 = 5            // type inferred
var num2 int            // explicitly typed

var num3 float32     // floating point variable
var name string      // string variable
var raining bool     // boolean variable
 
fmt.Println(num3)    // 0
fmt.Println(name)    // "" (empty string)
fmt.Println(raining) // false

- short variable declaration operator 

firstName := "Wei-Meng"

firstName, lastName, age := "Wei-Meng", "Lee", 25

var firstName, lastName string = "Wei-Meng", "Lee"


var (
    firstName string = "Wei-Meng"
    lastName  string = "Lee"
    age       int    = 25
)

- const 
 
const publisher = "Wiley"

- unused variable to a blank identifier (_), like this: 

var num1 = 5
_ = num1  // The compiler is now happy!

- string escape 

such as \n or \t), as shown in the following example:
```

address := "The White House\n1600 Pennsylvania Avenue
NW\nWashington, DC 20500"
```

- length 

fmt.Println(len(str1))  // 15 = 5 chars * 3 bytes

count the number of characters (runes) in a string, use the RuneCountInString() function:

fmt.Println(utf8.RuneCountInString(str1)) // 5

- tools 

Chinese characters to their Unicode representations at www.chineseconverter.com/en/convert/unicode.

- Use the %T printing verb in the Printf() function. It looks like this:

fmt.Printf("%T\n", start)        // time.Time

- Use the reflect package. The reflect package allows you to find out the data type of a variable

fmt.Println(reflect.TypeOf(start))         // time.Time
fmt.Println(reflect.ValueOf(start).Kind()) // struct

- convert a variable's type 

var age int
fmt.Print("Please enter your age: ")
fmt.Scanf("%d", &age)
fmt.Println("You entered:", age)

- run  program works as expected:

$ go run main.go

- strconv package's Atoi() function to try to convert the string into an integer value:

age, err := strconv.Atoi(input) // convert string to
                                // int
								
- check if the err variable contains a nil value								

if err != nil {        // an error occurred
    fmt.Println(err)
} else {
    fmt.Println("Your age is:", age)
}

b, err := strconv.ParseBool("t")
fmt.Println(b)        // true
fmt.Println(err)      // <nil>
fmt.Printf("%T\n", b) // bool

- Interpolating strings

onvert the integer variable value to string and then concatenate them:

s := name + ", your queue number is:" +
    strconv.Itoa(queue)

Sprintf() function from the fmt package:

s := fmt.Sprintf("%s, your queue number is %d",
    name, queue)


# Making decisions with if/else 
- example 
num := 6
condition := num % 2 == 0

logical expression:

num % 2 == 0

- comparison operators in go 

```
Operator		Description			Example

==				Equal to			num == 0

!=				Not equal to		num != 0

<				Less than			num < 0

<=				Less than or equal to 	num <= 0

>				Greater than		num > 0

>=				Greater than or equal to	num >= 0

&&	Logical AND operator. Both operands must be true in order for the condition to evaluate to true.	x && y
||
! 
```

- if 

if num % 2 == 1 {
    fmt.Println("Number is odd")
} else {
    fmt.Println("Number is even")
}

- functions 

func raining() bool {
    fmt.Println("Check if it is raining now…")
    return true
}
 
func snowing() bool {
    fmt.Println("Check if it is snowing now…")
    return true
}

if raining() || snowing() {
    fmt.Println("Stay indoors!")
}
/*
Check if it is raining now…
Stay indoors!
*/


- switch 

	+ default switch statement:

num := 5
dayOfWeek := ""
switch num {
case 1:
dayOfWeek = "Monday"
case 2:
    dayOfWeek = "Tuesday"
case 3:
    dayOfWeek = "Wednesday"
case 4:
    dayOfWeek = "Thursday"
case 5:
    dayOfWeek = "Friday"
case 6:
    dayOfWeek = "Saturday"
case 7:
    dayOfWeek = "Sunday"
default:
    dayOfWeek = "--error--"
}
 
fmt.Println(dayOfWeek) // Friday

When a block of statements is executed, control is immediately transferred out of the switch statement.

	+ multiple cases 
switch num {
    case 1:
        dayOfWeek = "Monday"
        fmt.Println("Monday blues…")
 
    case 2: dayOfWeek = "Tuesday"
    case 3: dayOfWeek = "Wednesday"
    case 4: dayOfWeek = "Thursday"
    case 5:
        dayOfWeek = "Friday"
        fmt.Println("TGIF!!!")
 
    case 6: dayOfWeek = "Saturday"
    case 7: dayOfWeek = "Sunday"
    default:
}


	+ switch statement with the fallthrough keyword, don't want to out of switch after execute a block 
	
// grade scores A, B, C, or D, you print Passed. If he scores F, you print Failed.
grade := "C"
switch grade {
    case "A":
        fallthrough
    case "B":
        fallthrough
    case "C":
        fallthrough
    case "D":
        fmt.Println("Passed")
    case "F":
        fmt.Println("Failed")
    default:
        fmt.Println("Absent")
}
	
	+ mutiple cases
grade := "C"
switch grade {
    case "A", "B", "C", "D":
        fmt.Println("Passed")
    case "F":
        fmt.Println("Failed")
    default:
        fmt.Println("Undefined")
}
	
score := 79
grade := ""
switch {
    case score < 50: grade = "F"
    case score < 60: grade = "D"
    case score < 70: grade = "C"
    case score < 80: grade = "B"
    default: grade = "A"
}
fmt.Println(grade)    // B	
	
	
	
# Using loops 
-  looping — while, do…while, and for — Go has only one looping construct

for (init; condition; post) {
}

func main() {
    for i:=0; i<5; i++ {
        fmt.Println(i)
    }
}


num++  // post-increment operator
++num  // pre-increment operator
num--  // post-decrement operator
--num  // pre-decrement operator

- fibonacci numbers 

max := 100
a, b := 0, 1
for ;b <= max; {
    println(b)
    a, b = b, a+b
}


- repeatedly waits for the user to input a string, until the user enters the string QUIT:

package main
 
import (
    "fmt"
    "strings"
)
 
func main() {
    for {
        fmt.Println("Enter QUIT to exit")
        var input string
        fmt.Print("Please enter a string:")
        fmt.Scanln(&input)
        if strings.ToUpper(input) == "QUIT" {
            break
        }
    }
}

$ go run main.go

- an array of three elements:

var OS [3]string
OS[0] = "iOS"
OS[1] = "Android"
OS[2] = "Windows"

for i, v := range OS {
    fmt.Println(i, v)
}

i: The index of the value you're accessing — in this case, the value is the OS array.
v: Each of the values in the OS array.

- the continue or the break statement only affects the current for loop

- define function 

func displayDate() {
    fmt.Println(time.Now().Date())
}

func displayDate(format string) {
    fmt.Println(time.Now().Format(format))
}

func swap(a, b int) {
    a, b = b, a
}

	+ passing value by pointer You can modify the parameters in the swap() function to take in pointers to int instead, like this: 

func swap(a, b *int) {
    *a, *b = *b, *a
}

x := 5
y := 6
swap(&x, &y)
fmt.Println(x, y) // 6 5

- return 

func addNum(num1, num2 int) int {  // returns int
    return num1 + num2
}

	+ returning results with a pair of parentheses, like this:

func countOddEven(s string) (int,int) {
    odds, evens := 0,0
    for _, c := range s {
        if int(c) % 2 == 0 {
            evens++
        } else {
            odds++
        }
    }
    return odds,evens
}


	+ naming return, the returning variable is named sum. This variable is used within the function and at the end of the function. The return statement without any argument will return the value of this variable. 

func addNum(num1 int, num2 int) (sum int) {
    sum = num1 + num2
    return  // you can still use "return sum"
}

- define a function that accepts a variable number of arguments, you use ellipses (…), like this:

func addNums(nums … int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

a fixed parameter together with a variadic parameter:

func addNums(total int, nums …int) int {
    fmt.Printf("%T", nums)
    for _, n := range nums {
        total += n
    }
    return total
}

- an anonymous function

```
package main
 
import "fmt"
 
func main() {
    var i func() int
}
```

```
func doSomething() int {
    return 5
}
 
func main() {
    var i func() int
    i = doSomething
}

//assign it an anonymous function, like this:

var i func() int
i = func() int {
    return 5
}
```

- implement closure with anonymous functions 

func fib() func() int {
    f1 := 0
    f2 := 1
    return func() int {
        f1, f2 = f2, (f1 + f2)
        return f1
    }
}

- example 

func filter(arr []int, cond func(int) bool) []int {
    result := []int{}
    for _, v := range arr {
        if cond(v) {
            result = append(result, v)
        }
    }
    return result
}

// change the condition in the anonymous function:

func main() {
    a := []int{1, 2, 3, 4, 5}
    evens := filter(a,
        func(val int) bool {
            return val > 3
        })
    fmt.Println(evens)
}


# Working with data structures 
- array 

var array_name [size_of_array]data_type

var nums [5]int   // an array of int (5 elements)
fmt.Println(nums) // [0 0 0 0 0]

	+ initializing array 
	
nums := [5]int{1, 2, 3, 4, 5}
fmt.Println(nums)

	+ omit the length of the size by using the … notation:

nums := […]int{1, 2, 3, 4, 5}

- multi dimensional array 

```
var table [5][6]string
for row := 0; row < 5; row++ {
    for column := 0; column < 6; column++ {
        table[row][column] =
            strconv.Itoa(row) + "," +
                strconv.Itoa(column)
    }
}
fmt.Println(table)
```

- A slice is represented by a slice header, which contains three fields:

ptr: A pointer that points to the address of the underlying array
len: The length of the slice
cap: The capacity, or maximum number of allowed elements in the array

slice s, you use the len() and cap() functions, respectively

- append item to array 

append an item to a slice, you use the append() function:

t = append(t, 6, 7, 8)

- slice 

// slice from 1:3, then your capacity will change (see Figure 6-15).

t = t[1:3]
fmt.Println(t)       // [2 3]
fmt.Println(len(t))  // 2
fmt.Println(cap(t))  // 4

// can make a copy of this slice, you need to create a slice of the same size:
v := make([]int, len(t))

// create copy of slices, use the copy() function. The copy() function has the following syntax:
copy(destination, source)

- inserting an item 

func insert(orig []int, index int, value int)
    ([]int, error) {
    if index < 0 {
        return nil, errors.New(
            "Index cannot be less than 0")
    }
 
    if index >= len(orig) {
        return append(orig, value), nil
    }
 
    orig = append(orig[:index+1], orig[index:]…)
    orig[index] = value
    return orig, nil
}


func delete(orig []int, index int) ([]int, error) {
    if index < 0 || index >= len(orig) {
        return nil, errors.New("Index out of range")
    }
    orig = append(orig[:index], orig[index+1:]…)
    return orig, nil
}


- define a structure 

package main
 
import "fmt"
 
type point struct {
    x float32
    y float32
    z float32
}
 
func main() {
    var pt1 point
    pt1.x = 3.1
    pt1.y = 5.7
    pt1.z = 4.2
}

pt2 := point{x: 5.6, y: 3.8, z: 6.9}

- constructure 

func newPoint(x, y, z float32) *point {
    p := point{x: x, y: y, z: z}
    return &p
}

- make a copy of structure 

The result from the newPoint() function (pt4 in the preceding example) is a pointer to a struct. If you try to assign pt4 to another variable — say, pt

create an independent copy of pt4, you need to use the * character, like this: 
pt6 := *pt4

create a reference to a struct — say, pt7 — you use the & prefix
pt8 := &pt7

- define function for structure 

```
import (
    "fmt"
    "math"
)
 
type point struct {
    x float32
    y float32
    z float32
}
 
func (p point) length() float64 {
    return math.Sqrt(
        (math.Pow(float64(p.x), 2) +
            math.Pow(float64(p.y), 2) +
            math.Pow(float64(p.z), 2)))
}
 
func newPoint(x, y, z float32) *point {
    p := point{x: x, y: y, z: z}
    return &p
}


func (p *point) move(deltax, deltay, deltaz float32) {
    p.x += deltax
    p.y += deltay
    p.z += deltaz
}
```

- comparing structure 

pt1 := point{x: 5.6, y: 3.8, z: 6.9}
pt2 := point{x: 5.6, y: 3.8, z: 6.9}
pt3 := point{x: 6.5, y: 3.8, z: 6.9}
 
fmt.Println(pt1 == pt2) // true
fmt.Println(pt2 == pt3) // false

You can't directly compare structs that contain fields that aren’t comparable, but you can use the cmp package (https://pkg.go.dev/github.com/google/go-cmp/cmp) to do that2

```
package main
 
import (
    "fmt"
    "github.com/google/go-cmp/cmp"
)
 
type Point struct {
    X    float32
    Y    float32
    Z    float32
    Name []string
}
 
func main() {
    pt1 := Point{X: 5.6, Y: 3.8, Z: 6.9,
             Name: []string{"pt1"}}
    pt2 := Point{X: 5.6, Y: 3.8, Z: 6.9,
             Name: []string{"pt"}}
    pt3 := Point{X: 5.6, Y: 3.8, Z: 6.9,
             Name: []string{"pt"}}
 
    fmt.Println(cmp.Equal(pt1, pt2)) // false
    fmt.Println(cmp.Equal(pt2, pt3)) // true
}
```

- establishing relationships suing maps 

map[keyType] valueType

heights = make(map[string]int)
heights["Peter"] = 170

- initializing a map with a map literal 

make() function to initialize a map variable

heights := map[string]int{
    "Peter": 170,
    "Joan":  168,
    "Jan":   175,   // <-- note the comma here
}

if v, ok := heights["Jim"]; ok {
    fmt.Println(v)
} else {
    fmt.Println("Key does not exist")
}

delete(map, key)2

getting the number of items in a map 

fmt.Println(len(heights))

- get all the keys in a map 

// get all the keys in map
var keys []string
for k := range heights {
    keys = append(keys, k)
}
fmt.Println(keys) // [Jan Peter Joan]

- define map functions 

```
package main
 
import (
    "fmt"
    "sort"
)
 
type kv struct {
    key   string
    value int
}
 
type kvPairs []kv
 
var heights map[string]int
 
func (p kvPairs) Len() int {
    // returns the length of the collection
    return len(p)
}
 
func (p kvPairs) Less(i, j int) bool {
    // indicates the first value (height) must be smaller
    // than the second value
    return p[i].value < p[j].value
}
 
func (p kvPairs) Swap(i, j int) {
    // swaps the items in the collection
    p[i], p[j] = p[j], p[i]
}
```

- creating a map of structs

```
type dob struct {
    day   int
    month int
    year  int
}
 
type people struct {
    name  string
    email string
    dob   dob
}

package main
 
import "fmt"
 
type dob struct {
    day   int
    month int
    year  int
}
 
type people struct {
    name  string
    email string
    dob   dob
}
 
var members map[int]people
 
func main() {
    members = make(map[int]people)
 
    members[1] = people{
        name:  "Mary Smith",
        email: "marysmith@example.com",
        dob: dob{
            day:   17,
            month: 3,
            year:  1990,
        },
    }
    members[2] = people{
        name:  "John Smith",
        email: "johnsmith@example.com",
        dob: dob{
            day:   9,
            month: 12,
            year:  1988,
        },
    }
    members[3] = people{
        name:  "Janet Doe",
        email: "janetdoe@example.com",
        dob: dob{
            day:   1,
            month: 12,
            year:  1988,
        },
    }
    members[4] = people{
        name:  "Adam Jones",
        email: "adamjones@example.com",
        dob: dob{
            day:   19,
            month: 8,
            year:  2001,
        },
    }
}

for k, v := range members {
    fmt.Println(k, v.name, v.email, v.dob)
}
```


- sort a slice use the SliceStable() function from the sort package. The SliceStable() function has the following signature:

func SliceStable(slice interface{},
                 less func(i, j int) bool)



- Encoding and decoding data using JSON 

JSON supports the following data types:

Object
String
Boolean
Number
Array
null

- using json package 

package main
 
import (
    "encoding/json"
    "fmt"
)

type People struct {
    Firstname string
    Lastname  string
}

func main() {
    var person People
 
    jsonString := `{"firstname":"Wei-Meng",
                    "lastname":"Lee"}`
 
    err := json.Unmarshal([]byte(jsonString), &person)
    if err == nil {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
    } else {
        fmt.Println(err)
    }
}

- decoding json to arrays 

[
    {
        "firstname":"Wei-Meng",
        "lastname":"Lee"
    },
    {
        "firstname":"Mickey",
        "lastname":"Mouse"
    }
]

func main() {
    var persons []People
    jsonString :=
        `[
            {
                "firstname":"Wei-Meng",
                "lastname":"Lee"
            },
            {
                "firstname":"Mickey",
                "lastname":"Mouse"
            }
        ]`
 
    json.Unmarshal([]byte(jsonString), &persons)
 
    for _, person := range persons {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
    }
}

type Rates struct {
    Base   string `json:"base currency"`
    Symbol string `json:"destination currency"`
}

- decoding json to struct 

```
package main
 
import (
    "encoding/json"
    "fmt"
)

func main() {
    var person People
 
    jsonString := `{"firstname":"Wei-Meng",
                    "lastname":"Lee"}`
 
    err := json.Unmarshal([]byte(jsonString), &person)
    if err == nil {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
    } else {
        fmt.Println(err)
    }
}
```

- decoding objects 

```
package main
 
import (
    "encoding/json"
    "fmt"
)
 
type People struct {
    Firstname string
    Lastname  string
    Details   struct {
        Height int
        Weight float32
    }
}
 
func main() {
    var persons []People
    jsonString :=
        `[
            {
                "firstname":"Wei-Meng",
                "lastname":"Lee",
                "details": {
                    "height":175,
                    "weight":70.0
                }
            },
            {
                "firstname":"Mickey",
                "lastname":"Mouse",
                "details": {
                    "height":105,
                    "weight":85.5
                }
            }
        ]`
 
    json.Unmarshal([]byte(jsonString), &persons)
 
    for _, person := range persons {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
        fmt.Println(person.Details.Height)
        fmt.Println(person.Details.Weight)
    }
}
```

- mapping unstructured data 
```
package main
 
import (
    "encoding/json"
    "fmt"
)
 
func main() {
    jsonString :=
        `{
            "success": true,
            "timestamp": 1588779306,
            "base": "EUR",
            "date": "2020-05-06",
            "rates": {
                "AUD": 1.683349,
                "CAD": 1.528643,
                "GBP": 0.874757,
                "SGD": 1.534513,
                "USD": 1.080054
            }
        }`
 
    var result map[string]interface{}
 
    json.Unmarshal([]byte(jsonString), &result)
    fmt.Println(result["success"]) // true
 
    rates := result["rates"]
    fmt.Println(rates)
    // map[USD:1.080054 AUD:1.683349 CAD:1.528643
    //     GBP:0.874757 SGD:1.534513]
 
    currencies := rates.(map[string]interface{})
    SGD := currencies["SGD"]
    fmt.Println(SGD)
    // 1.534513
}
```

The following statement indicates that result is a variable of type map, with key of type string, and value of type interface (which can be of any type)

- encoding to json 
```
package main
 
import (
    "encoding/json"
    "fmt"
    "time"
)
 
type Name struct {
    FirstName string
    LastName  string
}
 
type Address struct {
    Line1 string
    Line2 string
    Line3 string
}
 
type Customer struct {
    Name    Name
    Email   string
    Address Address
    DOB     time.Time
}
 
func main() {
 
    layoutISO := "2006-01-02"
    dob, _ := time.Parse(layoutISO, "2010-01-18")
 
    john := Customer{
                Name: Name{ FirstName: "John",
                            LastName: "Smith",
                          },
                Email: "johnsmith@example.com",
                Address: Address{
                     Line1: "The White House",
                     Line2: "1600 Pennsylvania Avenue NW",
                     Line3: "Washington, DC 20500",
                },
                DOB: dob,
    }
 
    johnJSON, err := json.Marshal(john)
    if err == nil {
        fmt.Println(string(johnJSON))
    } else {
        fmt.Println(err)
    }
}

```

- encoding interfaces to json 
```
package main
 
import (
    "encoding/json"
    "fmt"
    "time"
)
 
type Customer map[string]interface{}
type Name map[string]interface{}
type Address map[string]interface{}
 
func main() {
    layoutISO := "2006-01-02"
    dob, _ := time.Parse(layoutISO, "2010-01-18")
 
    john := Customer{
                "Name": Name{
                     "FirstName": "John",
                     "LastName": "Smith",
                },
                "Email": "johnsmith@example.com",
                "Address": Address{
                   "Line1": "The White House",
                   "Line2": "1600 Pennsylvania Avenue NW",
                   "Line3": "Washington, DC 20500",
                },
                "DOB":     dob,
            }
 
    johnJSON, err := json.MarshalIndent(john, "", "    ")
    if err == nil {
        fmt.Println(string(johnJSON))
    } else {
        fmt.Println(err)
    }
}
```

- defining method signatures using interfaces 

```
package main
 
import (
    "fmt"
)
 
type DigitsCounter interface {
}
 
func main() {
 
}
```

	+ implementing an interface 
```	
package main
 
import (
    "fmt"
)
 
type DigitsCounter interface {
    CountOddEven() (int, int)
}
 
type DigitString string

// DigitString implements DigitsCounter
func (ds DigitString) CountOddEven() (int, int) {
    odds, evens := 0, 0
    for _, digit := range ds {
        if digit%2 == 0 {
            evens++
        } else {
            odds++
        }
    }
    return odds, evens
}

s := DigitString("123456789")
var d DigitsCounter
d = s
fmt.Println(d.CountOddEven())  // 5 4
```

- how use interface 

```
type Circle struct {
    radius float64
    name   string
}
 
type Square struct {
    length float64
    name   string
}

type Shape interface {
    Area() float64
}

// Circle implements Shape
func (c Circle) Area() float64 {
    return math.Pi * math.Pow(c.radius, 2)
}

// Square implements Shape
func (s Square) Area() float64 {
    return math.Pow(s.length, 2)
}

func main() {
    c1 := Circle{radius: 5, name: "c1"}
    s1 := Square{length: 6, name: "s1"}
}

func calculateArea(listOfShapes []Shape) {
    for _, shape := range listOfShapes {
        fmt.Println("Area of shape is ", shape.Area())
    }
}
 
func main() {
    c1 := Circle{radius: 5, name: "c1"}
    s1 := Square{length: 6, name: "s1"}
 
    shapes := []Shape{c1, s1}
    calculateArea(shapes)
}
```

- empty interface 

interface{}

c1 := Circle{radius: 5, name: "c1"}

var v interface{} = c1



# multitask in go 

If the main() function is terminated, all the goroutines currently running will also be terminated.

- A Mutex is a mutual exclusion lock. A mutual exclusion lock is a technique to ensure exclusive access to shared data between threads of execution.

```
package main
 
import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)
 
var balance int
var mutex = &sync.Mutex{}
 
func credit() {
    for i := 0; i < 5; i++ {
        mutex.Lock()
        balance += 100
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
        fmt.Println("After crediting, balance is", balance)
        mutex.Unlock()
    }
}
 
func debit() {
    for i := 0; i < 5; i++ {
        mutex.Lock()
        balance -= 100
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
        fmt.Println("After debiting, balance is", balance)
        mutex.Unlock()
    }
}
 
func main() {
    balance = 200
    fmt.Println("Initial balance is", balance)
    go credit()
    go debit()
    fmt.Scanln()
}
```

- Using atomic counters for modifying shared resources

```
package main
 
import (
    "fmt"
    "math/rand"
    "sync"
    "sync/atomic"
    "time"
)
 
var balance int64
 
func credit() {
    for i := 0; i < 10; i++ {
        // adds 100 to balance atomically
        atomic.AddInt64(&balance, 100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
}
 
func debit() {
    for i := 0; i < 5; i++ {
        // deducts -100 from balance atomically
        atomic.AddInt64(&balance, -100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
}
 
func main() {
    balance = 200
    fmt.Println("Initial balance is", balance)
    go credit()
    go debit()
    fmt.Scanln()
    fmt.Println(balance)
}
```

- Synchronizing Goroutines, use sync.WaitGroup to wait goroutines 

```
package main
 
import (
    "fmt"
    "math/rand"
    "sync"
    "sync/atomic"
    "time"
)
 
var balance int64
 
func credit(wg *sync.WaitGroup) {
    // notify the WaitGroup when we are done
    defer wg.Done()
    for i := 0; i < 10; i++ {
        // adds 100 to balance atomically
        atomic.AddInt64(&balance, 100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
 
}
 
func debit(wg *sync.WaitGroup) {
    // notify the WaitGroup when we are done
    defer wg.Done()
    for i := 0; i < 5; i++ {
        // deducts -100 from balance atomically
        atomic.AddInt64(&balance, -100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
}
 
func main() {
    var wg sync.WaitGroup
 
    balance = 200
    fmt.Println("Initial balance is", balance)
 
    wg.Add(1) // add 1 to the WaitGroup counter
    go credit(&wg)
 
    wg.Add(1) // add 1 to the WaitGroup counter
    go debit(&wg)
 
    wg.Wait() // blocks until WaitGroup counter is 0
    fmt.Println("Final balance is", balance)
}
```

- Communicating between Goroutines Using Channels1

	+ understanding channels 
	
	ch := make(chan int)

	send value to channel you use the <- operator. The following example writes the value 5 into the ch channel:

	ch <- 5

	+ retrieves a value from the ch channel assigns it to a variable named value:

	value := <- ch

- How channels work 

```
package main
 
import (
    "fmt"
    "time"
)
 
//---send data into a channel---
func sendData(ch chan string) {
    fmt.Println("Sending a string into channel…")
    time.Sleep(2 * time.Second)
    ch <- "Hello"
}
 
//---getting data from the channel---
func getData(ch chan string) {
    fmt.Println("String retrieved from channel:", <-ch)
}
 
func main() {
    ch := make(chan string)
 
    go sendData(ch)
    go getData(ch)
 
    fmt.Scanln()
}
```

sum() that sums up a slice of integer values:
```
func sum(s []int, c chan int) {
    sum := 0
    for _, v := range s {
        sum += v
    }
    c <- sum
}
```

generate ten random numbers and assign it to a variable named s:
```
func main() {
    s := []int{}
    sliceSize := 10
    for i := 0; i < sliceSize; i++ {
        s = append(s, rand.Intn(100))
    }
}
```

deterministic state:

rand.Seed(time.Now().UnixNano())

call it as a goroutine:
```
func main() {
    s := []int{}
    sliceSize := 10
    for i := 0; i < sliceSize; i++ {
        s = append(s, rand.Intn(100))
    }
 
    c := make(chan int)
    partSize := 2
    parts := sliceSize / partSize
    i := 0
    for i < parts {
        go sum(s[i*partSize:(i+1)*partSize], c)
        i += 1
    }
}
```

- use a for loop, together with the select statement, like the following statements in bold:
```
func main() {
    c1 := make(chan int)
    c2 := make(chan int)
 
    go fib(10, c1)             // generate 10 Fibonacci numbers
    go counter(10, c2)         // generate 10 numbers
 
    c1Closed := false
    c2Closed := false
 
    for {
        select {
        case n, ok := <-c1:
            if !ok {
                // channel closed and drained
                c1Closed = true
                if c1Closed && c2Closed {
                    return
                }
            } else {
                fmt.Println("fib()", n)
            }
        case m, ok := <c2:
            if !ok {
                // channel closed and drained
                c2Closed = true
                if c1Closed && c2Closed {
                    return
                }
            } else {
                fmt.Println("counter()", m)
            }
        }
    }
}
```

retrieve the value from the channel and assign it to a pair of variables:

n, ok := <-c1

- Using Buffered Channels

So far, all my discussion on channels has centered on unbuffered channels. When you send a value to an unbuffered channel, your code will block until the value is received from the channel.
create a buffered channel of length 5:
```
func sum(s []int, c chan int) {
    sum := 0
    for _, v := range s {
        sum += v
    }
    c <- sum
    fmt.Println("Done and can continue to do other work")
}
 
func main() {
    s := []int{}
    sliceSize := 10
    for i := 0; i < sliceSize; i++ {
        s = append(s, rand.Intn(100))
    }
 
    c := make(chan int, 5) // buffered channel of length 5
    partSize := 2
    parts := sliceSize / partSize
    i := 0
    for i < parts {
        go sum(s[i*partSize:(i+1)*partSize], c)
        i += 1
    }
 
    i = 0
    total := 0
    time.Sleep(1 * time.Second) // simulate retrieving at a later time
    for i < parts {
        partialSum := <-c // read from channel
        fmt.Println("Partial Sum: ", partialSum)
        total += partialSum
        i += 1
    }
    fmt.Println("Total: ", total)
    fmt.Scanln()
}
``` 


# Organizing your code 
- Go applications always have this first statement:

package main

main.go file looks like this:
```

package main
 
import (
    "fmt"
    "math"
)
 
type Point struct {
    X float64
    Y float64
}
 
func (p Point) length() float64 {
    return math.Sqrt(math.Pow(p.X, 2.0) + math.Pow(p.Y, 2.0))
}
 
func main() {
    pt1 := Point{X: 2, Y: 3}
    fmt.Println(pt1)
    fmt.Println(pt1.length())
}
```

you need to ensure:

Both files are in the same directory.
Both packages have the same package name (main).
One of the files has a main() function.

- go env command to find out the location of the GOPATH environment variable

Modify the package name in point.go to geometry:

```
package geometry
 
import (
    "math"
)
 
type Point struct {
    X float64
    Y float64
}
 
func (p Point) Length() float64 {
    return math.Sqrt(math.Pow(p.X, 2.0) + math.Pow(p.Y, 2.0))
}
```

- organize package with directory 

$GOPATH
  |__src
    |__geometry
      |__coordinate
        |__point.go
		
```
// Package coordinate for coordinate geometry
package coordinate
 
import (
    "math"
)
 
// Point represents a point in the 2-D coordinate space
type Point struct {
    X float64
    Y float64
}
 
// Length calculates the length of point from the origin
func (p Point) Length() float64 {
    return math.Sqrt(math.Pow(p.X, 2.0) + math.Pow(p.Y, 2.0))
}
```

 use the go install command, like the following:

$ cd ~/go/src/geometry/coordinate
$ go install

- using third party packages 

you can download third-party packages from central repositories like PyPI (https://pypi.org) or npm (www.npmjs.com)

go get command followed by the URL of the package (without the https://), like this:

$ go get github.com/hackebrot/turtle

$GOPATH/src folder of your local computer, like this:

$GOPATH
  |__src
  |  |__github.com
  |    |__hackebrot
  |    |  |__turtle
  |    |    |__ …
  |    |    |__ …

  
use this package, you simply import it into your package, like this:
```
package main
 
import (
    "fmt"
    "github.com/hackebrot/turtle"
)
 
func main() {
    emoji, ok := turtle.Emojis["smiley"]
    if !ok {
        fmt.Println("No emoji found.")
    } else {
        fmt.Println(emoji.Char)
    }
}
```

- go documentation 

godoc by using the go get command:

C:\Users\Wei-Meng Lee>go get golang.org/x/tools/cmd/godoc

macOS

On the Mac, download and install godoc:

$ go get golang.org/x/tools/cmd/godoc


- godoc as a web server type the following command in Terminal:

$ launchctl load ~/Library/LaunchAgents/org.golang.godoc.plist
$ launchctl unload ~/Library/LaunchAgents/org.golang.godoc.plist



# Grouping packages into modules 
- creating modules, To create a module, follow these steps:

Create the following directories on your computer:

$HOME
  |__stringmod
    |__strings
      |__strings.go
    |__quotes
      |__quotes.go
	  
```
package strings
 
func internalFunction() {
    // In Go, a name is exported (visible outside the package) if it begins
    // with a capital letter
}
 
// Must begin with a capital letter in order to be exported
func CountOddEven(s string) (odds, evens int) {
    odds, evens = 0, 0
    for _, c := range s {
        if int(c)%2 == 0 {
            evens++
        } else {
            odds++
        }
    }
    return
}
```

```
package quotes
 
import (
    "github.com/hackebrot/turtle"
)
 
func GetEmoji(name string) string {
    emoji, ok := turtle.Emojis[name]
    if !ok {
        return ""
    }
    return emoji.Char
}
```

In Terminal or Command Prompt, type the following commands:

$ cd ~/stringmod
$ go mod init github.com/weimenglee/stringmod
go: creating new go.mod: module
github.com/weimenglee/stringmod

making my module available for download on GitHub. I’ve set the download URL as github.com/weimenglee/stringmod

- testing and building a module

Add a new file named main.go in the stringmod folder:

$HOME
  |__stringmod
    |__go.mod
    |__main.go
    |__strings
      |__strings.go
    |__quotes
      |__quotes.go

	  ```
package main
 
import (
    "fmt"
 
    "github.com/weimenglee/stringmod/quotes"
    "github.com/weimenglee/stringmod/strings"
)
 
func main() {
    o, e := strings.CountOddEven("12345")
    fmt.Println(o, e) // 3 2
 
    fmt.Println(quotes.GetEmoji("turtle"))
}
	  ```

- pushing a module on github 

publish the module to GitHub, accessible through the following link: https://github.com/weimenglee/stringmod.
	
-  install this newly published module on your local computer, use the following command:

$ go get github.com/weimenglee/stringmod

GOPATH, use the go env command

directory pkg Contains the non-executable packages. These packages are typically imported by other applications or modules.




# Seeing go in action 
- you go to www.amazon.com and start adding items to your shopping cart.

- fetching data from web services in go 

The Get() function accepts a URL as its argument and returns two results:

A Response struct
An error

- writing a go program to connect to a web api 

Fixer plan by going to https://fixer.io/ and clicking the Sign Up Free button, as shown in Figure 15-2.

URL to access the API:

http://data.fixer.io/api/latest?access_key=<access_key>

```
package main
 
import (
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
)
 
func main() {
    url :=
 "http://data.fixer.io/api/latest?access_key=<access_key>"
 
    if resp, err := http.Get(url); err == nil {
        defer resp.Body.Close()
        if body, err := ioutil.ReadAll(resp.Body);
            err == nil {
            fmt.Println(string(body))
        } else {
            log.Fatal(err)
        }
    } else {
        log.Fatal(err)
    }
    fmt.Println("Done")
}
```

```
package main
 
import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
)
 
type Result struct {
    Success   bool
    Timestamp int
    Base      string
    Date      string
    Rates     map[string]float64
}
 
type Error struct {
    Success bool
    Error   struct {
        Code int
        Type string
        Info string
    }
}
 
func main() {
    url :=
        "http://data.fixer.io/api/latest?access_key=" +
        "<access_key>"
 
    if resp, err := http.Get(url); err == nil {
        defer resp.Body.Close()
        if body, err := ioutil.ReadAll(resp.Body); err == nil {
            var result Result
            json.Unmarshal([]byte(body), &result)
            if result.Success {
                for i, v := range result.Rates {
                    fmt.Println(i, v)
                }
            } else {
                var err Error
                json.Unmarshal([]byte(body), &err)
                fmt.Println(err.Error.Info)
            }
        } else {
            log.Fatal(err)
        }
    } else {
        log.Fatal(err)
    }
    fmt.Println("Done")
}

if result.Success {
    // create an array to store all keys
    keys := make([]string, 0,
        len(result.Rates))
 
    // get all the keys---
    for k := range result.Rates {
        keys = append(keys, k)
    }
 
    // sort the keys
    sort.Strings(keys)
 
    // print the keys and values in
    // alphabetical order
    for _, k := range keys {
        fmt.Println(k, result.Rates[k])
    }
 
    /*
    for i, v := range result.Rates {
        fmt.Println(i, v)
    }
    */
} else {
    var err Error
    json.Unmarshal([]byte(body), &err)
    fmt.Println(err.Error.Info)
}

func fetchData(API int) {
    url := apis[API]
    if resp, err := http.Get(url); err == nil {
        defer resp.Body.Close()
        if body, err := ioutil.ReadAll(resp.Body);
            err == nil {
 
            var result map[string]interface{}
 
            json.Unmarshal([]byte(body), &result)
            switch API {
            case 1: // for the Fixer API
                if result["success"] == true {
                    fmt.Println(result["rates"].(
                        map[string]interface{})["USD"])
                } else {
                    fmt.Println(result["error"].(
                        map[string]interface{})["info"])
                }
            }
        } else {
            log.Fatal(err)
        }
    } else {
        log.Fatal(err)
    }
}

func main() {
    apis = make(map[int]string)
    apis[1] =
       "http://data.fixer.io/api/latest?access_key=" +
       "<access_key>"
    apis[2] =
       "http://api.openweathermap.org/data/2.5/weather?" +
       "q=SINGAPORE&appid=<api_key>"
 
    go fetchData(1)
    go fetchData(2)
 
    fmt.Scanln()
}
```


- getting ready to serve using rest apis 

A REST API uses several HTTP verbs for the clients to communicate with the service:

GET: To retrieve a resource from the service
PUT: To create a new resource or update an existing one on the service
POST: To create a new resource on the service
DELETE: To remove a resource from the service

	+ REST API URL.
	
http://server-address/api/version/service-name/resource-name 

- rest response, A REST API typically returns one of the following HTTP response codes:

200 OK: The request was successful.
201 Created: The request was successful and a resource was created. This response code is used to confirm the success of a PUT or POST request.
400 Bad Request: The request was malformed. This happens especially with POST and PUT requests, when the data doesn't pass validation or is in the wrong format.
404 Not Found: The required resource couldn’t be found. This response code is generally returned to all requests that point to a URL with no corresponding resource.
401 Unauthorized: You need to perform authentication before accessing the resource.
405 Method Not Allowed: The HTTP method used is not supported for this resource.
409 Conflict: A conflict has occurred — for example, you’re using a POST request to create the same resource twice.
500 Internal Server Error: Generally, a 500 response is used when processing fails due to unanticipated circumstances on the server side, causing the server to error out.

-  get your rest api 

```
package main
 
import (
    "fmt"
    "log"
    "net/http"
    "github.com/gorilla/mux"
)
 
func home(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Welcome to the REST API!")
}
 
func main() {
    router := mux.NewRouter()
    router.HandleFunc("/api/v1/", home)
 
    fmt.Println("Listening at port 5000")
    log.Fatal(http.ListenAndServe(":5000", router))
}
```

$ curl http://localhost:5000/api/v1/courses

-  query string (it’s the part in bold):

/api/v1/courses?country=SG&state=CA


/api/version/service?key=value&key=value 

bold to the allcourses() function:
```
func allcourses(w http.ResponseWriter, r *http.Request) {
    // fmt.Fprintf(w, "List of all courses")
    kv := r.URL.Query()
 
    for k, v := range kv {
        fmt.Println(k, v)
    }
}
```

- specifying request methods 

Methods() function to specify the HTTP methods supported on a particular path:
```
func course(w http.ResponseWriter, r *http.Request) {
    params := mux.Vars(r)
    fmt.Fprintf(w, "Detail for course " +
                   params["courseid"])
    fmt.Fprintf(w, "\n")
    fmt.Fprintf(w, r.Method)
}
```



# Working with dataset 
- setup mysql 

download it here:

macOS: https://dev.mysql.com/downloads/file/?id=499568
Windows: https://dev.mysql.com/downloads/file/?id=499590

Terminal/Command Prompt, type the following command:

$ mysql -u root -p

- creating a database and table 

MySQL server. At the MySQL client prompt, type the following command:

mysql> CREATE DATABASE CoursesDB;
mysql> INSERT INTO Course (ID, Details) VALUES ("IOT210","Applied Go Programming");

grant the account permission to access all databases and tables in the MySQL server, type the following command:

mysql> GRANT ALL ON *.* TO 'gouser'@'localhost';

- connecting to mysql database in go Terminal/Command Prompt:

$ go get "github.com/go-sql-driver/mysql"

```
package main
 
import (
    "database/sql"
    "fmt"
    _ "github.com/go-sql-driver/mysql"
)
 
func main() {
    // Use mysql as driverName and a valid DSN
    db, err := sql.Open("mysql",
        "gouser:password@tcp(127.0.0.1:3306)/CoursesDB")
 
    // handle error
    if err != nil {
        panic(err.Error())
    } else {
        fmt.Println("Database object created")
    }
 
    // defer the close till after the main function has
    // finished executing
    defer db.Close()
}
```
	
	
# Reference 
- online playground https://go.dev/play/

- go at google, language design in the service of software engineering 

https://go.dev/talks/2012/splash.article	
	
DSN, data source name The DSN has the following format:

<user>:<password>@tcp(<ip_address>:<port>)/<DB_name>
	
- retrieving data 
```
package main
 
import (
    "database/sql"
    "fmt"
 
    _ "github.com/go-sql-driver/mysql"
)
 
// map this type to the record in the table
type Course struct {
    ID      string
    Details string
}
 
func GetRecords(db *sql.DB) {
    results, err := db.Query("Select * FROM Course")
 
    if err != nil {
        panic(err.Error())
    }
 
    for results.Next() {
        // map this type to the record in the table
        var course Course
        err = results.Scan(&course.ID,
            &course.Details)
        if err != nil {
            panic(err.Error())
        }
 
        fmt.Println(course.ID,
            "-", course.Details)
    }
}
 
func main() {
    // Use mysql as driverName and a valid DSN
    db, err := sql.Open("mysql",
        "gouser:password@tcp(127.0.0.1:3306)/CoursesDB")
 
    // handle error
    if err != nil {
        panic(err.Error())
    } else {
        fmt.Println("Database object created")
        GetRecords(db)
    }
 
    // defer the close till after the main function has
    // finished executing
    defer db.Close()
}
	
```

- insert record 

```
func InsertRecord(db *sql.DB, ID string, Details string) {
    // use parameterized SQL statement
    result, err := db.Exec(
      "INSERT INTO Course VALUES (?, ?)", ID, Details)
    if err != nil {
        fmt.Println(err.Error())
    } else {
        if count, err := result.RowsAffected(); err == nil {
            fmt.Println(count, "row(s) affected")
        }
    }
}
```

- modify record 

```
func EditRecord(db *sql.DB, ID string, Details string) {
    result, err := db.Exec(
        "UPDATE Course SET Details=? WHERE ID=?",
        Details, ID)
    if err != nil {
        fmt.Println(err.Error())
    } else {
        if count, err := result.RowsAffected();
            err == nil {
            fmt.Println(count, "row(s) affected")
        }
    }
}
```

# The part of tens 
- Tem useful go packages to create applications 

color 
```
package main
 
import "github.com/fatih/color"
 
func main() {
    color.Red("Error Message")
    color.Green("Retro…")
    color.Blue("Color is cool!")
    customBg :=
        color.New(color.FgBlue).Add(
            color.BgWhite).Add(color.Italic)
    customBg.Println("How does this look like?")
}
```


now 
```
package main
 
import (
    "fmt"
    "time"
 
    "github.com/jinzhu/now"
)
 
func main() {
    fmt.Println(time.Now().Date())
    // 2020 December 8
 
    fmt.Println(now.Monday().Date())
    // 2020 December 7
 
    fmt.Println(now.BeginningOfWeek().Date())
    // 2020 December 6
 
    fmt.Println(now.EndOfWeek().Date())
    // 2020 December 12
 
    t, err := now.Parse("2020-12-13")
    if err == nil {
        fmt.Println(t)
        // 2020-12-13 00:00:00 +0800 +08
    }
}
```

go-pushbullet, android push notification  

goid, generate uuid 

json2go 

gojq, decode json string using unmarshal function 

turtle, make your go program resonate with kids 

go-http-client 

notify 

gosx-notifier, for mac users, create a notification on your macos desktop 


# Ten go resource 
- A Tour of Go (https://tour.golang.org/) is an interactive tutorial where you can learn, read

- Go by Example (https://gobyexample.com) is a hands-on introduction to Go programming.

- A Tour of Go (https://tour.golang.org/) is an interactive tutorial where you can learn, read, and write Go code directly

- Google using Go internally? The Golang FAQ (https://golang.org/doc/faq) is maintained by the Go team

- Go Bootcamp (http://www.golangbootcamp.com/book/) is a companion book to the Go Bootcamp event organized for the first time in Santa Monica

- Effective Go (https://golang.org/doc/effective_go.html) provides tips for writing clear, idiomatic Go code.

- Gophercises (https://gophercises.com) is a free course composed of mini-exercises to help Go developers practice writing Go programs

- Tutorialspoint is a website dedicated to providing online education in a variety of fields. 

- get answers to your questions on Go (https://stackoverflow.com/questions/tagged/go). 
















