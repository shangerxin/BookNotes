Professional C++, 4th Edition=Marc Gregoire;Note=Erxin

# Introduction
- recommend websites 

www.cppreference.com

www.cplusplus.com/reference/

- how to create a project with visual studio 

    + Visual C++ 2017 does not yet automatically enable C++17 features.
    
    right-click project and click Properties. go to Configuration Properties -> C/C++ -> Language and set the C++ Language Standard option to "ISO C++ 17 Standard" or "ISO C++ Latest Draft Standard"
    
    we can also change the C level standard too
    
    + enable or disable the precompile header base on your code base. Use it as much as possible 
    
    Project | Properties | C/C++ Precompiled Headers | "Not using precompiled headers"
    
- GCC, create your source files with any text editors and same them to a directory, open a terminal and run command 

$ gcc -lstdc++ -std=c++17 -o <executable_name> <source1.cpp> [source2.cpp …]

- source code used in this book is available for download at www.wiley.com/go/proc++4e.

- book list available at http://www.wrox.com/misc-pages/booklist.shtml.

- common preprocessor directives 

```
#include <file>

#define <key> [value]

#ifdef <key>

#endif 

# pragma <xyz>      //xyz is compiler dependent, often allows the programmer to display a warning or error 
```

avoid multiple include 
```
#ifndef MYHEADER_H
#define MYHEADER_H
// … the contents of this header file
#endif
```

equal to 
```
#pragma once
// … the contents of this header file
```

- the main() function 
```
int main(int argc, char* argv[])
```

- quoted string text 

\n 	new line
\r 	carriage return
\t 	tab
\\ 	backslash character
\" 	quotation mark 

    + i/o streams 

std::cout << "There are " << 219 << " ways I love you." << std::endl;

- namespaces 

namespace mycode {
    void foo();
}

```
#include "namespaces.h"

using namespace mycode;

int main()
{
    foo();  // Implies mycode::foo();
    return 0;
}
```

    + cpp17, nested namespace 
    
namespace MyLibraries {
    namespace Networking {
        namespace FTP {
            /* … */
        }
    }
}

to 

namespace MyLibraries::Networking::FTP {
    /* … */
}

- literals 

Decimal literal, 123
Octal literal, 0173
Hexadecimal literal, 0x7B
Binary literal, 0b1111011

A floating-point value (such as 3.14f)
A double floating-point value (such as 3.14)
A single character (such as 'a')
A zero-terminated array of characters (such as "character array")

A digits separator is a single quote character. For example,
23'456'789
0.123'456f

    + cpp17, hexadecimal floating point literals 
    
0x3.ABCp-10, 0Xb.cp12l.

- variables 
int uninitializedInt;
int initializedInt = 7;
cout << uninitializedInt << " is a random value" << endl;
cout << initializedInt << " was assigned an initial value" << endl;

    + cpp 17 std byte, before we have to use char, or unsigned char 
std::byte 

- operators 

```
=
!
+ 
- 
* 
/
% //mod
++ 
--
+=
-=
*=
/=
%=
|
|=
<<
>>
<<=
>>=
^ //exclusive or 
^=
```

- types 

enum PieceType { PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn };

    + strongly typed enumerations 
    
enum class PieceType
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};

enum class, the enumeration value names are not automatically exported to the enclosing scope

        * change default type 
enum class PieceType : unsigned long
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};

- structs 

struct Employee {
    char firstInitial;
    char lastInitial;
    int  employeeNumber;
    int  salary;
};

- conditional statements 

if (i > 4) {
    // Do something.
} else if (i > 2) {
    // Do something else.
} else {
    // Do something else.
}

    + cpp 17, initializers for if statements 
    
if (Employee employee = GetEmployee() ; employee.salary > 1000) { … }

- switch 

switch (menuItem) {
    case OpenMenuItem:
        // Code to open a file
        break;
    case SaveMenuItem:
        // Code to save a file
        break;
    default:
        // Code to give an error message
        break;
}

    + cpp 17, tell the compiler that a fallthrough is intentional using the [[fallthrough]] attribute

switch (backgroundColor) {
    case Color::DarkBlue:
        doSomethingForDarkBlue();
        [[fallthrough]];
    case Color::Black:
        // Code is executed for both a dark blue or black background color
        doSomethingForBlackOrDarkBlue();
        break;
    case Color::Red:
    case Color::Green:
        // Code to execute for a red or green background color
        break;
}

    + initializer for switch 
    
switch (<initializer> ; <expression>) { <body> }

- conditional operators 

std::cout << ((i > 2) ? "yes" : "no");

- logical evaluation operators 
< 
<=
>
>=
==
!=
&&
||

- functions 

void myFunction(int i, char c)
{
    std::cout << "the value of i is " << i << std::endl;
    std::cout << "the value of c is " << c << std::endl;
}

    + return type deduction 

auto addNumbers(int number1, int number2)
{
    return number1 + number2;
}

    + current function name 
    
int addNumbers(int number1, int number2)
{
    std::cout << "Entering function " << __func__ << std::endl;
    return number1 + number2;
}

- c-style array 

int myArray[3];
myArray[0] = 0;
myArray[1] = 0;
myArray[2] = 0;

    + initializer 
    
int myArray[3] = {0};
int myArray[] = {1, 2, 3, 4};

    + cpp17 array size 
    
unsigned int arraySize = std::size(myArray);

equal to 

unsigned int arraySize = sizeof(myArray) / sizeof(myArray[0]);

    + std::array 
    
fixed-size container called std::array, defined in the <array> header file. 
array<int, 3> arr = {9, 8, 7};

- std::vector 

// Create a vector of integers
vector<int> myVector = { 11, 22 };

// Add some more integers to the vector using push_back()
myVector.push_back(33);
myVector.push_back(44);

// Access elements
cout << "1st element: " << myVector[0] << endl;

    + cpp 17 structured bindings, Structured bindings allow you to declare multiple variables that are initialized with elements from an array
    
std::array<int, 3> values = { 11, 22, 33 };

auto [x, y, z] = values; 

struct Point { double mX, mY, mZ; };
Point point;
point.mX = 1.0; point.mY = 2.0; point.mZ = 3.0;
auto [x, y, z] = point;

- loops 
    + while 
    
int i = 0;
while (i < 5) {
    std::cout << "This is silly." << std::endl;
    ++i;
}

    + do while 
    
int i = 100;
do {
    std::cout << "This is silly." << std::endl;
    ++i;
} while (i < 5);

    + for loop 
    
for (int i = 0; i < 5; ++i) {
    std::cout << "This is silly." << std::endl;
}

    + range based for loop 
    
std::array<int, 4> arr = {1, 2, 3, 4};
for (int i : arr) {
    std::cout << i << std::endl;
}

- initializer lists 

#include <initializer_list>

using namespace std;

int makeSum(initializer_list<int> lst)
{
    int total = 0;
    for (int value : lst) {
        total += value;
    }
    return total;
}

int a = makeSum({1,2,3});
int b = makeSum({10,20,30,40,50,60});

- strings in C++ 

string myString = "Hello, World";
cout << "The value of myString is " << myString << endl;
cout << "The second letter is " << myString[1] << endl;

- stack and heaps 

- pointers 

int* myIntegerPointer;

Employee* anEmployee = getEmployee();
cout << (*anEmployee).salary << endl;

- dynamically allocated arrays 

int arraySize = 8;
int* myVariableSizedArray = new int[arraySize];

delete[] myVariableSizedArray;
myVariableSizedArray = nullptr;

Avoid using malloc() and free() from C. Instead, use new and delete, or new[] and delete[].

- null pointer constant 

NULL 

nullptr 

- smart pointers 

std::unique_ptr 

std::shared_ptr 

auto anEmployee = make_unique<Employee>();

    + make_unique() has been available since C++14. If your compiler is not yet C++14 compliant, you can make your unique_ptr as follows
    
unique_ptr<Employee> anEmployee(new Employee);

    + cpp17 
    
auto employees = make_unique<Employee[]>(10);
cout << "Salary: " << employees[0].salary << endl;

    + To create a shared_ptr, you should use std::make_shared<>()
    
auto anEmployee = make_shared<Employee>();
if (anEmployee) {
    cout << "Salary: " << anEmployee->salary << endl;
}

    + cpp17 support store an array in a shared_ptr
    
shared_ptr<Employee[]> employees(new Employee[10]);
cout << "Salary: " << employees[0].salary << endl;

shared_ptr<Employee[]> employees(new Employee[10]);
cout << "Salary: " << employees[0].salary << endl;

- auto_ptr, forget it; it was deprecated in C++11/14

- const constants 

const int versionNumberMajor = 2;
const int versionNumberMinor = 1;
const std::string productName = "Super Hyper Net Modulator";

- reference 

int x = 42;
int& xReference = x;

    + pass by reference 
    
void addOne(int& i)
{
    i++;  // Actually changes the original variable
}

    + pass by const reference, This prevents unnecessary copying. 
    
void printString(const std::string& myString)
{
    std::cout << myString << std::endl;
}

- Exceptions come with some new terminology. 

try {
    cout << divideNumbers(2.5, 0.5) << endl;
    cout << divideNumbers(2.3, 0) << endl;
    cout << divideNumbers(4.5, 2.5) << endl;
} catch (const invalid_argument& exception) {
    cout << "Exception caught: " << exception.what() << endl;
}

uses the built-in std::invalid_argument type, but it is preferable to write your own exception types

- type inference, auto and decltype 

    + auto keyword has a number of completely different uses:
    
Deducing a function’s return type, as explained earlier in this chapter.
Structured bindings, as explained earlier in this chapter.
Deducing the type of an expression, as discussed later in this section.
Deducing the type of non-type template parameters, see Chapter 12.
decltype(auto), see Chapter 12.
Alternative function syntax, see Chapter 12.
Generic lambda expressions, see Chapter 18.


const auto& f2 = foo();

    + decltype, takes an expression as argument and computes the type 
    
int x = 123;
decltype(x) y = 456;

decltype(foo()) f2 = foo();

- defining classes 

#include <string>

class AirlineTicket
{
    public:
        AirlineTicket();
        ~AirlineTicket();

        double calculatePriceInDollars() const;

        const std::string& getPassengerName() const;
        void setPassengerName(const std::string& name);

        int getNumberOfMiles() const;
        void setNumberOfMiles(int miles);

        bool hasEliteSuperRewardsStatus() const;
        void setHasEliteSuperRewardsStatus(bool status);
    private:
        std::string mPassengerName;
        int mNumberOfMiles;
        bool mHasEliteSuperRewardsStatus;
};

- using classes 

AirlineTicket myTicket;  // Stack-based AirlineTicket
myTicket.setPassengerName("Sherman T. Socketwrench");
myTicket.setNumberOfMiles(700);
double cost = myTicket.calculatePriceInDollars();
cout << "This ticket will cost $" << cost << endl;

// Heap-based AirlineTicket with smart pointer
auto myTicket2 = make_unique<AirlineTicket>();
myTicket2->setPassengerName("Laudimore M. Hallidue");
myTicket2->setNumberOfMiles(2000);
myTicket2->setHasEliteSuperRewardsStatus(true);
double cost2 = myTicket2->calculatePriceInDollars();
cout << "This other ticket will cost $" << cost2 << endl;
// No need to delete myTicket2, happens automatically

// Heap-based AirlineTicket without smart pointer (not recommended)
AirlineTicket* myTicket3 = new AirlineTicket();
// … Use ticket 3
delete myTicket3;  // delete the heap object!

- uniform initialization 

CircleStruct myCircle1 = {10, 10, 2.5};
CircleClass myCircle2(10, 10, 2.5);

- direct list initialization versus copy list initialization 

Copy list initialization. T obj = {arg1, arg2, …};
Direct list initialization. T obj {arg1, arg2, …};

- the standard library 

std::string, std::array, std::vector, std::unique_ptr, and std::shared_ptr



# Working with strings and string views 
- dynamic strings 

cout << "hello" << endl;

- the c++ std::string class 

string A("12");
string B("34");
string C;
C = A + B;    // C is "1234"

char* a = "12";
char b[] = "12";

if (strcmp(a, b) == 0){
}


string myString = "hello";
myString += ", there";
string myOtherString = myString;
if (myString == myOtherString) {
    myOtherString[0] = 'H';
}
cout << myString << endl;
cout << myOtherString << endl;

use the c_str() method on a string to get a const character pointer, representing a C-style string

   + cpp17 data() returns a char* when called on a non-const string.
   
auto string1 = "Hello World";    // string1 is a const char*
auto string2 = "Hello World"s;   // string2 is an std::string

- high level numeric conversions 

    string to_string(int val);
    string to_string(unsigned val);
    string to_string(long val);
    string to_string(unsigned long val);
    string to_string(long long val);
    string to_string(unsigned long long val);
    string to_string(float val);
    string to_string(double val);
    string to_string(long double val);
    

    int stoi(const string& str, size_t *idx=0, int base=10);
    long stol(const string& str, size_t *idx=0, int base=10);
    unsigned long stoul(const string& str, size_t *idx=0, int base=10);
    long long stoll(const string& str, size_t *idx=0, int base=10);
    unsigned long long stoull(const string& str, size_t *idx=0, int base=10);
    float stof(const string& str, size_t *idx=0);
    double stod(const string& str, size_t *idx=0);
    long double stold(const string& str, size_t *idx=0);

- C++17, all those problems are solved with the introduction of the std::string_view class, which is an instantiation of the std::basic_string_view class template, string_view a read-only string. 

    + string_view can not combined with string directly 
    
auto result = str + sv.data();

here is also a string_view constructor that accepts any raw buffer and a length. This can be used to construct a string_view out of a string buffer 

auto sv = "My string_view"sv;  //string_view literals 

- nonstandard strings 

CString class in the Microsoft MFC.



# Coding with style 
- prefix comment in file 

every file include the following:

    The last-modified date*
    The original author*
    A change-log (as described earlier)*
    The feature ID addressed by the file
    Copyright information
    A brief description of the file/class
    Incomplete features
    Known bugs

- a free tool called Doxygen (available at www.doxygen.org) parses comments to automatically build HTML documentation

- hoc comments 

Avoid offensive or derogatory language.

Liberal use of inside jokes is generally considered okay. 

Don’t put your initials in the code. 

- Decomposition is the practice of breaking up code into smaller pieces. decomposition through refactoring 

encapsulate field 

generalize type 

extract method 

extract class 

move method or move field 

pull up 

push down 


# Designing professional c++ program 
- design for c++ 

C++ has an immense feature set. It is almost a complete superset of the C language, plus classes and objects, operator overloading, exceptions, templates, and many other features. 

C++ is an object-oriented language.

C++ provides a useful Standard Library

- reuse design 

- big-o notation 

- opensource library 

few open-source portals where you can start your search, including the following:

    www.boost.org
    www.gnu.org
    github.com/open-source
    www.sourceforge.net
    
- chess game subsystems visualized as a UML use-case diagram 

ChessBoardView 

GamePlay 

Player 

ChessPieceView 

ChessBoard 

ChessPiece 

ErrorLogger 

- choosing thread model 



# Design with objects 
- object 
behavior 
property 

- mixins 

- abstraction 

- multi inheritance 

- utility class or library 

- component iterface 



# Design for reuse 
- provide document and comments 
- design general purpose interfaces 
- provide mutiple ways to perform the same functionality 
- solid principle 

single responsibility 

open/close 

liskov substitution principle 

interface segregation principle 

dependency inversion 


# C++ coding the professional way 
- memory management 
- allocation and deallocation 

int* ptr = new int;
delete ptr;
ptr = nullptr;

- array of objects 

Simple* mySimpleArray = new Simple[4];
// Use mySimpleArray …
delete [] mySimpleArray;
mySimpleArray = nullptr;

- leak 

void notLeaky()
{
    auto mySimpleSmartPtr = make_unique<Simple>();
    mySimpleSmartPtr->go();
}

auto mySimpleSmartPtr = make_unique<Simple>();
processData(mySimpleSmartPtr.get());

mySimpleSmartPtr.reset();             // Free resource and set to nullptr
mySimpleSmartPtr.reset(new Simple()); // Free resource and set to a new
                                   // Simple instance


- move 

class Foo
{
    public:
        Foo(unique_ptr<int> data) : mData(move(data)) { }
    private:
        unique_ptr<int> mData;
};

auto myIntSmartPtr = make_unique<int>(42);
Foo f(move(myIntSmartPtr));

- custom deleters 

By default, unique_ptr uses the standard new and delete operators to allocate and deallocate memory. You can change this behavior as follows: 

int* malloc_int(int value)
{
    int* p = (int*)malloc(sizeof(int));
    *p = value;
    return p;
}

int main()
{
    unique_ptr<int, decltype(free)*> myIntSmartPtr(malloc_int(42), free);
    return 0;
}

- shared_ptr 

uses a shared_ptr to store a file pointer. When the shared_ptr is reset (in this case when it goes out of scope), the file pointer is automatically closed with a call to CloseFile().

void CloseFile(FILE* filePtr)
{
    if (filePtr == nullptr)
        return;
    fclose(filePtr);
    cout << "File closed." << endl;
}
int main()
{
    FILE* f = fopen("data.txt", "w");
    shared_ptr<FILE> filePtr(f, CloseFile);
    if (filePtr == nullptr) {
        cerr << "Error opening file." << endl;
    } else {
        cout << "File opened." << endl;
        // Use filePtr
    }
    return 0;
}

- cast shared_ptrs are const_pointer_cast(), dynamic_pointer_cast(), and static_pointer_cast(). C++17 adds reinterpret_pointer_cast() to this list. T

- prevent double delete 

void noDoubleDelete()
{
    auto smartPtr1 = make_shared<Simple>();
    shared_ptr<Simple> smartPtr2(smartPtr1);
}

void doubleDelete()
{
    Simple* mySimple = new Simple();
    shared_ptr<Simple> smartPtr1(mySimple);
    shared_ptr<Simple> smartPtr2(mySimple); // double delete 
}

- aliasing 

A shared_ptr support so-called aliasing. This allows a shared_ptr to share ownership over a pointer (owned pointer) with another shared_ptr, but pointing to a different object (stored pointer). it be used to have a shared_ptr pointing to a member of an object while owning the object itself. Here’s an example:

```
class Foo
{
    public:
        Foo(int value) : mData(value) { }
        int mData;
};

auto foo = make_shared<Foo>(42);
auto aliasing = shared_ptr<int>(foo, &foo->mData);
```

- weak_ptr 

C++ that is related to shared_ptr, called weak_ptr. A weak_ptr can contain a reference to a resource managed by a shared_ptr. The weak_ptr does not own the resource

two ways to convert back to shared_ptr 
    + Use the lock() method on a weak_ptr instance, which returns a shared_ptr. The returned shared_ptr is nullptr if the shared_ptr associated with the weak_ptr has been deallocated in the meantime.
    
    + create a new shared_ptr instance and give a weak_ptr as argument to the shared_ptr constructor. This throws an std::bad_weak_ptr exception if the shared_ptr associated with the weak_ptr has been deallocated
    
    + example 
    
```
void useResource(weak_ptr<Simple>& weakSimple)
{
    auto resource = weakSimple.lock();
    if (resource) {
        cout << "Resource still alive." << endl;
    } else {
        cout << "Resource has been freed!" << endl;
    }
}

int main()
{
    auto sharedSimple = make_shared<Simple>();
    weak_ptr<Simple> weakSimple(sharedSimple);

    // Try to use the weak_ptr.
    useResource(weakSimple);

    // Reset the shared_ptr.
    // Since there is only 1 shared_ptr to the Simple resource, this will
    // free the resource, even though there is still a weak_ptr alive.
    sharedSimple.reset();

    // Try to use the weak_ptr a second time.
    useResource(weakSimple);

    return 0;
}
```

    + cpp17 weak_ptr also supports C-style arrays, just as shared_ptr supports C-style arrays since C++17.


- move semantics 

unique_ptr<Simple> create()
{
    auto ptr = make_unique<Simple>();
    // Do something with ptr…
    return ptr;
}

int main()
{
    unique_ptr<Simple> mySmartPtr1 = create();
    auto mySmartPtr2 = create();
    return 0;
}

- enable_shared_from_this 

The std::enable_shared_from_this mixin class allows a method on an object to safely return a shared_ptr or weak_ptr to itself.

shared_from_this(): returns a shared_ptr that shares ownership of the object.

weak_from_this(): returns a weak_ptr that tracks ownership of the object.

```
class Foo : public enable_shared_from_this<Foo>
{
    public:
        shared_ptr<Foo> getPointer() {
            return shared_from_this();
        }
};

int main()
{
    auto ptr1 = make_shared<Foo>();
    auto ptr2 = ptr1->getPointer();
}
```

- common memory pitfalls 
    + auto_ptr has some serious shortcomings. One of these shortcomings is that it does not work correctly when used inside Standard Library containers such as vectors. C++11 and C++14 officially deprecated auto_ptr
    
    cpp 17 complete removed it 
    
    + underallocating strings 
    
char buffer[1024] = {0};   // Allocate a whole bunch of memory.
while (true) {
    char* nextChunk = getMoreData();
    if (nextChunk == nullptr) {
        break;
    } else {
        strcat(buffer, nextChunk); // BUG! No guarantees against buffer overrun!
        delete [] nextChunk;
    }
}

- pointers can exist both on stack and on the heap 

int** handle = nullptr;
handle = new int*;
*handle = new int;

- The program exits when new fails because new throws an exception if there is not enough memory available for the request.

an alternative version of new, which will not throw an exception. 

```
int* ptr = new(nothrow) int;
```

    + array of objects, will be a pointer at stack and point to the elements on the heap 
    
    Simple* mySimpleArray = new Simple[4];
    // Use mySimpleArray …
    delete [] mySimpleArray;
    mySimpleArray = nullptr;

    + multi dimensional array 
    
    char board[3][3] = {};
    // Test code
    board[0][0] = 'X';   // X puts marker in position (0,0).
    board[2][1] = 'O';   // O puts marker in position (2,1).

    + multi dimensional heap array 
    
    char** allocateCharacterBoard(size_t xDimension, size_t yDimension)
    {
        char** myArray = new char*[xDimension]; // Allocate first dimension
        for (size_t i = 0; i < xDimension; i++) {
            myArray[i] = new char[yDimension];  // Allocate ith subarray
        }
        return myArray;
    }

    void releaseCharacterBoard(char** myArray, size_t xDimension)
    {
        for (size_t i = 0; i < xDimension; i++) {
            delete [] myArray[i];    // Delete ith subarray
        }
        delete [] myArray;           // Delete first dimension
    }

such as std::array, vector<vector<T>> for a two-dimensional dynamic array, and so on

you should consider writing (or reusing of course) a Matrix<T> or Table<T> class template which internally might use a vector<vector<T>>

- working with pointers 
    + pointer is created on the stack and safe the address to a heap etc. 

    + casting pointers 
    
    Document* documentPtr = getDocument();
    char* myCharPtr = (char*)documentPtr;

    Document* documentPtr = getDocument();
    char* myCharPtr = static_cast<char*>(documentPtr);   // BUG! Won't compile

    + arrays are pointers 
    
    int myIntArray[10] = {};
    int* myIntPtr = myIntArray;
    // Access the array through the pointer.
    myIntPtr[4] = 5;

- pointer arithmetic 

const wchar_t* myString = L"Hello, World";

wchar_t* toCaps(const wchar_t* inString);

- garbage collection 

Register all pointers with the garbage collector

Register all pointers with the garbage collector

Protect concurrent access to objects by making sure that no changes to pointers can occur while the garbage collector is running

I highly recommend you to research existing specialized garbage-collection libraries 

- Object pools are the equivalent of recycling. You buy a reasonable number of plates, and after using a plate, you clean it so that it can be reused later

- smart pointers 

Before C++17, you had to use make_unique() not only because you have to specify the type only once, but also because of safety reasons! 

unique_ptr<Simple> mySimpleSmartPtr(new Simple());

foo(make_unique<Simple>(), make_unique<Bar>(data()))

    + using unique pointer 
    
mySimpleSmartPtr->go();

(*mySimpleSmartPtr).go();

        * The get() method can be used to get direct access to the underlying pointer. 

auto mySimpleSmartPtr = make_unique<Simple>();
processData(mySimpleSmartPtr.get());

        *  optionally change it to another pointer using reset(). 

mySimpleSmartPtr.reset();             // Free resource and set to nullptr
mySimpleSmartPtr.reset(new Simple()); // Free resource and set to a new
                                   // Simple instance

        * release resource 
        
Simple* simple = mySimpleSmartPtr.release(); // Release ownership
// Use the simple pointer…
delete simple;
simple = nullptr;

        * a unique_ptr represents unique ownership, it cannot be copied! Using the std::move() utility
        
```
class Foo
{
    public:
        Foo(unique_ptr<int> data) : mData(move(data)) { }
    private:
        unique_ptr<int> mData;
};

auto myIntSmartPtr = make_unique<int>(42);
Foo f(move(myIntSmartPtr));
```       

        * unique_ptr and C-Style Arrays

auto myVariableSizedArray = make_unique<int[]>(10);

        * custom deleter 
        
By default, unique_ptr uses the standard new and delete operators to allocate and deallocate memory. You can change this behavior as follows: 

int* malloc_int(int value)
{
    int* p = (int*)malloc(sizeof(int));
    *p = value;
    return p;
}

int main()
{
    unique_ptr<int, decltype(free)*> myIntSmartPtr(malloc_int(42), free);
    return 0;
}

it can be used to automatically close a file or network socket or anything when the unique_ptr goes out of scope.

- shared_ptr

auto mySimpleSmartPtr = make_shared<Simple>();

- memory leak

Microsoft Visual C++*, its debug library has built-in support for memory leak detection.

```
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>
```

redefine the new operator 
```
#ifdef _DEBUG
    #ifndef DBG_NEW
        #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
        #define new DBG_NEW
    #endif
#endif  // _DEBUG
```

add line to the main() function 
```
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
```

instruct the debugger to break on the 147th allocation:
```
_CrtSetBreakAlloc(147);
```

- finding and fixing memory leaks in linux with Valgrind 

Valgrind finds the same two memory leaks—the first Simple object never deleted and the heap-based integer that it creates:

- double deleting and invalid pointers 

Many memory leak-detection programs, such as Microsoft Visual C++ and Valgrind, are capable of detecting double deletion and use of released objects.



# Gaining proficiency with classes and objects 
- access control 

class SpreadsheetCell
{
        void setValue(double inValue); // now has private access
    public:
        double getValue() const;
    private:
        double mValue;
};

    + repeat access list 
    
class SpreadsheetCell
{
    public:
        void setValue(double inValue);
    private:
        double mValue;
    public:
        double getValue() const;
};

- in class initializers

class SpreadsheetCell
{
    // Remainder of the class definition omitted for brevity
private:
    double mValue = 0;
};

- define methods 
```
#include "SpreadsheetCell.h"

void SpreadsheetCell::setValue(double inValue)
{
    mValue = inValue;
}

double SpreadsheetCell::getValue() const
{
    return mValue;
}
```

- calling other methods 
```
#include <string>
#include <string_view>
class SpreadsheetCell
{
    public:
        void setValue(double inValue);
        double getValue() const;

        void setString(std::string_view inString);
        std::string getString() const;
    private:
        std::string doubleToString(double inValue) const;
        double stringToDouble(std::string_view inString) const;
        double mValue;
};

```

C++17 compliant, you can replace std::string_view with const std::string&.

- this pointer 

void SpreadsheetCell::setValue(double value)
{
    value = value; // Ambiguous!
}

void SpreadsheetCell::setValue(double value)
{
    this->value = value;
}

- using objects 
    + object on the stack 
    
SpreadsheetCell myCell, anotherCell;
myCell.setValue(6);
anotherCell.setString("3.2");
cout << "cell 1: " << myCell.getValue() << endl;
cout << "cell 2: " << anotherCell.getValue() << endl;

    + object on the heap 
SpreadsheetCell* myCellp = new SpreadsheetCell();
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
        " " << myCellp->getString() << endl;
delete myCellp;
myCellp = nullptr;

    + smart pointers 
auto myCellp = make_unique<SpreadsheetCell>();
// Equivalent to:
// unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
        " " << myCellp->getString() << endl;
        
- default constructor, C++ fails to provide any syntax to tell the array creation code directly to call a different constructor. 

class SpreadsheetCell
{
    public:
        SpreadsheetCell();
        // Remainder of the class definition omitted for brevity
};

    + explicitly defaulted constructors 
    
class SpreadsheetCell
{
    public:
        SpreadsheetCell() = default;
        SpreadsheetCell(double initialValue);
        SpreadsheetCell(std::string_view initialValue);
        // Remainder of the class definition omitted for brevity
};

    + explicitly deleted contructors 
    
class MyClass
{
    public:
        MyClass() = delete;
};

    + constructor initializers 
    
SpreadsheetCell::SpreadsheetCell(double initialValue)
    : mValue(initialValue)
{
}

- copy constructor 
    
class SpreadsheetCell
{
    public:
        SpreadsheetCell(const SpreadsheetCell& src);
        // Remainder of the class definition omitted for brevity
};


explicitly call the copy constructor 

SpreadsheetCell myCell1(4);
SpreadsheetCell myCell2(myCell1); // myCell2 has the same values as myCell1

- initializer list contructors 

class EvenSequence
{
    public:
        EvenSequence(initializer_list<double> args)
        {
            if (args.size() % 2 != 0) {
                throw invalid_argument("initializer_list should "
                    "contain even number of elements.");
            }
            mSequence.reserve(args.size());
            for (const auto& value : args) {
                mSequence.push_back(value);
            }
        }

        void dump() const
        {
            for (const auto& value : mSequence) {
                cout << value << ", ";
            }
            cout << endl;
        }
    private:
        vector<double> mSequence;
};

EvenSequence p1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
p1.dump();

- delegating constructors 

SpreadsheetCell::SpreadsheetCell(string_view initialValue)
    : SpreadsheetCell(stringToDouble(initialValue))
{
}

- assign objects 

SpreadsheetCell myCell(5), anotherCell;
anotherCell = myCell;

class SpreadsheetCell
{
    public:
        SpreadsheetCell& operator=(const SpreadsheetCell& rhs);
        // Remainder of the class definition omitted for brevity
};


all assignment operators return *this, and the self-assignment case is no exception:

- explicitly defaulted and deleted assignment operator 

SpreadsheetCell& operator=(const SpreadsheetCell& rhs) = default;

- cpp11 has deprecated the compiler generation copy constructor. still can explicitly define 

MyClass(const MyClass& src) = default;

MyClass& operator=(const MyClass& rhs) = default;

- distinguishing copying from assignment 

    + copy 
SpreadsheetCell myCell(5);
SpreadsheetCell anotherCell(myCell);
SpreadsheetCell aThirdCell = myCell;
    
    + assignment 
anotherCell = myCell; // Calls operator= for anotherCell

- objects as return values 

string SpreadsheetCell::getString() const
{
    return doubleToString(mValue);
}

SpreadsheetCell myCell3(5);
string s2 = myCell3.getString();

When getString() returns the string, the compiler actually creates an unnamed temporary string object by calling a string copy constructor. When you assign this result to s1, the assignment operator is called for s1 with the temporary string as a parameter. Then, the temporary string object is destroyed. 

- copy constructors and object members 

SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src)
{
    mValue = src.mValue;
}

mValue is initialized using copy constructor 

SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src)
    : mValue(src.mValue)
{
}


# Mastering classes and objects 
- friends 

class Foo
{
    friend class Bar;
    // …
}; 

class Foo
{
    friend void Bar::processFoo(const Foo& foo);
    // …
     friend void dumpFoo(const Foo& foo);
}; 

void dumpFoo(const Foo& foo)
{
    // Dump all data of foo to the console, including
    // private and protected data members.
}

- implement destructor 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height);
        ~Spreadsheet();
        // Code omitted for brevity
};

Spreadsheet::~Spreadsheet()
{
    for (size_t i = 0; i < mWidth; i++) {
        delete [] mCells[i];
    }
    delete [] mCells;
    mCells = nullptr;
}

- handling moving with move semantics 

// lvalue reference parameter
void handleMessage(std::string& message)
{
    cout << "handleMessage with lvalue reference: " << message << endl;
}

// rvalue reference parameter
void handleMessage(std::string&& message)
{
    cout << "handleMessage with rvalue reference: " << message << endl;
}

std::string a = "Hello ";
std::string b = "World";
handleMessage(a);             // Calls handleMessage(string& value)

handleMessage(a + b);         // Calls handleMessage(string&& value)

handleMessage("Hello World"); // Calls handleMessage(string&& value)

handleMessage(std::move(b));  // Calls handleMessage(string&& value), force compiler call move with left value 

    + nested move moving semantics should follow the same rules 
    
void helper(std::string&& message)
{
}

void handleMessage(std::string&& message)
{
    helper(message); //not compile 
}

void handleMessage(std::string&& message)
{
    helper(std::move(message));
}

- rvalue reference 

int&& i = 2;
int a = 2, b = 3;
int&& j = a + b;

- implementing move semantics 

class Spreadsheet
{
    public:
        Spreadsheet(Spreadsheet&& src) noexcept; // Move constructor
        Spreadsheet& operator=(Spreadsheet&& rhs) noexcept; // Move assign
        // Remaining code omitted for brevity
    private:
        void cleanup() noexcept;
        void moveFrom(Spreadsheet& src) noexcept;
        // Remaining code omitted for brevity
};

- This is called a memory leak. That is why in assignment operators you must do a deep copy.

- disallowing assignment and pass-by-value 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height);
        Spreadsheet(const Spreadsheet& src) = delete;
        ~Spreadsheet();
        Spreadsheet& operator=(const Spreadsheet& rhs) = delete;
        // Code omitted for brevity
}

- function will not throw any exceptioni 

void myNonThrowingFunction() noexcept { /* … */ }

- dynamic allocation arrays 

C++, unlike in Java, it’s not possible to simply write new SpreadsheetCell[mWidth][mHeight].

Spreadsheet::Spreadsheet(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells = new SpreadsheetCell*[mWidth];
    for (size_t i = 0; i < mWidth; i++) {
        mCells[i] = new SpreadsheetCell[mHeight];
    }
}

the following verifyCoordinate() method is defined for the class:

- implementing move semantics 

Move constructors and move assignment operators should be marked with the noexcept

Two helper methods are introduced as well: cleanup(), which is used from the destructor and the move assignment operator, and moveFrom()

```
class Spreadsheet
{
    public:
        Spreadsheet(Spreadsheet&& src) noexcept; // Move constructor
        Spreadsheet& operator=(Spreadsheet&& rhs) noexcept; // Move assign
        // Remaining code omitted for brevity
    private:
        void cleanup() noexcept;
        void moveFrom(Spreadsheet& src) noexcept;
        // Remaining code omitted for brevity
};
```

void Spreadsheet::cleanup() noexcept
{
    for (size_t i = 0; i < mWidth; i++) {
        delete[] mCells[i];
    }
    delete[] mCells;
    mCells = nullptr;
    mWidth = mHeight = 0;
}

void Spreadsheet::moveFrom(Spreadsheet& src) noexcept
{
    // Shallow copy of data
    mWidth = src.mWidth;
    mHeight = src.mHeight;
    mCells = src.mCells;

    // Reset the source object, because ownership has been moved!
    src.mWidth = 0;
    src.mHeight = 0;
    src.mCells = nullptr;
}

// Move constructor
Spreadsheet::Spreadsheet(Spreadsheet&& src) noexcept
{
    moveFrom(src);
}

// Move assignment operator
Spreadsheet& Spreadsheet::operator=(Spreadsheet&& rhs) noexcept
{
    // check for self-assignment
    if (this == &rhs) {
        return *this;
    }

    // free the old memory
    cleanup();

    moveFrom(rhs);

    return *this;
}

Obviously, move semantics is useful only when you know that the source object will be destroyed.

    + moving object data members 
    
    using std::move(). Suppose the Spreadsheet class has an std::string data member called mName. 

void Spreadsheet::moveFrom(Spreadsheet& src) noexcept
{
    // Move object data members
    mName = std::move(src.mName);

    // Move primitives:
    // Shallow copy of data
    mWidth = src.mWidth;
    mHeight = src.mHeight;
    mCells = src.mCells;

    // Reset the source object, because ownership has been moved!
    src.mWidth = 0;
    src.mHeight = 0;
    src.mCells = nullptr;
}

- If the compiler finds a move constructor, the objects are moved instead of copied.

A vector grows dynamically in size to accommodate new objects. This is done by allocating a bigger chunk of memory and then copying or moving the objects from the old vector to the new and bigger vector. 

```
Spreadsheet createObject()
{
    return Spreadsheet(3, 2);
}

int main()
{
    vector<Spreadsheet> vec;
    for (int i = 0; i < 2; ++i) {
        cout << "Iteration " << i << endl;
        vec.push_back(Spreadsheet(100, 100));
        cout << endl;
    }

    Spreadsheet s(2,3);
    s = createObject();

    Spreadsheet s2(5,6);
    s2 = s;
    return 0;
}
```

- implementing swap with move semantics 

   + copy 
   
void swapCopy(T& a, T& b)
{
    T temp(a);
    a = b;
    b = temp;
}

    + move 
    
void swapMove(T& a, T& b)
{
    T temp(std::move(a));
    a = std::move(b);
    b = std::move(temp);
}

- The rule of zero states that you should design your classes in such a way that they do not require any of those five special member functions.

five special member functions: destructor, copy and move constructors, and copy and move assignment operators

se modern constructs such as Standard Library containers. For example, use a vector<vector<SpreadsheetCell>> instead of the SpreadsheetCell** data member

- static methods 

class SpreadsheetCell
{
    // Omitted for brevity
    private:
        static std::string doubleToString(double inValue);
        static double stringToDouble(std::string_view inString);
        // Omitted for brevity
};

In fact, a static method is just like a regular function. The only difference is that it can access private and protected static members of the class.

- const methods 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        double getValue() const;
        std::string getString() const;
        // Omitted for brevity
};

Marking a method as const signs a contract with client code guaranteeing that you will not change the internal values of the object within the method

destructor is not allowed to be declared const 

- mutable data members, new counter variable mutable, which tells the compiler that it’s okay to change it in a const method.

class SpreadsheetCell
{
    // Omitted for brevity
    private:
        double mValue = 0;
        mutable size_t mNumAccesses = 0;
};

double SpreadsheetCell::getValue() const
{
    mNumAccesses++;
    return mValue;
}

std::string SpreadsheetCell::getString() const
{
    mNumAccesses++;
    return doubleToString(mValue);
}

- method overloading 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        void set(double inValue);
        void set(std::string_view inString);
        // Omitted for brevity
};

- overloading based on const 

const_cast() pattern. For example, the Spreadsheet class has a method called getCellAt() returning a non-const reference to a SpreadsheetCell

class Spreadsheet
{
    public:
        SpreadsheetCell& getCellAt(size_t x, size_t y);
        const SpreadsheetCell& getCellAt(size_t x, size_t y) const;
        // Code omitted for brevity.
};

const SpreadsheetCell& Spreadsheet::getCellAt(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

SpreadsheetCell& Spreadsheet::getCellAt(size_t x, size_t y)
{
    return const_cast<SpreadsheetCell&>(std::as_const(*this).getCellAt(x, y));
}
    + cpp17 
using std::as_const() (defined in <utility>), call the const version of getCellAt(), and then remove the const from the result by using a const_cast():

    + older versions 
return const_cast<SpreadsheetCell&>(static_cast<const Spreadsheet&>(*this).getCellAt(x, y));

- explicitly delete overload 

- inline method, inline methods. Inlining is safer than using #define macros.

inline double SpreadsheetCell::getValue() const
{
    mNumAccesses++;
    return mValue;
}

inline std::string SpreadsheetCell::getString() const
{
    mNumAccesses++;
    return doubleToString(mValue);
}

- Microsoft Visual C++ supports Link-Time Code Generation (LTCG), which automatically inlines small function bodies, even if they are not declared as inline and even if they are not defined in a header file. GCC and Clang have similar features. 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        double getValue() const { mNumAccesses++; return mValue; }

        std::string getString() const
        {
            mNumAccesses++;
            return doubleToString(mValue);
        }
        // Omitted for brevity
};

- default arguments 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width = 100, size_t height = 100);
        // Omitted for brevity
};

- static data members, they are initialized to 0 by default. Static pointers are initialized to nullptr.

- inline data members, Starting with C++17, you can declare your static data members as inline. The benefit of this is that you do not have to allocate space for them in a source file

- accessing static data members outside methods 

int c = Spreadsheet::sCounter;

- const static data members 

class Spreadsheet
{
    public:
        // Omitted for brevity
        static const size_t kMaxHeight = 100;
        static const size_t kMaxWidth = 100;
};

- reference data members 

class SpreadsheetApplication; // forward declaration

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height,
            SpreadsheetApplication& theApp);
        // Code omitted for brevity.
    private:
        // Code omitted for brevity.
        SpreadsheetApplication& mTheApp;
};

Spreadsheet::Spreadsheet(size_t width, size_t height,
    SpreadsheetApplication& theApp)
    : mId(sCounter++)
    , mWidth(std::min(width, kMaxWidth))
    , mHeight(std::min(height, kMaxHeight))
    , mTheApp(theApp)
{
    // Code omitted for brevity.
}

- const reference data members 

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height,
            const SpreadsheetApplication& theApp);
            // Code omitted for brevity.
    private:
            // Code omitted for brevity.
            const SpreadsheetApplication& mTheApp;
};

The const reference SpreadsheetApplication data member can only be used to call const methods on the SpreadsheetApplication object. 

- nested classes 

access it outside the class by scoping it with the ClassName:: scope resolution syntax.

class Spreadsheet
{
    public:
        class Cell
        {
            public:
                Cell() = default;
                Cell(double initialValue);
                // Omitted for brevity
        };

        Spreadsheet(size_t width, size_t height,
            const SpreadsheetApplication& theApp);
        // Remainder of Spreadsheet declarations omitted for brevity
};

Spreadsheet::Cell::Cell(double initialValue)
    : mValue(initialValue)
{
}

    + another way 
    
class Spreadsheet
{
    public:
        class Cell;

        Spreadsheet(size_t width, size_t height,
            const SpreadsheetApplication& theApp);
        // Remainder of Spreadsheet declarations omitted for brevity
};

class Spreadsheet::Cell
{
    public:
        Cell() = default;
        Cell(double initialValue);
        // Omitted for brevity
};

declare a private or protected nested class, you can only use it inside the outer class. A nested class has access to all protected and private members of the outer class. 

- enumerated types inside classes 
class SpreadsheetCell
{
    public:
        // Omitted for brevity
        enum class Color { Red = 1, Green, Blue, Yellow };
        void setColor(Color color);
        Color getColor() const;
    private:
        // Omitted for brevity
        Color mColor = Color::Red;
};

- operator overloading 

class SpreadsheetCell
{
    public:
        // Omitted for brevity
         SpreadsheetCell operator+(const SpreadsheetCell& cell) const;
        // Omitted for brevity
};

- explict convertor 
class SpreadsheetCell
{
    public:
        SpreadsheetCell() = default;
        SpreadsheetCell(double initialValue);
        explicit SpreadsheetCell(std::string_view initialValue);
    // Remainder omitted for brevity
};

- global operator+ 

class SpreadsheetCell
{
    //Omitted for brevity
};

SpreadsheetCell operator+(const SpreadsheetCell& lhs,
    const SpreadsheetCell& rhs)
{
    return SpreadsheetCell(lhs.getValue() + rhs.getValue());    
}

SpreadsheetCell operator+(const SpreadsheetCell& lhs,
    const SpreadsheetCell& rhs);

- overloading arithmetic operators 

class SpreadsheetCell
{
    // Omitted for brevity
};

SpreadsheetCell operator<op>(const SpreadsheetCell& lhs,
    const SpreadsheetCell& rhs);                     

class SpreadsheetCell
{
    public:
        // Omitted for brevity
        SpreadsheetCell& operator+=(const SpreadsheetCell& rhs);
        SpreadsheetCell& operator-=(const SpreadsheetCell& rhs);
        SpreadsheetCell& operator*=(const SpreadsheetCell& rhs);
        SpreadsheetCell& operator/=(const SpreadsheetCell& rhs);
        // Omitted for brevity
};
                
- using interface and implementation classes 

This is called the pimpl idiom, private implementation idiom, or bridge pattern. The interface class method implementations simply call the equivalent methods on the implementation class object. 

```
#include "SpreadsheetCell.h"
#include <memory>

// Forward declarations
class SpreadsheetApplication;

class Spreadsheet
{
    public:
        Spreadsheet(const SpreadsheetApplication& theApp,
            size_t width = kMaxWidth, size_t height = kMaxHeight);
        Spreadsheet(const Spreadsheet& src);
        ~Spreadsheet();

        Spreadsheet& operator=(const Spreadsheet& rhs);

        void setCellAt(size_t x, size_t y, const SpreadsheetCell& cell);
        SpreadsheetCell& getCellAt(size_t x, size_t y);

        size_t getId() const;

        static const size_t kMaxHeight = 100;
        static const size_t kMaxWidth = 100;

        friend void swap(Spreadsheet& first, Spreadsheet& second) noexcept;

    private:
        class Impl;
        std::unique_ptr<Impl> mImpl;
};                
```

With stable interface classes, build times can be reduced.
                

# Discovering inheritance techniques 
- extending classes 

class Base
{
    public:
        void someMethod();
    protected:
        int mProtectedInt;
    private:
        int mPrivateInt;
};

class Derived : public Base
{
    public:
        void someOtherMethod();
};

- preventing inheritance 

class Base final
{
    // Omitted for brevity
};

- overriding methods 

class Base
{
    public:
        virtual void someMethod();
    protected:
        int mProtectedInt;
    private:
        int mPrivateInt;
};

class Derived : public Base
{
    public:
        virtual void someMethod() override; // Overrides Base's someMethod()
        virtual void someOtherMethod();
};

Derived myDerived;
Base& ref = myDerived;
myDerived.someOtherMethod();  // This is fine.
ref.someOtherMethod();        // Error

only use the virtual keyword can  not prevent future miss updated overwrite methods 

However, because the method is not virtual, it is not actually overridden. Rather, the Derived class creates a new method, also called go(), that is completely unrelated to the Base class’s method called go().

the vtable, or “virtual table.” Each class that has one or more virtual methods, has a vtable, and every object of such a class contains a pointer to said vtable. 


class Base
{
    public:
        virtual void func1() {}
        virtual void func2() {}
        void nonVirtualFunc() {}
};

class Derived : public Base
{
    public:
        virtual void func2() override {}
        void nonVirtualFunc() {}
};

-  the class is destroyed, such as std::unique_ptrs, then those members will not get deleted either if the destructor is never called.

- preventing overriding 

class Base
{
    public:
        virtual ~Base() = default;
        virtual void someMethod() final;
};

- class construction 
If the class has a base class, the default constructor of the base class is executed, unless there is a call to a base class constructor in the ctor-initializer

Non-static data members of the class are constructed in the order in which they are declared.

The body of the class’s constructor is executed.

- class destruction 

The body of the class’s destructor is called.

Any data members of the class are destroyed in the reverse order of their construction.

The parent class, if any, is destructed.

- casting up and down 

Base myBase = myDerived;  // Slicing! 

Base& myBase = myDerived; // No slicing!

This is why it’s always a good idea to make your methods and functions take references to classes instead of directly using objects of those classes

void presumptuous(Base* base)
{
    Derived* myDerived = static_cast<Derived*>(base);    //bad
    // Proceed to access Derived methods on myDerived.
}

void lessPresumptuous(Base* base) 
{
    Derived* myDerived = dynamic_cast<Derived*>(base);
    if (myDerived != nullptr) {
        // Proceed to access Derived methods on myDerived.
    }
}

- pure virtual methods and abstract base classes 

class SpreadsheetCell
{
    public:
        virtual ~SpreadsheetCell() = default;
        virtual void set(std::string_view inString) = 0;
        virtual std::string getString() const = 0;
};

class StringSpreadsheetCell : public SpreadsheetCell
{
    public:
        virtual void set(std::string_view inString) override;
        virtual std::string getString() const override;

    private:
        std::optional<std::string> mValue;
};

- multiple inheritance 

class Baz : public Foo, public Bar 
{
    // Etc.
};

    + name colliction 
    
class DogBird : public Dog, public Bird
{
    public:
        using Dog::eat;  // Explicitly inherit Dog's version of eat()
};

    + ambiguous base class, should not do this 
    
class Dog {};
class Bird : public Dog {};
class DogBird : public Bird, public Dog {}; // Error!

- inherite constructors 

class Base
{
    public:
        virtual ~Base() = default;
        Base() = default;
        Base(std::string_view str);
};

class Derived : public Base
{
    public:
        Derived(int i);
};


//explicitly inherit the Base constructors in the Derived class as follows:
class Derived : public Base
{
    public:
        using Base::Base;
        Derived(int i);
};

- base class members may have different access levels 

- virtual base class, C++ has another mechanism, called virtual base classes, for addressing this problem if you do want the shared parent to have its own functionality.

Without the virtual keyword, a call to sleep() on a DogBird object would be ambiguous and would generate a compiler error because DogBird would have two subobjects of class Animal

```
class Animal
{
    public:
        virtual void eat() = 0;
        virtual void sleep() { cout << "zzzzz...." << endl; }
};

class Dog : public virtual Animal
{
    public:
        virtual void bark() { cout << "Woof!" << endl; }
        virtual void eat() override { cout << "The dog ate." << endl; }
};

class Bird : public virtual Animal
{
    public:
        virtual void chirp() { cout << "Chirp!" << endl; }
        virtual void eat() override { cout << "The bird ate." << endl; }
};

class DogBird : public Dog, public Bird
{
    public:
        virtual void eat() override { Dog::eat(); }
};

int main()
{
    DogBird myConfusedAnimal;
    myConfusedAnimal.sleep();  // Not ambiguous because of virtual base class
    return 0;
}
```


# C++ quirks, oddities and incidentals 
- reference to pointer 

int* intP;
int*& ptrRef = intP;
ptrRef = new int;
*ptrRef = 5;


int x = 3;
int& xRef = x;
int* xPtr = &xRef; // Address of a reference is pointer to value
*xPtr = 100;

- reference data member 

class MyClass
{
    public:
        MyClass(int& ref) : mRef(ref) {}
    private:
        int& mRef;
};

- reference parameter 

void swap(int& first, int& second)
{
    int temp = first;
    first = second;
    second = temp;
}

int x = 5, y = 6;
int *xp = &x, *yp = &y;
swap(*xp, *yp);

- rvalue reference 

handleMessage("Hello World"); // A literal is not an lvalue.

std::string a = "Hello ";
std::string b = "World";
handleMessage(a + b);         // A temporary is not an lvalue.

// rvalue reference parameter
void handleMessage(std::string&& message)
{
    cout << "handleMessage with rvalue reference: " << message << endl;
}

- The version using vectors is already much better than the versions using pointers or references, but it’s usually recommended to avoid output parameters as much as possible. 

- In order to prevent the pointed-to values from being modified (as in the third line), you can add the keyword const to the declaration of ip like this:

const int* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!

semantically equivalent way to write this is as follows:

int const* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!

const before or after the int makes no difference in its functionality.

    + mark both pointer and values to const 
    
int const* const ip = nullptr;

//equal to 

const int* const ip = nullptr;

    + const keyword applies to whatever is directly to its left. Consider this line again
    
From left to right, the first const is directly to the right of the word int. Thus, it applies to the int to which ip points. Therefore, it specifies that you cannot change the values to which ip points. The second const is directly to the right of the *. Thus, it applies to the pointer to the int, which is the ip variable. Therefore, it specifies that you cannot change ip (the pointer) itself.

int const* const ip = nullptr;

//other syntax     
const int* const ip = nullptr;
    
const int * const * const * const ip = nullptr;
    
- const reference 

C++ programmers refer to a “const reference,” they mean something like this:
    
int z;
const int& zRef = z;
zRef = 4; // DOES NOT COMPILE

const int& zRef is equivalent to int const& zRef
    
const references are used most commonly as parameters
    
- const methods 

    + const expression 
    
const int getArraySize() { return 32; }

int main()
{
    int myArray[getArraySize()];    // Invalid in C++
    return 0;
}

    + Declaring a function as constexpr imposes quite a lot of restrictions
    
    The function body shall not contain any goto statements, try catch blocks, uninitialized variables, or variable definitions that are not literal types,1 and shall not throw any exceptions.

    The return type of the function shall be a literal type.

    the function cannot be virtual.

    All the function parameters shall be literal types.
    
    dynamic_cast() and reinterpret_cast() are not allowed.
    
    new and delete expressions are not allowed.
    
    + A constexpr constructor also has a lot of restrictions. Here are some of them:
    
    The class cannot have any virtual base classes.
    
    The constructor body either shall be explicitly defaulted, or shall satisfy the same requirements as the body of a constexpr function.
    
    All data members shall be initialized with constant expressions.
    
- static keyword 

“overloading” the keyword was attempting to avoid having to introduce new keywords into the language.

static methods are similarly at the class level instead of the object level. 

A static method does not execute in the context of a specific object.

External linkage means that the name is available from other source files. Internal linkage (also called static linkage) means that it is not. By default, functions and global variables have external linkage. 

specify internal (or static) linkage by prefixing the declaration with the keyword static. 

    + example 
    
#include <iostream>

static void f();

void f()
{
    std::cout << "f\n";
}
    
    + alternative, An alternative to using static for internal linkage is to employ anonymous namespaces. Instead of marking a variable or function static, wrap it in an unnamed namespace

#include <iostream>

namespace {
    void f();

    void f()
    {
        std::cout << "f\n";
    }
}

- static variables in functions 

```
void performTask()
{
    static bool initialized = false;
    if (!initialized) {
        cout << "initializing" << endl;
        // Perform initialization.
        initialized = true;
    }
    // Perform the desired task.
}
```

- All global variables and static class data members in a program are initialized before main() begins. The variables in a given source file are initialized in the order they appear in the source file.

two different source files, you cannot count on one being constructed before the other, and you cannot control the order of initialization. 

- types and casts 

    + type aliases 
    
using StringVector = std::vector<std::string>;

void processVector(const StringVector& vec) { /* omitted */ }

int main()
{
    StringVector myVector;
    processVector(myVector);
    return 0;
}

using string = basic_string<char>;

    + types for function pointers 
    
    take the address of a function and use it like you use a variable.
    
    ```
    using MatchFunction = bool(*)(int, int);
    
    void findMatches(int values1[], int values2[], size_t numValues,
                 MatchFunction matcher)
    {
        for (size_t i = 0; i < numValues; i++) {
            if (matcher(values1[i], values2[i])) {
                cout << "Match found at position " << i <<
                    " (" << values1[i] << ", " << values2[i] << ")" << endl;
            }
        }
    }
    ```
    MatchFunction that represents a pointer to any function that has two int parameters and returns a bool:

    Suppose the following is the prototype for Connect(), which returns an integer and accepts three parameters: a Boolean, an integer, and a C-style string.
    ```
    int __stdcall Connect(bool b, int n, const char* p);
    using ConnectFunction = int(__stdcall*)(bool, int, const char*);
    
    //Loading the library at run-time is done with the Windows LoadLibrary() kernel function:
    HMODULE lib = ::LoadLibrary("hardware.dll");
    
    //get a pointer to the function 
    ConnectFunction connect = (ConnectFunction)::GetProcAddress(lib, "Connect");
    connect(true, 3, "Hello world");
    ```

    + type aliases for pointers to methods and data members 
```
Employee employee;
using PtrToGet = int (Employee::*) () const;
PtrToGet methodPtr = &Employee::getSalary;
cout << (employee.*methodPtr)() << endl;

Employee employee;
auto methodPtr = &Employee::getSalary;
cout << (employee.*methodPtr)() << endl;
```

- typedefs 

Type aliases were introduced in C++11, Before C++11, you had to use typedef

typedef int* IntPtr;

typedef int (*FunctionType)(char, double);

equal to 

using FunctionType = int (*)(char, double);

Compared to typedefs, type aliases are more powerful when used with templates

- casts 

const_cast(), static_cast(), reinterpret_cast(), and dynamic_cast().


extern void ThirdPartyLibraryMethod(char* str);

void f(const char* str)
{
    ThirdPartyLibraryMethod(const_cast<char*>(str));
}

    + C++17, there is a helper method called std::as_const(), defined in <utility>, that returns a const reference version of its reference parameter. 
    
as_const(obj) is equivalent to const_cast<const T&>(obj), where T is the type of obj. As you can see, using as_const() is shorter than using const_cast(). 

```
std::string str = "C++";
const std::string& constStr = std::as_const(str);
```

//auto strips away reference and const qualifiers
//the result variable is type std::string, not const std::string&:
auto result = std::as_const(str);

- static_cast() 

```
int i = 3;
int j = 4;
double result = static_cast<double>(i) / j;
```

static_cast() is to perform downcasts in an inheritance hierarchy, as in this example:

```
class Base
{
    public:
        virtual ~Base() = default;
};

class Derived : public Base
{
    public:
        virtual ~Derived() = default;
};

int main()
{
    Base* b;
    Derived* d = new Derived();
    b = d; // Don't need a cast to go up the inheritance hierarchy
    d = static_cast<Derived*>(b); // Need a cast to go down the hierarchy

```

using static_cast() do not perform run-time type checking. They allow you to convert any Base pointer to a Derived pointer, or Base reference to a Derived reference

- reinterpret_cast() is a bit more powerful

```
class X {};
class Y {};

int main()
{
    X x;
    Y y;
    X* xp = &x;
    Y* yp = &y;
    // Need reinterpret cast for pointer conversion from unrelated classes
    // static_cast doesn't work.
    xp = reinterpret_cast<X*>(yp);
    // No cast required for conversion from pointer to void*
    void* p = xp;
    // Need reinterpret cast for pointer conversion from void*
    xp = reinterpret_cast<X*>(p);
    // Need reinterpret cast for reference conversion from unrelated classes
    // static_cast doesn't work.
    X& xr = x;
    Y& yr = reinterpret_cast<Y&>(x);
    return 0;
}
```
One use-case for reinterpret_cast() is with binary I/O of trivially copyable types.2 For example, you can write the individual bytes of such types to a file. When you read the file back into memory, you can use reinterpret_cast() to correctly interpret the bytes read from the file.

without performing any type checking.

- dynamic_cast() provides a run-time check on casts within an inheritance hierarchy. You can use it to cast pointers or references.

dynamic_cast() returns a null pointer (for the pointer version), or throws an std::bad_cast exception (for the reference version).

```
class Base
{
    public:
        virtual ~Base() = default;
};

class Derived : public Base
{
    public:
        virtual ~Derived() = default;
};
```

correct use of dynamic_cast()
```
Base* b;
Derived* d = new Derived();
b = d;
d = dynamic_cast<Derived*>(b);
```

dynamic_cast() on a reference will cause a exception to be thrown 
```
Base base;
Derived derived;
Base& br = base;
try {
    Derived& dr = dynamic_cast<Derived&>(br);
} catch (const bad_cast&) {
    cout << "Bad cast!" << endl;
}
```

The difference with dynamic_cast() is that it performs run-time (dynamic) type checking, while static_cast() and reinterpret_cast() perform the casting even if they are erroneous.

- scope resolution 
Variables that are initialized in the initialization statement of for loops are scoped to that for loop and are not visible outside that for loop

The global scope is unnamed, but you can access it specifically by using the scope resolution operator by itself
```
class Demo
{
    public:
        static int get() { return 5; }
};

int get() { return 10; }

namespace NS
{
    int get() { return 20; }
}

int main()
{
    auto pd = std::make_unique<Demo>();
    Demo d;
    std::cout << pd->get() << std::endl;    // prints 5
    std::cout << d.get() << std::endl;      // prints 5
    std::cout << NS::get() << std::endl;    // prints 20
    std::cout << Demo::get() << std::endl;  // prints 5
    std::cout << ::get() << std::endl;      // prints 10
    std::cout << get() << std::endl;        // prints 10
    return 0;
}
```

change default scope 
``` 
using namespace NS;
```
- Attributes are a mechanism to add optional and/or vendor-specific information into source code. 

Examples are __attribute__, __declspec, and so on. Since C++11, there is standardized support for attributes by using the double square brackets syntax [[attribute]].

[[noreturn]]means that a function never returns control to the call site. 

```
[[noreturn]] void forceProgramTermination()
{
    std::exit(1);
}

[[deprecated("Unsafe method, please use xyz")]] void func();
```

[[noreturn]] attribute, the compiler generates the following warning (output from Visual C++):


Starting with C++17, you can tell the compiler that a fallthrough in a switch statement is intentional using the [[fallthrough]] attribute. 
```
switch (backgroundColor) {
    case Color::DarkBlue:
        doSomethingForDarkBlue();
        [[fallthrough]];
    case Color::Black:
        // Code is executed for both a dark blue or black background color
        doSomethingForBlackOrDarkBlue();
        break;
    case Color::Red:
    case Color::Green:
        // Code to execute for a red or green background color
        break;
}
```

The [[nodiscard]] attribute can be used on a function returning a value to let the compiler issue a warning when that function is used without doing something with the returned value. 
```
[[nodiscard]] int func()
{
    return 42;
}

int main()
{
    func();
    return 0;
}
```

The [[maybe_unused]] attribute can be used to suppress the compiler from issuing a warning when something is unused
```
int func(int param1, [[maybe_unused]] int param2)
{
    return 42;
}
```

    + vendor-specific attributes 
[[clang::noduplicate]]

different vendors could clash, vendors are recommended to qualify them

- user defined literals 

'a': character
"character array": zero-terminated array of characters, C-style string
3.14f: float floating point value
0xabc: hexadecimal value

C++ also allows you to define your own literals. User-defined literals should start with an underscore. The first character following the underscore must be a lowercase letter. Some examples are: _i, _s, _km, _miles, and so on. 

- A cooked-mode literal operator should have either of the following

one parameter of type unsigned long long, long double, char, wchar_t, char16_t, or char32_t to process numeric values

two parameters where the first is a character array and the second is the length of the character array, to process strings

use _i to define a complex number, following implements a cooked literal operator for the user-defined literal _i to define a complex number literal:
```
std::complex<long double> operator"" _i(long double d)
{
    return std::complex<long double>(0, d);
}

std::complex<long double> c1 = 9.634_i;
auto c2 = 1.23_i;       // c2 has as type std::complex<long double>
```

implements a cooked literal operator for a user-defined literal _s to define std::string literals:
```
std::string operator"" _s(const char* str, size_t len)
{
    return std::string(str, len);
}

std::string str1 = "Hello World"_s;
auto str2 = "Hello World"_s;   // str2 has as type std::string
```

- standard user-defined literals 

“s” for creating std::strings
For example: auto myString = "Hello World"s;
Requires a using namespace std::string_literals;

    + cpp17 

“sv” for creating std::string_views
For example: auto myStringView = "Hello World"sv;
Requires a using namespace std::string_view_literals;
“h”, “min”, “s”, “ms”, “us”, “ns”, for creating std::chrono::duration time intervals, discussed in Chapter 20
For example: auto myDuration = 42min;
Requires a using namespace std::chrono_literals;
“i”, “il”, “if” for creating complex numbers, complex<double>, complex<long double>, and complex<float>, respectively
For example: auto myComplexNumber = 1.3i;
Requires a using namespace std::complex_literals;

using namespace std; also makes these standard user-defined literals avail

- header files 

    + include guard 

avoided with a mechanism known as include guards. The following code snippet shows the Logger.h header
```
#ifndef LOGGER_H
#define LOGGER_H

class Logger
{
    // ...
};

#endif // LOGGER_H
```

Nearly all compilers these days support the #pragma once directive 
```
#pragma once

class Logger
{
    // ...
};
```

    + forward-declared classes 
```
#pragma once

#include <string_view>

class Preferences;  // forward declaration

class Logger
{
    public:
        static void setPreferences(const Preferences& prefs);
        static void logError(std::string_view error);
};
```

    + cpp17 adds the __has_include("filename") and __has_include(<filename>) preprocessor constants. 

#if __has_include(<optional>)
    #include <optional>
#elif __has_include(<experimental/optional>)
    #include <experimental/optional>
#endif

- variable length argument list 

arbitrary types of arguments. A simple implementation looks like this

```
#include <cstdio>
#include <cstdarg>

bool debug = false;

void debugOut(const char* str, ...)
{
    va_list ap;
    if (debug) {
        va_start(ap, str);
        vfprintf(stderr, str, ap);
        va_end(ap);
    }
}
```

you must use macros defined in <cstdarg>. You declare a variable of type va_list, and initialize it with a call to va_start. The second parameter to va_start() must be the rightmost named variable in the parameter list. All functions with variable-length argumen  lists require at least one named parameter. 

    + accessing the arguments 
    
access the actual arguments yourself, you can use va_arg() to do so. It accepts a va_list as first argument, and the type of the argument to interpret. 
```
void printInts(size_t num, ...)
{
    int temp;
    va_list ap;
    va_start(ap, num);
    for (size_t i = 0; i < num; ++i) {
        temp = va_arg(ap, int);
        cout << temp << " ";
    }
    va_end(ap);
    cout << endl;
}
```
Avoid using C-style variable-length argument lists.

- preprocessor macros 
```
#define SQUARE(x) ((x) * (x)) // No semicolon after the macro definition!

int main()
{
    cout << SQUARE(5) << endl;
    return 0;
}
```

Macros also cause problems for debugging because the code you write is not the code that the compiler sees



# Writing generic code with template 
- cdoe with template 

```
class ChessPiece : public GamePiece
{
    public:
        virtual std::unique_ptr<GamePiece> clone() const override;
};

std::unique_ptr<GamePiece> ChessPiece::clone() const
{
    // Call the copy constructor to copy this instance
    return std::make_unique<ChessPiece>(*this);
}
```

```
template <typename T>
class Grid
{
    public:
        explicit Grid(size_t width = kDefaultWidth,
            size_t height = kDefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<T>& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and assignment operator.
        Grid(Grid&& src) = default;
        Grid<T>& operator=(Grid&& rhs) = default;

        std::optional<T>& at(size_t x, size_t y);
        const std::optional<T>& at(size_t x, size_t y) const;

        size_t getHeight() const { return mHeight; }
        size_t getWidth() const { return mWidth; }

        static const size_t kDefaultWidth = 10;
        static const size_t kDefaultHeight = 10;

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::vector<std::vector<std::optional<T>>> mCells;
        size_t mWidth, mHeight;
};

template <typename T>
Grid<T>::Grid(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
    // Equivalent to:
    //for (std::vector<std::optional<T>>& column : mCells) {
        column.resize(mHeight);
    }
}

template <typename T>
void Grid<T>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= mWidth || y >= mHeight) {
        throw std::out_of_range("");
    }
}

template <typename T>
const std::optional<T>& Grid<T>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

template <typename T>
std::optional<T>& Grid<T>::at(size_t x, size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}


Grid<int> myIntGrid; // declares a grid that stores ints,
                     // using default arguments for the constructor
Grid<double> myDoubleGrid(11, 11); // declares an 11x11 Grid of doubles

myIntGrid.at(0, 0) = 10;
int x = myIntGrid.at(0, 0).value_or(0);

Grid<int> grid2(myIntGrid);  // Copy constructor
Grid<int> anotherIntGrid;
anotherIntGrid = grid2;      // Assignment operator

Grid test;   // WILL NOT COMPILE
Grid<> test; // WILL NOT COMPILE


//declare a function or method that takes a Grid object, you must specify the type stored in that grid as part of the Grid type
void processIntGrid(Grid<int>& grid)
{
   // Body omitted for brevity
}

using IntGrid = Grid<int>;
void processIntGrid(IntGrid& grid) { }
```

- angle brackets 

    + old 
std::vector<std::vector<T> > mCells;
    
    + new style 
std::vector<std::vector<T> > mCells;

- distributing template code between files 

Templates don’t work that way. Because they are “templates” for the compiler to generate the actual methods for the instantiated types, both class template definitions and method definitions must be available to the compiler in any source file that uses them

```
template <typename T>
class Grid
{
    // Class definition omitted for brevity
};

#include "GridDefinitions.h"
```

you don’t add the Grid.cpp file to your project compiled separately; it should be #included only in a header file!


```
template <typename T>
class Grid
{
    // Class definition omitted for brevity
};

#include "Grid.h"
#include <utility>

template <typename T>
Grid<T>::Grid(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
        column.resize(mHeight);
    }
}
// Other method definitions omitted for brevity...

// Explicit instantiations for the types you want to allow.
template class Grid<int>;
template class Grid<double>;
template class Grid<std::vector<int>>;
```

- non-type template parameters

```
template <typename T, size_t WIDTH, size_t HEIGHT>
class Grid
{
    public:
        Grid() = default;
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<T, WIDTH, HEIGHT>& operator=(const Grid& rhs) = default;

        std::optional<T>& at(size_t x, size_t y);
        const std::optional<T>& at(size_t x, size_t y) const;

        size_t getHeight() const { return HEIGHT; }
        size_t getWidth() const { return WIDTH; }

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::optional<T> mCells[WIDTH][HEIGHT];
};

template <typename T, size_t WIDTH, size_t HEIGHT>
void Grid<T, WIDTH, HEIGHT>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= WIDTH || y >= HEIGHT) {
        throw std::out_of_range("");
    }
}

template <typename T, size_t WIDTH, size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

template <typename T, size_t WIDTH, size_t HEIGHT>
std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}
```

- default values for type parameters 

```
template <typename T = int, size_t WIDTH = 10, size_t HEIGHT = 10>
class Grid
{
    // Remainder is identical to the previous version
};

template <typename T, size_t WIDTH, size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

Grid<> myIntGrid;
Grid<int> myGrid;
Grid<int, 5> anotherGrid;
Grid<int, 5, 5> aFourthGrid;
```

    + C++17 adds support to automatically deduce the template parameters from the arguments passed to a class template constructor. 
std::pair<int, double> pair1(1, 2.3);
auto pair2 = std::make_pair(1, 2.3);

- write your own user-defined deduction guides. 

```
template<typename T>
class SpreadsheetCell
{
    public:
        SpreadsheetCell(const T& t) : mContent(t) { }

        const T& getContent() const { return mContent; }

    private:
        T mContent;
};

std::string myString = "Hello World!";
SpreadsheetCell cell(myString);

SpreadsheetCell(const char*) -> SpreadsheetCell<std::string>;
explicit TemplateName(Parameters) -> DeducedTemplate;
```

- method template 

Consider the original Grid template with only one template parameter
```
Grid<int> myIntGrid;
Grid<double> myDoubleGrid;

myDoubleGrid = myIntGrid;              // DOES NOT COMPILE
Grid<double> newDoubleGrid(myIntGrid); // DOES NOT COMPILE

Grid(const Grid& src);
Grid<T>& operator=(const Grid& rhs);

Grid(const Grid<T>& src);
Grid<T>& operator=(const Grid<T>& rhs);

template <typename T>
class Grid
{
    public:
        // Omitted for brevity

        template <typename E>
        Grid(const Grid<E>& src);

        template <typename E, size_t WIDTH2, size_t HEIGHT2>
        Grid(const Grid<E, WIDTH2, HEIGHT2>& src);

        void swap(Grid& other) noexcept;

        // Omitted for brevity
};

template <typename E>
Grid(const Grid<E>& src);

template <typename T, size_t WIDTH, size_t HEIGHT>
template <typename E, size_t WIDTH2, size_t HEIGHT2>
Grid<T, WIDTH, HEIGHT>::Grid(const Grid<E, WIDTH2, HEIGHT2>& src)
{
    for (size_t i = 0; i < WIDTH; i++) {
        for (size_t j = 0; j < HEIGHT; j++) {
            if (i < WIDTH2 && j < HEIGHT2) {
                mCells[i][j] = src.at(i, j);
            } else {
                mCells[i][j].reset();
            }
        }
    }
}

template <typename T>
template <typename E>
Grid<T>& Grid<T>::operator=(const Grid<E>& rhs)
{
    // no need to check for self-assignment because this version of
    // assignment is never called when T and E are the same

    // Copy-and-swap idiom
    Grid<T> temp(rhs); // Do all the work in a temporary instance
    swap(temp); // Commit the work with only non-throwing operations
    return *this;
}

template <typename T>
void Grid<T>::swap(Grid<T>& other) noexcept
{
    using std::swap;

    swap(mWidth, other.mWidth);
    swap(mHeight, other.mHeight);
    swap(mCells, other.mCells);
}

template <typename T, typename E> // Wrong for nested template constructor!
Grid<T>::Grid(const Grid<E>& src)
```

- class template specification 

```
// When the template specialization is used, the original template must be
// visible too. Including it here ensures that it will always be visible
// when this specialization is visible.
#include "Grid.h"

template <>
class Grid<const char*>
{
    public:
        explicit Grid(size_t width = kDefaultWidth,
            size_t height = kDefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<const char*>& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and assignment operator.
        Grid(Grid&& src) = default;
        Grid<const char*>& operator=(Grid&& rhs) = default;

        std::optional<std::string>& at(size_t x, size_t y);
        const std::optional<std::string>& at(size_t x, size_t y) const;

        size_t getHeight() const { return mHeight; }
        size_t getWidth() const { return mWidth; }

        static const size_t kDefaultWidth = 10;
        static const size_t kDefaultHeight = 10;

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::vector<std::vector<std::optional<std::string>>> mCells;
        size_t mWidth, mHeight;
};

Grid<int> myIntGrid;                 // Uses original Grid template
Grid<const char*> stringGrid1(2, 2); // Uses const char* specialization

const char* dummy = "dummy";
stringGrid1.at(0, 0) = "hello";
stringGrid1.at(0, 1) = dummy;
stringGrid1.at(1, 0) = dummy;
stringGrid1.at(1, 1) = "there";

Grid<const char*> stringGrid2(stringGrid1);

//This syntax tells the compiler that this class is a const char* specialization of the Grid class
template <>
class Grid<const char*>
//the template definitions, you do not repeat the template<> syntax before each method definition.
Grid<const char*>::Grid(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
        column.resize(mHeight);
    }
}

void Grid<const char*>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= mWidth || y >= mHeight) {
        throw std::out_of_range("");
    }
}

const std::optional<std::string>& Grid<const char*>::at(
    size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

std::optional<std::string>& Grid<const char*>::at(size_t x, size_t y)
{
    return const_cast<std::optional<std::string>&>(
        std::as_const(*this).at(x, y));
}
```

- deriving from class templates 

```
#include "Grid.h"

template <typename T>
class GameBoard : public Grid<T>
{
    public:
        explicit GameBoard(size_t width = Grid<T>::kDefaultWidth,
            size_t height = Grid<T>::kDefaultHeight);
        void move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest);
};

template <typename T>
GameBoard<T>::GameBoard(size_t width, size_t height)
    : Grid<T>(width, height)
{
}

template <typename T>
void GameBoard<T>::move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest)
{
    Grid<T>::at(xDest, yDest) = std::move(Grid<T>::at(xSrc, ySrc));
    Grid<T>::at(xSrc, ySrc).reset();  // Reset source cell
    // Or:
    // this->at(xDest, yDest) = std::move(this->at(xSrc, ySrc));
    // this->at(xSrc, ySrc).reset();
}

GameBoard<ChessPiece> chessboard(8, 8);
ChessPiece pawn;
chessBoard.at(0, 0) = pawn;
chessBoard.move(0, 0, 0, 1);
```

- alias templates 

```
using MyInt = int;

template<typename T1, typename T2>
class MyTemplateClass { /* ... */ };

using OtherName = MyTemplateClass<int, double>;

//alias template, This is something you cannot do with a typedef.
template<typename T1>
using OtherName = MyTemplateClass<T1, double>;

```

- function templates 

```
static const size_t NOT_FOUND = static_cast<size_t>(-1);

template <typename T>
size_t Find(const T& value, const T* arr, size_t size)
{
    for (size_t i = 0; i < size; i++) {
        if (arr[i] == value) {
            return i; // Found it; return the index
        }
    }
    return NOT_FOUND; // Failed to find it; return NOT_FOUND
}

template <typename T, size_t N>
size_t Find(const T& value, const T(&arr)[N])
{
    return Find(value, arr, N);
}

int myInt = 3, intArray[] = {1, 2, 3, 4};
size_t res = Find(myInt, intArray);
```

The C++ Standard Library provides a templatized std::find() function that is more powerful than the Find() function template

- function template specialization 

//C-style strings that compares them with strcmp() instead of operator==. Here is a specialization of the Find() 
```
template<>
size_t Find<const char*>(const char* const& value,
    const char* const* arr, size_t size)
{
    for (size_t i = 0; i < size; i++) {
        if (strcmp(arr[i], value) == 0) {
            return i; // Found it; return the index
        }
    }
    return NOT_FOUND; // Failed to find it; return NOT_FOUND
}

template<>
size_t Find(const char* const& value, const char* const* arr, size_t size)

const char* word = "two";
const char* words[] = {"one", "two", "three", "four"};
const size_t sizeWords = std::size(words);
size_t res;
// Calls const char* specialization
res = Find<const char*>(word, words, sizeWords);
// Calls const char* specialization
res = Find(word, words, sizeWords);
```

- function template overloading 

//write a non-template Find() function that works on const char*s
```
size_t Find(const char* const& value, const char* const* arr, size_t size)
{
    for (size_t i = 0; i < size; i++) {
        if (strcmp(arr[i], value) == 0) {
            return i; // Found it; return the index
        }
    }
    return NOT_FOUND; // Failed to find it; return NOT_FOUND
}
```

- Suppose you want to make your operator+ a stand-alone function template. 
```
template <typename T>
Grid<T> operator+(const Grid<T>& lhs, const Grid<T>& rhs)
{
    size_t minWidth = std::min(lhs.getWidth(), rhs.getWidth());
    size_t minHeight = std::min(lhs.getHeight(), rhs.getHeight());

    Grid<T> result(minWidth, minHeight);
    for (size_t y = 0; y < minHeight; ++y) {
        for (size_t x = 0; x < minWidth; ++x) {
            const auto& leftElement = lhs.mCells[x][y];
            const auto& rightElement = rhs.mCells[x][y];
            if (leftElement.has_value() && rightElement.has_value())
                result.at(x, y) = leftElement.value() + rightElement.value();
        }
    }
    return result;
}

// Forward declare Grid template.
template <typename T> class Grid;

// Prototype for templatized operator+.
template<typename T>
Grid<T> operator+(const Grid<T>& lhs, const Grid<T>& rhs);

template <typename T>
class Grid
{
    public:
         // Omitted for brevity
        friend Grid<T> operator+ <T>(const Grid<T>& lhs, const Grid<T>& rhs);
        // Omitted for brevity
};
```

To query whether an std::optional contains an actual value, you use the has_value() method, while value() is used to retrieve this value

particularly the explicit template specification <T> on operator+ (the space after operator+ is optional). This syntax tells the compiler that operator+ is itself a template.

- template parameter deduction 

```
template<typename RetType, typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

auto result = add<long, int, int>(1, 2);
auto result = add<long long>(1, 2);

template<typename RetType = long long, typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }
...
auto result = add(1, 2);
```

- return type of function templates 

```
template<typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

template<typename T1, typename T2>
auto add(const T1& t1, const T2& t2)
{
    return t1 + t2;
}

//auto strips reference and const qualifiers, s1 is of type string
auto s1 = getString();
const auto& s2 = getString();

//decltype will not strips const and reference 
decltype(getString()) s3 = getString();
decltype(auto) s4 = getString();

//now that C++ supports auto return type deduction and decltype(auto)
template<typename T1, typename T2>
decltype(auto) add(const T1& t1, const T2& t2)
{
    return t1 + t2;
}
```

    + cpp11 
```
template<typename T1, typename T2>
decltype(t1+t2) add(const T1& t1, const T2& t2) { return t1 + t2; }
```

- variable templates 

    + cpp14 support
```
template <typename T>
constexpr T pi = T(3.141592653589793238462643383279502884);

//This is a variable template for the value of pi
float piFloat = pi<float>;
long double piLongDouble = pi<long double>;
```


# Demystifying c++ i/o 
- book’s website at www.wrox.com/go/proc++4e on the Download Code tab.

cin 	An input stream, reads data from the “input console.”
cout 	A buffered output stream, writes data to the “output console.”
cerr 	An unbuffered output stream, writes data to the “error console,” which is often the same as the “output console.”
clog 	A buffered version of cerr.

- In C++, there are three common sources and destinations for streams: console, file, and string.

- put() and write()

put() and write() are raw output methods. Instead of taking an object or variable that has some defined behavior for output, put() accepts a single character, while write() accepts a character array

const char* test = "hello there\n";
cout.write(test, strlen(test));

- flush()

When you write to an output stream, the stream does not necessarily write the data to its destination right away. Most output streams buffer, or accumulate data instead of writing it out as soon as it comes in

- handle errors, The good() method provides an easy way to obtain basic information about the validity of the stream

cout.flush();
if (cout.fail()) {
    cerr << "Unable to flush to standard out" << endl;
}

cout.flush();
if (!cout) {
    cerr << "Unable to flush to standard out" << endl;
}
    + You can also tell the streams to throw exceptions when a failure occurs. 
cout.exceptions(ios::failbit | ios::badbit | ios::eofbit);
try {
    cout << "Hello World." << endl;
} catch (const ios_base::failure& ex) {
    cerr << "Caught exception: " << ex.what()
         << ", error code = " << ex.code() << endl;
}

//clear error 
cout.clear();

- output manipulators 

boolalpha and noboolalpha: Tells the stream to output bool values as true and false (boolalpha) or 1 and 0 (noboolalpha). The default is noboolalpha.
hex, oct, and dec: Outputs numbers in hexadecimal, octal, and base 10, respectively.
setprecision: Sets the number of decimal places that are output for fractional numbers. This is a parameterized manipulator (meaning that it takes an argument).
setw: Sets the field width for outputting numerical data. This is a parameterized manipulator.
setfill: Specifies the character that is used to pad numbers that are smaller than the specified width. This is a parameterized manipulator.
showpoint and noshowpoint: Forces the stream to always or never show the decimal point for floating point numbers with no fractional part.
put_money: A parameterized manipulator that writes a formatted monetary value to a stream.
put_time: A parameterized manipulator that writes a formatted time to a stream.
quoted: A parameterized manipulator that encloses a given string with quotes and escapes embedded quotes.

    + example 
// Boolean values
bool myBool = true;
cout << "This is the default: " << myBool << endl;
cout << "This should be true: " << boolalpha << myBool << endl;
cout << "This should be 1: " << noboolalpha << myBool << endl;

// Simulate "%6d" with streams
int i = 123;
printf("This should be '   123': %6d\n", i);
cout << "This should be '   123': " << setw(6) << i << endl;

// Simulate "%06d" with streams
printf("This should be '000123': %06d\n", i);
cout << "This should be '000123': " << setfill('0') << setw(6) << i << endl;

// Fill with *
cout << "This should be '***123': " << setfill('*') << setw(6) << i << endl;
// Reset fill character
cout << setfill(' ');

// Floating point values
double dbl = 1.452;
double dbl2 = 5;
cout << "This should be ' 5': " << setw(2) << noshowpoint << dbl2 << endl;
cout << "This should be @@1.452: " << setw(7) << setfill('@') << dbl << endl;
// Reset fill character
cout << setfill(' ');

// Instructs cout to start formatting numbers according to your location.
// Chapter 19 explains the details of the imbue call and the locale object.
cout.imbue(locale(""));

// Format numbers according to your location
cout << "This is 1234567 formatted according to your location: " << 1234567 
     << endl;

// Monetary value. What exactly a monetary value means depends on your
// location. For example, in the USA, a monetary value of 120000 means 120000
// dollar cents, which is 1200.00 dollars.
cout << "This should be a monetary value of 120000, "
     << "formatted according to your location: "
     << put_money("120000") << endl;

// Date and time
time_t t_t = time(nullptr);  // Get current system time
tm* t = localtime(&t_t);     // Convert to local time
cout << "This should be the current date and time "
     << "formatted according to your location: "
     << put_time(t, "%c") << endl;
     
// Quoted string
cout << "This should be: \"Quoted string with \\\"embedded quotes\\\".\": "
     << quoted("Quoted string with \"embedded quotes\".") << endl;

- the book C++ Standard Library Quick Reference, or online references http://www.cppreference.com/ or http://www.cplusplus.com/reference/.

- input streams 

string userInput;
cin >> userInput;

- handling input error 

while (cin >> ch) { ... }

The relation is again as follows: good() == (!fail() && !eof()).

```
cout << "Enter numbers on separate lines to add. "
     << "Use Control+D to finish (Control+Z in Windows)." << endl;
int sum = 0; 

if (!cin.good()) { 
    cerr << "Standard input is in a bad state!" << endl; 
    return 1; 
} 

int number;
while (!cin.bad()) { 
    cin >> number;
    if (cin.good()) {
        sum += number; 
    } else if (cin.eof()) {
        break; // Reached end of file
    } else if (cin.fail()) {
        // Failure!
        cin.clear(); // Clear the failure state.
        string badToken;
        cin >> badToken; // Consume the bad input.
        cerr << "WARNING: Bad input encountered: " << badToken << endl;
    }
} 
cout << "The sum is " << sum << endl;
```

- input methods 

get()

The get() method allows raw input of data from a stream.

unget()

For most purposes, the correct way to think of an input stream is as a one-way chute. 

putback()

The putback() method, like unget(), lets you move backward by one character in an input stream.

peek ()

The peek() method allows you to preview the next value that would be returned if you were to call get().

getline()

Obtaining a single line of data from an input stream is so common that a method exists to do it for you. The getline() method fills a character buffer with a line of data up to the specified size. 

- string streams 

closing the input stream with Control+D (Unix) or Control+Z (Windows).

```
cout << "Enter tokens. Control+D (Unix) or Control+Z (Windows) to end" << endl;
ostringstream outStream;
while (cin) {
    string nextToken;
    cout << "Next token: ";
    cin >> nextToken;
    if (!cin || nextToken == "done")
        break;
    outStream << nextToken << "\t";
}
cout << "The end result is: " << outStream.str();
```

- file streams, Marshalling is useful for saving objects to disk or sending them across a network.

std::ofstream and std::ifstream classes provide output and input functionality for files. defined in the <fstream> header file

    + different constants 
    
ios_base::app 	Open, and go to the end before each write operation.
ios_base::ate 	Open, and go to the end once immediately after opening.
ios_base::binary 	Perform input and output in binary mode as opposed to text mode. See the next section.
ios_base::in 	Open for input, start reading at the beginning.
ios_base::out 	Open for output, start writing at the beginning, overwriting existing data.
ios_base::trunc 	Open for output, and delete all existing data (truncate).


specify the open mode as follows:

ios_base::out | ios_base::binary  | ios_base::trunc

//The ifstream and ofstream destructors automatically close the underlying file, so there is no need to explicitly call close().
```
int main(int argc, char* argv[])
{
    ofstream outFile("test.txt", ios_base::trunc);
    if (!outFile.good()) {
        cerr << "Error while opening output file!" << endl;
        return -1;
    }
    outFile << "There were " << argc << " arguments to this program." << endl;
    outFile << "They are: " << endl;
    for (int i = 0; i < argc; i++) {
        outFile << argv[i] << endl;
    }
    return 0;
}
```

- text mode versus binary mode 

each line you write to, or read from a file ends with a \n. However, it is operating-system dependent how the end of a line is encoded in a file

on Windows, a line ends with \r\n instead of with a single \n character, a file is opened in text mode and you write a line ending with \n to it, the underlying implementation automatically converts the \n to \r\n before writing it to the file.

- jumping around with seek() and tell() 

The seek() and tell() methods are present on all input and output streams.

are several forms of seek(). The methods of seek() within an input stream are actually called seekg() (the g is for get), and the versions of seek() in an output stream are called seekp() (the p is for put).

    + three predefined position 
    
ios_base::beg 	The beginning of the stream
ios_base::end 	The end of the stream
ios_base::cur 	The current position in the stream

```
outStream.seekp(ios_base::beg);

std::streampos curPos = inStream.tellg();
if (ios_base::beg == curPos) {
    cout << "We're at the beginning." << endl;
}
```

- linking streams together 

ifstream inFile("input.txt");  // Note: input.txt must exist.
ofstream outFile("output.txt");
// Set up a link between inFile and outFile.
inFile.tie(&outFile);
// Output some text to outFile. Normally, this would
// not flush because std::endl is not sent.
outFile << "Hello there!";
// outFile has NOT been flushed.
// Read some text from inFile. This will trigger flush()
// on outFile.
string nextToken;
inFile >> nextToken;
// outFile HAS been flushed.

outFile.tie(&anotherOutputFile);


# Handling errors 
- the errno macro to signify errors. Each thread has its own errno value. errno acts as a thread-local integer variable
```
try {
    // ... code which may result in an exception being thrown
} catch (exception-type1 exception-name) {
    // ... code which responds to the exception of type 1
} catch (exception-type2 exception-name) {
    // ... code which responds to the exception of type 2
} catch (const exception& e) {
} catch (...) {
    cerr << "Error reading or opening file " << fileName << endl;
    terminate();
   
}
//


ifstream inputStream(fileName.data());
if (inputStream.fail()) {
    // We failed to open the file: throw an exception
    throw exception();
}

throw runtime_error("Error reading the file.");

```

- mark a function do not allowed throw exception 

vector<int> readIntegerFile(string_view fileName) noexcept;

- Because C++17 has officially removed support for exception specifications,

C++ runtime called std::unexpected() which by default called std::terminate() to terminate the application.

- writing your own exception classes 

writing your own exception classes.

The number of exceptions in the C++ Standard Library is limited. Instead of using an exception class with a generic name

```
class FileError : public exception
{
    public:
        FileError(string_view fileName) : mFileName(fileName) {}

        virtual const char* what() const noexcept override {
            return mMessage.c_str();
        }

        string_view getFileName() const noexcept { return mFileName; }

    protected:
        void setMessage(string_view message) { mMessage = message; }

    private:
        string mFileName;
        string mMessage;
};
```

- nested exceptions

You use std::throw_with_nested() to throw an exception with another exception nested inside it

```
class MyException : public std::exception
{
    public:
        MyException(string_view message) : mMessage(message) {}
        virtual const char* what() const noexcept override {
            return mMessage.c_str();
        }
    private:
        string mMessage;
};

void doSomething()
{
    try {
        throw runtime_error("Throwing a runtime_error exception");
    } catch (const runtime_error& e) {
        cout << __func__ << " caught a runtime_error" << endl;
        cout << __func__ << " throwing MyException" << endl;
        throw_with_nested(
            MyException("MyException with nested runtime_error"));
    }
}

int main()
{
    try {
        doSomething();
    } catch (const MyException& e) {
        cout << __func__ << " caught MyException: " << e.what() << endl;

        const auto* pNested = dynamic_cast<const nested_exception*>(&e);
        if (pNested) {
            try {
                pNested->rethrow_nested();
            } catch (const runtime_error& e) {
                // Handle nested exception
                cout << "  Nested exception: " << e.what() << endl;
            }
        }
    }
    return 0;
}

//with helper function in the standard provides a small helper function called std::rethrow_if_nested() that does it for you. 

int main()
{
    try {
        doSomething();
    } catch (const MyException& e) {
        cout << __func__ << " caught MyException: " << e.what() << endl;
        try {
            rethrow_if_nested(e);
        } catch (const runtime_error& e) {
            // Handle nested exception
            cout << "  Nested exception: " << e.what() << endl;
        }
    }
    return 0;
}
```

- rethrow exception 
```
void g() { throw invalid_argument("Some exception"); }

void f()
{
    try {
        g();
    } catch (const invalid_argument& e) {
        cout << "caught in f: " << e.what() << endl;
        throw;  // rethrow
    }
}

int main()
{
    try {
        f();
    } catch (const invalid_argument& e) {
        cout << "caught in main: " << e.what() << endl;
    }
    return 0;
}
```
- use smart pointers 

```
void funcOne() 
{
    string str1;
    auto str2 = make_unique<string>("hello");
    funcTwo();
}
```

- catch, clean up and rethrow 
```
void funcOne()
{
    string str1;
    string* str2 = new string();
    try {
        funcTwo();
    } catch (...) {
        delete str2;
        throw; // Rethrow the exception.
    }
    delete str2;
}
```

- memory allocate errors 

The default behaviors of new and new[] are to throw an exception of type bad_alloc, defined in the <new> header file

```
int* ptr = nullptr;
size_t integerCount = numeric_limits<size_t>::max();
try {
    ptr = new int[integerCount];
} catch (const bad_alloc& e) {
    cerr << __FILE__ << "(" << __LINE__
         << "): Unable to allocate memory: " << e.what() << endl;
    // Handle memory allocation failure.
    return;
}
// Proceed with function that assumes memory has been allocated.
```

- non-throwing new which return nullptr instead of throwing an exception 
```
int* ptr = new(nothrow) int[integerCount];
if (ptr == nullptr) {
    cerr << __FILE__ << "(" << __LINE__
         << "): Unable to allocate memory!" << endl;
    // Handle memory allocation failure.
    return;
}
// Proceed with function that assumes memory has been allocated.
```
- custom memory location error behavior, You set the new handler with a call to set_new_handler(), declared in the <new> header file.

new_handler is a typedef for the type of function pointer that set_new_handler() takes.
```
class please_terminate_me : public bad_alloc { };

void myNewHandler()
{
    cerr << "Unable to allocate memory." << endl;
    throw please_terminate_me();
}

int main()
{
    try {
        // Set the new new_handler and save the old one.
        new_handler oldHandler = set_new_handler(myNewHandler);

        // Generate allocation error
        size_t numInts = numeric_limits<size_t>::max();
        int* ptr = new int[numInts];

        // Reset the old new_handler
        set_new_handler(oldHandler);
    } catch (const please_terminate_me&) {
        cerr << __FILE__ << "(" << __LINE__
             << "): Terminating program." << endl;
        return 1;
    }
    return 0;
}
```

- errors in constructors 

Constructors don’t have a return value, so the standard pre-exception error-handling mechanism doesn’t work. Without exceptions, the best you can do is to set a flag in the object specifying that it is not constructed properly. You can provide a method, with a name like checkConstructionStatus()

You can throw an exception from a constructor, even though you can’t return a value. if an exception leaves a constructor, the destructor for that object will never be called!

If a derived class constructor throws an exception, C++ will execute the destructor of the fully constructed base class

In production-quality code, you should avoid using raw pointers

    + example handle errors in constructor 
```
template <typename T>
class Matrix
{
    public:
        Matrix(size_t width, size_t height);
        virtual ~Matrix();
    private:
        void cleanup();

        size_t mWidth = 0;
        size_t mHeight = 0;
        T** mMatrix = nullptr;
};


template <typename T>
Matrix<T>::Matrix(size_t width, size_t height)
{
    mMatrix = new T*[width] {};    // Array is zero-initialized!

    // Don't initialize the mWidth and mHeight members in the ctor-
    // initializer. These should only be initialized when the above
    // mMatrix allocation succeeds!
    mWidth = width;
    mHeight = height;

    try {
        for (size_t i = 0; i < width; ++i) {
            mMatrix[i] = new T[height];
        }
    } catch (...) {
        std::cerr << "Exception caught in constructor, cleaning up..."
            << std::endl;
        cleanup();
        // Nest any caught exception inside a bad_alloc exception.
        std::throw_with_nested(std::bad_alloc());
    }
}

template <typename T>
Matrix<T>::~Matrix()
{
    cleanup();
}

template <typename T>
void Matrix<T>::cleanup()
{
    for (size_t i = 0; i < mWidth; ++i)
        delete[] mMatrix[i];
    delete[] mMatrix;
    mMatrix = nullptr;
    mWidth = mHeight = 0;
}

//test 
class Element
{
    // Kept to a bare minimum, but in practice, this Element class
    // could throw exceptions in its constructor.
    private:
        int mValue;
};

int main()
{
    Matrix<Element> m(10, 10);
    return 0;
}
```

- function-try-blocks for constructors, Function-try-blocks work for normal functions as well as for constructors. 

```
MyClass::MyClass()
try
    : <ctor-initializer>
{
     /* ... constructor body ... */
}
catch (const exception& e)
{
     /* ... */
}
```
The catch statements catch any exception thrown either directly or indirectly by the ctor-initializer
The catch statements have to rethrow the current exception or throw a new exception.
The catch statements can access arguments passed to the constructor.
When a catch statement catches an exception in a function-try-block, all fully constructed base classes and members of the object are destroyed
Inside catch statements you should not access member variables that are objects because these are destroyed prior to executing the catch statements 
The catch statements in a function-try-block cannot use the return keyword to return a value from the function enclosed by it

    + function-try-blocks for constructors are useful only
To convert an exception thrown by the ctor-initializer to another exception.
To log a message to a log file.
To free naked resources that have been allocated in the ctor-initializer prior to the exception being thrown.

```
class SubObject
{
    public:
        SubObject(int i);
};

SubObject::SubObject(int i)
{
    throw std::runtime_error("Exception by SubObject ctor");
}
```

The constructor of MyClass uses a function-try-block to catch exceptions thrown in its ctor-initializer:
```
class MyClass
{
    public:
        MyClass();
    private:
        int* mData = nullptr;
        SubObject mSubObject;
};


MyClass::MyClass() 
try
    : mData(new int[42]{ 1, 2, 3 }), mSubObject(42)
{
    /* ... constructor body ... */
}
catch (const std::exception& e)
{
    // Cleanup memory.
    delete[] mData;
    mData = nullptr;
    cout << "function-try-block caught: '" << e.what() << "'" << endl;
}

int main()
{
    try {
        MyClass m;
    } catch (const std::exception& e) {
        cout << "main() caught: '" << e.what() << "'" << endl;
    }
    return 0;
}
```

the code in the example can be dangerous. Depending on the order of initialization, it could be that mData contains garbage when entering the catch statement.

The solution in this example’s case is to use a smart pointer for the mData member, for example std::unique_ptr, and to remove the function-try-block. Therefore:

    + Avoid using function-try-blocks!

Function-try-blocks are usually only necessary when you have naked resources as data members

- errors in destructors, You should not let any exceptions be thrown from destructors, for a couple of reasons:

Destructors are implicitly marked as noexcept, unless they are marked with noexcept(false)

Destructors can run while there is another pending exception, in the process of stack unwinding

What action would clients take? Clients don’t call destructors explicitly: they call delete, which calls the destructor.

The destructor is your one chance to free memory and resources used in the object.


# Overloading c++ operators 
- define what +, -, *, and / mean when applied to objects of that class.
- cannot do when you overload operators:

You cannot add new operator symbols.

cannot overload, such as . (member access in an object), :: (scope resolution operator), sizeof, ?: (the conditional operator), and a few others

The arity describes the number of arguments, or operands, associated with the operator. Unary operators, such as ++, work on only one operand. Binary operators, such as /, work on two operands. 

You cannot redefine operators for built-in types.

- three different types of operators:

Operators that must be methods. The C++ language requires some operators to be methods of a class because they don’t make sense outside of a class.

Operators that must be global functions. operator<< and operator>>, where the left-hand side is an iostream object, not an object of your class. 

Operators that can be either methods or global functions. 

- summary of overloadable operators 

operator+
operator-
operator*
operator/
operator%

operator-
operator+
operator~

operator++
operator--

operator=

operator+=
operator-=
operator*=
operator/=
operator%=

operator<<
operator>>
operator&
operator|
operator^

operator<<=
operator>>=
operator&=
operator|=
operator^=

operator<
operator>
operator<=
operator>=
operator==
operator!=

operator<<
operator>>

operator!

operator&&
operator||

operator[]

operator()

operator type(), Conversion, or cast, operators 

operator new
operator new[]

operator delete
operator delete[]

operator*
operator->

operator&

operator->*

operator,

- rvalue references 

    + defining move assignment operators, which are used by the compiler in cases where the second object is a temporary object that will be destroyed after the assignment. 

T& operator=(const T&);

    + The move assignment operator has almost the same prototype, but uses an rvalue reference.

T& operator=(T&&);

    + The std::string class from the Standard Library, for example, implements an operator+ using rvalue references as follows

string operator+(string&& lhs, string&& rhs);

return std::move(lhs.append(rhs));

- overloading the function call operator 

```
class FunctionObject
{
    public:
        int operator() (int param); // Function call operator
        int doSquare(int param);    // Normal method
};

// Implementation of overloaded function call operator
int FunctionObject::operator() (int param)
{
    return doSquare(param);
}

// Implementation of normal method
int FunctionObject::doSquare(int param)
{
    return param * param;
}

int x = 3, xSquared, xSquaredAgain;
FunctionObject square;
xSquared = square(x);               // Call the function call operator
xSquaredAgain = square.doSquare(x); // Call the normal method
```

Objects can retain information in their data members between repeated calls to their function call operators.

You can customize the behavior of a function object by setting data members. 

- solving ambiguity problmes with explicit conversion operators 

explicit operator double() const;

- new operator 
void* operator new(size_t size, void* p) noexcept;
void* operator new[](size_t size, void* p) noexcept;

void operator delete(void* ptr) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* p, void*) noexcept;
void operator delete[](void* p, void*) noexcept;

```
#include <cstddef>
#include <new>

class MemoryDemo
{
    public:
        virtual ~MemoryDemo() = default;

        void* operator new(size_t size);
        void operator delete(void* ptr) noexcept;

        void* operator new[](size_t size);
        void operator delete[](void* ptr) noexcept;

        void* operator new(size_t size, const std::nothrow_t&) noexcept;
        void operator delete(void* ptr, const std::nothrow_t&) noexcept;

        void* operator new[](size_t size, const std::nothrow_t&) noexcept;
        void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
};


void* MemoryDemo::operator new(size_t size)
{
    cout << "operator new" << endl;
    return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr) noexcept
{
    cout << "operator delete" << endl;
    ::operator delete(ptr);
}
void* MemoryDemo::operator new[](size_t size)
{
    cout << "operator new[]" << endl;
    return ::operator new[](size);
}
void MemoryDemo::operator delete[](void* ptr) noexcept
{
    cout << "operator delete[]" << endl;
    ::operator delete[](ptr);
}
void* MemoryDemo::operator new(size_t size, const nothrow_t&) noexcept
{
    cout << "operator new nothrow" << endl;
    return ::operator new(size, nothrow);
}
void MemoryDemo::operator delete(void* ptr, const nothrow_t&) noexcept
{
    cout << "operator delete nothrow" << endl;
    ::operator delete(ptr, nothrow);
}
void* MemoryDemo::operator new[](size_t size, const nothrow_t&) noexcept
{
    cout << "operator new[] nothrow" << endl;
    return ::operator new[](size, nothrow);
}
void MemoryDemo::operator delete[](void* ptr, const nothrow_t&) noexcept
{
    cout << "operator delete[] nothrow" << endl;
    ::operator delete[](ptr, nothrow);
}
```

- overloading delete with size of memory as parameter 

```
class MemoryDemo
{
    public:
        // Omitted for brevity 
        void* operator new(size_t size);
        void operator delete(void* ptr, size_t size) noexcept;
        // Omitted for brevity
};
```


# Overview of the C++ standard library 
- class MemoryDemo
{
    public:
        // Omitted for brevity 
        void* operator new(size_t size);
        void operator delete(void* ptr, size_t size) noexcept;
        // Omitted for brevity
};

- strings, std::string 

std::string is a type alias for a char instantiation of the std::basic_string

- Regular expressions are available through the <regex> header file

- i/o streams, The I/O functionality is defined in several header files: <fstream>, <iomanip>, <ios>, <iosfwd>, <iostream>, <istream>, <ostream>, <sstream>, <streambuf>, and <strstream>

- smart pointers 

unique_ptr, shared_ptr, and weak_ptr. shared_ptr and weak_ptr are thread-safe. They are all defined in the <memory> header. 

Before C++11, the functionality of unique_ptr was handled by a type called auto_ptr, which has been removed from C++17

- exceptions 

Exception support is defined in a couple of header files: <exception>, <stdexcept>, and <system_error>

- mathematical utility classes and functions.

A whole range of common mathematical functions is available, such as abs(), remainder(), fma(), exp(), log(), pow(), sqrt(), sin(), atan2(), sinh(), erf(), tgamma(), ceil(), floor(), and more. C++17 adds a number of special mathematical functions

There is a complex number class called complex, defined in <complex>, which provides an abstraction for working with numbers 

The compile-time rational arithmetic library provides a ratio class template, defined in the <ratio> header file. This ratio class template can exactly represent any finite rational number

The Standard Library also contains a class called valarray, defined in <valarray>, which is similar to the vector class but is more optimized for high-performance numerical applications. 

In C, you could access #defines, such as INT_MAX. While those are still available in C++, it’s recommended to use the numeric_limits class template defined in the <limits> header file. 

```
cout << "int:" << endl;
cout << "Max int value: " << numeric_limits<int>::max() << endl;
cout << "Min int value: " << numeric_limits<int>::min() << endl;
cout << "Lowest int value: " << numeric_limits<int>::lowest() << endl;

cout << endl << "double:" << endl;
cout << "Max double value: " << numeric_limits<double>::max() << endl;
cout << "Min double value: " << numeric_limits<double>::min() << endl;
cout << "Lowest double value: " << numeric_limits<double>::lowest() << endl;
```

- time utilities 

C++ includes the chrono library, defined in the <chrono> header file. This library makes it easy to work with time;

 Other time and date utilities are provided in the <ctime> header.

- Random Numbers

C++ already has support for generating pseudo-random numbers for a long time with the srand() and rand() functions. 

ince C++11, a random number library has been added to the standard, which is much more powerful. The new library is defined in <random>

- Initializer Lists

Initializer lists are defined in the <initializer_list> header file. They make it easy to write functions that can accept a variable number of arguments 

- pair and tuple 

Pair and Tuple

The <utility> header defines the pair template, which can store two elements with two different types

tuple, defined in <tuple>, is a generalization of pair. It is a sequence with a fixed size that can have heterogeneous elements. 

- optional, variant, and any

C++17 introduces the following new classes:

optional, defined in <optional>, holds a value of a specific type, or nothing. 
    
variant, defined in <variant>, can hold a single value of one of a given set of types, or nothing.

any, defined in <any>, is a class that can contain a single value of any type.

- Function Objects

A class that implements a function call operator is called a function object. 

certain Standard Library algorithms. The <functional> header file defines a number of predefined function objects

- Filesystem

C++17 introduces a filesystem support library. Everything is defined in the <filesystem> header, and lives in the std::filesystem namespace. It allows you to write portable code to work with a filesystem. 

- Multithreading

All major CPU vendors are selling processors with multiple cores. 

individual threads can be created using the thread class from the <thread> header.

take care that several threads are not reading and writing to the same piece of data at the same time. To prevent this, you can use atomics, defined in <atomic>, which give you thread-safe atomic access to a piece of data

thread synchronization mechanisms are provided by <condition_variable> and <mutex>.

you can use async and future. These are defined in the <future> header, and are easier to use than directly using the thread class.

- type traits 

Type traits are defined in the <type_traits> header file and provide information about types at compile time. 

- Standard Integer Types

The <cstdint> header file defines a number of standard integer types such as int8_t, int64_t and so on. 

- Containers, Both any and variant are introduced with C++17

The Standard Library provides implementations of commonly used data structures such as linked lists and queues.

If you need non-fixed-sized heterogeneous collections, you can wrap each element in an std::any instance and store those any instances in a container.

Alternatively, you can store std::variant instances in a container. A variant can be used if the number of different required types is limited and known at compile time. 

vector

The <vector> header file defines vector, The reason is that a vector is stored contiguously in memory, while a linked list is scattered around in memory. Computers are extremely efficient to work with contiguous data

list

A Standard Library list is a doubly linked list structure and is defined in <list>. Like an array or vector, it stores a sequence of elements. 

forward_list

The forward_list, defined in <forward_list>, is a singly linked list, compared to the list container, which is doubly linked. 

deque

The name deque is an abbreviation for a double-ended queue. A deque, defined in <deque>, provides quick (constant time) element access.

array

The <array> header defines array, which is a replacement for standard C-style arrays. Sometimes you know the exact number of elements in your container up front and you don’t need the flexibility of a vector or a list

queue

The name queue comes directly from the definition of the English word queue, which means a line of people or objects. The queue container is defined in <queue> and provides standard first in, first out (or FIFO) semantics. 

priority_queue

A priority_queue, also defined in <queue>, provides queue functionality in which each element has a priority. Elements are removed from the queue in priority order.

stack

The <stack> header defines the stack class, which provides standard first-in, last-out (FILO) semantics, also known as last-in, first-out (LIFO).

set and multiset

The set class template is defined in the <set> header file, and, as the name suggests, it is a set of elements, loosely analogous to the notion of a mathematical set: each element is unique, and there is at most one instance of the element in the set. Each element in a set must be unique. If you want to store duplicate elements, you must use a multiset

map and multimap

The <map> header defines the map class template, which is an associative array. You can use it as an array in which the index can be any type; for example, a string.

    + unordered associative containers/hash tables 
    
There are four unordered associative containers:

unordered_map
unordered_multimap
unordered_set
unordered_multiset

The first two containers are defined in <unordered_map>, and the other two containers in <unordered_set>.

bitset

C and C++ programmers commonly store a set of flags in a single int or long, using one bit for each flag. The <bitset> header file defines the bitset container, but this is not a container in the normal sense, in that it does not implement a specific data structure in which you insert and remove elements. A bitset has a fixed size and does not support iterators. its with the bitwise operators: &, |, ^, ~, <<, and >>. The C++ Standard Library provides a bitset class that abstracts this bit field manipulation

- algorithms 

For example, sets provide their own find() algorithm that is faster than the generic find() algorithm. 

begin()
end() 	Returns a non-const iterator to the first, and one past the last, element in a sequence.
cbegin()
cend() 	Returns a const iterator to the first, and one past the last, element in a sequence.
rbegin()
rend() 	Returns a non-const reverse iterator to the last, and one before the first, element in a sequence.
crbegin()
crend() 	Returns a const reverse iterator to the last, and one before the first, element in a sequence.

There are approximately 100 algorithms in the Standard Library, depending on how you count them

    + non-modifying sequence algorithms 

adjacent_find() 	Finds the first instance of two consecutive elements that are equal to each other or are equivalent to each other as specified by a predicate. 	O(N)
find()
find_if() 	Finds the first element that matches a value or causes a predicate to return true. 	O(N)
find_first_of() 	Like find, but searches for one of several elements at the same time. 	O(NM)
find_if_not() 	Finds the first element that causes a predicate to return false. 	O(N)
find_end() 	Finds the last subsequence in a sequence that matches another sequence or whose elements are equivalent, as specified by a predicate. 	O(M*(N-M))
search() 	Finds the first subsequence in a sequence that matches another sequence or whose elements are equivalent, as specified by a predicate.* 	O(NM)*
search_n() 	Finds the first instance of n consecutive elements that are equal to a given value or relate to that value according to a predicate.

Since C++17, search() accepts an optional extra parameter to specify the searching algorithm to use (default_searcher, boyer_moore_searcher, or boyer_moore_horspool_searcher). With the Boyer-Moore searchers. the worst case complexity is O(N+M) when the pattern is not found, and O(NM) when the pattern is found.

    + comparison algorithms 

equal() 	Determines if two sequences are equal by checking if parallel elements are equal or match a predicate.

mismatch() 	Returns the first element in each sequence that does not match the element in the same location in the other sequence.

lexicographical_compare() 	Compares two sequences to determine their “lexicographical” ordering. This algorithm compares each element of the first sequence with its equivalent element in the second. If one element is less than the other, that sequence is lexicographically first. If the elements are equal, it compares the next elements in order.

    + counting 
all_of() 	Returns true if the predicate returns true for all the elements in the sequence or if the sequence is empty; false otherwise.
any_of() 	Returns true if the predicate returns true for at least one element in the sequence; false otherwise.
none_of() 	Returns true if the predicate returns false for all the elements in the sequence or if the sequence is empty; false otherwise.
count()
count_if() 	Counts the number of elements matching a value or that cause a predicate to return true.

    + modifying sequence 
    
copy()
copy_backward() 	Copies elements from one sequence to another.
copy_if() 	Copies elements for which a predicate returns true from one sequence to another.
copy_n() 	Copies n elements from one sequence to another.
fill() 	Sets all elements in the sequence to a new value.
fill_n() 	Sets the first n elements in the sequence to a new value.
generate() 	Calls a specified function to generate a new value for each element in the sequence.
generate_n() 	Calls a specified function to generate a new value for the first n elements in the sequence.
move()
move_backward() 	Moves elements from one sequence to another. This uses efficient move semantics (see Chapter 9).
remove()
remove_if()
remove_copy()
remove_copy_if() 	Removes elements that match a given value or that cause a predicate to return true, either in place or by copying the results to a different sequence.
replace()
replace_if()
replace_copy()
replace_copy_if() 	Replaces all elements matching a value or that cause a predicate to return true with a new element, either in place or by copying the results to a different sequence.
reverse()
reverse_copy() 	Reverses the order of the elements in the sequence, either in place or by copying the results to a different sequence.
rotate()
rotate_copy() 	Swaps the first and second “halves” of the sequence, either in place or by copying the results to a different sequence. The two subsequences to be swapped need not be equal in size.

        * cpp17 avaliable 
sample() 	Selects n random elements from the sequence.
shuffle()
random_shuffle() 	Shuffles the sequence by randomly reordering the elements. It is possible to specify the properties of the random number generator used for shuffling. random_shuffle() is deprecated since C++14, and is removed from C++17.
transform() 	Calls a unary function on each element of a sequence or a binary function on parallel elements of two sequences. This is an in-place transformation.
unique()
unique_copy() 	Removes consecutive duplicates from the sequence, either in place or by copying results to a different sequence.

    + optional algorithm 

for_each() 	Executes a function on each element in the sequence. The sequence is specified with a begin and end iterator.

image for_each_n() 	Similar to for_each() but only processes the first n elements in the sequence. The sequence is specified by a begin iterator and a number of elements (n).

    + swap and exchange algorithms 
    
iter_swap()
swap_ranges() 	Swaps two elements or sequences of elements.
swap() 	Swaps two values, defined in the <utility> header.
image exchange() 	Replaces a given value with a new value and returns the old value. Defined in the <utility> header.

    + partition algorithm, A sequence is partitioned on a certain predicate, if all elements for which the predicate returns true are before all elements for which it returns false
    
is_partitioned() 	Returns true if all elements for which a predicate returns true are before all elements for which it returns false. 	Linear
partition() 	Sorts the sequence such that all elements for which a predicate returns true are before all elements for which it returns false, without preserving the original order of the elements within each partition. 	Linear
stable_partition() 	Sorts the sequence such that all elements for which a predicate returns true are before all elements for which it returns false, while preserving the original order of the elements within each partition. 	Linear logarithmic
partition_copy() 	Copies elements from one sequence to two different sequences. The target sequence is selected based on the result of a predicate, either true or false. 	Linear
partition_point() 	Returns an iterator such that all elements before this iterator return true for a predicate and all elements after this iterator return false for that predicate. 	

    + sorting algorithm 
    
is_sorted()
is_sorted_until() 	Checks if a sequence is sorted or which subsequence is sorted. 	Linear
nth_element() 	Relocates the nth element of the sequence such that the element in the position pointed to by nth is the element that would be in that position if the whole range were sorted, and it rearranges all elements such that all elements preceding the nth element are less than the new nth element, and the ones following it are greater than the new nth element. 	Linear
partial_sort()
partial_sort_copy() 	Partially sorts the sequence: the first n elements (specified by iterators) are sorted; the rest are not. They are sorted either in place or by copying them to a new sequence. 	Linear logarithmic
sort()
stable_sort() 	Sorts elements in place, either preserving the order of duplicate elements or not.

    + binary search algorithm 
lower_bound() 	Finds the first element in a sequence not less than (that is greater or equal to) a given value.
upper_bound() 	Finds the first element in a sequence greater than a given value.
equal_range() 	Returns a pair containing the result of both lower_bound() and upper_bound().
binary_search() 	Returns true if a given value is found in a sequence; false otherwise.

    + set algorithms 
inplace_merge() 	Merges two sorted sequences in place. 	Linear logarithmic
merge() 	Merges two sorted sequences by copying them to a new sequence. 	Linear
includes() 	Determines if every element from one sorted sequence is in another sorted sequence. 	Linear
set_union()
set_intersection()
set_difference()
set_symmetric_difference() 	Performs the specified set operation on two sorted sequences, copying results to a third sorted sequence.

    + heap algorithm, A heap is a standard data structure in which the elements of an array or sequence are ordered in a semi-sorted fashion, so that finding the “top” element is quick. 
    
is_heap() 	Checks if a range of elements is a heap. 	Linear
is_heap_until() 	Finds the largest subrange in the given range of elements that is a heap. 	Linear
make_heap() 	Creates a heap from a range of elements. 	Linear
push_heap()
pop_heap() 	Adds an element to, or removes an element from a heap. 	Logarithmic
sort_heap() 	Converts a heap into a range of ascending sorted elements. 	Linear logarithmic

    + minimum/maximum algorithm 
    
clamp() 	Makes sure a value (v) is between a given minimum (lo) and maximum (hi). Returns a reference to lo if v < lo; returns a reference to hi if v > hi; otherwise returns a reference to v.
min()
max() 	Returns the minimum or maximum of two or more values.
minmax() 	Returns the minimum and maximum of two or more values as a pair.
min_element()
max_element() 	Returns the minimum or maximum element in a sequence.
minmax_element() 	Returns the minimum and maximum element in a sequence as a pair.

    + numerical processing algorithms 

iota() 	Fills a sequence with successively incrementing values starting with a given value.
        * cpp17 
gcd() 	Returns the greatest common divisor of two integer types.
lcm() 	Returns the least common multiple of two integer types.
adjacent_difference() 	Generates a new sequence in which each element is the difference (or other binary operation) of the second and first of each adjacent pair of elements in the source sequence.
partial_sum() 	Generates a new sequence in which each element is the sum (or other binary operation) of an element and all its preceding elements in the source sequence.
exclusive_scan()
inclusive_scan() 	These are similar to partial_sum(). An inclusive scan is identical to a partial sum if the given summation operation is associative. However, inclusive_scan() sums in a non-deterministic order, while partial_sum() left to right, so for non-associative summation operations the result of the former is non-deterministic. The exclusive_scan() algorithm also sums in a non-deterministic order.
For inclusive_scan(), the ith element is included in the ith sum, just as for partial_sum(). For exclusive_scan(), the ith element is not included in the ith sum.
transform_exclusive_scan()
transform_inclusive_scan() 	Applies a transformation to each element in a sequence, then performs an exclusive/inclusive scan.
accumulate() 	“Accumulates” the values of all the elements in a sequence. The default behavior is to sum the elements, but the caller can supply a different binary function instead.
inner_product() 	Similar to accumulate(), but works on two sequences. This algorithm calls a binary function (multiplication by default) on parallel elements in the sequences, accumulating the result using another binary function (addition by default). If the sequences represent mathematical vectors, the algorithm calculates the dot product of the vectors.
reduce() 	Similar to accumulate(), but supports parallel execution. The order of evaluation for reduce() is non-deterministic, while it’s from left to right for accumulate(). This means that the behavior of the former is non-deterministic if the given binary operation is not associative or not commutative.
transform_reduce() 	Applies a transformation to each element in a sequence, then performs a reduce().

    + permutation algorithms, A permutation of a sequence contains the same elements but in a different order. 

is_permutation() 	Returns true if the elements in one range are a permutation of the elements in another range. 	Quadratic
next_permutation()
prev_permutation() 	Modifies the sequence by transforming it into its “next” or “previous” lexicographical permutation. Successive calls to one or the other will permute the sequence into all possible permutations of its elements, if you start with a properly sorted sequence. This algorithm returns false if no more permutations exist.

- two examples of missing functionality in STL 

The Standard Library does not guarantee any thread safety for accessing containers simultaneously from multiple threads.
The Standard Library does not provide any generic tree or graph structures. 


# Understanding containers and iterators 
- class template, and the ref() and cref() function templates are defined in the <functional> header. 

- elements in containers using the default allocator and comparator are shown in the following table

copy constructor 

move constructor 

assignment operator 

move assignment operator 

destructor 

default constructor 

operator == 

operator < 

- Iterators

The Standard Library uses the iterator pattern to provide a generic abstraction for accessing the elements of a container. 

- The standard defines five categories of iterators, as summarized in the following table.

input 

ouput 

forward 

bidirectional 

random access 

use std::distance() to compute the distance between two iterators of a container.

a const iterator for a vector of ints has as type std::vector<int>::const_iterator.

- vector, deque, list, forward_list, and array are called sequential containers.

vector 

template <class T, class Allocator = allocator<T>> class vector;

constructors and destructors 

vector<int> intVector; // Creates a vector of ints with zero elements

vector<int> intVector({ 1, 2, 3, 4, 5, 6 });

intVector.assign({ 1, 2, 3, 4 }); //copy assignment 

Comparing two vectors with operator== or operator!= requires the individual elements to be comparable with operator==.

with operator<, operator>, operator<=, or operator>= requires the individual elements to be comparable with operator<

    + iterate 
    
for (vector<double>::iterator iter = begin(doubleVector); iter != end(doubleVector); ++iter) {
    *iter /= max;
    cout << *iter << " ";
}

for (auto iter = begin(doubleVector); iter != end(doubleVector); ++iter) {
    *iter /= max;
    cout << *iter << " ";
}

vector<string> stringVector(10, "hello");
for (auto& str : stringVector) {
    str.append(" there");
}

    + const iterator 
    
vector<type>::const_iterator it = begin(myVector);

vector<string> stringVector(10, "hello");
for (auto iter = begin(stringVector); iter != end(stringVector); ++iter) {
    cout << *iter << endl;
}

vector<string> stringVector(10, "hello");
for (auto iter = begin(stringVector); iter != end(stringVector); ++iter) {
    cout << *iter << endl;
}

vector<string> stringVector(10, "hello");
for (auto iter = cbegin(stringVector); iter != cend(stringVector); ++iter) {
    cout << *iter << endl;
}

    + Generally, iterators are about as safe as pointers—that is, extremely unsafe. 

Recall that the iterator returned by end() is one element past the end of a vector, not an iterator referring to the last element! 
```
vector<int> intVector;
auto iter = end(intVector);
*iter = 10; // BUG! iter doesn't refer to a valid element.
```

use mismatched iterators. For example, the following for loop initializes an iterator from vectorTwo, and tries to compare it to the end iterator of vectorOne
```
vector<int> vectorOne(10);
vector<int> vectorTwo(10);

// Fill in the vectors.

// BUG! Possible infinite loop
for (auto iter = begin(vectorTwo); iter != end(vectorOne); ++iter) {
    // Loop body
}
```

    + The vector iterator is random access, which means that you can move it backward or forward

vector<int> intVector(10);
auto it = begin(intVector);
it += 5;
--it;
*it = 4;

    + Storing references in a vector, store std::reference_wrappers in the container. The std::ref() and cref() function templates are used to create non-const and const reference_wrapper instances. 
    
```
string str1 = "Hello";
string str2 = "World";

// Create a vector of references to strings.
vector<reference_wrapper<string>> vec{ ref(str1) };
vec.push_back(ref(str2));  // push_back() works as well.

// Modify the string referred to by the second reference in the vector.
vec[1].get() += "!";

// The end result is that str2 is actually modified.
cout << str1 << " " << str2 << endl;
```

    + adding and removing elements, an element to a vector with the push_back() method. The vector provides a parallel remove method called pop_back().

    erase() and the following versions of insert():

    insert(const_iterator pos, const T& x): the value x is inserted at position pos.
    insert(const_iterator pos, size_type n, const T& x): the value x is inserted n times at position pos.
    insert(const_iterator pos, InputIterator first, InputIterator last): the elements in the range [first, last) are inserted at position pos.

```
vector<int> vectorOne = { 1, 2, 3, 5 };
vector<int> vectorTwo;

// Oops, we forgot to add 4. Insert it in the correct place
vectorOne.insert(cbegin(vectorOne) + 3, 4);

// Add elements 6 through 10 to vectorTwo
for (int i = 6; i <= 10; i++) {
    vectorTwo.push_back(i);
}
printVector(vectorOne);
printVector(vectorTwo);

// Add all the elements from vectorTwo to the end of vectorOne
vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));
printVector(vectorOne);

// Now erase the numbers 2 through 5 in vectorOne
vectorOne.erase(cbegin(vectorOne) + 1, cbegin(vectorOne) + 5);
printVector(vectorOne);

// Clear vectorTwo entirely
vectorTwo.clear();

// And add 10 copies of the value 100
vectorTwo.insert(cbegin(vectorTwo), 10, 100);

// Decide we only want 9 elements
vectorTwo.pop_back();
printVector(vectorTwo);
```

- move sementics 

Without move semantics, assigning the result of createVectorOfSize() to myVector calls the copy assignment operator.
```
vector<int> createVectorOfSize(size_t size)
{
    vector<int> vec(size);
    int contents = 0;
    for (auto& i : vec) {
        i = contents++;
    }
    return vec;
}
…
vector<int> myVector;
myVector = createVectorOfSize(123);
```

push_back() makes a copy of myElement and puts it in the vector.

push_back(T&& val), which is the move equivalent of push_back(const T& val)

vec.push_back(move(myElement));

//The preceding call to push_back() triggers a call to the move version because the call to the string constructor results in a temporary object
vec.push_back(string(5, "a"));

- emplace operations 

An example is emplace_back() on a vector object, which does not copy or move anything. Instead, it makes space in the container and constructs the object in place

emplace_back(). The difference in performance between emplace_back() and push_back() using move semantics depends on how your specific compiler implements

```
vec.push_back(string(5, 'a'));
// Or
vec.emplace_back(5, 'a');
```

C++17, the emplace_back() method returns a reference to the inserted element. Before C++17, the return type of emplace_back() was void.
 
-  vector size() and capacity()

C++17 introduces non-member std::size() and std::empty() global functions. These are similar to the non-member functions that are available to get iterators

- directly accessing the data 

C++17 introduces a non-member std::data() global function that can be used to get a pointer to the data.

- vector example 

```
// Class template RoundRobin
// Provides simple round-robin semantics for a list of elements.
template <typename T>
class RoundRobin
{
    public:
        // Client can give a hint as to the number of expected elements for
        // increased efficiency.
        RoundRobin(size_t numExpected = 0);
        virtual ~RoundRobin() = default;

        // Prevent assignment and pass-by-value
        RoundRobin(const RoundRobin& src) = delete;
        RoundRobin& operator=(const RoundRobin& rhs) = delete;

        // Explicitly default a move constructor and move assignment operator
        RoundRobin(RoundRobin&& src) = default;
        RoundRobin& operator=(RoundRobin&& rhs) = default;

        // Appends element to the end of the list. May be called
        // between calls to getNext().
        void add(const T& element);

        // Removes the first (and only the first) element
        // in the list that is equal (with operator==) to element.
        // May be called between calls to getNext().
        void remove(const T& element);

        // Returns the next element in the list, starting with the first,
        // and cycling back to the first when the end of the list is
        // reached, taking into account elements that are added or removed.
        T& getNext();
    private:
        std::vector<T> mElements;
        typename std::vector<T>::iterator mCurrentElement;
};
```

- the vector<bool> specification 

The C++ standard requires a partial specialization of vector for bools, with the intention that it optimizes space allocation by “packing” the Boolean values. 

Even worse, accessing and modifying elements in a vector<bool> is much slower than, for example, in a vector<int>. Many C++ experts recommend avoiding vector<bool> in favor of the bitset.

use something like vector<std::int_fast8_t> or vector<unsigned char>. The std::int_fast8_t type is defined in <cstdint>

supports cbegin(), cend(), rbegin(), rend(), crbegin(), and crend().

- A Network Packet Buffer

When two computers communicate over a network, they send information to each other divided up into discrete chunks called packets.

- A priority queue is a queue that keeps its elements in sorted order. Instead of a strict FIFO ordering

- pair<int, double> aPair = make_pair(5, 10.10);

C++17 introduces template parameter deduction for constructors

auto aThirdPair = pair(5, 10.10);

- map 

map<string, int> m = {
    { "Marc G.", 123 },
    { "Warren B.", 456 },
    { "Peter V.W.", 789 }
};

map<int, Data> dataMap;

auto ret = dataMap.insert({ 1, Data(4) });   // Using an initializer_list
if (ret.second) {
    cout << "Insert succeeded!" << endl;
} else {
    cout << "Insert failed!" << endl;
}

ret = dataMap.insert(make_pair(1, Data(6))); // Using a pair object
if (ret.second) {
    cout << "Insert succeeded!" << endl;
} else {
    cout << "Insert failed!" << endl;
}

pair<map<int, Data>::iterator, bool> ret;

if (auto [iter, success] = dataMap.insert({ 1, Data(4) }); success) {
    cout << "Insert succeeded!" << endl;
} else {
    cout << "Insert failed!" << endl;
}

ret = dataMap.insert_or_assign(1, Data(7));
if (ret.second) {
    cout << "Inserted." << endl;
} else {
    cout << "Overwritten." << endl;
} 

map<int, Data> dataMap;
dataMap[1] = Data(4);
dataMap[1] = Data(6); // Replaces the element with key 1

for (auto iter = cbegin(dataMap); iter != cend(dataMap); ++iter) {
    cout << iter->second.getValue() << endl;
}

for (const auto& [key, data] : dataMap) {
    cout << data.getValue() << endl;
}

for (const auto& p : dataMap) {
    cout << p.second.getValue() << endl;
}

- looking up elements 

map<int, Data> dataMap;
dataMap[1] = Data(4);
dataMap[1] = Data(6);
dataMap[1].setValue(100);

- removing elements 

map<int, Data> dataMap;
dataMap[1] = Data(4);
cout << "There are " << dataMap.count(1) << " elements with key 1" << endl;
dataMap.erase(1);
cout << "There are " << dataMap.count(1) << " elements with key 1" << endl;

map<int, Data> dataMap2;
auto extractedNode = dataMap.extract(1);
dataMap2.insert(std::move(extractedNode));

map<int, int> src = { {1, 11}, {2, 22} };
map<int, int> dst = { {2, 22}, {3, 33}, {4, 44}, {5, 55} };
dst.merge(src);

- other containers 

including standard C-style arrays, strings, streams, and bitset.

istream_iterator and ostream_iterator that allow you to “iterate” through input and output streams. 

    + A bitset, defined in <bitset>, is templatized on the number of bits it stores. 
```
bitset<10> myBitset;

myBitset.set(3);
myBitset.set(6);
myBitset[8] = true;
myBitset[9] = myBitset[3];

if (myBitset.test(3)) {
    cout << "Bit 3 is set!"<< endl;
}
cout << myBitset << endl;
```


# Mastering standard library algorithms 
- performing error checking on stream input 

#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main()
{
    int num;
    vector<int> myVector;
    while (true) {
        cout << "Enter a number to add (0 to stop): ";
        cin >> num;
        if (num == 0) {
            break;
        }
        myVector.push_back(num);
    }

    while (true) {
        cout << "Enter a number to lookup (0 to stop): ";
        cin >> num;
        if (num == 0) {
            break;
        }
        auto endIt = cend(myVector);
        auto it = find(cbegin(myVector), endIt, num);
        if (it == endIt) {
            cout << "Could not find " << num << endl;
        } else {
            cout << "Found " << *it << endl;
        }
    }
    return 0;
}

auto it = find_if(cbegin(myVector), endIt, [](int i){ return i >= 100; });

- std::function, defined in the <functional> header file, can be used to create a type that can point to a function, a function object, or a lambda expression

std::function<R(ArgTypes…)>

void func(int num, const string& str)
{
    cout << "func(" << num << ", " << str << ")" << endl;
}

int main()
{
    function<void(int, const string&)> f1 = func;
    f1(1, "test");
    return 0;
}

    + using find_if() 
    
bool isEven(int num)
{
    return num % 2 == 0;
}

int main()
{
    vector<int> vec{ 1,2,3,4,5,6,7,8,9 };

    function<bool(int)> fcn = isEven;
    auto result = find_if(cbegin(vec), cend(vec), fcn);
    if (result != cend(vec)) {
        cout << "First even number: " << *result << endl;
    } else {
        cout << "No even number found." << endl;
    }
    return 0;
}

    + using raw function pointer 
    
void process(const vector<int>& vec, function<void(int)> f)
{
    for (auto& i : vec) {
        f(i);
    }
}

void print(int num)
{
    cout << num << "  ";
}

int main()
{
    vector<int> vec{ 0,1,2,3,4,5,6,7,8,9 };

    process(vec, print);
    cout << endl;

    int sum = 0;
    process(vec, [&sum](int num){sum += num;});
    cout << "sum = " << sum << endl;
    return 0;
}

template <typename F>
void processTemplate(const vector<int>& vec, F f)
{
    for (auto& i : vec) {
        f(i);
    }
}

- lambda expression 

auto basicLambda = []{ cout << "Hello from Lambda" << endl; };
basicLambda();

auto parametersLambda = [](int value){ cout << "The value is " << value << endl; };
parametersLambda(42);

double data = 1.23;
auto capturingLambda = [data]{ cout << "Data = " << data << endl; };

double data = 1.23;
auto capturingLambda = [&data]{ data *= 2; };

[=] captures all variables by value
[&] captures all variables by reference

[&x] captures only x by reference and nothing else.
[x] captures only x by value and nothing else.
[=, &x, &y] captures by value by default, except variables x and y, which are captured by reference.
[&, x] captures by reference by default, except variable x, which is captured by value.
[&x, &x] is illegal because identifiers cannot be repeated.
[this] captures the current object. In the body of the lambda expression you can access this object, even without using this->.

    + cpp17 

[*this] captures a copy of the current object


[capture_block](parameters) mutable constexpr
    noexcept_specifier attributes
    -> return_type {body}
    
    + generic lambda 

// Define a generic lambda to find values > 100.
auto isGreaterThan100 = [](auto i){ return i > 100; };

// Use the generic lambda with a vector of integers.
vector<int> ints{ 11, 55, 101, 200 };
auto it1 = find_if(cbegin(ints), cend(ints), isGreaterThan100);
if (it1 != cend(ints)) {
    cout << "Found a value > 100: " << *it1 << endl;
}

// Use exactly the same generic lambda with a vector of doubles.
vector<double> doubles{ 11.1, 55.5, 200.2 };
auto it2 = find_if(cbegin(doubles), cend(doubles), isGreaterThan100);
if (it2 != cend(doubles)) {
    cout << "Found a value > 100: " << *it2 << endl;
}

double pi = 3.1415;
auto myLambda = [myCapture = "Pi: ", pi]{ cout << myCapture << pi; };

    + it is possible to capture it by moving, as in this example:

auto myPtr = std::make_unique<double>(3.1415);
auto myLambda = [p = std::move(myPtr)]{ cout << *p; };

    + lambda as return type 
    
auto multiplyBy2Lambda(int x)
{
    return [x]{ return 2 * x; };
}

function<int(void)> fn = multiplyBy2Lambda(5);
cout << fn() << endl;

//x is not exist when lambda is executed 
auto multiplyBy2Lambda(int x)
{
    return [&x]{ return 2 * x; }; // BUG!
}

//good 
auto multiplyBy2Lambda(int x)
{
    return [x]{ return 2 * x; };
}

- Standard Library algorithms: count_if() and generate()

vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int value = 3;
int cnt = count_if(cbegin(vec), cend(vec),
                   [value](int i){ return i > value; });
cout << "Found " << cnt << " values > " << value << endl;

The generate() algorithm requires an iterator range and replaces the values in that range with the values returned from the function given as a third argument. 

- function objects 

call operator in a class such that objects of the class can be used in place of function pointers. These objects are called function objects

Your <functional> header might also contain functions like bind1st(), bind2nd(), mem_fun(), mem_fun_ref(), and ptr_fun(). These functions have officially been removed from the C++17 standard

    + arithmetic function objects 
```
plus<int> myPlus;
int res = myPlus(4, 5);
cout << res << endl;
```

arithmetic function objects is that you can pass them as callbacks to algorithms
```
double geometricMean(const vector<int>& nums)
{
    double mult = accumulate(cbegin(nums), cend(nums), 1, multiplies<int>());
    return pow(mult, 1.0 / nums.size());
}
```

    + transparent operator functors, allow you to omit the template type 
    
    specify multiplies<>() instead of multiplies<int>()
    
```    
double geometricMeanTransparent(const vector<int>& nums)
{
    double mult = accumulate(cbegin(nums), cend(nums), 1, multiplies<>());
    return pow(mult, 1.0 / nums.size());
}
```

    + comparison function objects 
    
    standard comparisons: equal_to, not_equal_to, less, greater, less_equal, and greater_equal.
    ```
    priority_queue<int, vector<int>, greater<>> myQueue;
    ```

    + logical function objects 
    
    logical_not (operator!), logical_and (operator&&), and logical_or (operator||). These logical operations deal only with the values true and false
    
```
bool allTrue(const vector<bool>& flags)
{
    return accumulate(begin(flags), end(flags), true, logical_and<>());
}
```

    + bitwise function objects 

    bitwise operations: bit_and (operator&), bit_or (operator|), bit_xor (operator^), and bit_not (operator~)

    + adaptor function objects 

    The adaptor function objects attempt to rectify this problem and others. They allow you to adapt function objects, lambda expressions, function pointers, basically any callable.

    + binders 

    Binders can be used to bind parameters of callables to certain values. Arguments that are not bound to specific values should be specified as _1, _2, _3, and so on.

```
string myString = "abc";
auto f1 = bind(func, placeholders::_1, myString);
f1(16);
```
func(16, abc)

    can also be used to switch parameter positions 
```
auto f2 = bind(func, placeholders::_2, placeholders::_1);
f2("Test", 32);
```

Using std::ref() to pass a proper reference correctly increments index
```
void increment(int& value) { ++value; }

int index  = 0;
auto incr = bind(increment, ref(index));
incr();
```

bind to overload functions 
```
void overloaded(int num) {}
void overloaded(float f) {}

auto f3 = bind(overloaded, placeholders::_1); // ERROR
auto f4 = bind((void(*)(float))overloaded, placeholders::_1); // OK

// Code for inputting scores into the vector omitted, similar as earlier.
auto endIter = end(myVector);
auto it = find_if(begin(myVector), endIter,
    bind(greater_equal<>(), placeholders::_1, 100));
if (it == endIter) {
    cout << "No perfect scores" << endl;
} else {
    cout << "Found a \"perfect\" score of " << *it << endl;
}

auto it = find_if(begin(myVector), endIter, [](int i){ return i >= 100; });
```

Negators are similar to binders but they complement the result of a callable. 
```
// Code for inputting scores into the vector omitted, similar as earlier.
auto endIter = end(myVector);
auto it = find_if(begin(myVector), endIter, not_fn(perfectScore));
if (it == endIter) {
    cout << "All perfect scores" << endl;
} else {
    cout << "Found a \"less-than-perfect\" score of " << *it << endl;
}
```

find_if_not() algorithm.
```
auto it = find_if(begin(myVector), endIter, [](int i){ return i < 100; });
```

The std::not_fn() adaptor is introduced with C++17. Before C++17 you could use the std::not1() and not2() adaptors. 
```
// Code for inputting scores into the vector omitted, similar as earlier.
auto endIter = end(myVector);
function<bool(int)> f = perfectScore;
auto it = find_if(begin(myVector), endIter, not1(f));
```

use not1() with your own functor class, then you had to make sure your functor class definition included two typedefs: argument_type and result_type

use not2(), then your functor class definition had to provide three  your functor class definition had to provide three typedefs: first_argument_type, second_argument_type, and result_type. 
The easiest way to do that was to derive your function object class from either unary_function or binary_function
```
class PerfectScore : public std::unary_function<int, bool>
{
    public:
        result_type operator()(const argument_type& score) const
        {
            return score >= 100;
        }
};

auto it = find_if(begin(myVector), endIter, not1(PerfectScore()));
```

not1() and not2() have been deprecated by the C++17 standard. 

    + calling member functions 

if you just pass a pointer to string::empty() to find_if(), the algorithm has no way to know that it received a pointer to a method instead of a normal function pointer or functor. 

C++ provides a conversion function called mem_fn() that you can call with a method pointer before passing it to an algorithm

```
void findEmptyString(const vector<string>& strings)
{
    auto endIter = end(strings);
    auto it = find_if(begin(strings), endIter, mem_fn(&string::empty));
    if (it == endIter) {
        cout << "No empty strings!" << endl;
    } else {
        cout << "Empty string at position: "
             << static_cast<int>(it - begin(strings)) << endl;
    }
}

//using lambda 
void findEmptyString(const vector<string>& strings)
{
    auto endIter = end(strings);
    auto it = find_if(begin(strings), endIter,
        [](const string& str){ return str.empty(); });
    // Remainder of function omitted because it is the same as earlier
}

using a container pointer 
void findEmptyString(const vector<string*>& strings)
{
    auto endIter = end(strings);
    auto it = find_if(begin(strings), endIter,
        [](const string* str){ return str->empty(); });
    // Remainder of function omitted because it is the same as earlier
}
```

    + C++17 introduces std::invoke(), defined in <functional>, which you can use to call any callable object with a set of parameters.

```
void printMessage(string_view message) { cout << message << endl; }

int main()
{
    invoke(printMessage, "Hello invoke.");
    invoke([](const auto& msg) { cout << msg << endl; }, "Hello invoke.");
    string msg = "Hello invoke.";
    cout << invoke(&string::size, msg) << endl;
}
```

    + write your own function objects 
```
class myIsDigit
{
    public:
        bool operator()(char c) const { return ::isdigit(c) != 0; }
};

bool isNumber(string_view str)
{
    auto endIter = end(str);
    auto it = find_if(begin(str), endIter, not_fn(myIsDigit()));
    return (it == endIter);
}
```

If you need stateful predicates for other algorithms, wrap your predicate in an std::reference_wrapper which you can create using std::ref().

    + use member function pointer directly 
```
class A {
public:
 int f();
 int (A::*x)(); // <- declare by saying what class it is a pointer to
};

int A::f() {
 return 1;
}


int main() {
 A a;
 a.x = &A::f; // use the :: syntax
 printf("%d\n",(a.*(a.x))()); // use together with an object of its class
}
```

- algorithm details 

all available Standard Library algorithms, divided into different categories. Most of the algorithms are defined in the <algorithm> header file

<algorithm> header file, but a few are located in <numeric> and in <utility>

- Iterators

InputIterator, OutputIterator, ForwardIterator, BidirectionalIterator, and RandomAccessIterator. These names are just names: they don’t provide binding type checking

- non-modifying sequence algorithms

two search algorithms: find() and find_if()

```
// The list of elements to be searched
vector<int> myVector = { 5, 6, 9, 8, 8, 3 };
auto beginIter = cbegin(myVector);
auto endIter = cend(myVector);

// Find the first element that does not satisfy the given lambda expression
auto it = find_if_not(beginIter, endIter, [](int i){ return i < 8; });
if (it != endIter) {
    cout << "First element not < 8 is " << *it << endl;
}

```

- specialized searchers 

three options: default_searcher, boyer_moore_searcher, or boyer_moore_horspool_searcher, all defined in <functional>. The last two options implement the well-known Boyer-Moore and Boyer-Moore-Horspool search algorithms. These are very efficient, and can be used to find a substring in a larger piece of text. 

```
string text = "This is the haystack to search a needle in.";
string toSearchFor = "needle";
auto searcher = std::boyer_moore_searcher(
    cbegin(toSearchFor), cend(toSearchFor));
auto result = search(cbegin(text), cend(text), searcher);
if (result != cend(text)) {
    cout << "Found the needle." << endl;
} else {
    cout << "Needle not found." << endl;
}
```
boyer-moore-horspool search algorithm, pattern not found, O(N+M), pattern found(NM)

- comparison algorithms 

three different ways: equal(), mismatch(), and lexicographical_compare(). 

equal() returns true if all corresponding elements are equal. 

mismatch() returns iterators, one iterator for each range, to indicate where in the range the corresponding elements mismatch.

lexicographical_compare()returns true if the first unequal element in the first range is less than its corresponding element in the second range

```
    // Compare the two containers
    if (equal(cbegin(myVector), cend(myVector),
              cbegin(myList), cend(myList))) {
        cout << "The two containers have equal elements" << endl;
    } else {
    // If the containers were not equal, find out why not
        auto miss = mismatch(cbegin(myVector), cend(myVector),
                             cbegin(myList), cend(myList));
        cout << "The following initial elements are the same in "
            << "the vector and the list:" << endl;
        for (auto i = cbegin(myVector); i != miss.first; ++i) {
            cout << *i << '\t';
        }
        cout << endl;
    }

    // Now order them.
    if (lexicographical_compare(cbegin(myVector), cend(myVector),
                                cbegin(myList), cend(myList))) {
        cout << "The vector is lexicographically first." << endl;
    } else {
        cout << "The list is lexicographically first." << endl;
    }
    return 0;
```

- counting algorithm 

counting algorithms are all_of(), any_of(), none_of(), count(), and count_if()
 
```
// all_of()
vector<int> vec2 = { 1, 1, 1, 1 };
if (all_of(cbegin(vec2), cend(vec2), [](int i){ return i == 1; })) {
    cout << "All elements are == 1" << endl;
} else {
    cout << "Not all elements are == 1" << endl;
}
```
- modifying sequence algorithms 

Ranges from maps and multimaps cannot be used as destinations of modifying algorithms. 

transform, A first version of the transform() algorithm applies a callback to each element in a range and expects the callback to generate a new element

```
transform(begin(myVector), end(myVector), begin(myVector),
    [](int i){ return i + 100;});
```

The copy() algorithm allows you to copy elements from one range to another, starting with the first element and proceeding to the last element in the range. 
```
copy(cbegin(vec1), cend(vec1), begin(vec2));

copy_backward(cbegin(vec1), cend(vec1), end(vec2));

auto endIterator = copy_if(cbegin(vec1), cend(vec1),
         begin(vec2), [](int i){ return i % 2 == 0; });
         
copy_n(cbegin(vec1), cnt, begin(vec2));
```

two move-related algorithms: move() and move_backward(). They both use move semantics
```
move(begin(vecSrc), end(vecSrc), begin(vecDst));
```

The replace() and replace_if() algorithms replace elements in a range matching a value or predicate
Its first and second parameters specify the range of elements in your container. 
The third parameter is a function or lambda expression that returns true or false. If it returns true, the value in the container is replaced with the value given as fourth parameter;
```
replace_if(begin(vec), end(vec), [](int i){ return i % 2 != 0; }, 0);
```

remove elements matching a certain condition. 
```
    auto it = remove_if(begin(strings), end(strings),
        [](const string& str){ return str.empty(); });
```

The unique() algorithm is a special case of remove() that removes all duplicate contiguous elements. The basic form of unique() runs in place, but there is also a version of the algorithm called unique_copy() that copies its results to a new destination range.

sample() algorithm returns a selection of n randomly chosen elements from a given source range and stores them in a destination range. 
```
returns a selection of n randomly chosen elements from a given source range and stores them in a destination range. 
```

The reverse() algorithm reverses the order of the elements in a range. 

shuffle() rearranges the elements of a range in a random order with a linear complexity. 

- operational algorithms 

The for_each_n() algorithm requires a begin iterator of the range, the number of elements to iterate over, and a function callback. It returns an iterator equal to begin + n.

```
for_each(cbegin(myMap), cend(myMap), [](const auto& p)
    { cout << p.first << "->" << p.second << endl; });
    
for_each_n(cbegin(myMap), 2, [](const auto& p)
    { cout << p.first << "->" << p.second << endl; });
```

- swap and exchange algorithms 
```
swap(a, b);

int returnedValue = exchange(a, b);
```

exchange() is useful in implementing move assignment operators. A move assignment operator needs to move the data from a source object to a destination object

```
mPtr = exchange(rhs.mPtr, nullptr); // Move + nullify
```

- partition algorithms 

partition_copy() copies elements from a source to two different destinations. The specific destination for each element is selected based on the result of a predicate, either true or false

```
auto pairIters = partition_copy(cbegin(vec1), cend(vec1),
    begin(vecEven), begin(vecOdd),
    [](int i){ return i % 2 == 0; });
```

- sorting algorithm 

A variant of sort(), called stable_sort(), maintains the relative order of equal elements in a range
```
sort(begin(vec), end(vec), greater<>());
```

- binary search 

These algorithms are binary_search(), lower_bound(), upper_bound(), and equal_range().

- set algorithm 

The set_union(), set_intersection(), set_difference(), and set_symmetric_difference() algorithms implement the standard semantics of those operations. 

```
if (includes(cbegin(vec1), cend(vec1), cbegin(vec2), cend(vec2))) {
    cout << "The second set is a subset of the first." << endl;
}

auto newEnd = set_union(cbegin(vec1), cend(vec1), cbegin(vec2),
    cend(vec2), begin(result));

newEnd = set_difference(cbegin(vec1), cend(vec1), cbegin(vec2),
    cend(vec2), begin(result));
```

the result is at most the minimum size of the two input ranges,

- minium/maxium algorithms 

std::clamp() is a little helper function, defined in <algorithm>, that you can use to make sure that a value (v) is between a given minimum (lo) and maximum (hi). 

The min() and max() algorithms compare two or more elements of any type using operator< or a user-supplied binary predicate

- parallel algorithm

C++17 adds support to more than 60 Standard Library algorithms for executing them in parallel to improve their performance. Examples include for_each(), all_of(), copy(), count_if(), find(), replace(), search(), sort(), transform(), and many more

- numerical processing 
inner_product(), defined in <numeric>, calculates the inner product of two sequences.
```
cout << inner_product(cbegin(v1), cend(v1), cbegin(v2), 0) << endl;
```

The iota() algorithm, defined in the <numeric> header file, generates a sequence of values in a specified range starting with a specified value and applying operator++

The gcd() algorithm returns the greatest common divisor, while lcm() returns the least common multiple of two integer types

std::accumulate() is one of the few algorithms that does not support parallel execution. Instead, you need to use the newly introduced std::reduce() algorithm to calculate a generalized sum with the option to execute it in parallel. 

use the generalized transform_reduce(), which has the option to execute in parallel

C++17 introduces four scan algorithms: exclusive_scan(), inclusive_scan(), transform_exclusive_scan(), and transform_inclusive_scan().

- the voter registration audit problem statement 


# String localization and regular expressions 
- localizing string literals 

cout << "Read " << n << " bytes" << endl;

cout << Format(IDS_TRANSFERRED, n) << endl;

IDS_TRANSFERRED could be defined as “Read $1 bytes”, while the Dutch version of the resource could be defined as “$1 bytes gelezen”.

- wide characters 

wchar_t that holds a wide character. Languages with non-ASCII (U.S.) characters

The C++ standard does not define a size for wchar_t. Some compilers use 16 bits while others use 32 bits. To write cross-platform code, it is not safe to assume that wchar_t is of a particular size.

```
wchar_t myWideCharacter = L'm';
```

wide-versions of cout, cin, cerr, and clog available, called wcout, wcin, wcerr, and wclog.
```
wcout << L"I am a wide-character string literal." << endl;
```

- avaliable character types 

char: Stores 8 bits. This type can be used to store ASCII characters

char16_t: Stores at least 16 bits. This type can be used as the basic building block for UTF-16 encoded, one Unicode character is encoded as one or two char16_ts.

char32_t: Stores at least 32 bits. This type can be used for storing UTF-32 encoded Unicode characters as one char32_t.

wchar_t: Stores a wide character of a compiler-specific size and encoding.

char16_t and char32_t instead of wchar_t is that the size of char16_t is guaranteed to be at least 16 bits, and the size of char32_t is guaranteed to be at least 32 bits, independent of the compiler

There is no minimum size guaranteed for wchar_t.

defines the following macros.

__STDC_UTF_32__: If defined by the compiler, then the type char32_t uses UTF-32 encoding. 

__STDC_UTF_16__: If defined by the compiler, then the type char16_t uses UTF-16 encoding. 

- string prefixes 

u8: A char string literal with UTF-8 encoding.

u: A char16_t string literal, which can be UTF-16 if __STDC_UTF_16__ is defined by the compiler.

U: A char32_t string literal, which can be UTF-32 if __STDC_UTF_32__ is defined by the compiler.

L: A wchar_t string literal with a compiler-dependent encoding.

```
const char* s1 = u8R"(Raw UTF-8 encoded string literal)";
const wchar_t* s2 = LR"(Raw wide string literal)";
const char16_t* s3 = uR"(Raw char16_t string literal)";
const char32_t* s4 = UR"(Raw char32_t string literal)";

const char* formula = u8"\u03C0 r\u00B2";
```

Besides the std::string class, there is also support for wstring, u16string, and u32string. 
```
using string = basic_string<char>;
using wstring = basic_string<wchar_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
```

- convert between char16_t/char32_t and multibyte characters, and vice versa: mbrtoc16, c16rtomb, mbrtoc32, and c32rtomb, The <locale> header defines the following four encoding conversion classes.

codecvt<char,char,mbstate_t>

codecvt<char16_t,char,mbstate_t>

codecvt<char32_t,char,mbstate_t>

codecvt<wchar_t,char,mbstate_t>

    + Before C++17, the following three code conversion facets were defined in <codecvt>: codecvt_utf8, codecvt_utf16, and codecvt_utf8_utf16. These could be used with two convenience conversion interfaces: wstring_convert and wbuffer_convert

- locals and facets 

    + using locales 
    The POSIX standard is to separate a language and an area into two-letter sections with an optional encoding. For example, the locale for the English language as spoken in the U.S. is en_US
    
    lang[_country_region[.code_page]]

    use the user’s locale for a stream by calling the imbue() method on the stream.

```
wcout.imbue(locale(""));
wcout << 32767 << endl;
```

string::npos when the given substring is not found.

```
locale loc("");
if (loc.name().find("en_US") == string::npos &&
    loc.name().find("en-US") == string::npos) {
    wcout << L"Welcome non-U.S. English speaker!" << endl;
} else {
    wcout << L"Welcome U.S. English speaker!" << endl;
}
```


ctype 	Character classification facets.
codecvt 	Conversion facets, see earlier in this chapter.
collate 	Comparing strings lexicographically.
time_get 	Parsing dates and times.
time_put 	Formatting dates and times.
num_get 	Parsing numeric values.
num_put 	Formatting numeric values.
numpunct 	Defines the formatting parameters for numeric values.
money_get 	Parsing monetary values.
money_put 	Formatting monetary values.
moneypunct 	Defines formatting parameters for monetary values.

- character classification 

The <locale> header contains the following character classification functions: std::isspace(), isblank(), iscntrl(), isupper(), islower(), isalpha(), isdigit(), ispunct(), isxdigit(), isalnum(), isprint(), isgraph(). They all accept two parameters: the character to classify, and the locale to use for the classification. 

bool result = isupper('A', locale(""));

- character conversion 

std::toupper() and tolower(). They accept two parameters: the character to convert, and the locale to use for the conversion.

Using Facets. 

use_facet<moneypunct<wchar_t>>(locale("en_GB"));

- regular expressions

ECMAScript: The grammar based on the ECMAScript standard.
basic: The basic POSIX grammar.
extended: The extended POSIX grammar.
awk: The grammar used by the POSIX awk utility.
grep: The grammar used by the POSIX grep utility.
egrep: The grammar used by the POSIX grep utility

library is in the <regex> header file and in the std namespace. 

basic_regex: An object representing a specific regular expression.
match_results: A substring that matched a regular expression
sub_match: An object containing a pair of iterators into the input sequence. 

The iterators can be any of the following:

const char*
const wchar_t*
string::const_iterator
wstring::const_iterator

```
using regex  = basic_regex<char>;
using wregex = basic_regex<wchar_t>;

using csub_match  = sub_match<const char*>;
using wcsub_match = sub_match<const wchar_t*>;
using ssub_match  = sub_match<string::const_iterator>;
using wssub_match = sub_match<wstring::const_iterator>;

using cmatch  = match_results<const char*>;
using wcmatch = match_results<const wchar_t*>;
using smatch  = match_results<string::const_iterator>;
using wsmatch = match_results<wstring::const_iterator>;

using cregex_iterator  = regex_iterator<const char*>;
using wcregex_iterator = regex_iterator<const wchar_t*>;
using sregex_iterator  = regex_iterator<string::const_iterator>;
using wsregex_iterator = regex_iterator<wstring::const_iterator>;

using cregex_token_iterator  = regex_token_iterator<const char*>;
using wcregex_token_iterator = regex_token_iterator<const wchar_t*>;
using sregex_token_iterator  = regex_token_iterator<string::const_iterator>;
using wsregex_token_iterator = regex_token_iterator<wstring::const_iterator>;

template<…>
bool regex_match(InputSequence[, MatchResults], RegEx[, Flags]);

regex r("\\d{4}/(?:0?[1-9]|1[0-2])/(?:0?[1-9]|[1-2][0-9]|3[0-1])");
while (true) {
    cout << "Enter a date (year/month/day) (q=quit): ";
    string str;
    if (!getline(cin, str) || str == "q")
        break;

    if (regex_match(str, r))
        cout << "  Valid date." << endl;
    else
        cout << "  Invalid date!" << endl;
}

const sregex_iterator end;
for (sregex_iterator iter(cbegin(str), cend(str), reg);
    iter != end; ++iter) {
    cout << "\"" << (*iter)[0] << "\"" << endl;
}

const sregex_token_iterator end;
for (sregex_token_iterator iter(cbegin(str), cend(str), reg);
    iter != end; ++iter) {
    cout << "\"" << *iter << "\"" << endl;
}
```

The previous section describes regex_iterator, which iterates through every matched pattern. In each iteration of the loop you get a match_results object, which you can use to extract subexpressions 



# Additional library utilities 
- The Ratio library allows you to exactly represent any finite rational number that you can use at compile time.

using r1 = ratio<1, 60>;

intmax_t num = r1::num;
intmax_t den = r1::den;

Remember that a ratio is a compile-time constant, which means that the numerator and denominator need to be known at compile time.

- The chrono library is a collection of classes that work with times. 
duration<long, ratio<1>> d1;

using nanoseconds  = duration<X 64 bits, nano>;
using microseconds = duration<X 55 bits, micro>;
using milliseconds = duration<X 45 bits, milli>;
using seconds      = duration<X 35 bits>;
using minutes      = duration<X 29 bits, ratio<60>>;
using hours        = duration<X 23 bits, ratio<3600>>;

- A clock is a class consisting of a time_point and a duration. 

// Get current time as a time_point
system_clock::time_point tpoint = system_clock::now();
// Convert to a time_t
time_t tt = system_clock::to_time_t(tpoint);
// Convert to local time
tm* t = localtime(&tt);
// Write the time to the console
cout << put_time(t, "%H:%M:%S") << endl;

- random number 

before c++11, C-style srand() and rand() functions.

```
srand(static_cast<unsigned int>(time(nullptr)));
cout << rand() << endl;
```

random number engine available:

random_device
linear_congruential_engine
mersenne_twister_engine
subtract_with_carry_engine

    + seudo-random number engines:

    The linear congruential engine requires a minimal amount of memory to store its state.

    + the Mersenne twister generates the highest quality of random numbers. The period of a Mersenne twister depends on an algorithmic parameter
    
    + The subtract with carry engine requires a state of around 100 bytes; 
    
```
template<class UIntType, size_t w, size_t n, size_t m, size_t r,
         UIntType a, size_t u, UIntType d, size_t s,
         UIntType b, size_t t, UIntType c, size_t l, UIntType f>
    class mersenne_twister_engine {...}
    
template<class Engine, size_t p, size_t r> class
    discard_block_engine {...}
template<class Engine, size_t w, class UIntType> class
    independent_bits_engine {...}
template<class Engine, size_t k> class
    shuffle_order_engine {...}
    
```

- std::optional, defined in <optional>, holds a value of a specific type, or nothing. It can be used for parameters of a function if you want to allow for values to be optional. 

```
optional<int> getData(bool giveIt)
{
    if (giveIt) {
        return 42;
    }
    return nullopt;  // or simply return {};
}

auto data1 = getData(true);
auto data2 = getData(false);
```

- std::variant, defined in <variant>, can hold a single value of one of a given set of types. When you define a variant, you have to specify the types it can potentially contain

class Foo { public: Foo() = delete; Foo(int) {} };
class Bar { public: Bar() = delete; Bar(int) {} };

int main()
{
    variant<Foo, Bar> v;
}

- std::any, defined in <any>, is a class that can contain a single value of any type. 

vector<any> v;
v.push_back(any(42));

- tuples, The std::pair class, defined in <utility> and introduced in Chapter 17, can store exactly two values

pair<int, string> p1(16, "Hello World");
pair<bool, float> p2(true, 0.123f);

    + cpp 17+
```
std::tuple t1(16, "Test"s, true);

tuple t1(16, "Test"s, true);
auto[i, str, b] = t1;
cout << "Decomposed: i = "
     << i << ", str = \"" << str << "\", b = " << b << endl;
```
If you want to decompose a tuple without structured bindings, you can use the std::tie() utility function, which generates a tuple of references. 

```
tuple<int, string, bool> t1(16, "Test", true);
int i = 0;
string str;
bool b = false;
cout << "Before: i = " << i << ", str = \"" << str << "\", b = " << b << endl;
tie(i, str, b) = t1;
```

Tuples also support the following comparison operators: ==, !=, <, >, <=, and >=

- std::make_from_tuple() constructs an object of a given type T, passing the elements of a given tuple as arguments to the constructor of T.

- std::apply() calls a given callable (function, lambda expression, function object, and so on)

int add(int a, int b) { return a + b; }
...
cout << apply(add, std::make_tuple(39, 3)) << endl;

- C++17 introduces a filesystem support library. Everything is defined in the <filesystem> header, and lives in the std::filesystem namespace. 

The basic component of the library is a path. A path can be an absolute or a relative path, and can include a filename or not.

```
path p1(LR"(D:\Foo\Bar)");
path p2(L"D:/Foo/Bar");
path p3(L"D:/Foo/Bar/MyFile.txt");
```

- directory entry 

A path just represents a directory or a file on a filesystem. A path may refer to a non-existing directory or file.

An entire collection of helper functions is available. For example, you can use copy() to copy files or directories, create_directory() to create a new directory on the filesystem
```
space_info s = space("c:\\");
cout << "Capacity: " << s.capacity << endl;
cout << "Free: " << s.free << endl;
```

directory iteration 
```
void processPath(const path& p)
{
    if (!exists(p)) {
        return;
    }

    auto begin = recursive_directory_iterator(p);
    auto end = recursive_directory_iterator();
    for (auto iter = begin; iter != end; ++iter) {
        const string spacer(iter.depth() * 2, ' ');

        auto& entry = *iter;

        if (is_regular_file(entry)) {
            cout << spacer << "File: " << entry;
            cout << " (" << file_size(entry) << " bytes)" << endl;
        } else if (is_directory(entry)) {
            std::cout << spacer << "Dir: " << entry << endl;
        }
    }
}
```


# Part IV mastering advanced features of C++ 
- allocators 

template <class T, class Allocator = allocator<T>> class vector;

Allocator class called allocator, which implements these methods as wrappers for operator new and operator delete.

- stream iterators 

ostream_iterator—an output stream iterator
istream_iterator—an input stream iterator

The ostream_iterator class writes elements using operator<<. ostreambuf_iterator and an istreambuf_iterator, but these are rarely used and are not further discussed here

    + ouitput stream iterator 

vector<int> myVector(10);
iota(begin(myVector), end(myVector), 1);   // Fill vector with 1,2,3...10

// Print the contents of the vector.
copy(cbegin(myVector), cend(myVector), ostream_iterator<int>(cout, " "));

    + input stream iterator 
    
cout << "Enter numbers separated by white space." << endl;
cout << "Press Ctrl+Z followed by Enter to stop." << endl;
istream_iterator<int> numbersIter(cin);
istream_iterator<int> endIter;
int sum = accumulate(numbersIter, endIter, 0);
cout << "Sum: " << sum << endl;

- iterator adaptors 

The Standard Library provides an std::reverse_iterator class template that iterates through a bidirectional or random access iterator in a reverse direction. 
```
for (auto iter = begin(collection); iter != end(collection); ++iter) {}

for (auto iter = rbegin(collection); iter != rend(collection); ++iter) {}

vector<int> myVector;
populateContainer(myVector);

int num;
cout << "Enter a number to find: ";
cin >> num;

auto it1 = find(begin(myVector), end(myVector), num);
auto it2 = find(rbegin(myVector), rend(myVector), num);
if (it1 != end(myVector)) {
}
```

- insert interators 

actually insert elements into a container: insert_iterator, back_insert_iterator, and front_insert_iterator. They are all templatized on a container type, and take the actual container reference in their constructor

```
vector<int> vectorOne, vectorTwo;
populateContainer(vectorOne);

back_insert_iterator<vector<int>> inserter(vectorTwo);
copy_if(cbegin(vectorOne), cend(vectorOne), inserter,
    [](int i){ return i != 100; });

copy(cbegin(vectorTwo), cend(vectorTwo), ostream_iterator<int>(cout, " "));
copy_if(cbegin(vectorOne), cend(vectorOne),
    back_inserter(vectorTwo), [](int i){ return i != 100; });
```

- move iterators 

move semantics, which can be used to prevent unnecessary copying in cases where you know that the source object will be destroyed after an assignment operation or copy construction. 


```
class MoveableClass
{
    public:
        MoveableClass() {
            cout << "Default constructor" << endl;
        }
        MoveableClass(const MoveableClass& src) {
            cout << "Copy constructor" << endl;
        }
        MoveableClass(MoveableClass&& src) noexcept {
            cout << "Move constructor" << endl;
        }
        MoveableClass& operator=(const MoveableClass& rhs) {
            cout << "Copy assignment operator" << endl;
            return *this;
        }
        MoveableClass& operator=(MoveableClass&& rhs) noexcept {
            cout << "Move assignment operator" << endl;
            return *this;
        }
};

vector<MoveableClass> vecSource;
MoveableClass mc;
vecSource.push_back(mc);
vecSource.push_back(mc);

vector<MoveableClass> vecTwo(make_move_iterator(begin(vecSource)),
                             make_move_iterator(end(vecSource)));
//cpp17                              
vector<MoveableClass> vecTwo(move_iterator(begin(vecSource)),
                             move_iterator(end(vecSource)));                         
```

- write a standard library 

Suppose that you want to find all the elements matching a predicate in a given range. The find() and find_if() algorithms are the most likely candidates

```
template <typename InputIterator, typename OutputIterator, typename Predicate>
OutputIterator find_all(InputIterator first, InputIterator last,
                        OutputIterator dest, Predicate pred);
                        
template <typename InputIterator, typename OutputIterator, typename Predicate>
OutputIterator find_all(InputIterator first, InputIterator last,
                        OutputIterator dest, Predicate pred)
{
    while (first != last) {
        if (pred(*first)) {
            *dest = first;
            ++dest;
        }
        ++first;
    }
    return dest;
}

vector<int> vec{ 3, 4, 5, 4, 5, 6, 5, 8 };
vector<vector<int>::iterator> matches;

find_all(begin(vec), end(vec), back_inserter(matches),
    [](int i){ return i == 5; });                        
```

- iterator traits 

additional information about their iterators. know the type of the elements referred to by the iterator in order to store temporary values

```
#include <iterator>

template <typename IteratorType>
void iteratorTraitsTest(IteratorType it)
{
   typename std::iterator_traits<IteratorType>::value_type temp;
   temp = *it;
   cout << temp << endl;
}

vector<int> v{ 5 };
iteratorTraitsTest(cbegin(v));

the variable temp in iteratorTraitsTest() is of type int. The output is 5.
```

- a basic hash map 

deletion, and lookup in the average case, linear in the worst case. Instead of storing elements in sorted order, a hash table hashes, or maps, each element to a particular bucket

hash function, The first choice when writing a hash_map is how to handle hash functions. 

```
// Calculate a hash by treating the key as a sequence
// of bytes and summing the ASCII values of the bytes.
template <typename T>
size_t hash<T>::operator()(const T& key) const
{
    const size_t bytes = sizeof(key);
    size_t sum = 0;
    for (size_t i = 0; i < bytes; ++i) {
        unsigned char b = *(reinterpret_cast<const unsigned char*>(&key) + i);
        sum += b;
    }
    return sum;
}

// A hash specialization for strings
template <>
class hash<std::string>
{
    public:
        size_t operator()(const std::string& key) const;
}; 

// Calculate a hash by summing the ASCII values of all characters.
size_t hash<std::string>::operator()(const std::string& key) const
{
    size_t sum = 0;
    for (auto c : key) {
        sum += static_cast<unsigned char>(c);
    }
    return sum;
}
```

- hash map interface 

```
template <typename Key, typename T, typename KeyEqual = std::equal_to<>,
    typename Hash = hash<Key>>
class hash_map
{
    public:
        using key_type = Key;
        using mapped_type = T;
        using value_type = std::pair<const Key, T>;

        virtual ~hash_map() = default;  // Virtual destructor

        // Throws invalid_argument if the number of buckets is illegal.
        explicit hash_map(const KeyEqual& equal = KeyEqual(),
            size_t numBuckets = 101, const Hash& hash = Hash());

        // Copy constructor
        hash_map(const hash_map<Key, T, KeyEqual, Hash>& src) = default;
        // Move constructor
        hash_map(hash_map<Key, T, KeyEqual, Hash>&& src) noexcept = default;

        // Copy assignment operator
        hash_map<Key, T, KeyEqual, Hash>& operator=(
            const hash_map<Key, T, KeyEqual, Hash>& rhs);
        // Move assignment operator
        hash_map<Key, T, KeyEqual, Hash>& operator=(
            hash_map<Key, T, KeyEqual, Hash>&& rhs) noexcept;

        // Inserts the key/value pair x.
        void insert(const value_type& x);

        // Removes the element with key k, if it exists.
        void erase(const key_type& k);

        // Removes all elements.
        void clear() noexcept;

        // Find returns a pointer to the element with key k.
        // Returns nullptr if no element with that key exists.
        value_type* find(const key_type& k);
        const value_type* find(const key_type& k) const;

        // operator[] finds the element with key k, or inserts an
        // element with that key if none exists yet. Returns a reference to
        // the value corresponding to that key.
        T& operator[] (const key_type& k);

        // Swaps two hash_maps.
        void swap(hash_map<Key, T, KeyEqual, Hash>& other) noexcept;
    private:
        // Implementation details not shown yet
};
```

- type alias and implementation 

using key_type = Key;
using mapped_type = T;
using value_type = std::pair<const Key, T>;

//add to the private defintion section 
private:
    using ListType = std::list<value_type>;
    std::vector<ListType> mBuckets;
    size_t mSize = 0;
    KeyEqual mEqual;
    Hash mHash;


// Construct mBuckets with the correct number of buckets.
template <typename Key, typename T, typename KeyEqual, typename Hash>
hash_map<Key, T, KeyEqual, Hash>::hash_map(
    const KeyEqual& equal, size_t numBuckets, const Hash& hash)
    : mBuckets(numBuckets), mEqual(equal), mHash(hash)
{
    if (numBuckets == 0) {
        throw std::invalid_argument("Number of buckets must be positive");
    }
}

- searching elements 

template <typename Key, typename T, typename KeyEqual, typename Hash>
std::pair<
    typename hash_map<Key, T, KeyEqual, Hash>::ListType::iterator, size_t>
        hash_map<Key, T, KeyEqual, Hash>::findElement(const key_type& k)
{

    // Hash the key to get the bucket.
    size_t bucket = mHash(k) % mBuckets.size();

    // Search for the key in the bucket.
    auto iter = find_if(begin(mBuckets[bucket]), end(mBuckets[bucket]),
        [this, &k](const auto& element) { return mEqual(element.first, k); });

    // Return a pair of the iterator and the bucket index.
    return std::make_pair(iter, bucket);
}

    + implement the find() method as a simple wrapper for findElement():

template <typename Key, typename T, typename KeyEqual, typename Hash>
typename hash_map<Key, T, KeyEqual, Hash>::value_type*
    hash_map<Key, T, KeyEqual, Hash>::find(const key_type& k)
{
    // Use the findElement() helper, and C++17 structured bindings.
    auto[it, bucket] = findElement(k);
    if (it == end(mBuckets[bucket])) {
        // Element not found -- return nullptr.
        return nullptr;
    }
    // Element found -- return a pointer to it.
    return &(*it);
}


template <typename Key, typename T, typename KeyEqual = std::equal_to<>,
    typename Hash = hash<Key>>
class hash_map
{
    public:
        using key_type = Key;
        using mapped_type = T;
        using value_type = std::pair<const Key, T>;
        using reference = value_type&;
        using const_reference = const value_type&;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using hash_map_type = hash_map<Key, T, KeyEqual, Hash>;
        // Remainder of class definition omitted for brevity
};

- writing an iterator 

Your iterator should generally provide overloaded operator* and operator->, plus some other operations depending on its specific behavior. As long as your iterator provides the basic iteration operations

define the const_hash_map_iterator class. The first thing to note is that each const_hash_map_iterator object is an iterator for a specific instantiation of the hash_map class. In order to provide this one-to-one mapping, the const_hash_map_iterator must also be a class template

```
template <typename HashMap>
class const_hash_map_iterator
{
    public:
        using value_type = typename HashMap::value_type;
        using difference_type = ptrdiff_t;
        using iterator_category = std::bidirectional_iterator_tag;
        using pointer = value_type*;
        using reference = value_type&;
        using list_iterator_type = typename HashMap::ListType::const_iterator;

        // Bidirectional iterators must supply a default constructor.
        // Using an iterator constructed with the default constructor
        // is undefined, so it doesn't matter how it's initialized.
        const_hash_map_iterator() = default;

        const_hash_map_iterator(size_t bucket, list_iterator_type listIt,
            const HashMap* hashmap);

        // Don't need to define a copy constructor or operator= because the
        // default behavior is what we want.

        // Don't need destructor because the default behavior
        // (not deleting mHashmap) is what we want!

        const value_type& operator*() const;

        // Return type must be something to which -> can be applied.
        // Return a pointer to a pair<const Key, T>, to which the compiler
        // will apply -> again.
        const value_type* operator->() const;

        const_hash_map_iterator<HashMap>& operator++();
        const_hash_map_iterator<HashMap> operator++(int);

        const_hash_map_iterator<HashMap>& operator--();
        const_hash_map_iterator<HashMap> operator--(int);

        // The following are ok as member functions because we don't
        // support comparisons of different types to this one.
        bool operator==(const const_hash_map_iterator<HashMap>& rhs) const;
        bool operator!=(const const_hash_map_iterator<HashMap>& rhs) const;
    protected:
        size_t mBucketIndex = 0;
        list_iterator_type mListIterator;
        const HashMap* mHashmap = nullptr;

        // Helper methods for operator++ and operator--
        void increment();
        void decrement();
};

template<typename HashMap>
const_hash_map_iterator<HashMap>::const_hash_map_iterator(size_t bucket,
    list_iterator_type listIt, const HashMap* hashmap)
    : mBucketIndex(bucket), mListIterator(listIt), mHashmap(hashmap)
{
}

// Return a reference to the actual element.
template<typename HashMap>
const typename const_hash_map_iterator<HashMap>::value_type&
    const_hash_map_iterator<HashMap>::operator*() const
{
    return *mListIterator;
}

// Return a pointer to the actual element, so the compiler can
// apply -> to it to access the actual desired field.
template<typename HashMap>
const typename const_hash_map_iterator<HashMap>::value_type*
    const_hash_map_iterator<HashMap>::operator->() const
{
    return &(*mListIterator);
}

// Behavior is undefined if mListIterator already refers to the past-the-end
// element, or is otherwise invalid.
template<typename HashMap>
void const_hash_map_iterator<HashMap>::increment()
{
    // mListIterator is an iterator into a single bucket. Increment it.
    ++mListIterator;

    // If we're at the end of the current bucket,
    // find the next bucket with elements.
    auto& buckets = mHashmap->mBuckets;
    if (mListIterator == end(buckets[mBucketIndex])) {
        for (size_t i = mBucketIndex + 1; i < buckets.size(); i++) {
            if (!buckets[i].empty()) {
                // We found a non-empty bucket.
                // Make mListIterator refer to the first element in it.
                mListIterator = begin(buckets[i]);
                mBucketIndex = i;
                return;
            }
        }
        // No more non-empty buckets. Set mListIterator to refer to the
        // end iterator of the last list.
        mBucketIndex = buckets.size() - 1;
        mListIterator = end(buckets[mBucketIndex]);
    }
}
```

- iterator type aliases and access methods 

```
template <typename Key, typename T, typename KeyEqual = std::equal_to<>,
    typename Hash = hash<Key>>
class hash_map
{
    public:
        // Other type aliases omitted for brevity
        using iterator = hash_map_iterator<hash_map_type>;
        using const_iterator = const_hash_map_iterator<hash_map_type>;

        // Iterator methods
        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;
        const_iterator cbegin() const;
        const_iterator cend() const;
        // Remainder of class definition omitted for brevity
};


//using the hash_map iterators 

hash_map<string, int> myHash;
myHash.insert(make_pair("KeyOne", 100));
myHash.insert(make_pair("KeyTwo", 200));
myHash.insert(make_pair("KeyThree", 300));

for (auto it = myHash.cbegin(); it != myHash.cend(); ++it) {
    // Use both -> and * to test the operations.
    cout << it->first << " maps to " << (*it).second << endl;
}

// Print elements using a range-based for loop
for (auto& p : myHash) {
    cout << p.first << " maps to " << p.second << endl;
}

// Print elements using a range-based for loop and C++17 structured bindings
for (auto&[key, value] : myHash) {
    cout << key << " maps to " << value << endl;
}

// Create an std::map with all the elements in the hash_map.
map<string, int> myMap(cbegin(myHash), cend(myHash));
for (auto& p : myMap) {
    cout << p.first << " maps to " << p.second << endl;
}
```

- C++17 adds extract() and merge() methods to the list of requirements. These have to do with handling nodes as discussed 

template <typename... Args>
std::pair<iterator, bool> emplace(Args&&... args);

template <typename... Args>
iterator emplace_hint(const_iterator hint, Args&&... args);

template <typename Key, typename T, typename KeyEqual, typename Hash>
typename hash_map<Key, T, KeyEqual, Hash>::size_type
    hash_map<Key, T, KeyEqual, Hash>::erase(const key_type& k)
{
    // First, try to find the element.
    auto[it, bucket] = findElement(k);
    if (it != std::end(mBuckets[bucket])) {
        // The element exists -- erase it.
        mBuckets[bucket].erase(it);
        mSize--;
        return 1;
    } else {
        return 0;
    }
}


# Advanced templates 
- additional template parameter 

template <typename T, typename Container>
class Grid
{
    public:
        explicit Grid(size_t width = kDefaultWidth,
            size_t height = kDefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid<T, Container>& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and assignment operator.
        Grid(Grid&& src) = default;
        Grid<T, Container>& operator=(Grid&& rhs) = default;

        typename Container::value_type& at(size_t x, size_t y);
        const typename Container::value_type& at(size_t x, size_t y) const;

        size_t getHeight() const { return mHeight; }
        size_t getWidth() const { return mWidth; }

        static const size_t kDefaultWidth = 10;
        static const size_t kDefaultHeight = 10;

    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::vector<Container> mCells;
        size_t mWidth = 0, mHeight = 0;
};

template <typename T, typename Container>
void Grid<T, Container>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= mWidth || y >= mHeight) {
        throw std::out_of_range("");
    }
}

template <typename T, typename Container>
const typename Container::value_type&
    Grid<T, Container>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return mCells[x][y];
}

template <typename T, typename Container>
typename Container::value_type&
    Grid<T, Container>::at(size_t x, size_t y)
{
    return const_cast<typename Container::value_type&>(
        std::as_const(*this).at(x, y));
}

- use the template methods 

Grid<int, vector<optional<int>>> myIntVectorGrid;
Grid<int, deque<optional<int>>> myIntDequeGrid;

myIntVectorGrid.at(3, 4) = 5;
cout << myIntVectorGrid.at(3, 4).value_or(0) << endl;

myIntDequeGrid.at(1, 2) = 3;
cout << myIntDequeGrid.at(1, 2).value_or(0) << endl;

Grid<int, vector<optional<int>>> grid2(myIntVectorGrid);
grid2 = myIntVectorGrid;

- grid vector 

template <typename T, typename Container = std::vector<std::optional<T>>>
class Grid
{
    // Everything else is the same as before.
};

Grid<int, deque<optional<int>>> myDequeGrid;
Grid<int, vector<optional<int>>> myVectorGrid;
Grid<int> myVectorGrid2(myVectorGrid);


template <typename T,
 template <typename E, typename Allocator = std::allocator<E>> class Container
    = std::vector>
class Grid
{
    public:
        // Omitted code that is the same as before
        std::optional<T>& at(size_t x, size_t y);
        const std::optional<T>& at(size_t x, size_t y) const;
        // Omitted code that is the same as before
    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::vector<Container<std::optional<T>>> mCells;
        size_t mWidth = 0, mHeight = 0;
};

template <..., template <TemplateTypeParams> typename
ParameterName, ...>

- template parameters 

template <typename T, const T DEFAULT = T()>
class Grid
{
    // Identical as before.
};

template <typename T, const T DEFAULT>
Grid<T, DEFAULT>::Grid(size_t width, size_t height)
        : mWidth(width), mHeight(height)
{
    mCells.resize(mWidth);
    for (auto& column : mCells) {
        column.resize(mHeight);
        for (auto& element : column) {
            element = DEFAULT;
        }
    }
}

template <typename T, const T& DEFAULT>
class Grid
{
    // Everything else is the same as the previous example.
};

#include "Grid.h" // The file containing the Grid template definition

template <size_t WIDTH, size_t HEIGHT>
class Grid<const char*, WIDTH, HEIGHT>
{
    public:
        Grid() = default;
        virtual ~Grid() = default;

// Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid& operator=(const Grid& rhs) = default;

        std::optional<std::string>& at(size_t x, size_t y);
        const std::optional<std::string>& at(size_t x, size_t y) const;

        size_t getHeight() const { return HEIGHT; }
        size_t getWidth() const { return WIDTH; }
    private:
        void verifyCoordinate(size_t x, size_t y) const;

        std::optional<std::string> mCells[WIDTH][HEIGHT];
};

- template recursion 

template <typename T>
class OneDGrid
{
    public:
        explicit OneDGrid(size_t size = kDefaultSize);
        virtual ~OneDGrid() = default;

        T& operator[](size_t x);
        const T& operator[](size_t x) const;

        void resize(size_t newSize);
        size_t getSize() const { return mElements.size(); }

        static const size_t kDefaultSize = 10;
    private:
        std::vector<T> mElements;
};

template <typename T>
OneDGrid<T>::OneDGrid(size_t size)
{
    resize(size);
}

template <typename T>
void OneDGrid<T>::resize(size_t newSize)
{
    mElements.resize(newSize);
}

template <typename T>
T& OneDGrid<T>::operator[](size_t x)
{
    return mElements[x];
}

template <typename T>
const T& OneDGrid<T>::operator[](size_t x) const
{
    return mElements[x];
}

- a real n-dimensional grid 

OneDGrid<OneDGrid<OneDGrid<int>>> threeDGrid;

template <typename T, size_t N>
class NDGrid
{
    public:
        explicit NDGrid(size_t size = kDefaultSize);
        virtual ~NDGrid() = default;

        NDGrid<T, N-1>& operator[](size_t x);
        const NDGrid<T, N-1>& operator[](size_t x) const;

        void resize(size_t newSize);
        size_t getSize() const { return mElements.size(); }

        static const size_t kDefaultSize = 10;
    private:
        std::vector<NDGrid<T, N-1>> mElements;
};

template <typename T>
class NDGrid<T, 1>
{
    public:
        explicit NDGrid(size_t size = kDefaultSize);
        virtual ~NDGrid() = default;

        T& operator[](size_t x);
        const T& operator[](size_t x) const;

        void resize(size_t newSize);
        size_t getSize() const { return mElements.size(); }

        static const size_t kDefaultSize = 10;
    private:
        std::vector<T> mElements;
};

template <typename T, size_t N>
NDGrid<T, N>::NDGrid(size_t size)
{
    resize(size);
}

template <typename T, size_t N>
void NDGrid<T, N>::resize(size_t newSize)
{
    mElements.resize(newSize);
    // Resizing the vector calls the 0-argument constructor for
    // the NDGrid<T, N-1> elements, which constructs
    // them with the default size. Thus, we must explicitly call
    // resize() on each of the elements to recursively resize all
    // nested Grid elements.
    for (auto& element : mElements) {
        element.resize(newSize);
    }
}

template <typename T, size_t N>
NDGrid<T, N-1>& NDGrid<T, N>::operator[](size_t x)
{
    return mElements[x];
}

template <typename T, size_t N>
const NDGrid<T, N-1>& NDGrid<T, N>::operator[](size_t x) const
{
    return mElements[x];
}

- variadic templates,  syntax to define a parameter pack for variadic templates. A parameter pack is something that can accept a variable number of arguments.

template<typename... Types>
class MyVariadicTemplate { };

MyVariadicTemplate<int> instance1;
MyVariadicTemplate<string, double, list<int>> instance2;
MyVariadicTemplate<> instance3;

//avoid zero type argument 
template<typename T1, typename... Types>
class MyVariadicTemplate { };

- type-safe variable length argument lists 
```
void handleValue(int value) { cout << "Integer: " << value << endl; }
void handleValue(double value) { cout << "Double: " << value << endl; }
void handleValue(string_view value) { cout << "String: " << value << endl; }

void processValues() { /* Nothing to do in this base case.*/ }

template<typename T1, typename... Tn>
void processValues(T1 arg1, Tn... args)
{
    handleValue(arg1);
    processValues(args...);
}
```
//call with variate variables 
processValues(1, 2, 3.56, "test", 1.1f);
  handleValue(1);
  processValues(2, 3.56, "test", 1.1f);
    handleValue(2);
    processValues(3.56, "test", 1.1f);
      handleValue(3.56);
      processValues("test", 1.1f);
        handleValue("test");
        processValues(1.1f);
          handleValue(1.1f);
          processValues();

    + To use non-const references and still allow literal values, you can use forwarding references. The following implementation uses forwarding references, T&&, and uses std::forward() for perfect forwarding of all parameters.
```
void processValues() { /* Nothing to do in this base case.*/ }

template<typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(std::forward<T1>(arg1));
    processValues(std::forward<Tn>(args)...);
}
```

//The ... operator is used to unpack the parameter pack. It uses std::forward() on each individual argument in the pack and separates them with commas. 
processValues(std::forward<Tn>(args)...);

int numOfArgs = sizeof...(args);

- variable number of mixin classes 

class Mixin1
{
    public:
        Mixin1(int i) : mValue(i) {}
        virtual void Mixin1Func() { cout << "Mixin1: " << mValue << endl; }
    private:
        int mValue;
};

class Mixin2
{
    public:
        Mixin2(int i) : mValue(i) {}
        virtual void Mixin2Func() { cout << "Mixin2: " << mValue << endl; }
    private:
        int mValue;
};

template<typename... Mixins>
class MyClass : public Mixins...
{
    public:
        MyClass(const Mixins&... mixins) : Mixins(mixins)... {}
        virtual ~MyClass() = default;
};


MyClass<Mixin1, Mixin2> a(Mixin1(11), Mixin2(22));
a.Mixin1Func();
a.Mixin2Func();

MyClass<Mixin1> b(Mixin1(33));
b.Mixin1Func();
//b.Mixin2Func();    // Error: does not compile.

MyClass<> c;
//c.Mixin1Func();    // Error: does not compile.
//c.Mixin2Func();    // Error: does not compile.

- folding expressions, C++17 adds supports for so-called folding expressions. This makes working with parameter packs in variadic templates much easier.

Ѳ can be any of the following operators: + - * / % ^ & | << >> += -= *= /= %= ^= &= |= <<= >>= = == != < > <= >= && || , .* ->*.

Unary right fold 	(pack Ѳ ...) 	        pack0 Ѳ (... Ѳ (packn-1 Ѳ packn))
Unary left fold 	(... Ѳ pack) 	        ((pack0 Ѳ pack1) Ѳ ... ) Ѳ packn
Binary right fold 	(pack Ѳ ... Ѳ Init) 	pack0 Ѳ (... Ѳ (packn-1 Ѳ (packn Ѳ Init)))
Binary left fold 	(Init Ѳ … Ѳ pack) 	    (((Init Ѳ pack0) Ѳ pack1) Ѳ … ) Ѳ packn

void processValues() { /* Nothing to do in this base case.*/ }

template<typename T1, typename... Tn>
void processValues(T1 arg1, Tn... args)
{
    handleValue(arg1);
    processValues(args...);
}

template<typename... Tn>
void processValues(const Tn&... args)
{
    //Basically, the three dots in the function body trigger folding. That line is expanded to call handleValue() for each argument in the parameter pack, and each call to handleValue() is separated by a comma. 
    (handleValue(args), ...);
    
    //equal to 
    (handleValue(a1), (handleValue(a2), handleValue(a3)));
}

template<typename... Values>
void printValues(const Values&... values)
{
    ((cout << values << endl), ...);
    //equal to printValues(v1, v2, v3);
    ((cout << v1 << endl), ((cout << v2 << endl), (cout << v3 << endl)));
}

template<typename T, typename... Values>
double sumValues(const T& init, const Values&... values)
{
    return (init + ... + values);
    //equal to 
    return (((init + v1) + v2) + v3);
}

- meta programming 

    + factorial at compile time 

template<unsigned char f>
class Factorial
{
    public:
        static const unsigned long long val = (f * Factorial<f - 1>::val);
};

template<>
class Factorial<0>
{
    public:
        static const unsigned long long val = 1;
};

int main()
{
    cout << Factorial<6>::val << endl;
    return 0;
}

//factorial of 6, mathematically written as 6!, which is 1×2×3×4×5×6 or 720.

    + you don’t necessarily need to use template metaprogramming. Since the introduction of constexpr, it can be written as follows without any templates

constexpr unsigned long long factorial(unsigned char f)
{
    if (f == 0) {
        return 1;
    } else {
        return f * factorial(f - 1);
    }
}

//value is calculated at compile time 
constexpr auto f1 = factorial(6);

//value is calculated at runtime 
auto f1 = factorial(6);

    + uses template recursion, needs to do something in a loop at compile time. 

template<int i>
class Loop
{
    public:
        template <typename FuncType>
        static inline void Do(FuncType func) {
            Loop<i - 1>::Do(func);
            func(i);
        }
};

template<>
class Loop<0>
{
    public:
        template <typename FuncType>
        static inline void Do(FuncType /* func */) { }
};

- printing tuples 

std::tuple. Tuples are explained in Chapter 20. They allow you to store any number of values, each with its own specific type

```
template<typename TupleType, int n>
class tuple_print
{
    public:
        tuple_print(const TupleType& t) {
            tuple_print<TupleType, n - 1> tp(t);
            cout << get<n - 1>(t) << endl;
        }
};

template<typename TupleType>
class tuple_print<TupleType, 0>
{
    public:
        tuple_print(const TupleType&) { }
};

int main()
{
    using MyTuple = tuple<int, string, bool>;
    MyTuple t1(16, "Test", true);
    tuple_print<MyTuple, tuple_size<MyTuple>::value> tp(t1);
}
```

    + template that automatically deduces the template parameters

```
template<typename TupleType, int n>
class tuple_print_helper
{
    public:
        tuple_print_helper(const TupleType& t) {
            tuple_print_helper<TupleType, n - 1> tp(t);
            cout << get<n - 1>(t) << endl;
        }
};

template<typename TupleType>
class tuple_print_helper<TupleType, 0>
{
    public:
        tuple_print_helper(const TupleType&) { }
};

template<typename T>
void tuple_print(const T& t)
{
    tuple_print_helper<T, tuple_size<T>::value> tph(t);
}

int main()
{
    auto t1 = make_tuple(167, "Testing", false, 2.3);
    tuple_print(t1);
}
```

- C++17 introduced constexpr if. These are if statements executed at compile time. 

//If a branch of a constexpr if statement is never taken, it is never compiled. This can be used to simplify a lot of template metaprogramming techniques

template<typename TupleType, int n>
class tuple_print_helper
{
    public:
        tuple_print_helper(const TupleType& t) {
            if constexpr(n > 1) {
                tuple_print_helper<TupleType, n - 1> tp(t);
            }
            cout << get<n - 1>(t) << endl;
        }
};

template<typename T>
void tuple_print(const T& t)
{
    tuple_print_helper<T, tuple_size<T>::value> tph(t);
}

    + we can write more simplified template recursive code 
    
template<typename TupleType, int n>
void tuple_print_helper(const TupleType& t) {
    if constexpr(n > 1) {
        tuple_print_helper<TupleType, n - 1>(t);
    }
    cout << get<n - 1>(t) << endl;
}

template<typename T>
void tuple_print(const T& t)
{
    tuple_print_helper<T, tuple_size<T>::value>(t);
}

    + more simplified 
template<typename TupleType, int n = tuple_size<TupleType>::value>
void tuple_print(const TupleType& t) {
    if constexpr(n > 1) {
        tuple_print<TupleType, n - 1>(t);
    }
    cout << get<n - 1>(t) << endl;
}

- using a compile-time integer sequence with folding 

std::index_sequence_for to generate an index sequence of the same length as the length of a given parameter pack.

```
template<typename Tuple, size_t... Indices>
void tuple_print_helper(const Tuple& t, index_sequence<Indices...>)
{
    ((cout << get<Indices>(t) << endl), ...);
}

template<typename... Args>
void tuple_print(const tuple<Args...>& t)
{
    tuple_print_helper(t, index_sequence_for<Args...>());
}
```

- Type traits allow you to make decisions based on types at compile time,  an asterisk (*) are only available since C++17.


    Primary type categories
        is_void
        is_integral
        is_floating_point
        is_pointer
        ...
    Type properties
        is_const
        is_literal_type
        is_polymorphic
        is_unsigned
        is_constructible
        is_copy_constructible
        is_move_constructible
        is_assignable
        is_trivially_copyable
        is_swappable*
        is_nothrow_swappable*
        has_virtual_destructor
        has_unique_object_representations*
        ...
    Reference modifications
        remove_reference
        add_lvalue_reference
        add_rvalue_reference
    Pointer modifications
        remove_pointer
        add_pointer

	

    Composited type categories
        is_reference
        is_object
        is_scalar
        ...
    Type relations
        is_same
        is_base_of
        is_convertible
        is_invocable*
        is_nothrow_invocable*
        ...
    const-volatile modifications
        remove_const
        add_const
        ...
    Sign modifications
        make_signed
        make_unsigned
    Array modifications
        remove_extent
        remove_all_extents
    Logical operator traits
        conjuction*
        disjunction*
        negation*
    Other transformations
        enable_if
        conditional
        invoke_result*
        ...

- using type categories 

template <class T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant<T, v>;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template <bool B>
using bool_constant = integral_constant<bool, B>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;


if (is_integral<int>::value) {
    cout << "int is integral" << endl;
} else {
    cout << "int is not integral" << endl;
}

if (is_class<string>::value) {
    cout << "string is a class" << endl;
} else {
    cout << "string is not a class" << endl;
}

- using type relations, are is_same, is_base_of, and is_convertible.

template<typename T1, typename T2>
void same(const T1& t1, const T2& t2)
{
    bool areTypesTheSame = is_same_v<T1, T2>;
    cout << "'" << t1 << "' and '" << t2 << "' are ";
    cout << (areTypesTheSame ? "the same types." : "different types.") << endl;
}

int main()
{
    same(1, 32);
    same(1, 3.01);
    same(3.01, "Test"s);
}

- The use of enable_if is based on a feature called Substitution Failure Is Not An Error (SFINAE), a complicated feature of C++

typename enable_if<..., bool>::type

enable_if_t<..., bool>


//the check_type() functions return true or false depending on whether or not the types of the given values are the same.


```
template<typename T1, typename T2>
enable_if_t<is_same_v<T1, T2>, bool>
    check_type(const T1& t1, const T2& t2)
{
    cout << "'" << t1 << "' and '" << t2 << "' ";
    cout << "are the same types." << endl;
    return true;
}

template<typename T1, typename T2>
enable_if_t<!is_same_v<T1, T2>, bool>
    check_type(const T1& t1, const T2& t2)
{
    cout << "'" << t1 << "' and '" << t2 << "' ";
    cout << "are different types." << endl;
    return false;
} 

int main()
{
    check_type(1, 32);
    check_type(1, 3.01);
    check_type(3.01, "Test"s);
}
```

- using constexpr if to simplify enable_if_constructs 

constexpr if feature, introduced in C++17, helps to dramatically simplify certain use cases of enable_if.

```
class IsDoable
{
    public:
        void doit() const { cout << "IsDoable::doit()" << endl; }
};

class Derived : public IsDoable { };

template<typename T>
enable_if_t<is_base_of_v<IsDoable, T>, void>
    call_doit(const T& t)
{
    t.doit();
}

template<typename T>
enable_if_t<!is_base_of_v<IsDoable, T>, void>
    call_doit(const T&)
{
    cout << "Cannot call doit()!" << endl;
}

Derived d;
call_doit(d);
call_doit(123);
```

    + use the new cpp17 is_invocable trait to simplify the code 
    
template<typename T>
void call_doit(const T& [[maybe_unused]] t)
{
    if constexpr(is_invocable_v<decltype(&IsDoable::doit), T>) {
        t.doit();
    } else {
        cout << "Cannot call doit()!" << endl;
    }
}

- logical operator traits 

logical operator traits: conjunction, disjunction, and negation. Variable templates, ending with _v, are available as well. 

```
cout << conjunction_v<is_integral<int>, is_integral<short>> << " ";
cout << conjunction_v<is_integral<int>, is_integral<double>> << " ";

cout << disjunction_v<is_integral<int>, is_integral<double>,
                      is_integral<short>> << " ";

cout << negation_v<is_integral<int>> << " ";
```


# Multithreaded programming with c++ 
- third party c++ library 

C++ libraries that try to make multithreaded programming more platform independent, such as pthreads and the boost::thread library. 

- Race conditions can occur when multiple threads want to access any kind of shared resources. 

- Tearing is a specific case or consequence of a data race. There are two kinds of tearing: torn read and torn write.

If two threads are writing to the data at the same time, one thread might have written part of the data, while another thread might have written another part of the data. 

- deadlocks 

acquire the permission in different order. The following table shows this situation in pseudo-code.

use the standard std::lock() or std::try_lock() functions described later in the section “Mutual Exclusion.” 

- false-sharing, Most caches work with so-called cache lines. 

For modern CPUs, cache lines are usually 64 bytes. If something needs to be written to a cache line, the entire line needs to be locked. This can bring a serious performance penalty for multithreaded code

You can optimize your data structures by using explicit memory alignments to make sure data that is worked on by multiple threads does not share any cache lines. To do this in a portable manner, C++17 introduces a constant called hardware_destructive_interference_size, defined in <new>, which returns you the minimum recommended offset between two concurrently accessed objects to avoid cache line sharing.

- threads 

Functions such as CreateThread(), _beginthread(), and so on, on Windows, and pthread_create() with the pthreads library, require that the thread function has only one parameter. 

```
void counter(int id, int numIterations)
{
    for (int i = 0; i < numIterations; ++i) {
        cout << "Counter " << id << " has value " << i << endl;
    }
}

thread t1(counter, 1, 6);
```

a joinable thread object is destroyed, you need to make sure to call either join() or detach() on it. 

call std::terminate(), which abruptly terminates all threads and the application itself.
 
```
thread t1(counter, 1, 6);
thread t2(counter, 2, 4);
t1.join();
t2.join();
```
- should use std::ref() or cref() from the <functional> header to pass your instance by reference, for example

Counter c(2, 12);
thread t2(ref(c));

- thread with lambda 

int main()
{
    int id = 1;
    int numIterations = 5;
    thread t1([id, numIterations] {
        for (int i = 0; i < numIterations; ++i) {
            cout << "Counter " << id << " has value " << i << endl;
        }
    });
    t1.join();
}

- thread with member function 

class Request
{
    public:
        Request(int id) : mId(id) { }

        void process()
        {
            cout << "Processing request " << mId << endl;
        }
    private:
        int mId;
};

int main()
{
    Request req(100);
    thread t{ &Request::process, &req };
    t.join();
}

- thread local storage, thread local, which means that each thread will have its own unique copy of the variable and it will last for the entire duration of the thread.

```
int k;
thread_local int n;
```

if the thread_local variable is declared in the scope of a function, its behavior is as if it were declared static, except that every thread has its own unique copy and is initialized exactly once per thread

- cancelling threads, use atomic variables or condition variables, both discussed later in this chapter.

- retrieving results from threads 

    + One way is to pass a pointer or reference to a result variable to the thread in which the thread stores the results. 

    +  Another method is to store the results inside class member variables of a function object

    This only works if you use std::ref() to pass your function object by reference to the thread constructor.

- copying and rethrowing exceptions 

    + These functions work not only with std::exceptions, but also with other kinds of exceptions, ints, strings, custom exceptions,
    
    exception_ptr current_exception() noexcept;

    This is intended to be called from inside a catch block

    + [[noreturn]] void rethrow_exception(exception_ptr p);

    This function rethrows the exception referenced by the exception_ptr parameter. 

    + template<class E> exception_ptr make_exception_ptr(E e) noexcept;

    This function creates an exception_ptr object that refers to a copy of the given exception object. 
    
    try {
        throw e;
    } catch(…) {
        return current_exception();
    }
    
    how handling exceptions across different threads can be implemented using these functions
```
void doSomeWork()
{
    for (int i = 0; i < 5; ++i) {
        cout << i << endl;
    }
    cout << "Thread throwing a runtime_error exception…" << endl;
    throw runtime_error("Exception from thread");
}

//the function current_exception() is used to get a reference to the exception being handled, which is then assigned to the exception_ptr parameter.

void threadFunc(exception_ptr& err)
{
    try {
        doSomeWork();
    } catch (…) {
        cout << "Thread caught exception, returning exception…" << endl;
        err = current_exception();
    }
}

//The following doWorkInThread() function is called from within the main thread.

void doWorkInThread()
{
    exception_ptr error;
    // Launch thread
    thread t{ threadFunc, ref(error) };
    // Wait for thread to finish
    t.join();
    // See if thread has thrown any exception
    if (error) {
        cout << "Main thread received exception, rethrowing it…" << endl;
        rethrow_exception(error);
    } else {
        cout << "Main thread did not receive any exception." << endl;
    }
} 

int main()
{
    try {
        doWorkInThread();
    } catch (const exception& e) {
        cout << "Main function caught: '" << e.what() << "'" << endl;
    }
}
```

- ATOMIC OPERATIONS LIBRARY

Atomic types allow atomic access, which means that concurrent reading and writing without additional synchronization is allowed

```
atomic<int> counter(0) ;  // Global variable
++counter;                // Executed in multiple threads
```

You need to include the <atomic> header to use these atomic types. The C++ standard defines named integral atomic types for all primitive types

```
atomic_bool 	atomic<bool>
atomic_char 	atomic<char>
atomic_uchar 	atomic<unsigned char>
atomic_int 	atomic<int>
atomic_uint 	atomic<unsigned int>
atomic_long 	atomic<long>
atomic_ulong 	atomic<unsigned long>
atomic_llong 	atomic<long long>
atomic_ullong 	atomic<unsigned long long>
atomic_wchar_t 	atomic<wchar_t>
```

The std::atomic class template can be used with all kinds of types, not only integral types. For example, you can create an atomic<double>, or an atomic<MyType>, but only if MyType is trivially copyable.

uses std::this_thread::sleep_for() to introduce a small delay in each loop.

```
#include <atomic>

void increment(atomic<int>& counter)
{
    for (int i = 0; i < 100; ++i) {
        ++counter;
        this_thread::sleep_for(1ms);
    }
}

int main()
{
    atomic<int> counter(0);
    vector<thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.push_back(thread{ increment, ref(counter) });
    }

    for (auto& t : threads) {
        t.join();
    }
    cout << "Result = " << counter << endl;
}
```

- atomic operations 

bool atomic<T>::compare_exchange_strong(T& expected, T desired);

A second example is atomic<T>::fetch_add(), which works for integral atomic types. It fetches the current value of the atomic type, adds the given increment to the atomic value

```
atomic<int> value(10);
cout << "Value = " << value << endl;
int fetched = value.fetch_add(4);
cout << "Fetched = " << fetched << endl;
cout << "Value = " << value << endl;
```

following atomic operations: fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor(), ++, --, +=, -=, &=, ^=, and |=. Atomic pointer types support fetch_add(), fetch_sub(), ++, --, +=, and -=.

- mutual exclusion 

mutual exclusion in the form of mutex and lock classes. These can be used to implement synchronization between threads 

provides non-timed mutex and timed mutex classes.

std::mutex, recursive_mutex, and shared_mutex (since C++17). The first two classes are defined in <mutex>, and the last one in <shared_mutex>

lock(): The calling thread tries to obtain the lock and blocks until the lock has been acquired.

try_lock(): The calling thread tries to obtain the lock.

unlock(): The calling thread releases the lock it currently holds, making it available for another thread.

A thread already having ownership of a mutex is not allowed to call lock() or try_lock() again on that mutex. This might lead to a deadlock!

The shared_mutex class supports the concept of shared lock ownership, also known as readers-writers lock. A thread can get either exclusive ownership or shared ownership of the lock.

    + timed mutex classes 

    std::timed_mutex, 
    recursive_timed_mutex,  
    shared_timed_mutex. 
    
    The first two classes are defined in <mutex>, and the last one in <shared_mutex>. They all support the lock(), try_lock(), and unlock() methods
    
    try_lock_for(rel_time): The calling thread tries to obtain the lock for a certain relative time.

    try_lock_until(abs_time): The calling thread tries to obtain the lock until the system time equals or exceeds the specified absolute time

- locks, The C++ standard defines four types of locks: std::lock_guard, unique_lock, shared_lock, and scoped_lock. The latter has been introduced with C++17.

lock_guard, defined in <mutex>, is a simple lock with two constructors:

This is a constructor accepting a reference to a mutex. 
```
explicit lock_guard(mutex_type& m); 
```


This is a constructor accepting a reference to a mutex and an instance of std::adopt_lock_t.
```
ock_guard(mutex_type& m, adopt_lock_t);
```

- unique_lock 

std::unique_lock, defined in <mutex>, is a more sophisticated lock that allows you to defer lock acquisition until later in the execution

explicit unique_lock(mutex_type& m);

unique_lock(mutex_type& m, defer_lock_t) noexcept;

an instance of std::defer_lock_t. There is a predefined defer_lock_t instance provided


- The shared_lock class, defined in <shared_mutex>, has the same type of constructors and the same methods as unique_lock. The difference is that the shared_lock class calls the shared ownership-related methods on the underlying shared mutex. 

- acquiring multiple locks at once 

template <class L1, class L2, class… L3> void lock(L1&, L2&, L3&…);

std::scoped_lock, defined in <mutex>, is similar to lock_guard, except that it accepts a variable number of mutexes. This greatly simplifies acquiring multiple locks. 

You can use std::call_once() in combination with std::once_flag to make sure a certain function or method is called exactly one time, no matter how many threads try to call call_once()

```
once_flag gOnceFlag;

void initializeSharedResources()
{
    // … Initialize shared resources to be used by multiple threads.
    cout << "Shared resources initialized." << endl;
}

void processingFunction()
{
    // Make sure the shared resources are initialized.
    call_once(gOnceFlag, initializeSharedResources);

    // … Do some work, including using the shared resources
    cout << "Processing" << endl;
}

int main()
{
    // Launch 3 threads.
    vector<thread> threads(3);
    for (auto& t : threads) {
        t = thread{ processingFunction };
    }
    // Join on all threads
    for (auto& t : threads) {
        t.join();
    }
} 
```

- The double-checked locking pattern is actually an anti-pattern, which you should avoid! It is shown here because you might come across it in existing code bases. 

Instead, use other mechanisms such as simple locks, atomic variables, call_once(), magic statics, and so on.


```
void initializeSharedResources()
{
    // … Initialize shared resources to be used by multiple threads.
    cout << "Shared resources initialized." << endl;
}

atomic<bool> gInitialized(false);
mutex gMutex;

void processingFunction()
{
    if (!gInitialized) {
        unique_lock lock(gMutex);
        if (!gInitialized) {
            initializeSharedResources();
            gInitialized = true;
        }
    }
    cout << "OK" << endl;
}

int main()
{
    vector<thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.push_back(thread{ processingFunction });
    }
    for (auto& t : threads) {
        t.join();
    }
}
```
- Condition variables allow a thread to block until a certain condition is set by another thread, or until the system time reaches a specified time.

std::condition_variable: A condition variable that can wait only on a unique_lock<mutex>

std::condition_variable_any: A condition variable that can wait on any kind of object, including custom lock types.

condition_variable support following methods

notify_one()
notify_all()
wait(unique_lock<mutex>& lk)
wait_for(unique_lock<mutex>& lk, const chrono::duration<Rep, Period>& rel_time)
wait_unitl(unique_lock<mutex>& lk, const chrono::time_point<Clock, Duration>& abs_time);

use of wait() accepting a predicate to correctly handle spurious wake-ups. 

```
unique_lock lock(mMutex);
while (true) {
    // Wait for a notification.
    mCondVar.wait(lock, [this]{ return !mQueue.empty(); });
    // Condition variable is notified, so something is in the queue.
    // Process queue item…
}
```

The C++ standard also defines a helper function called std::notify_all_at_thread_exit(cond, lk) where cond is a condition variable and lk is a unique_lock<mutex> instance. 

- futures 

A future can be used to more easily get the result out of a thread, and to transport exceptions from one thread to another thread

A promise is something where a thread stores its result. A future is used to get access to the result stored in a promise. That is, a promise is the input side for a result, a future is the output side. 

C++ provides a standard future, called std::future. You can retrieve the result from an std::future as follows.
```
if (myFuture.wait_for(0)) {  // Value is available
    T result = myFuture.get();
} else {                // Value is not yet available
    …
}
```

std::promise class as one way to implement the concept of a promise. You can call set_value() on a promise to store a result, or you can call set_exception() on it to store an exception in the promise

```
void DoWork(promise<int> thePromise)
{
    // … Do some work …
    // And ultimately store the result in the promise.
    thePromise.set_value(42);
}

int main()
{
    // Create a promise to pass to the thread.
    promise<int> myPromise;
    // Get the future of the promise.
    auto theFuture = myPromise.get_future();
    // Create a thread and move the promise into it.
    thread theThread{ DoWork, std::move(myPromise) };

    // Do some more work…

    // Get the result.
    int result = theFuture.get();
    cout << "Result: " << result << endl;

    // Make sure to join the thread.
    theThread.join();
}
```

- packaged task, An std::packaged_task makes it easier to work with promises than explicitly using std::promise, as in the previous section. 

A packaged_task automatically creates a promise, automatically stores the result of the called function, CalculateSum() in this case

```
int CalculateSum(int a, int b) { return a + b; }

int main()
{
    // Create a packaged task to run CalculateSum.
    packaged_task<int(int, int)> task(CalculateSum);
    // Get the future for the result of the packaged task.
    auto theFuture = task.get_future();
    // Create a thread, move the packaged task into it, and
    // execute the packaged task with the given arguments.
    thread theThread{ std::move(task), 39, 3 };

    // Do some more work…

    // Get the result.
    int result = theFuture.get();
    cout << result << endl;

    // Make sure to join the thread.
    theThread.join();
}
```

- std::async 

C++ runtime more control over whether or not a thread is created to calculate something, you can use std::async(). 

launch::async: forces the runtime to execute the function asynchronously on a different thread.

launch::deferred: forces the runtime to execute the function synchronously on the calling thread when get() is called.


```
int calculate()
{
    return 123;
}

int main()
{
    auto myFuture = async(calculate);
    //auto myFuture = async(launch::async, calculate);
    //auto myFuture = async(launch::deferred, calculate);

    // Do some more work…

    // Get the result.
    int result = myFuture.get();
    cout << result << endl;
}
```

- exception handling, If you use std::promise as your promise, you can call set_exception() to store an exception in it. 

```
int calculate()
{
    throw runtime_error("Exception thrown from calculate().");
}

int main()
{
    // Use the launch::async policy to force asynchronous execution.
    auto myFuture = async(launch::async, calculate);

    // Do some more work…

    // Get the result.
    try {
        int result = myFuture.get();
        cout << result << endl;
    } catch (const exception& ex) {
        cout << "Caught exception: " << ex.what() << endl;
    }
}
```

- std::shared_future, std::future<T> only requires T to be move-constructible. When you call get() on a future<T>, the result is moved out of the future and returned to you.

A shared_future can be created by using std::future::share(), or by passing a future to the shared_future constructor. 

```
promise<void> thread1Started, thread2Started;

promise<int> signalPromise;
auto signalFuture = signalPromise.get_future().share();
//shared_future<int> signalFuture(signalPromise.get_future());

auto function1 = [&thread1Started, signalFuture] {
    thread1Started.set_value();
    // Wait until parameter is set.
    int parameter = signalFuture.get();
    // …
};

auto function2 = [&thread2Started, signalFuture] {
    thread2Started.set_value();
    // Wait until parameter is set.
    int parameter = signalFuture.get();
    // …
};

// Run both lambda expressions asynchronously.
// Remember to capture the future returned by async()!
auto result1 = async(launch::async, function1);
auto result2 = async(launch::async, function2);

// Wait until both threads have started.
thread1Started.get_future().wait();
thread2Started.get_future().wait();

// Both threads are now waiting for the parameter.
// Set the parameter to wake up both of them.
signalPromise.set_value(42);
```

- example multiple threads queue 

class Logger
{
    public:
        // Starts a background thread writing log entries to a file.
        Logger();
        // Gracefully shut down background thread.
        virtual ~Logger();
        // Prevent copy construction and assignment.
        Logger(const Logger& src) = delete;
        Logger& operator=(const Logger& rhs) = delete;
        // Add log entry to the queue.
        void log(std::string_view entry);
    private:
        //boolean
        bool mExit = false;
        // The function running in the background thread.
        void processEntries();
        // Mutex and condition variable to protect access to the queue.
        std::mutex mMutex;
        std::condition_variable mCondVar;
        std::queue<std::string> mQueue;
        // The background thread.
        std::thread mThread;
};

Logger::Logger()
{
    // Start background thread.
    mThread = thread{ &Logger::processEntries, this };
}

void Logger::log(string_view entry)
{
    // Lock mutex and add entry to the queue.
    unique_lock lock(mMutex);
    mQueue.push(string(entry));
    // Notify condition variable to wake up thread.
    mCondVar.notify_all();
}

void Logger::processEntries()
{
    // Open log file.
    ofstream logFile("log.txt");
    if (logFile.fail()) {
        cerr << "Failed to open logfile." << endl;
        return;
    }

    // Start processing loop.
    unique_lock lock(mMutex);
    while (true) {
        if (!mExit) { // Only wait for notifications if we don't have to exit.
           // Wait for a notification.
            mCondVar.wait(lock);
        }
        // Condition variable notified, something might be in the queue.
        lock.unlock();
        while (true) {
            lock.lock();
            if (mQueue.empty()) {
                break;
            } else {
                logFile << mQueue.front() << endl;
                mQueue.pop();
            }
            lock.unlock();
        }
        if (mExit) {
            break;
        }
    }
}


//test code 
void logSomeMessages(int id, Logger& logger)
{
    for (int i = 0; i < 10; ++i) {
        stringstream ss;
        ss << "Log entry " << i << " from thread " << id;
        logger.log(ss.str());
    }
}

int main()
{
    Logger logger;
    vector<thread> threads;
    // Create a few threads all working with the same Logger instance.
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(logSomeMessages, i, ref(logger));
    }
    // Wait for all threads to finish.
    for (auto& t : threads) {
        t.join();
    }
}

- thread pools 

Intel Threading Building Blocks (TBB), Microsoft Parallel Patterns Library (PPL), and so on. 

Use parallel Standard Library algorithms: The Standard Library contains a large collection of algorithms. Since C++17,

Try to use the single-thread ownership pattern: This means that a block of data is owned by no more than one thread at a time. 

The best synchronization is no synchronization

Use atomic types and operations when possible

Use locks to protect mutable shared data

Release locks as soon as possible

Do not manually acquire multiple locks, instead use std::lock() or std::try_lock()

Use RAII lock objects: Use the lock_guard, unique_lock, shared_lock, or scoped_lock RAII classes to automatically release locks

Use a multithreading-aware profiler: This helps to find performance bottlenecks in your multithreaded applications

Understand the multithreading support features of your debugger

Use thread pools instead of creating and destroying a lot of threads dynamically

Use higher-level multithreading libraries: The C++ standard, at this moment, only provides basic building blocks for writing multithreaded code


# C++ Software engineering 


# Writing efficient C++ 
- avoid creating temporary objects 
- use inline methods and functions 
- cache where necessary 

disk access 

network communication 

object allocation 

thread creation 

- object pools 

- profiling 

free profiling tools available: Very Sleepy and Luke Stackwalker are popular profilers for Windows,

Valgrind and gprof (GNU profiler) are well-known profilers for Unix/Linux systems

    + linux 
    Compile your program with a special flag that causes it to log raw execution information when it is run.
    
    > gcc -lstdc++ -std=c++17 -pg -o namedb NameDB.cpp NameDBTest.cpp
    
    > gprof namedb gmon.out > gprof_analysis.out
    
    + window 
    
    enable the “Performance Wizard” option and click the Start button. This starts a wizard, as shown

    CPU Sampling: This method is used to monitor applications with low overhead.
    
    Instrumentation: This method adds extra code to the application to be able to accurately count the number of function calls and to time individual function calls. 

    Resource contention data (concurrency): This method allows you to graphically monitor multithreaded applications.

    will show a hot path of your program 
    
    
# Becoming adept at testing 
- unit tests might contain the following tests:

    Test a simple addition
    Test addition of large numbers
    Test addition of negative numbers
    Test addition of zero to a number
    Test the commutative property of addition
    Test a simple multiplication
    Test multiplication of large numbers
    Test multiplication of negative numbers
    Test multiplication with zero
    Test the commutative property of multiplication

- Define the Granularity of Your Tests

Writing unit tests takes time, there is no way around this. Software developers are often crunched for time. 

- the tests could be split into the following categories:

    Basic tests
    Error tests
    Localization tests
    Bad input tests
    Complicated tests

- VS create your unit test 

template <typename T>
class ObjectPool
{
    public:
        ObjectPool() = default;
        virtual ~ObjectPool() = default;

        // Prevent assignment and pass-by-value
        ObjectPool(const ObjectPool<T>& src) = delete;
        ObjectPool<T>& operator=(const ObjectPool<T>& rhs) = delete;

        // The type of smart pointer returned by acquireObject().
        using Object = std::shared_ptr<T>;

        // Reserves and returns an object for use.
        Object acquireObject();

    private:
        // Stores the objects that are not currently in use by clients.
        std::queue<std::unique_ptr<T>> mFreeList;
};

#pragma once
#include <CppUnitTest.h>

TEST_CLASS(ObjectPoolTest)
{
    public:
        TEST_CLASS_INITIALIZE(setUp);
        TEST_CLASS_CLEANUP(tearDown);

        TEST_METHOD(testSimple);  // Your first test!
};


#include "stdafx.h"
#include "ObjectPoolTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

void ObjectPoolTest::setUp() { }
void ObjectPoolTest::tearDown() { }

void ObjectPoolTest::testSimple()
{
    Assert::IsTrue(0 < 1);
}

void ObjectPoolTest::testException()
{
    Assert::ExpectException<std::invalid_argument>(
        []{throw std::invalid_argument("Error"); },
        L"Unknown exception caught.");
}

With the Visual C++ Testing Framework, you don’t even need to worry about exceptions; the framework catches and reports them as necessary.

The code is written according to the AAA principle: Arrange, Act, Assert; the test first sets up everything for the test to run, then does some work

- System tests operate at an even higher level than integration tests. These tests examine the program as a whole. System tests often make use of a virtual user that simulates a human being working with the program. 

- Regression testing is more of a testing concept than a specific type of test. The idea is that once a feature works, developers tend to put it aside and assume that it will continue to work. 

- successful testing 
    + design your automated test system 
    + don't forget about stress testing 
    + test on a variety of platforms or a platform that closely mirros the customer's system 
    + some tests can be written to intentionally inject faults in a system 
    + bugs and tests are closely related 
    + don't remove tests that are failing 


# Conquering debugging 
- logging 

two examples:

    log4cpp at http://log4cpp.sourceforge.net/
    Boost.Log at http://www.boost.org/

- Debug Traces

When debugging complicated problems, public error messages generally do not contain enough information. You often need a complete trace of the code path taken, or values of variables before the bug showed up

- compile-time debug mode 

GCC allows you to specify –Dsymbol through the command-line. Microsoft VC++ allows you to specify the symbols through the Visual Studio IDE, or by specifying /D symbol if you use the VC++ command-line tools. Visual C++ automatically defines the _DEBUG symbol for debug builds.

- static assertions, assertions are evaluated at compile time 

static_assert(sizeof(void*) == 8, "Requires 64-bit compilation.");

- memory freeing errors 

memory leak 

using mismatched alloation and free operations 

freeing memory more than once 

freeing unallocated memory 

freeing stack memory 
```
void freeStack()
{
int x;
int* p = &x;
delete p; // BUG! Freeing stack memory
}
```
    
- memory access errors 

acessing invalid memory 
```
void accessInvalid()
{
int* p = reinterpret_cast<int*>(10000);
*p = 5; // BUG! p is not a valid pointer.
}
```

accessing freed memory 
```
void accessFreed()
{
int* p1 = new int;
delete p1;
int* p2 = new int;
*p1 = 5; // BUG! The memory pointed to
// by p1 has been freed.
}
```

accessing memory in a different allocation
```
void accessElsewhere()
{
int x, y[10], z;
x = 0;
z = 0;
for (int i = 0; i <= 10; i++) {
y[i] = 5; // BUG for i==10! element 10
// is past end of array.
}
}
``` 

reading unintialized memory 
```
void readUninitialized()
{
int* p;
cout << *p; // BUG! p is uninitialized
}
```
    
- debugging multithreaded programs 

use a debugger 

use log-based debugging 

insert forced sleeps and context switches 

perform code review 
    
- design techniques and frameworks 

class Animal
{
    public:
        virtual bool eats(const Bear&) const = 0;
        virtual bool eats(const Fish&) const = 0;
        virtual bool eats(const Dinosaur&) const = 0;
};
    
class Bear : public Animal
{
    public:
        virtual bool eats(const Bear&) const override { return false; }
        virtual bool eats(const Fish&) const override { return true; }
        virtual bool eats(const Dinosaur&) const override { return false; }
};    
    
    + mixin classes 
    
class Movable
{
    public:
        virtual void move() { /* Implementation to move an item… */ }
};
    
    
    
# Cross platform development 
- However, processor differences do sometimes rise up to the level of C++ code. The first one discussed, the size of integers, is very important if you are writing cross-platform code.    
    
    
five standard signed integer types: signed char, short int, int, long int, and long long int. In this list, each type provides at least as much storage as those preceding it in the list.
    
C++ standard does define a number of types that have clearly specified sizes, all defined in the <cstdint>    
    
```
int8_t
int16_t
int32_t
int64_t 	Signed integers of which the size is exactly 8, 16, 32, or 64 bits. This type is defined by the standard as being optional, although most compilers support it.
int_fast8_t
int_fast16_t
int_fast32_t
int_fast64_t 	Signed integers with sizes of at least 8, 16, 32, or 64 bits. For these, the compiler should use the fastest integer type it has that satisfies the requirements.
int_least8_t
int_least16_t
int_least32_t
int_least64_t 	Signed integers with sizes of at least 8, 16, 32, or 64 bits. For these, the compiler should use the smallest integer type it has that satisfies the requirements.
intmax_t 	An integer type with the maximum size supported by the compiler.
intptr_t 	An integer type big enough to store a pointer. This type is also optional, but most compilers support it.
```

- binary compatible because their processors do not support the same set of instructions. 
    + One solution to support platforms that are not binary compatible is to build each version separately with a compiler on each target platform.
    
    + cross-compiler on your platform X that generates binary code for platforms Y and Z.
    
    + open-source software has become increasingly popular. One of the major reasons is that it allows programmers to collaboratively develop software
    
    
- Address Sizes

When someone describes an architecture as 32-bit, they most likely mean that the address size is 32 bits, or 4 bytes. In general, a system with a larger address size can handle more memory and might operate more quickly on complex programs

consider the following code snippet, which outputs the size of a pointer:

```
int *ptr = nullptr;
cout << "ptr size is " << sizeof(ptr) << " bytes" << endl;
```

32 bit x86 will be 4 bytes, 64 bytes system will be 8 bytes 
    
- Byte Order

One way to represent the number is to put the high-order byte first in memory and the low-order byte next. This strategy is called big-endian ordering because the bigger part of the number comes first

Some other processors, such as x86, arrange the bytes in the opposite order, putting the low-order byte first in memory. This approach is called little-endian ordering

All modern computers store numbers in a binary representation, but the representation of the same number on two platforms may not be identical.     
    
if you are sending binary data across a network, you may need to consider the ordering of the other system. One solution is to use the standard network byte ordering

- Implementation Issues

When a C++ compiler is written, it is designed by a human being who attempts to adhere to the C++ standard. Unfortunately, the C++ standard is more than a thousand pages long 
    
- Compiler Quirks and Extensions

There is no simple rule for finding or avoiding compiler bugs. The best you can do is to stay up to speed on compiler updates and perhaps subscribe to a mailing list or newsgroup 
    
- Library Implementations

Most likely, your compiler includes an implementation of the C++ Standard Library. Because the Standard Library is written in C++
    
- platform specific features 
    
Graphical user interfaces: Most commercial programs today run on an operating system that has a graphical user interface
    
Networking: The Internet has changed the way we write applications. These days, most applications check for updates through the web, and games provide a networked multiplayer mode.
    
OS events and application interaction: In pure C++ code, there is little interaction with the surrounding operating system and other applications
    
Low-level files: Chapter 13 explains standard I/O in C++, including reading and writing files. Many operating systems provide their own file APIs which incompatible with standard file classes in C++ 

Threads: Concurrent threads of execution within a single program were not directly supported in C++03 or earlier. Since C++11, a threading support library has been included with the Standard Library
    
- cross language development 

    + Mixing C and C++

As you already know, the C++ language is almost a superset of the C language. That means that almost all C programs will compile and run in C++. 

The ease of incorporating C code in a C++ program comes in handy when you encounter a useful library or legacy code that was written in C. 
    
    + Shifting Paradigms

One of the dangers of mixing C and C++ is that your program may start to lose its object-oriented properties. For example, if your object-oriented web browser is implemented with a procedural networking library, the program will be mixing these two paradigms.
    
- Linking with C Code

The previous example assumed that you had the raw C code to work with. The example took advantage of the fact that most C code will successfully compile with a C++ compiler. 

```
void MyFunc(double);
void MyFunc(int);
void MyFunc(int, int);    
```

Microsoft VC++ generates names as follows:

```
?MyFunc@@YAXN@Z
?MyFunc@@YAXH@Z
?MyFunc@@YAXHH@Z
```

So, names generated by the C compiler are quite simple, for example, _MyFunc. necessary to tell the C++ compiler to not mangle that name. This is done by using the extern "language" qualification both in the header file 
    
syntax of extern "language":

```
extern "language" declaration1();
extern "language" declaration2();

or it can also be like this:

extern "language" {
    declaration1();
    declaration2();
}
```
    
A more common pattern for using extern is at the header level. For example, if you are using a graphics library written in C, it probably came with an .h file for you to use.  
```
// graphicslib.hpp
extern "C" {
    #include "graphicslib.h"
}
```
    
header files 
```
#ifdef __cplusplus
    extern "C" {
#endif
        declaration1();
        declaration2();
#ifdef __cplusplus
    } // matches extern "C"
#endif
```

- calling c++ code from c# 

```
#include <iostream>

using namespace std;

extern "C"
{
    __declspec(dllexport) int FunctionInDLL(const wchar_t* p)
    {
        wcout << L"The following string was received by C++:\n    '";
        wcout << p << L"'" << endl;
        return 42;    // Return some value…
    }
}
```

example uses __declspec(dllexport) to tell the linker that this function should be made available to clients of the library. This is the way you do it with Microsoft Visual C++. Other linkers might use a different mechanism to export functions.

c# include the Interop namespace:
```
using System.Runtime.InteropServices;
```

tell c# where it can find the function. This is done with the following line, assuming you have compiled the library as HelloCpp.dll:
````
[DllImport("HelloCpp.dll", CharSet = CharSet.Unicode)]
public static extern int FunctionInDLL(String s);
```

use the C++ library from C#:
```
using System;
using System.Runtime.InteropServices;

namespace HelloCSharp
{
    class Program
    {
        [DllImport("HelloCpp.dll", CharSet = CharSet.Unicode)]
        public static extern int FunctionInDLL(String s);

        static void Main(string[] args)
        {
            Console.WriteLine("Written by C#.");
            int result = FunctionInDLL("Some string from C#.");
            Console.WriteLine("C++ returned the value " + result);
        }
    }
}
```

- calling c++ from java with JNI 

Java cross-language adventure, start with the Java program. For this example, the simplest of Java programs will suffice:

```
public class HelloCpp {
    public static void main(String[] args)
    {
        System.out.println("Hello from Java!");
    }
}
```

native keyword and leave out the implementation:

```
public class HelloCpp {
    // This will be implemented in C++.
    public static native void callCpp();

    // Remainder omitted for brevity
}

public class HelloCpp {
    static {
        System.loadLibrary("hellocpp");
    }

    // Remainder omitted for brevity
}
```

The C++ code will eventually be compiled into a shared library that gets dynamically loaded into the Java program. The name of the library can be whatever you want, for example, hellocpp.so on Linux systems, or hellocpp.dll on Windows systems.
```
public class HelloCpp {
    static {
        System.loadLibrary("hellocpp");
    }

    // This will be implemented in C++.
    public static native void callCpp();

    public static void main(String[] args)
    {
        System.out.println("Hello from Java!");
        callCpp();
    }
}
```

Your C++ program will need to implement this function. The full prototype is as follows:
```
JNIEXPORT void JNICALL Java_HelloCpp_callCpp(JNIEnv*, jclass);

#include <jni.h>
#include "HelloCpp.h"
#include <iostream>

JNIEXPORT void JNICALL Java_HelloCpp_callCpp(JNIEnv*, jclass)
{
    std::cout << "Hello from C++!" << std::endl;
}
```

Using the GCC compiler on Linux, your compile command might look like this:

```
g++ -shared -I/usr/java/jdk/include/ -I/usr/java/jdk/include/linux \
HelloCpp.cpp -o hellocpp.so
```

- Calling C++ Code from Scripts

C++ contains a built-in general-purpose mechanism to interface with other languages and environments. 

You can use a scripting language to interact with the operating system and control the flow of the script

Following is the main() function for a C++ program that encrypts the input string. Notice that the program returns 0 for success and non-0 for failure, as is standard in Linux.

```
int main(int argc, char* argv[])
{
    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " string-to-be-encrypted" << endl;
        return -1;
    }
    cout << encrypt(argv[1]);
    return 0;
}
```

- Calling Assembly Code from C++

C++ is considered a fast language, especially relative to other languages. Yet, in some rare cases, you might want to use raw assembly code when speed is absolutely critical.

asm can be used by a C++ compiler to allow the programmer to insert raw assembly code. The keyword is part of the C++ standard, but its implementation is compiler-defined. In some compilers, you can use asm to drop from C++ down to the level of assembly right in the middle of your program.

several reasons to avoid assembly code:

    1. Your code is no longer portable to another processor once you start including raw assembly code for your platform.
    2. Most programmers don’t know assembly languages and won’t be able to modify or maintain your code.
    3. Assembly code is not known for its readability. It can hurt your program’s use of style.
    4. Most of the time, it is not necessary. If your program is slow, look for algorithmic problems, or consult some of the other performance suggestions from 


















