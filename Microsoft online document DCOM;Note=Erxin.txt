Microsoft online document DCOM;Note=Erxin

# DCOM 
- COM+ can be used to develop enterprise-wide, mission-critical, distributed applications for Windows.

- COM+ version 1.5 is included in Windows starting with Windows XP, windows server 2003

1.0 is include in windows 2000 

- application level access checks enabled by default

- application pooling 

ConcurrentApps property of the COMAdminCatalogObject object in the Applications collection, COM+ Application Pooling adds scalability for single-threaded processes

- application recycling 

factors such as memory leaks, reliance on third-party code, and nonscalable resource usage, COM+ application recycling provides a simple solution to gracefully shut down 

Application recycling significantly increases the overall stability of your applications.

- COM+ introduces support for COM+ partitions, a feature that allows multiple versions of COM+ applications to be installed and configured on the same machine. 

- COM+ services without components, use the services provided by COM+ without needing to build a component to contain the methods that call those services

- COM+ SOAP service 

expose a COM+ application as an XML web service. You can also transparently use an XML web service, whether deployed using COM+ or not

- configurable isolation level, new TxIsolationLevel property or the Component Services administrative tool to configure an application's isolation level according to need

- Creating private components, IsPrivateComponent, to mark these components as private, take advantage of all COM+ services.

- DTC security settings, MIcrosoft Distributed Transaction Coordinator (DTC), enabling you to customize your security levels

XA transactions as before by creating a registry entry under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\XADLL, where the value name is the name of the DLL

- Low memory activation gates, COM+ automatically checks memory before creating a COM+ server or object.

https://docs.microsoft.com/en-us/windows/win32/cossdk/com--low-memory-activation-gates

-  COM+ allows you to move and copy your components. This means you can configure a single physical implementation of a component many different times

- Network access, enable network COM+ access

On the Start menu, point to Control Panel, then select Add or Remove Programs.

Click Add/Remove Windows Components.

Select Application Server and click Details.

Check the box next to Enable network COM+ access, and then click OK.

Click Next to complete the Windows Components wizard.

Click Finish to close the wizard.

- Pausing and disabling applications 

An administrator can pause and resume COM+ server applications or disable and enable COM+ library or server applications, or even individual configured components.

- Process dumping, dump the entire state of a process without terminating it

- Process Initialization, create a class that implements the IProcessInitializer interface. When the process starts up, it calls IProcessInitializer::Startup and when shutting down, it calls IProcessInitializer::Shutdown.

- Running COM+ application as NT services, COM+ server application as an NT service. This means that the server can be automatically started or restarted if your application always needs to be running

- Side-by-side (SxS) assemblies allow applications to specify which version of a system DLL or classic COM component to use, such as MDAC, MFS, MSVCRT, or MSXML. For example, if an ASP application relies on MSXML version 2.0, you can ensure that this application still uses MSXML version 2.0 even after service packs are applied to the server.

- Windows Error Reporting (WER) component, available starting in Windows XP. WER enables users to notify Microsoft of application faults, kernel faults, and unresponsive applications.


# Developers overview 
## COM+ Programming overview 
- COM+ improvements 
    + COM+ support neutral apartment threading, which allows a component to have serialized access along with the ability to execute on any thread
    + COM+ support context which is set of properties define the execution environment 
    + COM+ provide role-based security, asynchronous object execution, and a built-in moniker
    
- Application and component administration 

RegDB, stores the metadata that describes components.

COM+ exposes the COM+ catalog, which accesses information in the RegDB

- Automatic transactions 

COM+ supports all Microsoft Transaction Server (MTS) 2.0 semantics and adds the auto-done

Component Services administrative tool


### COM+ application overview 
- hierachy

{COM+ application
    {Component
        {Interface 
            {Method
            }
        }
    }
}

- benefits of COM+ 

a deployment scope for COM components 

a common configuration scope for COM components, security boundaries and queuing 

storage of component attributes 

component dynamic link libraries, loaded into processes (DLLHost.exe) on demand 

managed server processes to host components 

Creation and management of threads used by components 

Access to the context object for resource dispensers, automatic associated with context 

- types of applications 

server applications, runs in its own process, support all COM+ services 

library applictions, run in the process of the client creates it 

application proxies, a set of files containing registration information that allows a client to remotely access a server application. 

COM+ server application, including CLSIDs, ProgIDs, RemoteServerName, and marshaling information, to the client computer.

COM+ preinstalled applications
    NET Utilities
    Analyzer Control Publisher Application
    COM+ Explorer
    COM+ QC Dead Letter Queue Listener
    COM+ Utilities
    IIS In-Process Applications
    IIS Out-Of-Process Pooled Applications
    System Application

- COM+ System Application includes the value EOAC_DISABLE_AAA. This value, which disables activate-as-activator (AAA) activations, is used with the CoInitializeSecurity function when launching the System Application.

EOAC_DISABLE_AAA allows an application that runs under a privileged account

- parts of a COM+ application 

consist of one or more COM components,  exposed by a COM class that specify a contract. , interface semantics, marshaling buffer format

COM interfaces are immutable; the COM contract states that they cannot be modified.

- configured and unconfigured components 
COM component is added to a COM+ appliation is a configured component 

COM components built for COM+ applications are in-process server components. The component must contain a type library (.tlb file) to describe all classes 

unconfigured component is a component that isn't installed in a COM+ application.

    + note 
    
Do not use the same AppID for both a COM+ application and in the registry for an unconfigured component. When the unconfigured component is activated , as activation may retrieve the COM+ application information 

- Developing COM+ application 

COM classes and implementation classes.
Group the classes into components.
Select the set of COM+ services for your component or Component Services administrative tool or the COM+ administration object model

    + create COM+ application 
    
Integrate the components into a COM+ application.

Specify the correct set of attributes for each of the classes, These attributes express the components dependencies on any COM+ services

Configure environment-specific attributes on classes and applications, object pool size, environment specific attributes can be set later by system admin 

Export the app

    + admin COM+ application 

Installing the partially configured COM+ application 

Providing environment-specific attributes

Re-exporting the fully configured COM+ application

Creating an application proxy

- COM+ contexts and threading models 

In COM+, a context is defined as set of run-time properties associated with one or more COM objects to provide services for objects 

In COM+, every COM object is associated with precisely one context as it runs

every context resides within precisely one COM apartment. 

Multiple objects can run within the same context

multiple contexts can reside within the same apartment. 

unconfigured components that do not use COM+ services, the context is ignore 



# COM+ Contexts 
- programmatic interaction with context properties 

associated ObjectContext object that keeps track of its properties

accessed ObjectContext, you can call methods on the IObjectContext interface 

calling IObjectContext::SetComplete has the effect of setting the transaction consistency bit to "consistent" and the JIT-activation done bit to "done" 

IObjectContext, other specialized interfaces providing access to context properties are IObjectContextInfo, IContextState, and IObjectContextActivity.

ISecurityCallContext also accesses context properties. You can use IGetSecurityCallContext::GetSecurityCallContext to obtain ISecurityCallContext

- Understanding 

Context activation, or the initialization of an object in an appropriate context.
    
    Interception, or what COM+ does on calls across a context boundary.

- MTS context wrappers. The purpose they servedâ€”providing automatic services by trapping creation requests

use the SafeRef function. In MTS, SafeRef was used to obtain a reference 

- Context activation 

In COM+, every COM object is created with an associated context. This is called activation. 

calling CoCreateInstance

object pooling, an object is activated without being created from scratch

- flowing of context properties 

COM+ has to compare the context of the caller with the configuration of the called component and then decide where to activate the downstream component 

COM+ looks it up in the COM+ class registration database, which is optimized for extremely fast run-time lookups

the configuration is consistent with the context of the caller and the component can be activated within the caller's context

when downstream component cannot be activated within the caller's context, it is activated in its own context in an appropriate apartment

- ignored context properties,  These properties are fundamentally ignored when context is flowed. Or if a component uses only process-level access checking, its security context property is ignored

- forcing activation in the caller's context 

an object cannot be activated in its own context by selecting the Must be activated in callers context option on the Activation tab of the component Properties page, using the Component Services administrative tool

    + reference
    https://docs.microsoft.com/en-us/windows/win32/cossdk/enforcing-activation-in-the-caller-s-context

    + COM+ activates an instance of the component in a context 
    
    The object is activated in the creator's context if possible.
    
    cannot be activated in the caller's context, CoCreateInstance fails or activation fails if it requires its own context; CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT is returned.

- default context, it is for unconfigured componentsâ€”that is, COM components not installed in COM+ applications and not registered in the COM+ class registration database. 

If unconfigured components have a compatible threading model, they are activated in the caller's context. Otherwise, they are activated in a default context 

- hooking activation, implementing IObjectControl::Activate and IObjectControl::Deactivate, you can hook activation and deactivation together to perform special initialization in the new context


- interception of cross context calls  

in global variablesâ€”you should always use CoMarshalInterface and CoUnmarshalInterface, translate an object reference into a proxy usable in a different context. 

insist that the object that cannot be marshaled be activated only in the context of its caller and never in its own context, must be activated in caller's context option in Activation tab of component properties page 

- COM+ threading models 

An apartment is a collection of contexts contained in a process, a

{process 
    {apartment
        {activity 
            {context}
            {context}
        }
    }
}

calls across apartments (out-of-process) are indirect and require proxy and stub code. Apartments allow for objects with different synchronization and reentrancy properties and have two categories: single-threaded and multithreaded

a single-threaded apartment (STA) execute on the particular thread in which they were created. rely on the Microsoft Windows message queue

Objects in a multithreaded apartment (MTA) execute on any thread and allow any number of methods to occur simultaneously. MTAs support reentrance implicitly.

COM+ classes are marked with a ThreadingModel property that allows COM+ to create the object in the proper apartment. CoCreateInstance uses ThreadingModel property 

Threads must call CoInitializeEx before they can use COM+

The main thread apartment is determined to be the first STA called by CoInitializeEx. This is usually associated with the main thread of a process. CoInitializeEx indicates the type of apartment by flags 

    + COINIT_MULTITHREADEDâ€”Locates the thread in the single multithreaded apartment.
    
    + COINIT_APARTMENTTHREADEDâ€”Places the thread into a new STA.
    
- Threading model attribute 
    + apartment types 

    Main Thread Apartment
    Single Thread Apartment
    Free Thread Apartment
    Neutral Apartment
    Any Apartment

    + Component Services administrative tool to view the threading-model

    + do not specify threading model for a component, COM+ use main therad apartment, which is the default 
    
    + programming model for apartments in COM+.

Model 	Apartment 	Free 	Both 	Neutral 	Not Specified
stnm     cp           mp     cp      np         mtp
stm      cp           mp     cp      np         cp
mt       hstp         mp     mp      np         mtp 
n(on st) hstp(for t)  mp     np      np         mtp 
n(on mt) hstp         mp     np      np         mtp 

stnm, single threaded not main 
cp, current apartment 
mp, multithreaded apartment 
np, neutral apartment 
mtp, main threaded apartment 
mt, multithreaded 
n(on st), netural (on STA thread) 
n(on mt), neutral (on MTA thread)
hstp, host single threaded apartment 
hstp(for t), host single threaded apartment for this thread 

- neutral apartments 

it is the preferred model for COM+ for components with no user interfaces 

implement because they must deal with interlocking access

```
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
   {CLSID}
      InprocServer32
         ThreadingModel = Neutral
```

In neutral apartments, objects follow the guidelines for multithreaded apartments but can execute on any kind of thread. object's context is received without causing a thread switch.

Each process can have only one neutral apartment. 

- Components that have user interfaces should continue to use single-threaded apartments as the preferred model


# COM+ Services primier 
- illustrates a fundamental aspect of COM+ services:

Step 1: Creating a Transactional Component
Step 2: Extending a Transaction Across Multiple Components
Step 3: Reusing Components

- creating a transactional component 

COM+ automatically starts a transaction and enlists the database (resource manager) in that transaction

{client} -> {transaction boundary {updateAuthorAddress}<-> {sql server}}

COM+ application and installing the application, the transaction attribute must be set to Required, which guarantees that COM+ creates each UpdateAuthorAddress object in a transaction. 

    + sample 
https://docs.microsoft.com/en-us/windows/win32/cossdk/step-2--extending-a-transaction-across-multiple-components

- extending a transaction across components 

The second component, ValidateAuthorAddress, validates the author's address and returns the results to its caller, UpdateAuthorAddress.

{client} -> {transaction boundary {updateAuthorAddress}<-> {sql server}}
                                    |               A
                                    V               |
                                    {ValidateAuthorAddress}

COM+ doesn't count the votes until it deactivates the root object

    + Setting a component's transaction attribute to Supported can result in the new object being created in the calling object's transaction
    
    + All objects participating in the same transaction share a common transaction identifier
    
    + Each object in a transaction votes independently of other objects. COM+ count the votes when root object is deactivated
    
    + The IContextState and IObjectContext interfaces provide methods and that produce similar voting results 
    
    vote between commit and abort until COM+ deactivates the object 

IContextState combination methods 	IObjectContext equivalent method
SetMyTransactionVote txVote = TxCommit
SetDeactivateOnReturn bDeactivate = True        SetComplete

    + COM+ sets an object's vote to the equivalent of EnableCommit unless the component votes explicitly
    
    + Voting explicitly can reduce the overall duration of the transaction

- Reusing components 

COM+ provided transaction processing, JIT activation, and concurrency protection
 
COM+ always makes the first object created in the transaction the root object



# COM+ Services 
- Application pooling

 allows single-threaded processes to scale and can also help you recover from failures in single processes
 
- concepts, single threaded processes to scale, help recover from failures 

ICOMAdminCatalog2 interface support application pooling.

Library applications have the recycling and pooling properties of their host process.

ConcurrentApps property of the COMAdminCatalogObject object in the Applications collection

ConcurrentApps is an integer value that specifies the maximum number of simultaneous Dllhost processes, set by administration tool or programmatically 

ConcurrentApps property is set to 1, which is the default value, pooling service is disabled 

- application pooling tasks 

Library applications have the recycling and pooling properties of their host process.

steps 
    + In the console tree of the Component Services administrative tool, right-click the COM+ application
    
    + On the Pooling & Recycling tab, under Application Pooling, enter a value for Pool Size, it is the number of instances of app 

set with visual basic code 
```
Function SetMyApplicationPooling( _
  strApplicationName As String, _
  lngPoolValue As Long _
) As Boolean  ' Return False if any errors occur.

    SetMyApplicationPooling = False  ' Initialize the function.
    On Error GoTo My_Error_Handler  ' Initialize error handling.

    Dim objCatalog As COMAdmin.COMAdminCatalog
    Dim objAppCollection As COMAdmin.COMAdminCatalogCollection
    Dim objApplication As COMAdmin.COMAdminCatalogObject
    Set objCatalog = CreateObject("COMAdmin.COMAdminCatalog")
    Set objAppCollection = objCatalog.GetCollection("Applications")
    objAppCollection.Populate 
    For Each objApplication in objAppCollection
        If objApplication.Name = strApplicationName Then
            objApplication.Value("ConcurrentApps") = lngPoolValue
            MsgBox strApplicationName & _
              " pooling value set to " & lngPoolValue
            Exit For
        End If
    Next
    objAppCollection.SaveChanges

    Set objApplication = Nothing
    Set objAppCollection = Nothing
    Set objCatalog = Nothing
    SetMyApplicationPooling = True  ' Successful end to procedure
    Exit Function

My_Error_Handler:  ' Replace with specific error handling.
    MsgBox "Error # " & Err.Number & " (Hex: " & Hex(Err.Number) _
      & ")" & vbNewLine & Err.Description
    Set objApplication = Nothing
    Set objAppCollection = Nothing
    Set objCatalog = Nothing
End Function
```

C++ set the application pool 
```
#include <windows.h>
#include <stdio.h>
#import "C:\WINDOWS\system32\Com\ComAdmin.dll"
#include "ComAdmin.h"
#include "StrSafe.h"  // For the StringCchLengthW function

BOOL SetMyApplicationPooling (OLECHAR* szMyApp, LONG lPool) {
    IUnknown * pUnknown = NULL;
    ICOMAdminCatalog * pCatalog = NULL;
    ICatalogCollection * pAppColl = NULL;
    ICatalogObject * pApplication = NULL;
    HRESULT hr = S_OK;
    BSTR bstrMyApp = NULL;
    unsigned int uMaxLen = 255;  // Maximum length of szMyApp
    LCID lLan = 1024;// Use the default language for comparing strings.

try {
    // Test the input pool value.
    if ((lPool < 1) || (lPool > 1048576)) throw(E_INVALIDARG);
    
    // Test the input szMyApp to make sure it's OK to use.
    hr = StringCchLengthW(szMyApp, uMaxLen, NULL);
    if (FAILED (hr)) throw(hr);
    
    // Convert szMyApp to a BSTR.
    bstrMyApp = SysAllocString(szMyApp);

    // Create a COMAdminCatalog object and get its IUnknown.
    hr = CoCreateInstance(CLSID_COMAdminCatalog, NULL, 
      CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnknown);
    if (FAILED (hr)) throw(hr);

    // Get the ICOMAdminCatalog interface.
   hr = pUnknown->QueryInterface(IID_ICOMAdminCatalog, 
      (void**)&pCatalog); 
    if (FAILED (hr)) throw(hr);

    // Get an interface to the Applications collection.
    hr = pCatalog->GetCollection(L"Applications", (IDispatch**)&pAppColl);
    if (FAILED (hr)) throw(hr);

    // Populate all of the Applications collection.
    hr = pAppColl->Populate();
    if (FAILED (hr)) throw(hr);

    // Get the number of applications in the collection.
    LONG lCount = -1;
    hr = pAppColl->get_Count(&lCount);
    if (FAILED (hr)) throw(hr);

    // Iterate through each application in the collection.
    VARIANT varName;
    VariantInit(&varName);
    for (LONG lIdx = 0; lIdx < lCount; lIdx++) {
        hr = pAppColl->get_Item(lIdx, (IDispatch**)&pApplication);
        if (FAILED (hr)) throw(hr);

        // Get the Name value of each application.
       hr = pApplication->get_Name(&varName);
        if (FAILED (hr)) throw(hr);

        // Compare the application name to bstrMyApp.
        hr = VarBstrCmp(varName.bstrVal, bstrMyApp, lLan, NULL);
        if (FAILED (hr)) throw(hr);
        if (VARCMP_EQ == hr) {  // The strings are equal.
            // Set the new pooling value.
            VARIANT varPool;
            VariantInit(&varPool);
            varPool.vt = VT_I4;  // Tell the VARIANT it's holding a LONG.
            varPool.lVal = lPool;
            hr = pApplication->put_Value(L"ConcurrentApps", varPool);
            if (FAILED (hr)) throw(hr);
            printf("%S pooling value set to %ld.\n", bstrMyApp, lPool);
            break;
        }
    }
    LONG lNum;
    hr = pAppColl->SaveChanges(&lNum);
    if (FAILED (hr)) throw(hr);

    // Clean up.
    SysFreeString(bstrMyApp);
    pUnknown->Release();
    pUnknown = NULL;
    pApplication->Release();
    pApplication = NULL;
    pAppColl->Release();
    pAppColl = NULL;
    pCatalog->Release();
    pCatalog = NULL;
    return (TRUE);
}  // Try

catch(HRESULT hr) {  // Replace with specific error handling.
    printf("Error # %#x: ", hr);
    ErrorDescription(hr);
    SysFreeString(bstrMyApp);
    if (NULL != pUnknown) pUnknown>Release();
    pUnknown = NULL;
    if (NULL != pApplication) pApplication->Release();
    pApplication = NULL;
    if (NULL != pAppColl) pAppColl->Release();
    pAppColl = NULL;
    if (NULL != pCatalog) pCatalog->Release();
    pCatalog = NULL;
    return (FALSE);
}catch(...) {
    printf("An unexpected exception occurred.\n");
    throw;
}
}  // SetMyApplicationPooling
```

- COM+ application recycling 

a simple solution to gracefully shut down a process associated with an application and restart it

Dllhost process services all future object requests, which leaves the old Dllhost to finish servicing the remaining object requests. The old Dllhost process is shut down when it detects the release of all external references to objects in the process or when the expiration time-out value is reached. 

cannot recycle a COM+ application that has been configured to run as a Windows service

COM+ Administrative SDK. You can recycle processes based on several criteria,  COMAdminCatalogObject object in the Applications collection:

    + RecycleLifetimeLimit, maxium number of minutes a process can run 
    + RecyleMemoryLimit 
    + RecycleCallLimit
    + RecycleActivationLimit 
    
COM+ application recycling tasks, right-click the COM+ server application you want to be recycled and then click Properties

- COM+ application running as service applications 

the Queued Components listeners can be started automatically if they are configured as a service.
If your application needs to perform privileged operations, the application can run as the local system account.
If other services need to be marked as dependent, Component Services provides that option. 

    + starting an application manually, it acts like a DLL host with the security settings of a service. The service will be started up manually when activated and shut down automatically when it times out.
    
    + configuring a COM+ server application as a service application 
    
    the system services can be marked as dependent and will not start the application until the system services have been started in the specified order.
    
- service configurations 
    
the system services can be marked as dependent and will not start the application until the system services have been started in the specified order
    
- COM+ service application tasks 
    
A COM+ server application can be created as a service to start either automatically during the system startup or manually by activations
    
    + Component Services administrative tool
    
    + right click COM+ service app then click properties 
    
    + configure an app run as service 
    administrative tool 
    right-click com+ server app 
    properties, click activation 
    activation type check run application as NT service 
    click setup new service button 
    startup type, select automatic or manual 
    a particular error, select Ignore, Normal, Severe, or Critical in the Error Handling box
    (option) set service dependencies 
    allowed to interact with the desktop, check the Allow service to interact with desktop
    click create 
    assign service to a user account 
    
    + reference 
    https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc731901(v=ws.11)?redirectedfrom=MSDN
    component service administration
    
- 4 way to open  Component Services administrative tool
    + run 
    dcomcnfg
    
    + start menu dcomcnfg 
    
    + command prompt 
    $ dcomcnfg.exe 
    
- open program and features 
$ appwiz.cpl 

- COM+ compensating resource manager 
COM+ Compensating Resource Manager (CRM) provides a quick and easy way to integrate application resources with Microsoft Distributed Transaction Coordinator (DTC) transactions

CRM is a alternative to dev a full Microsoft Transaction Services (MTS) resource manager. consists of two components 
    + CRM worker, always requires a transaction. write log 
    + CRM Compensator. This component is created by the CRM infrastructure at the completion of the transaction

COM+ CRM provides atomicity with transactional notifications, and durability with the CRM log, but does not provide isolation of resources

    + three interface types for the basic CRM functions
    ICrmLogControl is implemented on the CRM clerk and is used by the CRM Worker to write log 
    
    ICrmCompensator and ICrmCompensatorVariants are implemented on the CRM Compensator. These interfaces are used to deliver transaction outcome notifications and their associated log 
    
    The COM+ CRM monitoring interfaces are used for monitoring the CRMs within a particular server application

- COM+ CRM security considerations 

COM+ creates the CRM compensator component and calls the ICrmCompensator interface. 

the system administrator can use role-based security to restrict the CRM Compensator component

- the CRM worker first obtains the ICrmLogControl interface, which allows the CRM worker to write records to the durable log

the ICrmLogControl::RegisterCompensator method. After this method is called, the CRM Compensator is created by the CRM infrastructure

write records to the CRM log using ICrmLogControl. The CRM worker must write ahead; that is, it must write a record to the log describing an action before it actually performs 

    + WriteLogRecordVariants, writing a structured log record 
    + WriteLogRecord, writing an unstructured log record 
    
use the ICrmLogControl::ForceLog method instead to guarantee that all writes done

finished writing and forcing records to the log, it must release ICrmLogControl. When the transaction completes

implements either the ICrmCompensator interface or the ICrmCompensatorVariants interface. These interfaces are used to pass the unstructured (Visual C++) or structured (Visual Basic) records to the CRM Compensator

a CRM Compensator uses the abort notification to reverse the action that was performed by the CRM worker

the CRM Compensator needs to clean up that state if the transaction commits.

 the CRM log file created for the server application is based on the AppId (a GUID) of the server application

CRM log file is placed in the same directory as the DTC log file (normally your %SystemRoot%\winnt\system32\DtcLog

location of the CRM log files can be changed using the COM+ administration SDK

 main factor to consider is whether a specific CRM cares which node of the cluster it is operating on

- COM+ CRM registry settings 

All CRM registry settings are under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\COM3\CRM. Create the CRM key under the COM3 key

VTRACE1, DEWORD, enables debug trace messages 
IgnoreCompensatorErrors, DWORD, allows the CRM infrastructure to ignore all errors returned from CRM compoensators 

CheckpointIntervalInSec, checkpoint interval in seconds 

InitialLogFileSizeInKB, CRM log file size in kilobytes 

RecoveryTraceEnabled, recovery trace is a text file 

- Troubleshooting the COM+ CRM 

Event log 

Exceptions from the CRM compensator 

Recovery trace 

Trying to run the CRM not enabled 

Trying to run CRMs in client processes 

Recovery in process 

Security on CRM log file 

In-doubt transactions, DTC transaction might go into the in-doubt state; that is, the DTC cannot determine the transaction outcome

Creation and release of CRM compensator

- Design suggestions for developing a COM+ CRM 

suggest steps 
    + set the VTRACE1 registry flag 
    + check CRM interfaces
    
    https://docs.microsoft.com/en-us/windows/win32/cossdk/com--crm-interfaces
    
    implement base on your requirements 
    
    + develop CRM worker first, log records 
    
    + debug CRM compensator 
    
    + develop the real CRM compensator and replace the debug compensator with real CRM compensator 
    
    + delete the CRM log in each time 
    
    + considerations 
    write ahead before doing action 
    isolation 
    recovery in progress 
    error handling 
    recovery time 
    idempotence, actions that CRM compensator must be idempotent 
    initiation of recovery 

- COM+ CRM monitoring interface 

ICrmMonitor
	Using ICrmMonitor::GetClerks, a snapshot can be obtained of the current set of active CRM clerks 

ICrmMonitorClerks
	Using this interface, the clerk collection object can be browsed for information about the state of the clerk collection

ICrmMonitorLogRecords
	This interface can be used to query the current state of the transaction, to find out how many log records this CRM clerk has written

- COM+ CRM interfaces 

ICrmCompensator 	This interface delivers unstructured log records in Visual C++.

ICrmCompensatorVariants 	This interface delivers structured log records to the CRM Compensator when using Visual Basic.

ICrmFormatLogRecords 	This interface converts the log records to viewable format so that they can be presented using a generic monitoring tool.

ICrmLogControl 	This interface is used by the CRM Worker and CRM Compensator to write records to the log and make them durable.

ICrmMonitor 	This interface captures a snapshot of the current state of a CRM and holds a specific CRM clerk.

ICrmMonitorClerks 	This interface obtains information about the state of clerks.

ICrmMonitorLogRecords 	This interface monitors the individual log records maintained by a specific CRM clerk for a given transaction.

- COM+ compensating resource manager tasks 

CRM Worker, transaction = requiredsync = yesJIT = yesthreading model = Both

CRM Compensator, transaction = disabledsync = disabledJIT = nothreading model = Both

    + configuring COM+ CRM components 


- COM+ events 

Subscribers can query this store and select the events that they want to hear about

- COM+ events concepts, COM+ events service maintains subscription data in the COM+ catalog

COM+ Events service uses an event class object to manage the connection between publisher and subscriber. 

calling CoCreateInstance or the Microsoft Visual Basic CreateObject method and requesting the event interface

provide a self-registering DLL that exports the DllRegisterServer and DllUnregisterServer functions. The DllRegisterServer function registers a COM class, and the DllUnregisterServer function unregisters the component

Event class objects,  methods of the ICOMAdminCatalog::InstallEventClass or ICOMAdminCatalog::InstallMultipleEventClasses interfaces from administration tool or programmatically 

COM+ Events service uses type library marshaling. this bring some restrictions on event class interfaces, marshaler does not support the MIDL attributes size_is and length_is etc.

publication attributes with properties 
    + EventCLSID. A unique identifier that specifies the CLSID of the component.
    + EventClassName. A unique identifier that specifies the PROGID of the component.
    + TypeLibrary. Provides a list of interfaces offered by the event class object. There is no need to implement the firing interfaces specified in the type library.

- Event subscriptions 

Component Services administrative tool or programmatically by using the ICOMAdminCatalog::InstallComponent 

The SubscriptionsForComponent collection is used to add, delete, or change information pertaining to subscriptions

use the Add method to add an entry to the collection.

To set up the various properties of the subscription object, use the Value property. 

To save the changes, use SaveChanges on the SubscriptionsForComponent collection object.

Subscriptions specify the following information 
    + Identity and location of the subscriber
    + Delivery method
    + Event methods to deliver
    + Event class object and PublisherID property of an event class component from which the subscriber wants to receive events
    
three types of subscriptions 

    + persistent 
    
    Specify the subscriber object by the SubscriberMoniker property of the subscription
    
    Subscriber objects created by a persistent subscription are always released after each event call.
    
    + transient 
    
    transient subscriptions, you can use the TransientSubscriptions collection
    
    transient subscription, see Registering a Transient Subscription
    
    + per user 

    deliver events only when the subscriber is logged on to the event system's computer.
    
    To receive meta-events from the event system, applications must create a subscription that resides on the event system's computer and that specifies the firing interface ID (IID_IEventObjectChange)
    
COM+ events does not support a distributed event store. A subscriber must subscribe to an event on each computer from which it wants to receive notification. 
register the event class object and subscriptions on a central computer and instantiate this event class object from the remote computers. 
Delivery of events is provided either by DCOM or by the COM+ queued components service.
publisher can implement a publisher filter to control subscribers 

- filtering events in COM+ 

The filter criteria string recognizes relational operators for checking equality (=, ==, !, !=, ~, ~=, <>), nested parentheses, and logical keywords AND, OR, or NOT

publisher filter invokes IFiringControl::FireSubscription

- The COM+ queued components service can be used to make the publisher and subscriber processing time independent by queuing the publisher's message and later replaying it to the subscriber

The recorder batches all method invocations into a message, and then the player invokes those methods in order when the message is processed

    + two places
    
    Between the publisher and event object
    Between the event object and subscriber

deliver asynchronous event, sets SubscriberMoniker as follows: "queue:/new:/{12345678-1234-1234-1234-123456789012}".

- COM+ events security considerations 

select Packet Privacy as the Authentication Level for Calls setting

use role-based security to help ensure that callers of your event class object's methods have appropriate

- COM+ events tasks 
    + steps to use COM+ events 
    
    register an event class 
    
    registering a subscription 
    
    registering a transient subscription 
    
    publishing an event 
    
    creating a publisher filter 

- registering an event class with administration tool 
    + create a new COM+ app 
    + open the applicatio nfolder and select components 
    + on action, click New 
    + instal new event class(es)
    + enter the path to the event class component DLL 
    + click OK 

- registering a subscription 

    + after register event in COM+ catalog, then we can add subscribers 
    + create new com+ app, installing the subscriber component 
    + right click subscriptions folder to enable COM+ new subscription wizard  
    + enter the name for subscription 
    + enable subscription 
    + click ok 

- registering a transient subscription 

transient subscriptions are tied to a particular object and are stored only in the event system

Transient subscriptions can be more efficient than persistent subscriptions, but you must manage their object life cycles.

it can not set with administration tool, need to use administrative interfaces 

    + VB 
    
```
Public Function CreateTransientSubscription( _
  ByVal clsid As String, ByVal objref As Object) As String 
    Dim oCOMAdminCatalog As COMAdmin.COMAdminCatalog
    Dim oTSCol As COMAdminCatalogCollection
    Dim oSubscription As ICatalogObject
    Dim objvar As Variant
    On Error GoTo CreateTransientSubscriptionError
    Set oCOMAdminCatalog = CreateObject("COMAdmin.COMAdminCatalog")
    'Gets the TransientSubscriptions collection
    Set oTSCol = oCOMAdminCatalog.GetCollection( _
      "TransientSubscriptions")
    Set oSubscription = oTSCol.Add
    Set objvar = objref
    oSubscription.Value("SubscriberInterface") = objref
    oSubscription.Value("EventCLSID") = clsid
    oSubscription.Value("Name") = "TransientSubscription"
    oTSCol.SaveChanges
    CreateTransientSubscription = oSubscription.Value("ID")
    Set oSubscription = Nothing
    Set oTSCol = Nothing
    Set oCOMAdminCatalog = Nothing
    Set objvar = Nothing
    Exit Function
CreateTransientSubscriptionError:
    CreateTransientSubscription = ""
    Err.Raise Err.Number, "[CreateTransientSubscription]" & _
      Err.Source, Err.Description
End Function
```

CreateTransientSubscription function returns a string, which is a GUID that can be used as a handle or a cookie to revoke the subscription

call the Remove method of COMAdminCatalogCollection on the TransientSubscriptions collection, passing in the index corresponding to the subscription with the GUID

- publishing an event 

calling CoCreateInstance or the Microsoft Visual Basic CreateObject method using EventClassID or EventClassName as an argument

The event system then publishes events on the event class CLSID_EventObjectChange with the interface ID IID_IEventObjectChange.

- creating a publisher filter 

using IEventControl::SetPublisherFilter

 compose the event object with the COM+ queued components service, the preferred method is to use the MultiPublisherFilterCLSID property in the event class to set publisher filter 

You can also use SetPublisherFilter. 

The publisher filter objects must support either IPublisherFilter or IMultiInterfacePublisherFilter, depending on whether you have a single firing interface or multiple firing interfaces. The Initialize method is called by event class object immediately after creating the filter 

COM+ Events tries to invoke two methods on the filter. First it calls IPublisherFilter::PrepareToFire and passes an IFiringControl interface pointer to the filter. It will Query the filter object for the event interface, if it supports, it invokes a method on it. 

- COM+ instrumentation concepts 

build your own COM+ event management and logging programs when you want to display various performance metrics for your COM+ components.

Visual Studio Analyzer (VSA) format when you are upgrading MTS packages that are receiving MTS events

implement the COM+ instrumentation interfaces to receive notifications

a loosely coupled events (LCE) system that stores event information from different publishers 

when you subscribe to a COM+ instrumentation interface or method, you can specify properties for the subscription in the COMSVCSEVENTINFO structure, such as the application ID (guidApp member) or the process ID (dwPid member)

- COM+ instrumentation interfaces 

using COM+ Events, a loosely coupled events (LCE) system that stores event information from different publishers in an event store in the COM+ catalog

IComActivityEvents 
IComAppEvents 
IComApp2Events
IComCRMEvents 
IComExceptionEvents 
IComIdentityEvents 
IComInstanceEvents
IComINstance2Events 
IComMethodEvents 
ICommeMethod2Events
IComObjectPoolEvents
IComObjectPool2Evets
IComObjectPoolEvents2
IComQCEvents 
IComResourceEvents 
IComSecurityEvents 
IComThreadEvents
IComTrackingInfoCollection
IComTrackingInfoEvents 
IComTrackingInfoObject
IComTrackingInfoProperties 
IComTransactionEvents 
IComTransaction2Events 
IComUserEvent 
ISystemAppEventData

- COM+ Just-in-time activation 

    + concepts 
    
    The just-in-time (JIT) activation service enables COM+ to deactivate an object while a client still holds an active reference to that object. The next time the client calls a method on the object, which the client believes to be still active, the COM+ JIT activation service reactivates the object transparently to the client
        * client is simplied 
        * improved performance 
        * server saved memory 
    
    Enabling JIT Activation for a Component.
        https://docs.microsoft.com/en-us/windows/win32/cossdk/transactions-and-com--jit-activation
        
        component is enabled for JIT activation, synchronization is automatically set to required
        
    deactivation an object based on the status of the doneness bit 
        * set true, COM+ deactivates the object when the current method call returns.
        * set to false, remain active 
        
        * following ways:
        Using IContextState
        Using IObjectContext
        Using the auto-done property
    
    using the auto done property, configure a method such that the object is automatically deactivated on method return
    
        * If SUCCEEDS(hr), it is as though you called SetComplete.
        * If FAILED(hr), it is as though you called SetAbort.

    COM+ calls IObjectControl::Deactivate when it deactivates the object and IObjectControl::Activate when it reactivates it.
    
    transactions and COM+ JIT activation 
    
    Statelessness. You would not hold state that would violate transaction
    
    using COM+ Object Pooling. By pooling objects that are JIT activated, you can dedicate a certain amount of memory to hold a certain number of objects
    
    + tasks 
    
    enable JIT activation for a component 
        * administrative tool, right-click the component that you want to configure and then click Properties.
        
        * activation tab 
        * enable just in time activation 
    
    setting the done bit following ways:

        * Using IContextState,  IContextState::SetDeactivateOnReturn to set the done, IContextState::GetDeactivateOnReturn to get the current status
        * Using IObjectContext, SetComplete, SetAbort, EnableCommit, DisableCommit
        * Using the auto-done property

    enabling auto-done for a method 
        * administrative tool, right-click the method that you want to configure and then click Properties.
        
        * general tab 
        
        * select the Automatically deactivate this object when this method returns check box
    
    enforcing activation in the default context 
    
        * choose to activate a configured component in the default context
        
        * resources by limiting the number of contexts
        
        * limiting the number of cross-context calls
        
        * import older COM applications into COM+ and run them without a problem. 
        
        old COM objects may require pass reference within apartment without marshaling, in administration tool mark all the classes in the application as Must be activated in the default context. to shift to COM+
        
        * in administration tool can set enforce activation in default context in property tab
        
        any COM object don't required COM+ services will be good to activate in default context 
    
    the following occurs when COM+ activates an instance of the component in a context:

        * The object is activated in the creator's context if possible.
        * Object activation fails if it requires its own context; CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT is returned.

    
- COM+ lowe memory activation gates

If the percentage of virtual memory available to the application falls below a fixed threshold, the activation fails before the object is created. 

    + concepts 
    multithreaded apartment (MTA) and a free-threaded object need locking
    
    eliminate the need to use locking by setting the synchronization attribute for a component
    
    COM+ proactively monitors memory load in the system and ensures that a reasonable amount of memory is available before executing user code
    
    COM+ low memory activation gates tasks 
    + tasks 

- COM+ object constructor strings 

COM+ object constructor strings support generic programming. They enable you to write a single component with a degree of generality 

should not be used to store security-sensitive information.
    + concepts 
    elies on object constructor strings, using IObjectConstruct, and recompile it to produce several customizable components each with a distinct CLSID
    
    COM+ calls the IObjectConstruct::Construct method that it implements. 
    
    the constructor string by using IObjectConstructString. Empty strings can be valid entries.
    
    + tasks 
        * administration tool 
        * Enable object construction check box.
        * In the Constructor string box, enter the construction string (for example, DSN=AccountingServer)
        
    example 
    
    ```
    Implements IObjectConstruct
    Private Sub IObjectConstruct_Construct( ByVal pCtorObj As Object )
        Dim strConstructorString As String
        strConstructorString = pCtorObj.ConstructString
         Parse and use strConstructorString here. 
    End Sub
    ```

- COM+ object pooling 
    + concepts 
    
    configure a component to have instances of itself kept active in a pool, ready to be used by any client that requests the component.
    
    Pooled objects can implement IObjectControl to control how they are reused.
    IObjectControl::Activate 
    IObjectControl::CanBePooled 
    IObjectControl::Deactivate 
    
    + how object pooling works 
    
    it can be reused and should return an appropriate value for IObjectControl::CanBePooled.
    
    object to do some small unit of work, pushing or pulling data, and then the object will call IObjectContext::SetComplete or IObjectContext::SetAbort and return.

    objects must support aggregationâ€”that is, they must support being created by invoking CoCreateInstance with a non-NULL pUnkOuter argument

    + Components developed with Microsoft Visual Basic 6.0 and earlier cannot be pooled 

    Poolable objects that participate in transactions must manually enlist managed resources. 

    + turning off automatic enlistment 

    Auto-enlistment is sometimes coupled with connection pooling, as with ODBC, and sometimes not, as with OLE DB. You might need to ensure that auto-enlistment is off

    + client requesting an object has an associated transaction, If an object with transaction affinity is found, it is returned to the client; otherwise, an object from the general pool is returned

    + Controlling object lifetime and state with IObjectControl

    + tasks 
    
    consider, minimul size, maximum size, creation timeout 
    
    administration tool can set these values 
    
    + monitoring object statistics

    To enable object statistics for the component, under Activation Context, select the Component supports events and statistics

- COM+ partitions 

COM+ partitions service to install different versions of a COM+ application on a computer and run them simultaneously.

administrative tools can manage COM+ partitions 

    + concepts 
    it's necessary to use different versions or configurations of an application on the same computer, COM+ partitions can avoid conflicts 
    
    + implementation 
    
    an administrator can create a partition using the Component Services administrative tool. local partition can server local user only. Within Active directory can server domain
    
    After a partition is created and a COM+ application is installed into it, the administrator can assign that partition as a default partition for one or more users on that server

    + partitions and active directory 

    Created in Active Directory, partition sets allow users in a domain to access COM+ applications throughout the domain

    specific user or organizational unit (OU) is assigned, or mapped, to a partition set

    To make COM+ applications available to domain users, an administrator must perform tasks both on the domain controller and server where COM+ installed 

    + domain controller 
    
    administrative tool or programmatically by using the Active Directory Services Interface (ADSI).
    
    + COM+ application server 
    
    creates a new partition, specifying the same partition name and partition ID (GUID) as that of the partition that was created within Active Directory on the domain controller. The COM+ Partitions folder within the Component Services administrative tool

    + Mapping user identities and OUs to partition sets 
    Ensures that applications are available to the appropriate users in the domain
    
    Helps COM+ in determining the partition in which an application is located
    
    Establishes a user's right to access a particular application

    + The global partition, A global partition is automatically created when COM+ is installed. The global partition is designed to contain system-wide applications to all users or domain 
    
    must be marked as public, not private, components.
    
    + partition properties 
    Partition name 
    
    Partition id 
    
    Description 
    
    Disable deletion 
    
    Disable changes 
    
    + Registering and activating components in partitions 
    
    the partitions service allows an administrator to copy applications or components from one partition into another
     
    a component is copied, all associated partition properties are copied with it, except the application's identity or any of the members of a role
    
    client calls  CoCreateInstance or CoGetObject function
        * locates the partition in which the component resides 
        * locates the correct component within that partition 
    
    + locating partition dependes on 
    parameters 
    component is activated is local or remote 
    the internal use of the partition cache 
    
        * calling program, whether the function call includes a partition moniker, which consists of a partition ID and a CLSID, or includes a CLSID only
        
        CoGetObject or GetObject Parition moniker(includes partition ID and CLSID) uses the partition ID specified in the partition moniker 
        CoCreateInstance CLSID Uses either the partition ID of the user identity's default partition or the partition ID added to the context 
        
        * using partition monikers 
        
        A partition moniker is used within code to explicitly specify the partition of the activated component. 
        
        moniker is used to locate the partition, the activation occurs from that partition
        ```
        HRESULT CoGetObject(
          L"partition:partitionGUID/new:clsid",
          pBindOptions,
          IID_IUnknown,
          (void**)&pIUnknown);
        ```
        
        ```
        // Create CLSID1 configured in the Production partition.
        HRESULT hr = CoGetObject(
            L"partition:{35056070-D5B7-4b59-9FBF-0D23417F6937}/new:CLSID1",
            pBindOptions, IID_IUnknown, (void**)&pIUnknown);
        ```
        
        ```vb
        GetObject("partition:partitionGUID/new:CLSID") As Object
        ```
        
        partition moniker is being used as an argument 
        ```
        Dim objCLSID1 As Object
        Set objCLSID1 = GetObject( _
           "partition:{35056070-D5B7-4b59-9FBF-0D23417F6937}/new:CLSID1")
            "partition:{35056070-D5B7-4b59-9FBF-0D23417F6937}/new:CLSID1")
        ```
        
        * use of partition ids and object context
        
        partition id is added to the context, ensures that after a chain of activations has begun, the partition ID remains the same unless it is changed explicitly
        
        * local and remote activation 
        
        exist on another computer, the partition properties are marshaled to the other computer 
        
        * partition cache 
        minimize network traffic resulting from frequent lookups of user-to-partition-set mapping in Active Directory
        
        made in Active Directory between user identities or OUs and their partition set, COM+ will check local first then check Activate directory 
        
clients call -> read cache -> user to partition mapping -y-> found 
                                |                                 A
                                no                                |
                                |                                 |
                                V                                 |
                                Read Active Directory             |
                                |                                 |
                                V                                 |
                                User to partition                 |
                    +---------> mapping found                     |
                    |           |                                 |
                    |           V                                 |
                    |           Move up                           |
                    |           One OU level                      |
                    |           |                                 |
                    |           V                                 |
                    |           read cache                        |
                    |           |                                 |
                    |           V                                 |
                    +--no------- OU to partion                    |
                                mapping found?                    |
                                |                                 |
                                Yes ------------------------------+

        * locating a component for activation 
        
        partition for component located ?
        |
        V 
        is in same app -yes-> active 
        |
        no 
        |
        V 
        search partition for public version -yes-> active 
        |
        no 
        |
        V
        search global -yes-> active 
        |
        no 
        |
        V
        activation failed 

    + COM+ queued components and partitions

a queued component within a partition is executed, the message is queued and the component is eventually executed within the component's partition

the queued components service uses the same queue for any queued components that share the same application name such as multiple instances 

activate a non-queued component applies to a queued component, as follows:

    1. a moniker and a partition id is included
    
    2. no moniker then use the parition id of the object's context 
    
    3. none of above use the mapping with active directory 

    + application design restrictions 

    app design to prevents multiple instances of the application from being installed on a computer can not use partition feature 
    
        * On a computer without partitions, this registry key is typically computer/CLSID

        * on a computer with partitions, this registry key is computer/partition ID/application ID/CLSID
        
    global resources such as shared memory, data files, and registry entries. can cause problem in multiple instances 
    
    type libraries 
    
        * marshaling data between components when functon calls 
        * helping COM+ queued components and COM+ events 
        * providing the correct information within vb editor 
        
    + COM+ partitions tasks win2k+
        
        * creating and configuring com+ paritions with ICOMAdminCatalog2 interface on the COMAdminCatalog class
    CurrentParition property 
    CurrentParitionID 
    CurrentParitionName 
    FlushPartitionCache 
    GetPartitionID 
    GetPartitionName 
    GlobalPartitionID 
    
    COM+ administration collections 
    https://docs.microsoft.com/en-us/windows/win32/cossdk/com--administration-collections
    
    Partitions 
    PartitionUsers 
    RolesForPartition 
    UsersInPartitionRole 
    
    Properties of other COM+ administration collections
    PartitionID on ApplicationInstances
    AppPartitionID on Applications 
    PartitionDescription, PartitionID, and PartitionName properties on the FilesForImport collection
    DSPartitionLookupEnabled, LocalPartitionLookupEnabled, and PartitionsEnabled properties on the LocalComputer collection
    EventClassPartitionID and SubscriberPartitionID properties on the SubscriptionsForComponent collection
    EventClassPartitionID and SubscriberPartitionID properties on the TransientSubscriptions collection

        * Managing local paritions 
```
Sub CreatePartition (PartitonGuid, PartitionName)
   Set cat = CreateObject("COMAdmin.COMAdminCatalog")
   Set collPartitions = cat.GetCollection("Partitions")
   collPartitions.Populate
   Set part = collPartitions.Add
   ' If you don't specify a partition GUID, one is created for you.
   ' Otherwise, you can specify one this way:
   part.Value("ID") = PartitonGuid
   part.Value("Name") = PartitionName
   collPartitions.SaveChanges
   Set part = Nothing
   Set collPartitions = Nothing
   Set cat = Nothing
End Sub
```
        * managing partitions within active directory 

        Active Directory Users and Computers administrative tool, you can manage COM+ partitions programmatically through Active Directory System Interface (ADSI)
        
        create new COM+ partitions with active direction for your domain 
        
        create com+ partition sets within active directory and map them to your newly created COM+ partitions 
        
        configure your active directory partition on your local machine 
        
        install your COM+ application in the appropriate com+ partitions 
 
        ADSI are as follows:
        DS_USERPARTITIONSETLINK_NAME
        DS_PARTITIONLINK_NAME
        DS_OBJECTID_NAME
        DS_DEFAULTPARTITIONLINK_NAME
        DS_USERLINK_NAME
        DS_PARTITIONSET_NAME
        DS_PARTITION_NAME
        
        * setting administrator rights for a partition 
       Component Services administrative tool, administrative roles can be assigned to users by expanding the Roles folder 
        
        * grouping applications into partitions 
        
        an application can be installed into one or more partitions 
        
        only one instance of a given component can exist in an application 
        
        * public and private components 
        
        app can be installed in multiple partitions 
        
        only one instance of a component can exist in an app 
        
        A server application, Public and private.
        
        A library application, Public only
        
        app in the global partition, Public only
        
        * collecting partition metrics, an application service provider (ASP) might want to charge a customer for its resource usage.
        
        * partition cache, cache stores user-to-partition mappings and is designed to avoid repetitive Active Directory access
        
- COM+ quequed components 

    + concepts
benefits of queued processing 

COM+ queued components service separates the transaction into activities that must be completed now and those that can be completed at a later time

queued components service allows the server component to operate independently of the client

        * architecture 

        COM+ queued componenets service consists 

        Recorder (for the client or send side)
        Listener (for the server or receive side)
        Player (for the server or receive side)
        
        Client -> {Recorder} -> {Queue} -> {Listener} -> {Player} -> {Server}
        
        recorder marshals the client's security context into the message and records all of the client's method calls. as a proxy 
        
        listener retrieves the message from the queue and passes it to the queued components player
        
        player unmarshals the client's security context at the server side and then invokes the server component and makes the same method calls
        
        * A transaction is a series of modifications of a data store
        
        * queued components security 
        
        supports role-based security semantics
        
        discover the role membership of their caller (ISecurityCallContext::IsCallerInRole) or a specific user (ISecurityCallContext::IsUserInRole)
        
        Message Queuing authenticates the message sender identity. When the caller identity and the message sender identity are the same
        
        COM+ queued components does not support impersonation-style security
        
        * developing queued components 
        
        COM+ queued components service, you must have the Message Queuing service already installed
        
        messaging constraints
        1. must contain input parameters only 
        2. must return no application specific results 
        
        the client passes the object to the recorder. The recorder marshals the object into a Message Queuing message and passes it to the listener. After the listener picks up the message and passes it to the player, the player must reinstantiate the object to dispatch it to the method call
        
        COM+ does not provide pass-by-value semantics for standard COM objects, the recorder and player need help from the component to marshal and unmarshal the object.
        
        * vb persistable objects,  IPersistStream and can be passed as parameters to queued component method calls. 

        object's IPersistStream interface or calling the IPersistStreamInit::InitNew, or IPersistStream::Load 
        
        ADO Recordset or OLE DB rowset objects between components allows one component to process the results of queries executed by another component
        
        * security limitations in workgroup mode 
        
        message queuing workgroup configuration does not permit queued components support application security. administration tool should configure by selecting Do not authenticate messages on the Queuing tab for the COM+ application's Properties dialog
        
        * threading considerations 
        
        COM+ queued components recorder is capable of running in the process's multithreaded apartment (MTA) or in a single-threaded apartment (STA). When the recorder is run in the STA, COM+ requires that each apartment containing objects must have a Message Queuing queue to handle calls
        
        This means that the thread's work function must have a message loop. When a queued component is instantiated, the interface pointer returned is always a proxy interface pointer which point to the recorder
         
        If you are using primitives to synchronize the threads, consider using MsgWaitForMultipleObjects instead of other synchronization functions
        
        * receiving a response 
        client applications should not block while waiting for a response from a queued request. 
        
        queued component that runs on a server is for the client to pass the called method a notification object. A notification object is an instance of a queued component that runs on the client. 
        
        * queued components errors 
        
        The COM+ queued components service handles poison messages by using a series of retry queues. After several retries, the message is moved to a final resting queue. Messages stay in the resting queue until they are moved manually by using the queued components message mover utility.
        
        server side error, listener and player work together, when play back failed, listener 
        1. dequeues the message 
        2. instantiates the objects 
        3. suffers a rollback 
        4. puts the message back on top of the queue,

        there are severn queues for each app 
        
        normal input, name of the queue is appliation name 
        first retry queue, queue is named ApplicationName_0. 
        second retry queue
        third 
        forth 
        fifth
        application specific final resting queue, This queue is named ApplicationName_DeadQueue. 
        
        * COM+ events are issued in 
        a transaction aborts 
        a message is moved from one queue to another 
        when a message is deposited onto the final resting queue 
        
        * server side exception handling 
        messge is moved to retry queues 
        final retry on the last retry queue fails 
        retrieves the target component from the message and checks for an exception class 
        run-time isntantiates the exception class 
        runtime queries IPlayBackControl on the exception class 
        runtime plays back all property and method calls to the exception class 
        if steps 4 through 6 do not succeed the run-time omves the message onto the application specific final resting queue 
        
        * client-side errors 
        
        message cannot be moved from client to server. In this case, the message is moved to the client-side dead letter queue.
        
        an instance of the exception class and calls QueryInterface to request IPlaybackControl. If this is successful, the dead letter queue monitor invokes IPlaybackControl::FinalClientRetry.
        
        * persistent client-side failures 
        
        the ProgID or the CLSID of a component implementing IPlaybackControl. The queued components service has a dead letter queue
        
        Message queuing fails to deliver a message to the server puts the message onto the Xact dead letter queue 
        The dead letter queue listenr(DLQL) finds a message on the Xact dead letter queue 
        THe DLQL retrieves the target component CLSID from the message and check an exception class 
        The DLQL queries for IPlaybackControl for exception class 
        THe DLQL calls IPlayBackControl::FinalClientRetry 
        The DLQL play back all property and method calls 
        The DLQL deletes the message if the exception handler completes 
        
        intervene the process, use the message mover utility, see Handling Errors.
        
    + tasks 
    
        * creating queuable components 
        
         administrative tool, under Component Services, open the COM+ Applications
         
         check box labeled Queued
         
        * creating component queues 
         administration tool 
         Activate the check box labeled Queued â€“ This application can be reached by MSMQ queues.
         
        * use the administration tool to control authentication and activating 
         
         ICOMAdminCatalog::StartApplication example.
         
        * handling errors in queued components 
         
        The message mover utility is an Automation object that can be invoked with a VBScript.
        
        use in vb add a reference to COM+ services type library 
        ```vb
        Function MyMessageMover( _
          strSource As String, _
          strDest As String _
        ) As Boolean  ' Return False if any errors occur.

            MyMessageMover = False  ' Initialize the function.
            On Error GoTo My_Error_Handler  ' Initialize error handling.

            Dim lngMovedMessages As Long
            Dim objMessageMover As COMSVCSLib.MessageMover
            Set objMessageMover = CreateObject("QC.MessageMover")
            objMessageMover.SourcePath = strSource
            objMessageMover.DestPath = strDest
            lngMovedMessages = objMessageMover.MoveMessages

            MsgBox lngMovedMessages & " messages moved from " & _
              strSource & " to " & strDest

            MyMessageMover = True  ' Successful end to procedure
            Set objMessageMover = Nothing
            Exit Function

        My_Error_Handler:  ' Replace with specific error handling.
            MsgBox "Error # " & Err.Number & " (Hex: " & Hex(Err.Number) _
              & ")" & vbNewLine & Err.Description
            Set objMessageMover = Nothing
            lngMovedMessages = -1
        End Function
        
        Sub Main()
          ' Replace AppName with the name of a COM+ application.
          If Not MyMessageMover(".\private$\AppName_deadqueue", ".\AppName") Then
              MsgBox "MyMessageMover failed."
          End If
        End Sub

        ```
        
        use the MessageMover object, you must have Message Queuing installed on your computer and the application specified by AppName must have queuing enabled
        
        ```
        #include <windows.h>
        #include <stdio.h>
        #import "C:\WINDOWS\system32\ComSvcs.dll"
        #include "ComSvcs.h"
        #include "StrSafe.h"  

        BOOL MyMessageMover (OLECHAR* szSource, OLECHAR* szDest) {
            IUnknown * pUnknown = NULL;
            IMessageMover * pMover = NULL;
            HRESULT hr = S_OK;
            BSTR bstrSource = NULL;
            BSTR bstrDest = NULL;
            unsigned int uMaxLen = 255;  // Maximum length of szMyApp

        try {
            // Test the input strings to make sure they're OK to use.
            hr = StringCchLengthW(szSource, uMaxLen, NULL);
            if (FAILED (hr)) throw(hr);
            hr = StringCchLengthW(szDest, uMaxLen, NULL);
            if (FAILED (hr)) throw(hr);
            
            // Convert the input strings to BSTRs.
            bstrSource = SysAllocString(szSource);
            bstrDest = SysAllocString(szDest);

            // Create a MessageMover object and get its IUnknown.
            hr = CoCreateInstance(CLSID_MessageMover, NULL, 
              CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnknown);
            if (FAILED (hr)) throw(hr);    

            // Get the IMessageMover interface.
            hr = pUnknown->QueryInterface(IID_IMessageMover, (void**)&pMover); 
            if (FAILED (hr)) throw(hr);

            // Put the source and destination files.
            hr = pMover->put_SourcePath(bstrSource);
            if (FAILED (hr)) throw(hr);
            hr = pMover->put_DestPath(bstrDest);
            if (FAILED (hr)) throw(hr);

            // Move the messages.
            LONG lCount = -1;
            hr = pMover->MoveMessages(&lCount);
            if (FAILED (hr)) throw(hr);
            printf("%ld messages moved from %S to %S.\n", 
              lCount, bstrSource, bstrDest);

            // Clean up.
            SysFreeString(bstrDest);
            SysFreeString(bstrSource);
            pUnknown->Release();
            pUnknown = NULL;
            pMover->Release();
            pMover = NULL;
            return (TRUE);
        }  // try

        catch(HRESULT hr) {  // Replace with specific error handling.
            printf("Error # %#x: ", hr);
            ErrorDescription(hr);
            SysFreeString(bstrDest);
            SysFreeString(bstrSource);
            if (NULL != pUnknown) pUnknown->Release();
            pUnknown = NULL;
            if (NULL != pMover) pMover->Release();
            pMover = NULL;
            return (FALSE);
        }catch(...) {
            printf("An unexpected exception occurred.\n");
            throw;
        }        
        }  // MyMessageMover        
        #include <windows.h>
        #include <stdio.h>
        #import "C:\WINDOWS\system32\ComSvcs.dll"
        #include "ComSvcs.h"
        #include "StrSafe.h"  

        BOOL MyMessageMover (OLECHAR* szSource, OLECHAR* szDest) {
            IUnknown * pUnknown = NULL;
            IMessageMover * pMover = NULL;
            HRESULT hr = S_OK;
            BSTR bstrSource = NULL;
            BSTR bstrDest = NULL;
            unsigned int uMaxLen = 255;  // Maximum length of szMyApp

        try {
            // Test the input strings to make sure they're OK to use.
            hr = StringCchLengthW(szSource, uMaxLen, NULL);
            if (FAILED (hr)) throw(hr);
            hr = StringCchLengthW(szDest, uMaxLen, NULL);
            if (FAILED (hr)) throw(hr);
            
            // Convert the input strings to BSTRs.
            bstrSource = SysAllocString(szSource);
            bstrDest = SysAllocString(szDest);

            // Create a MessageMover object and get its IUnknown.
            hr = CoCreateInstance(CLSID_MessageMover, NULL, 
              CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnknown);
            if (FAILED (hr)) throw(hr);    

            // Get the IMessageMover interface.
            hr = pUnknown->QueryInterface(IID_IMessageMover, (void**)&pMover); 
            if (FAILED (hr)) throw(hr);

            // Put the source and destination files.
            hr = pMover->put_SourcePath(bstrSource);
            if (FAILED (hr)) throw(hr);
            hr = pMover->put_DestPath(bstrDest);
            if (FAILED (hr)) throw(hr);

            // Move the messages.
            LONG lCount = -1;
            hr = pMover->MoveMessages(&lCount);
            if (FAILED (hr)) throw(hr);
            printf("%ld messages moved from %S to %S.\n", 
              lCount, bstrSource, bstrDest);

            // Clean up.
            SysFreeString(bstrDest);
            SysFreeString(bstrSource);
            pUnknown->Release();
            pUnknown = NULL;
            pMover->Release();
            pMover = NULL;
            return (TRUE);
        }  // try

        catch(HRESULT hr) {  // Replace with specific error handling.
            printf("Error # %#x: ", hr);
            ErrorDescription(hr);
            SysFreeString(bstrDest);
            SysFreeString(bstrSource);
            if (NULL != pUnknown) pUnknown->Release();
            pUnknown = NULL;
            if (NULL != pMover) pMover->Release();
            pMover = NULL;
            return (FALSE);
        }catch(...) {
            printf("An unexpected exception occurred.\n");
            throw;
        }        
        }  // MyMessageMover    

        //call the myMessageMover
        #include <windows.h>
        #include <stdio.h>

        #define _WIN32_DCOM  // To use CoInitializeEx()

        void main() 
        {
            HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            if (FAILED (hr)) {
                printf("CoInitializeEx failed: Error # %#x\n", hr);
                exit(0);  // Replace with specific error handling.
            }
            if (! MyMessageMover(L".\\private$\\AppName_deadqueue", 
              L".\\AppName"))
                printf("MyMessageMover failed.\n");
            CoUninitialize();
        }        
        ```
        
        * using the queue moniker 
        
         queue moniker is used to activate a queued component programmatically.
         
         ```vb
         Set objMyQC = GetObject ("queue:/new:QCShip.Ship")
         Set objMyQC = GetObject ("queue:/new:{812DF40E-BD88-11D0-8A6D-00C04FC340EE}")
         Set objMyQC = GetObject ("queue:/new:812DF40E-BD88-11D0-8A6D-00C04FC340EE")
         ```
         
         ```cpp
        hr = CoGetObject (
              L"queue:/new:QCShip.Ship",
              NULL, IID_IShip, (void**)&pShip);
              
        hr = CoGetObject (
          L"queue:/new:{812DF40E-BD88-11D0-8A6D-00C04FC340EE}", 
          NULL, IID_IShip, (void**)&pShip);      
          
        hr = CoGetObject (
          L"queue:/new:812DF40E-BD88-11D0-8A6D-00C04FC340EE",
          NULL, IID_IShip, (void**)&pShip);
         ```
         
        queue moniker parameters:
        computer name 
        queue name 
        path name 
        format name
        
        The complete set of COM+ Administrative SDK functions is available by using COM objects
        
        
- COM+ resource dispenser service 
    + concepts 
    The application process achieves high performance by using a minimum number of frequently used resources.
    
    dispenser manager provided by COM+ tracks resource dispensers and coordinates among them. It implements two interfaces: IDispenserManager and IHolder
    
    Distributed Transaction Coordinator (DTC) transaction. This implies use of either an internal or an external
    
    resource dispenser might be a DLL that is accessed by the application through an import library (or using the LoadLibrary and GetProcAddress functions)
    
    the COM+ context, and controls the inventory statistics manager. (For more information, see COM+ Dispenser Manager.) The resource dispenser first calls the GetDispenserManager function and then calls the IDispenserManager::RegisterDispenser method, passing the IDispenserDriver pointer
    
    dispenser manager provides resource pooling for the resource dispensers 
    
    dispenser manager uses the inventory statistics manager to manage pool resource inventory levels. 
    
    dispenser manager polls each holder, a component created by the dispenser manager that lists the resource inventory for each resource dispenser, every 10 seconds to allow it to readjust its resource inventory
    
        * COM resource dispenser thread types 
        Apartment thread(STA)
        Free thread(MTA)
        Non-COM thread 
        
        If a resource dispenser is not a COM object, it must be able to handle calls arriving from any thread at any time. If a resource dispenser is a COM object, the COM object should be registered with a threading model of Both. This allows STA or MTA threads
        
        * pool resource states available to COM+ resource dispenser 
        
        unenlisted inventory, not use by an object and not enlisted in a transaction 
        
        resources in enlisted inventory, not in use by an object but is enlisted in a transaction in enlisted inventory 
        
        reousrce in unlisted use
        
        resources in enlisted inventory, COM+ notifies the dispenser manager that the transaction is complete 
        
        in unenlisted use, non transaction this resource in unenlisted use 
        
        in enlisted use, run in a transaction 
        
        * enlisting a resource in a transaction 
        resource dispenser must be able to enlist in an OLE transaction with the Distributed Transaction Coordinator (DTC)
        
        * resource dispenser resource allocation process 
        
        dispenser allocates a resource from its holder
        
        The resource dispenser calls the holder's IHolder::AllocResource method, passing this RESTYPID.
        
        a new resource is created by calling IDispenserDriver::CreateResource.
        
        a new resource is created by calling IDispenserDriver::CreateResource.
        
        The AllocResource method call returns to the resource dispenser 
        
        * tracking non allocated resources 
        
        dispenser manager can track a resource that is not inventoried, based on knowledge of the object's lifetime. When a tracked, non-allocated resource is freed
        
        * automatic resource reclamation 
        
        COM+ notifies the dispenser manager each time an object's lifetime ends. The dispenser manager then notifies each registered resource dispenser's Holder
        
        * following types are used in the resource dispenser interfaces.
        
        RESTYPID, DWORD identifies a type of resource
        
        RESID, DWORD identifies a perticular resource 
        
        SRESID, unicode string version of RESID 
        
        TRANSID, identifies a transaction 
        
        TIMEINSECS, how along a resource can be inactive 
        
        * COM+ resource dispenser interfaces
        
        IDispenserDriver, This interface is called by the resource dispenser holder to create
        
        IDispenserManager, Resource dispensers use this interface to connect to the dispenser manager.
        
        IHolder, This interface is used to prepare and handle resources.
    + tasks 

    implementing a COM+ resouce dispenser 
    
    1. Decide on RESTYPID format that categorizes
    
    2. Use the Mtxdm.h and Mtxdm.lib header file and library
    
    3. Build a DLL that implements the IDispenserDriver interface and the API 
    
    4. In the startup (DllMain or first call to the dispenser API), call the GetDispenserManager function, IDispenserManager interface
    
    5. Call IDispenserManager::RegisterDispenser, passing a pointer to your implementation of IDispenserDriver.
    
    6. Store this pointer so that you can call IHolder::AllocResource and IHolder::FreeResource.
    
    7. make calls to AllocResource and FreeResource. calling back to your CreateResource method
    
- COM+ security 

    + concepts 
    
    Programmatic role-based security

    Impersonation to use a client's identity to access a protected resource.
    
    Auditing features based on security call context information
    
    COM+ provides authentication services. While these services are actually provided at a more fundamental level by COM 
    
    COM+ provides facilities to enable various levels of impersonation. Impersonation is configured administratively
    
    A software restriction policy provides a way to run untrusted
    
    Security Policy administrative tool, which enables administrators to configure trust levels for individual files. 
    
    COM+ provides a way to specify the software restriction policy for each server application so that they do not need to depend on the restriction policy of the dllhost.exe file
    
    description of factors to consider for library applications, see Library Application Security.
    
    COM+ applications are typically middle-tier applications; that is, they move information between clients and back-end resources such as databases. 
    
    application is deployed, the system administrator can populate the role with actual users and user groups.
    
    COM+ library applications are hosted by other processes, there is a security boundary between the library application and the hosting process. 
    
    COM+ library applications, you must select component-level security if you want to use roles.
    
    use the ISecurityCallContext interface to access security call contex
    
    Security call context is passed along every time a security boundary is crossed
    
    every automatic service provided by COM+, automatic role checking is based on properties included on the object context. 
    
    a SecurityCallContext object
    
    COM, you cannot call CoInitializeSecurity from a component that is part of a COM+ application because CoInitializeSecurity is called by the surrogate that the COM+ application runs in
    
    checking role membership call the ISecurityCallContext::IsCallerInRole method
    
    ```
    ISecurityCallContext* pSecCtx;
    VARIANT_BOOL bIsInRole;

    HRESULT hr = CoGetCallContext(IID_ISecurityCallContext, (void**)&pSecCtx);
    if (FAILED(hr)) throw(hr);
    if (NULL == pSecCtx) { 
        // No security call context is available.
        // Display an error message and return.
        return E_FAIL;
    }
    hr = pSecCtx->IsCallerInRole(myRole, &bIsInRole);
    return hr;
    ```
    
    checking role based security is enabled, using the ISecurityCallContext::IsSecurityEnabled method available from the security call context object,
    
```
ISecurityCallContext* pSecCtx;
VARIANT_BOOL bIsEnabled;

HRESULT hr1 = CoGetCallContext(IID_ISecurityCallContext, (void**)&pSecCtx);
if (FAILED(hr1)) throw(hr1);
if (NULL == pSecCtx) {
    // Display error message.
    return E_FAIL;
}

HRESULT hr2 = pSecCtx->IsSecurityEnabled(&bIsEnabled);
return hr2;
```

    accessing security call context information:
    SecurityCallContext Collection
    SecurityCallers Collection
    SecurityIdentity Collection
    
        * client authentication 
        
        choose from several authentication levels that provide varying degrees of security, ranging from no authentication to encryption of every packet and all method 
        
        never specify authentication level, COM+ calls CoInitializeSecurity for you, and this can be called only once per process.
        
        https://docs.microsoft.com/en-us/windows/win32/cossdk/client-side-requirements-for-impersonation
        
        https://docs.microsoft.com/en-us/windows/win32/cossdk/server-side-requirements-for-impersonation
        
        impersonation, delegation, which is the impersonation of clients over the network, the client and server user accounts must be properly configured in the Active Directory Service
        https://docs.microsoft.com/en-us/windows/desktop/com/delegation-and-impersonation
        
        * cloaking, the server's cloaking capability largely determines how impersonation will behave
        
        * negotiation of authentication level 
        
        Per client machine, with the machine-wide COM authentication level set by using either DCOMCNFG or the Component Services administrative tool.
        
        Per client process programmatically, with CoInitializeSecurity
        
        At any point programmatically, using CoSetProxyBlanket
        
        * authentication steps 
        authentication level is chosen as MAX 
        
        negotiation of authentication protocol 
        
        server authentication protocol 
        
        optionally client authenticates server identity 
        
        method calls are communicated with chosen level of authentication 
        
        * client impersanation and delegation 
        Impersonation is the ability of a thread to execute in a security context different from that of the process owning the thread. 
        
        The server identity must be marked as "Trusted for delegation" in the Active Directory Service.
        
        The client identity must NOT be marked as "Account is sensitive and cannot be delegated" in the Active Directory Service
        
        the server's cloaking capability largely determines how impersonation will behave.
        
        the authority the client explicitly grants the server through an impersonation level and the server's ability to mask its own identity when making calls on the client's behalf. This latter capability is known as cloaking.
        
        * performance impact to impersonation 
        
        Impersonation can significantly affect performance and scaling. It is generally more expensive to impersonate a client on a call than to make the call directly.
        
        The computational overhead of passing around identity in complicated patterns, particularly dynamic clocking 
        
        The general complexity of enforcing redundant security checking in numerous places
        
        Resources such as database connections, when opened impersonating a client, cannot be reused across multiple clients
        
        * Queued components do not support impersonation, the token will be unavailable, recorder -> listener -> player, Role-based security still applies, however, and programmatic security using the ISecurityCallContext interface will work.
        
        * client side requirements for impersonation 
        
        The client can indicate the impersonation level programmatically, using either CoSetProxyBlanketâ€”equivalent to IClientSecurity::SetBlanket or CoInitializeSecurity, which can be called once per process
        
        * server side requirements for impersonation 
        
        The server performs impersonation programmatically. It explicitly assumes the client's security credentials by using CoImpersonateClient
        
        the server can revert to its own process token using CoRevertToSelf.
        
        * Cloaking
        
        Impersonation with static cloaking. presented once to a downstream server on a call using CoSetProxyBlanket, setting the original client identity once on the proxy
        
        Impersonation with dynamic cloaking. The original client identity is discovered as the server thread token on each method call to the downstream server. 
        
        * Using the software restriction policy in COM+ 
        
        Unrestricted and Disallowed. all COM+ applications. If SRPRunningObjectChecks is enabled, attempts to connect to running objects
        
        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Ole
            SRPRunningObjectChecks = value
            
        * library application security 
        
        Library applications run under the client process security token, only as much privilege as the client has
        
        Library applications do not control process-level security.
        
        can be configured to either participate or not participate in host process authentication, by enabling or disabling authentication
        
        Library applications cannot set an impersonation level
        
        * Configuring security for library applications 
        
        Authentication is enabled, and role-based security is used.
        {host process 
        -----------------
        process level authentication 
        --------------------------
        {library application 
            |
            V
            {check for role membership 
                  |
                  V
                {   }        
            }
        }
        }
        
        Authentication is enabled, and role-based security is not used. role membership is not checked at the library application level. 
        any caller of the library application that makes call
        {host process 
        -----------------
        process level authentication 
        --------------------------
        {library application 
            |
            V
            {
                  |
                  V
                {   }        
            }
        }
        }
        
        
        Authentication is disabled, and role-based security is used. In this scenario, security checks are being done at the process level but callers to the library application are unauthenticated. 
        This scenario enables you to effectively turn off process security and still have an appropriate level access checks using role-based security.
        {host process 
        ----------------------                                  
        process level authentication                            |
        -------------------------                               |
        {library application   |       call to library app are unauthenticated
                              |                                 |
                              V                                 V
        { check for role membership 
                |
                V                       
            {       }                                         {    }  
        }
        }
        }
        
        
        Authentication is disabled, and role-based security is not used. security checks are still done at the process level but, as in the preceding scenario, callers of the library application always pass this security check. 
        This scenario should be chosen when your COM object needs to receive unauthenticated callbacks, as might be the case with an ActiveX control hosted by Internet Explorer
        
        {host process 
        ----------------------                                  
        process level authentication                            |
        -------------------------                               |
        {library application   |       call to library app are unauthenticated
                              |                                 |
                              V                                 V
        { 
                |
                V                       
            {       }                                         {    }  
        }
        }
        }
        
        * multi tier application security 
        
        At the database? At the middle tier? In the components? Somewhere else? Everywhere? As security mechanisms increase in number and complexity
        
        enforce detailed security in the COM+ application at the middle tier. 
        1. It enables connection pooling among all clients
        2. It generally optimizes data access
        3. It can minimize the logic overhead for enforcing security,
        4. It can provide great flexibility in a security policy
        
        * enforcing security at database 
        Impersonating the client can be much slower than making the call directly
        
        database connection made under a specific user identity cannot be pooled
        
        it a scaling bottleneck
        
        * trusted scenario using microsoft sql server roles 
        Connections can be opened that are specific to a particular database role
        
    + tasks 

        * configure role based security 

        * enabling access checks for an application 

        Component Services administrative tool
        https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc731901(v=ws.11)?redirectedfrom=MSDN

        Microsoft Distributed Transaction Coordinator (DTC) service to be running.

        * configuring role based security 
        
        Security level
        1. Perform access checks only at the process level
        2. Perform access checks at the process and component level
        
        * defining roles for an application 
         console tree of the Component Services administrative tool, locate the COM+ application to which you want to add the role.
         
         assign a Windows group to a security role

        In the console tree of the Component Services administrative tool, Locate the role to which you want to add the user account or group.
        
        Users folder in the role, point to New, and then click User.
        
        * setting authentication level for a server application 
        
        administration tool 
        security tab 
        levels:
        None 
        Connect, authenticates credentials only when the connection is made 
        Call, authenticates credentials at the beginning of every call 
        Packet, authenticates credentials and verifies that all call data is received 
        Packet integrity, authenticates credentials and verifies call data has been modified 
        Packet privacy, authenticates credentials and encrypt the packet 
        
        * Enablling authentication for a library application with administration tool 
        
        Impersonation level box, select the appropriate level. 
        Anonymous 
        Identify, server can obtain the client's identity and impersonate client 
        Impersonate, server can impersonate the client, server and client on the same computer then the server can access network otherwise can only impersonate client to access local resource 
        Delgate, the server can impersonate the client while acting on its behalf, the client's credentials can be passed 
        
        * configuring the software restriction policy 
        
        on the security tab, software Restriction Policy, select the Apply software restriction policy check box; this enables you to set the trust level.
        Disallowed, the application is disallowed from using the full privileges of the user 
        Unrestricted, the application unrestricted access to the user's privileges 
        
- COM+ services without components 

COM+ without needing to build a component to contain the methods that call those services. This feature is intended for advanced Visual C++ developers who are concerned about performance.

    + concepts, tasks 
    
    COM+ 1.5, IIS had to create shim objects solely to be able to use COM+ transaction services in ASP pages. The performance costs that come from creating those objects include storing the configuration data in both the IIS metabase and the COM+ registration database (RegDB) 
    
    O(n2), making the implementation of new services extremely difficult.
    
    The CServiceConfig class implements the interfaces needed to configure the different services while providing the flexibility to support multiple services
    
    CoCreateActivity function, which applies the services to all of the work submitted via the activity that is created by the function
    
    they can also be used by embedding the work that uses the services between calls to the CoEnterServiceDomain and CoLeaveServiceDomain functions.
    
    the CServiceConfig object is needed.
    
    CServiceConfig class is used to configure the COM+ services that can be used without components. 
    
    IServiceInheritanceConfig 
    IServiceCOMTIIntrinsicsConfig 
    IServiceIISIntrinsicsConfig 
    IServiceSxSConfig 
    IServiceSYnchronizationConfig 
    IServiceTrackerConfig 
    IServiceTransactionConfig 
    
    configure a CServiceConfig object to use COM+ transactions.
    ```
    // Create a CServiceConfig object.
    HRESULT hr = CoCreateInstance(CLSID_CServiceConfig, NULL, CLSCTX_INPROC_SERVER, 
      IID_IUnknown, (void**)&pUnknownCSC);
    if (FAILED(hr)) throw(hr);

    // Query for the IServiceInheritanceConfig interface.
    hr = pUnknownCSC->QueryInterface(IID_IServiceInheritanceConfig, 
      (void**)&pInheritanceConfig);
    if (FAILED(hr)) throw(hr);

    // Inherit the current context before using transactions.
    hr = pInheritanceConfig->ContainingContextTreatment(CSC_Inherit);
    if (FAILED(hr)) throw(hr);

    // Query for the IServiceTransactionConfig interface.
    hr = pUnknownCSC->QueryInterface(IID_IServiceTransactionConfig, 
      (void**)&pTransactionConfig);
    if (FAILED(hr)) throw(hr);

    // Configure transactions to always create a new one.
    hr = pTransactionConfig->ConfigureTransaction(CSC_NewTransaction);
    if (FAILED(hr)) throw(hr);

    // Set the isolation level of the transactions to ReadCommitted.
    hr = pTransactionConfig->IsolationLevel( 
      COMAdminTxIsolationLevelReadCommitted);
    if (FAILED(hr)) throw(hr);

    // Set the transaction time-out to 1 minute.
    hr = pTransactionConfig->TransactionTimeout(60);
    if (FAILED(hr)) throw(hr);
    ```
    
    CoCreateActivity function is used to submit batch work to the COM+ system. 
    IServiceActivity interface of that object. 
    the SynchronousCall or AsynchronousCall methods of IServiceActivity, respectively. A pointer to an IServiceCall interface
    batch work is implemented by the developer in the OnCall method of the IServiceCall interface
    
    CoEnterServiceDomain and CoLeaveServiceDomain are used together to surround an area of code that runs
    
    the CServiceConfig object that is passed in to CoEnterServiceDomain. The code that is surrounded by CoEnterServiceDomain and CoLeaveServiceDomain
    ```
    // A CServiceConfig object was created as follows:
    // hr = CoCreateInstance(CLSID_CServiceConfig, NULL, CLSCTX_INPROC_SERVER, 
    //   IID_IUnknown, (void**)&pUnknownCSC);

    // Enter the Service Domain.
    HRESULT hr = CoEnterServiceDomain(pUnknownCSC);
    if (FAILED(hr)) throw(hr);

    // Do the work that uses COM+ services here.
    //DoMyWork();

    // Leave the Service Domain.
    CoLeaveServiceDomain(NULL);
    ```

- COM+ shared property manager 

the shared property manager (SPM). The SPM is a resource dispenser that you can use to share state among multiple objects

    + concepts 
    The SPM also implements locks and semaphores to help protect shared properties from simultaneous access
    
    instantiate the SharedPropertyGroupManager, SharedPropertyGroup, and SharedProperty objects from COM+ components rather than from a base client
    
    shared porperty groups 
    ISharedPropertyGroupManager
        CreatePropertyGroup 
        get_Group
        get_NewEnum 
            ISharedPropertyGroup 
            CreateProperty 
            CreatePropertyByPosition 
            get_Property 
            get_PropertyByPosition 
                ISharedProperty 
                get_Value 
                put_Value 
    
    ISharedPropertyGroupManager is used to create shared property groups
    ISharedPropertyGroup is used to create and access the shared properties in a shared property group. 
    ISharedProperty is used to set or retrieve the value of a shared property. 
    
    + tasks 
    
    COM+ Shared Property Manager, see ISharedProperty::put_Value. This C++ sample shows how to create a shared property group

- COM+ SOAP service 

administrative tool, you can expose a COM+ application as an XML web service. You can also transparently use an XML web service

using COM+ to expose your configured COM components as XML web services.
https://www.w3.org/TR/SOAP/

```
POST /StockQuote HTTP/1.1
Host: www.stockquoteserver.com
Content-Type: text/xml; "charset=utf-8"
Content-Length: nnnn
SOAPAction: "Some-URI"

<SOAP-ENV:Envelope
xmlns:SOAP-ENV="https://schemas.xmlsoap.org/soap/envelope/"
SOAP-ENV:encodingStyle="https://schemas.xmlsoap.org/soap/encoding/">
<SOAP-ENV:Body>
<m:GetLastTradePrice xmlns:m="Some-URI">
<symbol>DIS</symbol>
</m:GetLastTradePrice>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
```

COM+ provides two ways for you to access and use a remote XML web service

    1. The well-known object (WKO) mode can be used to access any XML web service
    2. The client-activated object (CAO) mode can be used only to access XML web services 
    
By default, unencrypted SOAP communications are received at the HTTP port (80) and encrypted SOAP communications are received at the HTTPS port (443). 

    + convert a security SOAP to unsecure SOAP 

    IIS) administration tool.
    
    Locate the virtual directory for the application and open the Properties dialog box.
    
    Check Enable default content page on the Documents tab.
    
    From the Directory Security tab click Edit under Anonymous access and authentication control.
    
    Check Anonymous access to enable anonymous access and click OK.
    Click Edit under Secure communications.
    
    Uncheck the Require secure channel (SSL) checkbox
    
    + tasks 
        * Create XML web services 
        * Securing XML web services 
        * accessing XML web services in WKO mode 
        * accessing XML web services in CAO mode 
        * exporting a SOAP-enabled application 
        * importing a SOAP-enabled application 
    
- COM+ synchronization 

XML web service, and choose Properties.

Click the Activation tab in the properties dialog.

Select the Uses SOAP check box.

You can also configure IIS to require the communications with the caller take place over a secure channel established using the Secure Sockets Layer (SSL) 

    + context menu of my computyer > manage 
    +  Services and Applications and Internet Information Service, locate the icon corresponding to the virtual root directory for your XML web service
    + Directory Security tab of the properties dialog, locate Authentication and access control 
    + Authentication Methods dialog box, under Authenticated access
    + On the Directory Security tab of the properties dialog, locate Authentication and access controland click the corresponding Edit button. Select the Enable anonymous access check box. Click OK.

    + XML Web Service publishes a WSDL description of its syntax. a WSDL description of its syntax. Just create an instance of the component by using the soap:wsdl=URL moniker, where URL is the URL of the WSDL description of the XML web service you want to access. 
    
    well-known object (WKO) mode of accessing XML web services.

```
Set Obj = GetObject("soap:wsdl=https://servername/vroot/progID.soap?WSDL")
output = Obj.Method(input)
```

```
HRESULT hr = CoGetObject(
     L"soap:wsdl=https://servername/vroot/progID.soap?WSDL",
     pBindOptions,
     IID_IUnknown,
     (void**)&pIUnknown);
if (FAILED(hr)) throw(hr);
```

    run-time generation and the lack of persistent connections in WKO mode results in significantly reduced performance in comparison to CAO mode.

- Accessing XML web services in CAO mode 

client-activated object (CAO) mode, which avoids the run-time generation of a proxy and increases performance by using persistent connections

The application's components can then be instantiated on the client just like the components of local applicationsâ€”for example, using GetObject and CoCreateInstance.

COM+ application that has been exposed as an XML web service in CAO mode.
```
Set Obj = GetObject("progID")
output = Obj.Method(input)
```

```
HRESULT hr = CoCreateInstance(
     CLSID_CObject,  // CLSID of the server component
     NULL,
     pBindOptions,
     IID_IUnknown,
     (void**)&pIUnknown);
if (FAILED(hr)) throw(hr);
```

- exporting a SOAP enabled application 

 import it into the client for which you want to access the corresponding XML web service.

    + component services administrative tool 
    under component services > com+ applications 
    
    choose Export. The COM+ Application Export Wizard appears
     
    Enter the full path and filename for the application file to be created, enter the full path and filename for the MSI

    Export As, select the Application Proxy â€“ Install on other machines to enable access to this machine radio button
    
    + import XML SOAP enabled application 
    
    COM+ Applications folder, and then choose New. The COM+ Application Install Wizard appears.
    
    COM+ Application Install Wizard, click Install pre-built application(s).
    
    Browse the network to locate or specify the network path of the MSI file
    
- COM+ sychronization 

background and task information about the COM+ synchronization service.
    
    + concepts 
    
    synchronization is not required when you have a single threaded apartment(STA)
    
    important when you haver a multithreaded apartment(MTA) and a free threaded objects had to handle locking 
    
    synchronization has
    1. allows one caller to enter the component at a time 
    2. prohibits flow across process or across computer 
    3. flows from component to component within a process 
    4. allows reentrancy from the same caller 
    
    Synchronization determines which activity will contain an object, objects can reside in     
    1. Creator's activity
    2. New activity
    3. No activity

    COM+ ensures concurrency by a series of locks for each activity. COM+ manages access to all objects across activities by a nested series of calls chained throughout the network.
    
    synchronization settings:
    Disabled
    Not Supported
    Supported
    Required
    Requires New

    synchronization is required if the COM+ just-in-time (JIT) activation service is enabled
    
    synchronization attributes 
    disabled 
    not supported 
    supported 
    required , COM+ ensures all objects created from the component will be synchronized 
    requires new, COM+ initiates a new synchronization which distinct caller's. this setting allows you to make outside calls to an instance of your component more efficiently it is more expensive 
    
    share the same synchronization boundary. If client A calls the creator object and client B calls your object, the second call will have to wait until the first call is completed. If you set Requires New, your object is created in a separate synchronization boundary. In this case, calls from other objects can be processed at the same time. 
    
    + synchronization dependencies 
    
    COM+ synchronization attribute 
    Disabled 
    Not Supported 
    Supported 
    Required 
    Requires New 
    
    + tasks 
    
    administration tool, Concurrency tab. Under Synchronization support, click the option button adjacent to the value 
    
- COM+ tracking 

important differences between these services

instrumentation                 COM+ tracking 
fine grained data               aggregated data 
event subscribers               metrics are calculated automatically by the COM+ 
event trigger                   tracking data can retrieve at any time 
event based subscription        event based and polling on a COM local server 

tracker server, a component of the system application. Components in COM+ library applications and services without components (SWC) contexts also support tracking
 
COM+ updates statistics for a tracked process when certain events occur in the process, such as the creation of an object or the completion of a method call.

tracking data can register a subscription for the IComTrackingInfoEvents event interface

every three seconds, the tracker server calls each subscriber's IComTrackingInfoEvents::OnNewTrackingInfo method, sending the most recent tracking data in the form of a collection object.

use the IGetAppTrackerData interface of the tracker server.

- COM+ transactions, If a single operation in the series fails during the exchange, the entire exchange fails. 

    + concepts 
    
    ACID properties, atomic, consistent, isolated and durable properties 
    Configuring transactions describes the transaction and attribute values 
    Configuring tasnaction isolation levels 
    Managing automatic transactions in COM+ 
    Using non-transactional components ina  transaction 
    
    A transaction must execute exactly once and must be atomic
    A transaction must preserve the consistency of data
    A transaction must be a unit of isolation
    A transaction must be recoverable and therefore must have durability
    
    transaction attributes 
    Disabled 
    Not supported 
    Supported 
    Required 
    Requires New 
    
    + transaction boundaries 
    
    A transaction has a beginning, an end, and occurs exactly once. During its execution, a transaction may call on a resource, such as a database or queue, to accomplish one or more tasks.
    
    The first object in a transaction boundary is special to the transaction and is called the root object of the transaction.
    
    + mapping transactions 
    
    By mapping transactions, you can determine the best setting for each component you write. 
    
    In the illustration, the client creates Object 1, which requires a transaction. Because no transaction exists, COM+ creates Transaction 1 and places Object 1 in it as the root object. Object 1 creates Object 2, which supports transactions and is therefore placed in Transaction 1. Object 2 creates Object 3, which does not support transactions and therefore is placed outside all transactions. Object 2 also creates Object 4, which requires a transaction and is therefore placed in Transaction 1. Object 3 creates Object 5, which supports transactions. However, because Object 5 is created by an object that does not exist within a transaction, it also is placed outside all transactions. Object 4 creates Object 6, which requires a new transaction, so COM+ creates Transaction 2 and places Object 6 in it as the root object. Object 6 creates Object 7, which supports transactions and is therefore placed in Transaction 2.
    
    client->{transaction 1 {obj1 root}->{obj2 supported}}
                                            |
                                            V
                                            {obj3 not support}
                                            |
                                            V
                                            {obj 5 support}
    
    + configuring transaction isolation levels 
    
    experienced developers can increase concurrency to improve performance and scalability.
    
    transaction isolation levels.
    Serialized 
    Repeatable 
    Read committed 
    Read uncommitted 
    Any, Any isolation level is supported. 
    
    + managing automatic transactions in COM+ 
    
    COM+ creates a context object, sets both the JIT activation and Synchronization attributes to Required, and sets the consistent and done flags to True and False
    
    COM+ communicates with the Distributed Transaction Coordinator (DTC) to begin a transaction.
    
    The DTC generates a transaction identifier and passes it back to COM+. 
    
    When the client creates the object, COM+ activates it within the transaction boundary
    
    + end a transaction 
    The root object of the transaction completes its work and COM+ releases it
    
    The client releases the root object. Without a reference, the root object deactivates and the transaction attempts to commit.
    
    The transaction exceeds its time-out threshold. The transaction aborts automatically if not committed within the transaction time-out period, The default transaction time-out period is 60 seconds.
    
    + consistent and done flags 
    
    Each context object also contains a consistent flag and a done flag. 
    
    The done flag determines the duration of a transaction. When a method call returns, COM+ inspects the done flag.
    
    The consistent flag casts a vote to commit or abort the transaction in which it executes, and the done flag finalizes the vote. 
    
    + speeding transactions by notify the root object 
    task successfully, it should set its consistent and done flags to True by calling the IObjectContext::SetComplete method
    
    calling the IObjectContext::SetAbort method. By calling the SetAbort method, an object returns control to its caller
    
    ```
    Sub MyObjMethod1()
      On Error GoTo MyObjMethod1_err
      Dim ObjCtx As ObjectContext
      Dim InteriorObj1 As Cinterior  ' Cinterior is a user-defined object.

      Set ObjCtx = GetObjectContext()
      Set InteriorObj1 = CreateObject ("MyDll.Cinterior")
      InteriorObj1.Method1
      ' If the call completed successfully, then...
      ObjCtx.SetComplete
    Exit Sub
      MyObjMethod1_err:
      ' Doom the transaction and exit.
      ObjCtx.SetAbort
      ' Pass the message back to client.
      Err.Raise Err.Number, , Err.Description
    End Sub
    ```
    + terminating an automatic transaction by calling SetComplete 

calling the IObjectContext::SetComplete method, which is exposed through both the IObjectContext interface and the ObjectContext object

    + limitations of the transaction context object 

transaction context object, the application logic that combines the work of multiple objects into a single transaction

COM+ must be available on the non-transactional client computer.

    + bring your own transaction (BYOT)

allows a component to be created with or to inherit an external transaction.

YOT transactions include the ICreateWithTransactionEx interface and the ICreateWithTipTransactionEx interface. 

    + tasks 
    
    Transactions tab. Under Transaction support, select the option for the value you want. The default value for all components is Not Supported.

    Transaction Isolation Level

    Options tab. Under Transaction Timeout, enter the transaction time-out in seconds

    either the IObjectContext or the IContextState interfaces. The strategies used by these two interfaces differ significantly. IObjectContext has four methods 
    
    
    
# General tasks 
-  the Component Services administrative tool generates a single .msi file, which contains the following

- administrative tool generates a single .msi file, which contains the following:

    Windows Installer tables with COM registration information (see the Windows Installer documentation for details).
    An .apl file containing the application's attributes. (This is an internal file; the format of this file is not documented.)
    DLLs and type libraries that describe the interfaces implemented by the COM+ application's classes.

- deloying applications proxies 

including proxy/stub DLLs and type libraries for DCOM/QC interface remoting. This subset is called an application proxy

Application proxies generated by COM+ are Windows Installer installation packages. After installation, the application proxies appear in the client computer's Add/Remove Programs

    + information 

    Class identity information (CLSIDs and ProgIDs). An application proxy supports up to two ProgIDs.
    Application identity and relation of classes to applications (AppID).
    Location information per application (Remote Server Name).
    Marshaling information for all the interfaces exposed by the application (for example, type libraries and proxy/stubs).
    MSMQ queue names and identifiers (if the queued components service is enabled for the application).
    Class, interface, and method attributes, excluding role information.
    Application attributes.

    + install on os 
    
    application proxies can be installed on any operating system that supports DCOM (and Windows Installer). On computers that aren't running COM+, only the subset of information required for DCOM remoting is installed

    (using the HKEY_CLASSES_ROOT, APPID/CLSID keys)

- COM+ catalog 

COM+ catalog uses two different stores, as follows:

    1. The COM+ registration database
    2. The Windows registry (HKEY_CLASSES_ROOT)

- split registration 

the basic COM aspect of the registration is stored in the Windows registry  

new services and attributes (for example, queued components) are stored in the COM+ registration database.

    + transactional updates to the catalog 
    
    When you invoke the COM+ Administration Library from a transactional component, the updates to the COM+ registration database will take place within the calling component's transaction boundary.
    
- the COMREPL replication utility 
    
COMREPL is a utility that will replicate the COM+ catalog from a given source computer to one or more target computers. 

Microsoft Internet Information Services (IIS) has a similar utility (IISSync), which makes use of COMREPL to replicate IIS and COM+ configuration

    + use COMREPL 
    
    %windir%\system32\Com to the default environment path
    
    $ COMREPL sourceComputer targetComputerList [/n [/v]]
    sourceComputer, name of the source 
    targetComputerList, separated by space 
    /n suppresses confirmation prompt before starting replication 
    /v echoes log file output to the console 

    all target computers must already have COM+ installed
    The user must pass role checks for the system application
    No local machine accounts that may be used
    The target computer(s) must be online
    The user is responsible for replicating all non-COM+ data
    Clusters can participate in replication, COMREPL replicates only to named computers
    
    + what gets replicated 
    
        * COM+ setup program are not repliated 

    System application
    COM+ utilities
    COM+ QC Dead Letter Queue Listener

        * these application are not replicated 
    
    IIS in-process applications
    IIS utilities
    All applications created for isolated or pooled virtual roots
    
        * computer list in the computer folders in administration tool will not be replicated 
        
        * properties of LocalComputer are replicated 
TransactionTimeout
ResourcePoolingEnabled
DCOMEnabled
DefaultAuthenticationLevel
DefaultImpersonationLevel
SecurityTrackingEnabled
CISEnabled
SecureReferencesEnabled
InternetPortsListed
DeafultToInternetPorts
Ports
RpcProxyEnabl

        * LocalComputer collection properties are not replicated 

    Description
    ApplicationProxyRSN
    IsRouter

        * replication phases 
        
        To separate work done to prepare the source from work
        To delay modification of the target until all data has been acquired
        
        prepare phase, Exports all the installed applications locally on the source computer. 
        
        copy phase 
        
        install phase 
        
    + file mangement, transfer of application files, COMREPL automatically manages sets of file system folders on the source and target
    
    + logging and error reporting 
    
    COMREPL generates a log file containing status and error messages. 
    
    in %systemdir%\com\replication\ComRepl.log.
    
     in the event log on source or target computers.

- Debugging COM+ applications 

configure Visual C++ project or the Component Services administrative tool to launch the debugger

use the COM+ Launch in debugger setting. You will find this in the Component Services administrative tool as a check box on the Advanced tab of the COM+ application Properties

change the transaction time-out setting on the Options tab of the My Computer Properties window.

    + To enable RPC debugging in Visual C++

    In Visual C++, on the Tools menu, click Options.

    In the Options dialog box, on the Debug tab, select the OLE RPC debugging and Just-in time debugging check boxes.

    Click OK.

    + To enable a server application component to launch the Visual C++ debugger

    On the Project menu, click Settings.

    In the Project Settings dialog box, in the Settings For box, select Win32 Debug.

    On the Debug tab, in the Category box, select General.

    In the Executable for debug session box, enter the fully qualified path for Dllhost.exe, followed by an argument specifying the application ID of the COM+ application containing the component.
    
    ```
    C:\Winnt\System32\Dllhost.exe /ProcessID:{applicationID}
    ```
    
    + To enable library application debugging with Visual C++

    In Visual C++, on the Project menu, click Settings.

    In the Project Settings dialog box, in the Settings For box, click Win32 Debug.

    On the Debug tab, in the Category box, click Additional DLLs.

    In the Modules list, add the component DLLs in your library application. This allows you to set breakpoints before your DLL is actually loaded.

    Click OK.

    + debugging without visual C++ 
    
    To specify a debugger from the Component Services administrative tool

    In the console tree, select the COM+ library application containing the components you wish to debug.

    Right-click the application, and then click Properties.

    In the application's Properties dialog box, click the Advanced tab.

    Under Debugging, select the Launch in debugger check box.

    In the Debugger path box, enter path to the debugger you want to use. You can also click Browse to locate the debugger. Following is an example: C:\Winnt\System32\Ntsd.exe.

    Click OK.
    
    + debugging component in VB 

        * To debug a Visual Basic component in the Visual C++ environment

        In Visual Basic 6.0, open the Visual Basic project that you want to debug.

        On the File menu, click Make YourProject.dll.

        In the Make Project dialog box, click Options.

        In the Project Properties dialog box, on the Compile tab, click Compile to Native Code and No Optimization and select the Create Symbolic Debug Info check box.

        Click OK, and then click OK again to compile your project.

        Move the compiled DLL to the location where COM+ applications are normally installed.
        
        Start Visual C++.

        On the File menu, click Open Workspace.

        In the Open Workspace dialog box, set Files of Type to All files(*.*), select your compiled component, and click Open.

        From the File menu, click Open (not Open Workspace) and open the Visual Basic module (.bas), form (.frm), or class (.cls) that you want to debug.

        On the Project menu, click Settings.

        In the Project Settings dialog box, on the Debug tab, select General in the Category box.

        In the Executable for debug session box, enter the fully qualified path for Dllhost.exe
        ```
        Following is an example: C:\Winnt\System32\Dllhost.exe /ProcessID:{}.
        ```
        
        Click OK 
        
        * COM+ visual basic debugging support contrasted with MTS 
        
        Debugging multiple componentsâ€”In COM+, you can debug scenarios in which a client running in one instance of the IDE makes calls to any number of DLLs running in another as a project group.
        
        Debugging Limitations on Class_Initialize and Class_Terminate Eventsâ€”With COM+, you can put code in the Class_Initialize and Class_Terminate events of a COM+ application
        
        Although it is no longer needed as a workaround, you can still implement the IObjectControl interface and use its Activate and Deactivate methods
        
        Watching MTS Objectsâ€”With COM+, you can add watches for object variables returned by COM+
        
        ```
        Dim obj As Object
        Set obj = CreateObject("MyApp.MyClass")
        obj.Test  'Call the user-defined subroutine named Test.
        Set obj = Nothing
        ```
- Handling errors in COM+ 

keep in mind as you develop components for COM+.

    1. Return an HRESULT value for all methods in all component interfaces.  COM+ uses HRESULT values to report on any errors in making function calls or interface method calls
    
    https://docs.microsoft.com/en-us/windows/desktop/com/structure-of-com-error-codes

    2. Initiate the ErrorInfo collection object by whatever means your development tool provides.

    Your component must implement the ISupportErrorInfo Automation interface to advertise its support for the ErrorInfo collection

    IErrorInfo Automation interface to retrieve the error information. Visual Basic programmers have easy access to the ErrorInfo collection object

    3. Use transactions to manage shared resource failures. Automatic transactions can significantly reduce the amount of error-handling code

    4. Raise errors explicitly. Avoid letting error information leave an object unless the object explicitly raises the error.

    5. Use the FACILITY_ITF range of errors to report interface-specific errors. Interface-specific errors should be in the FACILITY_ITF range of errors
    
    ```
    const HRESULT ERROR_NUMBER = MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 10);
    ```
    
    + how COM+ modifies return values 
    
    returns an HRESULT value indicating success (such as S_OK, S_FALSE, or NOERROR), COM+ sometimes converts the HRESULT into a COM+ error code before it returns to the caller.
    
    returns S_OK after calling IObjectContext::SetComplete, if the object is the root of a transaction that fails to commit, the HRESULT is converted to CONTEXT_E_ABORTED.
    
    When COM+ converts an HRESULT value, it clears all of the method's output parameters. Returned references are released, and the values of the returned object pointers are set to NULL.
    
    + fault isolation and failfast policy 
    
    COM+ assumes that the entire process has been corrupted, and the process is immediately terminated to prevent it from spreading potentially corrupted information to other processes
    
    COM+ does not allow exceptions to propagate outside of a context. If an exception occurs while executing within a COM+ context and the application doesn't catch the exception before returning from the context
    
    inspect the Event Viewer application log for details on any failfast action or serious application errors.
    
    + finding the source of an error 
    
    the application error is caused by COM+, you can interpret the error message viewing the Winerror.h file or by using the Microsoft Visual C++ error utility.
    
    You should first refer to the application log in the Event Viewer to check the application associated with the event message. 
    
    + interpreting error codes 
    
    For a list of system-defined HRESULT values, see the header file Winerror.h included with the Windows SDK
    
    ```
    #include <stdio.h>
    #include <windows.h>
    #include <tchar.h>

    void ErrorDescription(HRESULT hr) 
    { 
         if(FACILITY_WINDOWS == HRESULT_FACILITY(hr)) 
             hr = HRESULT_CODE(hr); 
         TCHAR* szErrMsg; 

         if(FormatMessage( 
           FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, 
           NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
           (LPTSTR)&szErrMsg, 0, NULL) != 0) 
         { 
             _tprintf(TEXT("%s"), szErrMsg); 
             LocalFree(szErrMsg); 
         } else 
             _tprintf( TEXT("[Could not find a description for error # %#x.]\n"), hr); 
    }
    ```
    
    error code reference 
    https://docs.microsoft.com/en-us/windows/win32/cossdk/interpreting-error-codes
    
    COMADMIN_E_ALREADYINSTALLED, The object is already registered.
    ...

    + troubleshooting 
    Distributed Transaction Coordinator (DTC) is running on all servers.
    Check network communication
    Make sure that SQL and DTC are located on the same computer 
    Set the transaction time-out to a higher number than the default 60 seconds
    Make sure that your ODBC drivers are thread-safe
    If you have difficulty getting an application to work over several servers, reboot the client
    
- Automating COM+ administration 

Component Services Administration (COMAdmin) Library, to automate all tasks in the administration of COM+ applications and services

    + do the following:

    Create and configure COM+ applications.
    Install and export existing COM+ applications.
    Manage installed COM+ applications.
    Manage and configure services.
    Remotely administer Component Services on a different machine.

    + can do the following:

    Write scripts to perform routine administrative tasks.
    Write scripts to automate processes in the development of COM+ applications.
    Develop general-purpose tools for administering and monitoring Component Services.
    Develop setup executables to install and deploy your COM+ application.

    + reference classes and interfaces 
    
    COMAdminCatalog
    COMAdminCatalogCollection
    COMAdminCatalogObject
    ICOMAdminCatalog
    ICOMAdminCatalog2
    ICatalogCollection
    ICatalogObject

    + overview of the COMAdmin objects 


- Designing COM+ application 
- Conversion of MTS packages to COM+ applications 







# Windows shell 
https://docs.microsoft.com/en-us/windows/win32/shell/shell-entry

# Window 32 api reference 
https://docs.microsoft.com/en-us/windows/win32/api/


# Window document for previous versions 
https://docs.microsoft.com/en-us/previous-versions/windows/
- Window IT Pro 
- Window Servers 
- Windows embedded 
- Windows app development 
https://docs.microsoft.com/en-us/previous-versions/visualstudio/windows-sdk/ms717358(v=vs.110)

preivous win8 etc. 
- Windows hardware 
- Internet explorer 
- Game development 
- Silverlight 

# Extending explorer with band object 
https://www.codeproject.com/Articles/2219/Extending-Explorer-with-Band-Objects-using-NET-and



# Edge document 
https://docs.microsoft.com/en-us/microsoft-edge/


# Internet explorer reference 
https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/




# COM+ reference 
https://docs.microsoft.com/en-us/windows/win32/cossdk/com--reference
    
    
    
    
# Window 32 API reference 
https://docs.microsoft.com/en-us/windows/win32/api/






































































