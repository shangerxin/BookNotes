Microsoft online document, Microsoft interface definition language (MIDL);Note=Erxin

# Reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-start-page



# Purpose 
- MIDL can be used in all client/server applications based on Windows operating systems.
- network environments that include such operating systems as Unix and Apple. Microsoft supports the Open Group (formerly known as the Open Software Foundation) DCE standard for RPC interoperability.

- MIDL compiler generates C-language files from IDL files.

- Application Configuration (ACF) files for MIDL


# Using MIDL compiler 
- invoking the compiler 

command line using the following command:

$ midl <options> filename.idl

MIDL compiler /help and /? switches

    + remarks 

The new global flag $(MIDL_OPTIMIZATION) exists in win32.mak. When an .idl file is compiled using this flag, the generated stub can utilize the latest RPC features available

- response files. A response file is a text file containing one or more MIDL compiler command-line options. 

You can specify a MIDL response file as, include one or more response files, with commandline parameters 

$ midl -Oicf @midl1.rsp -envwin32 @midl2.rsp itf.idl

- Using C/C++ preprocessor with MIDL 

By default, MIDL uses the preprocessor for the Microsoft C/C++ compiler from the same building environment

MIDL spawns separate preprocessor runs for top-level IDL and ACF files

included with the #include directive are handled by the preprocessor directly.

- C-preprocessor requirements for MIDL 

The MIDL switches /cpp_cmd, /cpp_opt, and /no_cpp are used to override the default behavior of the compiler.

the MIDL compiler switch /cpp_cmd enables an override of the default C/C++-preprocessor 

$ midl /cpp_cmd preprocessor_name idl-filename 

In the output stream of the preprocessor, the #line directives are present to enable better diagnostic messages.

The preprocessor must redirect output to the standard output device, stdout.

for the Microsoft C/C++ preprocessor the /E option would have to be used

$ midl /cpp_cmd cl.exe /cpp_opt "/E" file.idl

the #line directive in MIDL 
```
#line digit-sequence "filename" new-line
 
# digit-sequence "filename" new-line
```

if the /no_cpp switch is used, the input file must not have other preprocessor directives

- dealing with #defines in IDL files 

explanation applies to any files processed by MIDL, such as *.idl, *.acf, *.h files.

when MIDL replicates type definitions from an input file to the generated H file, the #defines are not replicated, do not use #defines directly in IDL files if they are to be used later from the generated H file

    + workarounds 
    
    Use the const declaration specification.
    
    ```
    const short ARRSIZE = 10
    ```
    
    will be compiled to 
    
    ```
    #define ARRSIZE 10
    ```

    Use separate header files that are imported or included in the IDL file, and later included in the C-source code.
    
    Use enumeration constants in the IDL file.

    Use cpp_quote to reproduce #define in the generated header file.
    
    handle **#**define statements is to package them in a separate header file, either into a file devoted to **#**define statements or into a file that contains only type definitions

    Importing a header or IDL file to another IDL file prevents the typedef statements from being replicated to the H file generated by MIDL 
    
    ```
    typedef enum midlworkaround { MAXSTRINGCOUNT = 300 };
    ```
    
    cpp_quote directive of MIDL can be used to write out an arbitrary string directly into the generated H file.
    ```
    cpp_quote ("#define ARRSIZE 10")
    ```
    
- verifying preprocessor options 

MIDL /cpp_opt switch, the preprocessor command line is composed of all the /I, /D and /U switches used in the MIDL command line, as well as /E and /nologo switches

To see the switches passed on to the preprocessor, use the compiler's /confirm switch.

- saving preprocessor output 

easiest and the least obtrusive way to obtain the preprocessed files from a MIDL compile run is to use the -savePP switch. The -savePP switch simply prevents MIDL from deleting the temporary files

$ midl -savePP -Id:\nt\public\sdk\inc -DNTENV=1 -Oicf -env win32 stub.idl


/E /nologo are the switches that MIDL adds when invoking the preprocessor
```
$ cl /E /nologo -Id:\nt\public\sdk\inc -DNTENV=1 stub.idl > stub.pp
$ cl /E /P -Id:\nt\public\sdk\inc -DNTENV=1 stub.idl
```


The /cpp_opt switch can also be used to obtain a preprocessed file
```
$ Midl -Oicf -win32 -cpp_opt "/E /P -Id:\nt\public\sdk\inc -DNTENV=1" stub.idl
```

- C/C++ compiler considerations 

    + natural alignment 

    A base type, such as short, float and __int64, and a pointer is aligned naturally
    
    base types have sizes of 1, 2, 4 or 8. Pointers have a size of 4 in 32-bit environments and 8 in 64-bit environments
    
    + A compound type is aligned naturally if each of its components is aligned naturally relative to the beginning of the type
    
    + connection between alignment and memory size of a type in languages like C or C++ and IDL as expressed by the operator sizeof(). The size is a multiple of the alignment
    
    Natural alignment is important because accessing misaligned data may cause an exception on some systems
    
    Data can be marked for a safe manipulation when misaligned, but typically that involves a speed penalty that may be substantial on some platforms
    
    + simple rule, new alignment of a packed type is the smaller of the packing level and its natural alignment. 
    
    a multiple of the new alignment. The sizeof() operator returns the reduced size for packed types.
    
    + 1 byte character 
    
```
struct mystructtype 
{    
    char c1;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
    long l2;  /* requires 4 bytes */
    char c3;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
 } mystruct;
```

This structure is naturally aligned at 4 and has the natural size of 12. will be misaligned if located in memory at an address that is not a multiple of 4

packing level 2, the structure is aligned at 2 and its size is 8. will be misaligned if located in memory at an address that is not a multiple of 2.

packing level 1, the structure is aligned at 1 and its size is 6, The structure packed with level 1 can be placed anywhere without causing a misalignment fault.

- C-Compiler definitions for proxy/stubs 

macros are invoked with the /D (or -D) preprocessor switch at the C-compile time
    
REGISTER_PROXY_DLL, 	Generates DllMain, DllRegisterServer, and DllUnregisterServer, self-register your proxy DLL in the system registry.

PROXY_CLSID=<clsid>, 	Specifies a class identifier for the server. I

PROXY_CLSID_IS={0x8hexdigits, ... {0x2hexdigits,0x2hexdigits,...}}      specify server's class id in binary hex format 

PROXY_CLSID=<clsid> macro when you want to explicitly specify the proxy/stub server's CLSID 

default DllRegisterServer function runs, it registers the server with ThreadingModel=Both.

makefile example 
```
example.h example.tlb example_p.c example_i.c dlldata.c : example.idl
    midl example.idl
dlldata.obj : dlldata.c
    CL /c /DWIN32 /DREGISTER_PROXY_DLL dlldata.c
example.obj : example_p.c
    CL /c /DWIN32 /DREGISTER_PROXY_DLL \
    /DPROXY_CLSID=7a98c250-6808-11cf-b73b-00aa00b677a7
example_p.c
iids.obj : example_i.c
PROXYSTUBOBJS = dlldata.obj example.obj iids.obj
PROXYSTUBLIBS = kernel32.lib rpcns4.lib rpcrt4.lib uuid.lib
proxy.dll : $(PROXYSTUBOBJX) example.def
    link /dll /out:proxy.dll /def:example.def
        $(PROXYSTUBOBJS) $(PROXYSTUBLIBS)
    regsvr32 /s proxy.dll
```

- using the __midl predefined constant 

MIDL compiler processes the input IDL and ACF files, __midl is defined by default and is used for conditional compilation to attain consistency throughout the build

example MIDL ver. 6.0.x has the __midl defined as 600.

/U switch removes any previous definition of a name by passing the name to the C preprocessor 

$ midl /U name 

- MIDL and RPC 

The MIDL compiler generates the C-language stub and header files necessary to create the interface between the client application and the server application

    + client stub 
    
    MIDL compiler switches /client, /cstub, and /out affect the client stub file.
    
    + server stub 
    
    MIDL compiler switches /server, /sstub, and /out affect the server stub file.
    
    + the header file 
    
    the generated header file contains an include line to the H file generated from the imported file. the files included with the #include directive. 
    
    MIDL compiler switches /header and /out affect the header file.
    
    + targeting stubs for specific 32 bit or 64 bit platforms
    
    Microsoft RPC and the MIDL 3.0 
    
    MIDL generates two types of guards: a platform-dependent guard (32-bit versus 64-bit) and a release-dependent guard (feature set dependency).
    ```
    #if !defined(__RPC_WIN32__)
    #error  Invalid build platform for this stub.
    #endif
    ```
    
    if the interface uses features supported only on Windows√Ç 2000 or later, MIDL generates a guard with the TARGET_IS_NT50_OR_LATER macro.
    
    The guard macros, defined in Rpcndr.h, depend on the setting of WINVER and _WIN32_WINNT and are evaluated by the C/C++ compiler.
    
    ```
    CFLAGS = $(CFLAGS) -D_WIN32_WINNT=0x500
    ```

- MIDL and COM 

the MIDL compiler combines all client and object server auxiliary routines and data into a single interface proxy file

the MIDL compiler generates an interface header file, an interface UUID file and an interface registration file. You will use all these files when creating a proxy DLL
    
    + the interface proxy file 
 
interface proxy file (U_p.c) is a C file that contains routines equivalent to those in the client stub and server stub files of an object (COM) interface

The interface proxy file includes the supporting routines and data only for methods of the interfaces defined in the current IDL file

proxy file contains the following two surrogate methods when compiled in the mixed mode (/Os), and equivalent interpreter data when compiled in the interpreter mode (/Oi).

        * The client-side surrogate, such as IFaceB_Method_Proxy 
    
        * The server-side surrogate, for example, IFaceB_Method_Stub

name for a proxy file generated from a file.idl is file_p.c.Use the /proxy MIDL compiler switch to override the default name

    + header file

    The default name for a header file generated from a file.idl is File.h, The /header MIDL compiler switch overrides the default name 

    + interface uuid file 
    
    IID file generated from a file.idl is File_i.c. The /iid MIDL compiler switch overrides the default name of the interface UUID file.
    
    + the interface registration file 
    
    interface registration file collects information that helps in the registration of COM interfaces packaged into a DLL or EXE file.
    
    the MIDL compiler implements a timeout approach to waiting on a file it cannot open,

    an input file is dlldata.c. The /dlldata MIDL compiler switch can be used to override the default name of the file
    
    + marshaling OLE data types 
    
    To use the BSTR data type in remote procedure calls, import the wtypes.idl file into your interface definition (IDL) file and link to Oleaut32.lib, your stubs use the ready-made helper functions BSTR_UserSize, BSTR_UserMarshal, BSTR_UserUnmarshal, and BSTR_UserFree.
    
    To use other Automation data types, such as VARIANT and SAFEARRAY, or types that use those types (for example, DISPPARAMS and EXCEPINFO), import the objidl.idl file into your IDL file and link to the oleaut32.lib at build time.
    
    To use OLE data types (such as CLIPFORMAT, SNB, STGMEDIUM, ASYNC_STGMEDIUM), or system handles (such as HMETAFILE_PICT, HENHMETAFILE, HMETAFILE, HBITMAP, HPALETTE, and HGLOBAL), import the objidl.idl file into your interface definition file and link to the ole32.lib
    
    The following OLE handles are also defined with the [wire_marshal] attribute, but only as handles within a computer since they cannot be used in remote procedure calls to other computers at this time: HWND, HMENU, HACCEL, HDC, HFONT, HICON, HBRUSH. Import the objidl.idl file into your IDL file and link to ole32.lib at build time to use these handles in interprocess communication on a single computer.
    
    more info, see The wire_marshal Attribute, The type_UserSize Function, The type_UserMarshal Function, The type_UserUnmarshal Function, The type_UserFree Function, and Targeting Stubs for Specific 32-bit or 64-bit Platforms.
    
- MIDL and ODL 


Microsoft Interface Definition Language (MIDL) now includes the complete Object Definition Language (ODL) syntax. generate a type library and optional header files for a COM application.


the documentation refers to an ODL file, it is referring to a file that Mktyplib.exe can parse. When it refers to an IDL file, it is referring to a file that the MIDL compiler can parse. 

    + reference 
    https://docs.microsoft.com/en-us/windows/win32/midl/midl-and-odl
    
- MIDLRT and windows runtime components 

    + reference 
    https://docs.microsoft.com/en-us/windows/win32/midl/midlrt-and-windows-runtime-components
    
- interface definitions and type libraries 

interface definition language (IDL) files and application configuration files (ACF) for MIDL, how to import files, type libraries, and system header files.

    + interfaces in distributed objects 

Applications based on remote procedure calls (RPC), Component Object Model (COM), and Distributed Component Object Model (DCOM) specify their interfaces using MIDL.

    + COM, DCOM, type libraries 
    
    type library, A type library (.tlb) is a binary file that stores information about a COM or DCOM object's properties and methods in a form that is accessible to other applications at runtime.
 
    The COM/DCOM run-time environment can also use a type library to provide automatic cross-apartment, cross-process, and cross-machine marshaling for interfaces described in type libraries.
    
    + characteristics of an interface 
    
    The IDL file specifies the characteristics of the application's interfaces on the wire 
    
    The ACF file specifies interface characteristics, such as binding handles, that pertain only to the local operating environment. The ACF file can also specify how to marshal and transmit a complex data 
    
    + interface definition file (IDL)
    
        * data types in the body 
        
        The interface body, which is enclosed in braces ({ }), contains the data types be used in RPC 
        
        OSF-DCE specification for RPC interfaces does not allow multiple interfaces in a single IDL file. Therefore, if you are compiling in MIDL's OSF-compatibility mode ( /osf), your IDL file can contain only one interface
        
    ```
    interface ITwo; //forward declaration
    interface IOne 
    {
    ...uses ITwo...
    }
    interface ITwo 
    {
    ...uses IOne...
    }    
    ```
        
    + type definition construct declarations and imports 
    
    multiple interfaces are not permitted when you use the /osf switch
    
    The import keyword specifies the names of one or more IDL files to import
    
        * constant declaration specifies Boolean, integer, character, wide-character, string, and void * constants. For more information, see const
        
        * A general declaration is similar to the C typedef statement with the addition of IDL type attributes
        
        * function 
    ```
[ 
    uuid(12345678-1234-1234-1234-123456789ABC), 
    version(3.1), 
    pointer_default(unique) 
] 
interface IdlGrammarExample 
{ 
    import "windows.idl", "other.idl"; 
    const wchar_t * NAME = L"Example Program"; 
    typedef char * PCHAR; 
 
    HRESULT DictCheckSpelling( 
        [in, string] PCHAR   word,     // word to look up 
        [out]        short * isPresent // 0 if not present 
    ); 
}
    ```
        
- IDL attributes 

    + Field Attributes
    + Aliasing and Marshaling Attributes
    
    This format, the Network Data Representation (NDR) format, is often called the wire format of the data
    
    marshaling the data, stubs must convert data from its native format in the program's memory space to NDR
    
    unmarshaling the data, t convert the data from NDR to the native format for that program.
    
call_as 	    Maps a nonremotable function to a remote procedure call.
iid_is 	        Provides the interface identifier of the COM interface that is the object of the pointer.
transmit_as 	Converts a data type to a simpler type for transmission over a network.
wire_marshal 	Similar to transmit_as but you implement the routines to size, marshal, unmarshal, and free the data.
    
    + Asynchronous Attributes
    
    An asynchronous procedure returns immediately without waiting for results
    
async 	    When applied to a function parameter, defines a handle that allows the caller to make an asynchronous call
    
async_uuid 	Directs the MIDL compiler to define both synchronous and asynchronous versions of a COM interface.

maybe 	    The client making this remote procedure call does not expect any response indicating delivery or completion of the call, and delivery is not guaranteed. 

message 	The remote procedure call is to be treated as an asynchronous message from the client to the server. The client makes the call and returns immediately
    
    + Array and Sized-Pointer Attributes

    specify characteristics of arrays and multiple levels of pointers
    
    size_is 	Specifies the amount of memory to be allocated for sized pointers, sized pointers to sized pointers, and single- or multidimensional arrays
    
    max_is 	The maximum value for an array index.
    
    length_is 	The number of array elements to be transmitted.
    
    first_is 	The index of the first array element to be transmitted.
    
    last_is 	Gives the index of the last array element to be transmitted.
    
    string 	Indicates that the one-dimensional char, wchar_t, byte (or equivalent) array, or the pointer to such an array, is to be handled as a string.
    
    range 	Specifies a range of allowable values for arguments or fields whose values are set at runtime.
    
        + reference pointers, unique pointers, and full pointer
        
        pointer attributes ref, unique, and ptr
        
        + A pointer attribute can be applied as a type attribute; as a field attribute that applies to a structure member, union member, or parameter; or as a function attribute return type, can also appear with the pointer_default keyword.
        
        + To apply different pointer attributes to multiple pointer declarators, you must define intermediate types 
        
        + pointer attributes using the following priority rules
        
        Attributes explicitly applied to the pointer type
        Attributes explicitly applied to the pointer parameter or member
        The pointer_default attribute in the IDL file that defines the type
        The pointer_default attribute in the IDL file that imports the type
        ptr (osf mode); unique (Microsoft RPC default mode)
        
        + pointer attribute can be inherit when import into another file, by default. Compile with /osf will not support 
        
        + A pointer returned by a function must be a unique pointer or a full pointer.
        
        + specify a pointer attribute at the top level of a typedef statement, the specified attribute is applied to the pointer declarator, as expected.
        

    + Data Type Attributes
    
    data types in a typedef statement to further define the usage or effect of the data type.
    
    context_handle 	Identifies a binding handle that maintains state (context) information
    
    handle 	Specifies a custom handle type specific to the application.
    
    ms_union 	Controls the NDR alignment of nonencapsulated unions. 
    
    pipe 	Allows transmission of an open-ended stream of typed data across a remote procedure call.
    
    transmit_as 	Specifies how a data type will be transmitted over a network, used for custom marshaling.
    
    v1_enum 	Directs that the specified enumerated type be transmitted as a 32-bit entity instead of 16 bit default 
    
    wire_marshal 	Similar to transmit_as but you implement the routines to size, marshal, unmarshal, and free the data.
    
    + Directional Attributes
    
    in 	The parameter is being passed from the caller to the called function.
    
    out 	The parameter is being passed from the called function to the caller.
    
    + Function Call Attributes
    
    message 	The remote procedure call is to be treated as an asynchronous message from the client to the server. 
    
    maybe 	The client making this remote procedure call does not expect any response indicating delivery or completion of the call. 
    
    broadcast 	The remote procedure call is to be sent to all of the servers on the network. 
    
    idempotent 	The call does not change state and returns the same information each time it is called with the same input parameters.
    
    callback 	Designates a function that resides in the client application, which the server can call to obtain information from the client.
    
    call_as 	Maps a nonremotable function to a remote procedure call.
    
    local 	Designates a local procedure for which MIDL does not generate stub code.
    
    
    + Interface Header Attributes
    
    async_uuid 	Directs the MIDL compiler to define both synchronous and asynchronous versions of a COM interface.
    
    uuid 	Designates a 128-bit value that distinguishes a particular interface from all others. the value may represent a GUID,  a CLSID or an IID 
    
    local 	Directs the MIDL compiler to generate header files only. 
    
    ms_union 	Controls the NDR alignment of nonencapsulated unions. 
    
    object 	Identifies the interface as a COM interface and directs the MIDL compiler to generate proxy/stub code
    
    version 	Identifies a particular version of an interface in cases where multiple versions of the interface exist. 
    
    pointer_default 	Specifies the default pointer type for all pointers except for those included in parameter lists.  type can be unique, ref, or ptr.
    
    endpoint 	Specifies a static (well-known) endpoint on which a server application listen 
    
    + Performance Attributes
    
    ignore 	Designates that a pointer contained in a structure or union and the object indicated by the pointer is not to be transmitted.
    
    local 	Designates a function that is local to the application for which MIDL does not need to generate stub code.
    
    wire_marshal 	Defines a data type as a simpler type for transmission over a network and allows you to implement marshaling and unmarshaling
    
    + Pointer Type Attributes
    ptr 	Designates a pointer as a full pointer, with all the capabilities of a C-language pointe
    
    ref     Designates a reference pointer, one that simply provides the address of some data. Reference pointers can never be null.
    
    unique 	Lets a pointer be null, but does not support aliasing.
    
    pointer_default 	Applied to an interface to specify the default pointer type for all pointers in that interface except top-level parameter pointers, which automatically default to ref pointers.
    
    iid_is 	Provides the interface identifier of the COM interface the object of the pointer 
    
    string 	Specifies that the pointer points to a string.
    
    + Structure and Union Attributes
    
    switch_* attributes to specify the characteristic of a union in a remote procedure call
    
    switch 	Selects the discriminant for an encapsulated union.
    
    switch_is 	Identifies the discriminant for a nonencapsulated union.
    
    switch_type 	Identifies the type of the discriminant for a nonencapsulated union.
    
    ignore 	Designates that a pointer contained in a structure or union and the object indicated by the pointer is not to be transmitted.
    
    + Type Library Attributes
    
    aggregatable 	Defines the coclass as supporting objects that can directly expose another object's interface pointer.
    
    appobject 	Identifies the coclass as an application object, which is associated with a full EXE application.
    
    bindable 	Indicates that the property supports data binding.  allows the client to be notified a property has changed 
    
    coclass 	Provides a listing of the supported interfaces for a component object.
    
    control 	Identifies a coclass or library as a COM control, from which a container site
    
    custom 	Defines a custom attribute (one not defined in MIDL).
    
    default 	Indicates that the interface or dispinterface, defined within a coclass, represents the default interface.
    
    defaultbind 	Indicates the single, bindable property that best represents the object.
    
    defaultcollelem 	Flags the property as an accessor function for an element of the default collection. 
    
    defaultvalue 	Allows specification of a default value for a typed optional parameter.
    
    defaultvtable 	Allows an object to have two different source interfaces.
    
    dispinterface 	Defines a set of properties and methods on which you can call IDispatch::Invoke.
    
    displaybind 	Indicates a property that should be displayed to the user as bindable.
    
    dllname(str) 	Defines the name of the DLL that contains the entry points for a module.
    
    dual 	Identifies an interface that exposes properties and methods both through IDispatch and directly through the Vtable.
    
    entry 	Specifies an exported function or constant in a module by identifying the entry point in the DLL.
    
    helpcontext 	Specifies a context identifier that lets the user view information about this element in the Help file.
    
    helpfile 	Sets the name of the Help file for a type library.
    
    helpstring 	Specifies a character string that is used to describe the element to which it applies.
    
    helpstringdll 	Sets the name of the DLL to use to perform the document string lookup.
    
    hidden 	Indicates that the item exists but should not be displayed in a user-oriented browser.
    
    id 	Specifies a DISPID for a member function
    
    immediatebind 	Indicates that the database will be notified immediately of all changes to a property of a data-bound object.
    
    lcid 	When applied to the library statement, along with a localeID argument, identifies the locale for a type library or for a function argument and lets you use international characters
    
    library 	Instructs the MIDL compiler to generate type library information for the interfaces and classes referenced inside the statement.
    
    licensed 	Indicates that the coclass to which it applies is licensed, and instances must be created using IClassFactory2.
    
    nonbrowsable 	Indicates that the property appears in an object browser but not appear in a property browser which show property value 
    
    noncreatable 	Prevents a client from using the default class factory to create instances of an object interface.
    
    nonextensible 	Specifies that the IDispatch implementation includes only the properties and methods listed in the interface description and cannot be extended
    
    ```
[
    uuid(uuid-number), 
    nonextensible 
    [, optional-attribute-list]
] 
interface | dispinterface interface-name 
{
    interface-definition
}
    ```
    
    oleautomation 	Indicates that an interface is compatible with automation.
    
    optional 	Specifies an optional parameter for a member function.
    
    propget 	Specifies a property accessor function.
    
    propput 	Specifies a property-setting function.
    
    propputref 	Specifies a property-setting function that uses a reference instead of a value.
    
    public 	Ensures that an alias declared with typedef becomes part of the type library.
    
    readonly 	Prohibits assigning a new value to a variable.
    
    requestedit 	Indicates that the property supports the OnRequestEdit notification.
    
    restricted 	Specifies that a library, or member of a module, interface, or dispinterface cannot be called arbitrarily.
    
    retval 	Designates the parameter that receives the return value of the member.
    
    source 	Indicates that a member of a coclass, property, or method is a source of events.
    
    string 	Indicates that the one-dimensional char, wchar_t, byte (or equivalent) array or the pointer to such an array must be treated as a string.
    
    uidefault 	Indicates that the type information member is the default member for display in the user interface.
    
    usesgetlasterror 	Specifies that a module entry point uses SetLastError to return error codes and that a caller can then call GetLastError to retrieve the error code if there is an error on entering a function.
    
    uuid 	Designates a unique identifier for a type library, coclass, or interface.
    
    vararg 	Specifies that the function takes a variable number of arguments.
    
    version 	Identifies a particular version of a type library.
    
- application configuration file, ACF 

Client may each need their own set of marshaling routine. It is inefficient to generate stub code for functions that will never be implemented in a particular client application.

local aspects of your interface in an application configuration file (ACF), you can separate the differences between the client interfaces from their network representation, allowing the server to send and receive data in a consistent format

```
[ interface-attribute-list] interface interface-name {. . .}
```

However, when you use the MIDL compiler option / acf to explicitly specify an ACF file name, the interface names do not have to match

- ACF attributes 

    + binding ACF attributes 
    
    async 	                Defines a handle that allows the caller to make an asynchronous call and return immediately without waiting for results
    
    auto_handle 	        Tells MIDL to let the stub code control the binding automatically. 
    
    context_handle_noserialize 	Guarantees that a context handle will never be serialized, regardless of the application's default behavior.
    
    context_handle_serialize 	Guarantees that a context handle will always be serialized, regardless of the application's default behavior
    
    explicit_handle 	    Lets the client application control the binding with an explicit parameter in each procedure.
    
    implicit_handle 	    Specifies a handle for procedures that do not have an explicit handle parameter.
    
    strict_context_handle 	Guarantees that the methods in the interface will only accept context handles that were created by a method of that interface.
    
    + stub optimization ACF attributes 
    
    codenocode 	Use the code and nocode attributes together to avoid generating stub code for unused functions. 
    
    optimize 	Lets you fine-tune the level of optimization that the MIDL compiler performs when generating stub code, by specifying that data is to be marshaled by either the mixed-mode or interpreted method. 
    
    + type conversion and marshaling ACF attributes 
    
    encodedecode 	Instructs MIDL to expose the type or procedure serialization (pickling) routines it generates for the stubs. 
    
    represent_as 	Specifies how a data type will be represented on the wire, when the exact nature of a client's data type is unimportant to the server
    
    user_marshal 	Controls how data is transmitted over the wire by implementing your own marshaling routines. 
    
    + memory management ACF attributes 
    
    allocate 	Specifies the way the client application and stub allocate and release memory for pointers. 
                allocate attribute to direct the stub to compute the size of all memory referenced through the pointer of the specified type and to make a single call to midl_user_allocate.
                
    byte_count 	Enables you to create a persistent, contiguous block of memory that can be reused over multiple remote procedure calls.             
    
    enable_allocate 	Specifies that the server stub code should enable the stub memory-management environment.
    
    + error and exception handling Acf attribute 
    
    comm_statusfault_status 	Let your client application handle exceptions gracefully by causing communication and server errors to be returned to the client as parameter values. 
    
    + using ACF attributes in an IDL file 
    
    You can use the /app_config MIDL compiler option to specify binding handle attributes in the IDL file rather than in a separate ACF file.
    
    apply the auto_handle, implicit_handle, and explicit_handle attributes to the header of an RPC interface in an IDL file.
    
- MIDL data types 

    + MIDL Base Types
    boolean 	8 bits. Not compatible with oleautomation interfaces; use VARIANT_BOOL instead.
    
    byte 	8 bits.
    char 	8 bits.
    double 	64-bit floating point number.
    error_status_t 	32-bit unsigned integer for returning status values for error handling.
    float 	32-bit floating point number.
    handle_t 	Primitive handle type for binding.
    hyper 	64-bit integer.
    int 	32-bit integer. On 16-bit platforms, cannot appear in remote functions without a size qualifier such as short, small, long or hyper.
    
    __int8 	8-bit integer. Equivalent to small.
    __int16 	16-bit integer. Equivalent to short.
    __int32 	32-bit integer. Equivalent to long.
    __int3264 	An integer that is 32-bit on 32-bit platforms, and is 64-bit on 64-bit platforms.
    __int64 	64-bit integer. Equivalent to hyper.
    long 	32-bit integer.
    short 	16-bt integer.
    small 	8-bit integer.
    void 	Indicates that the procedure does not return a value.
    void * 	32-bit pointer for context handles only.
    wchar_t 	16-bit predefined type for wide characters.
    
        * singed and unsigned types 
        
        DCE IDL compilers do not recognize the keyword signed. Therefore, this feature is not available when you use the MIDL compiler /osf switch.
        
        Visual C++ development environment, the /J command-line option changes the default sign of char from signed to unsigned.
        
        control the sign of variables of type char and small with the MIDL compiler command-line switch /char. This switch allows you to specify the default sign used by your compiler. 
        
        * other MIDL data types 
        
        MIDL recognizes a number of COM and Automation data types, such as BSTR, VARIANT, and SAFEARRAY, and COM handles, such as HMETAFILE_PICT, HENHMETAFILE, HMETAFILE, HBITMAP, HPALETTE, and HGLOBAL. 
        
    + MIDL Arrays
    + MIDL Type Definitions
    + MIDL Enumerated Types
    + MIDL Structures
    + MIDL Unions
    + MIDL Binding Handles







- importing files and type libraries 

- importing system header files 






    

# MIDL commandline reference 



# MIDL language reference 



# reference microsoft learn 
https://docs.microsoft.com/en-us/



# MIDL language reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-language-reference





# Compiler warning and errors 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-compiler-errors-and-warnings