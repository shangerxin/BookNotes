Master JavaScript Functional Programming - Second Edition=Federico;Note=Erxin


# Theory with practice 

- NW.js (previously known as node-webkit) lets you call all Node.js modules directly from DOM and enables a new way of writing applications with all Web technologies.

- js new tech 

Ionic, Apache Cordova, or React Native or desktop apps that are made with Electron or NW.js

- what is not 

FP isn't just an academic ivory tower thing

FP isn't the opposite of object-oriented programming (OOP)

FP isn't overly complex to learn

- what we need 

modular 

understandable 

testable 

extensible 

reusable code 

- After all, we want to use FP to simplify our coding, not to make it more complex!

- going functional with javascript 

es6, 2015 
es7, 2016 
es8, 2017 
es9, 2018 

http://www.ecma-international.org/

- key features of javascript

Functions as first-class objects
Recursion
Arrow functions
Closures
Spread

- recursion 

function fact(n) {
 if (n === 0) {
 return 1;

 } else {
 return n * fact(n - 1);
 }
}

console.log(fact(5)); // 120

- closures 

function newCounter() {
 let count = 0;
 return function() {
 count++;
 return count;
 };
}

const nc = newCounter();
console.log(nc()); // 1
console.log(nc()); // 2
console.log(nc()); // 3

- arrow functions 

const fact2 = n => {
  if (n === 0) {
    return 1;

  } else {
    return n * fact2(n - 1);
  }
};
console.log(fact2(5)); // also 120

- spread

const x = [1, 2, 3];

function sum3(a, b, c) {
  return a + b + c;
}

const y = sum3(...x); // equivalent to sum3(1,2,3)
console.log(y); // 6

- check out javascript feature matrix 

https://kangax.github.io/compat-table/es6/

http://node.green/

- transpiler 

babel 

typescript 

- working online 

JSFiddle (at https://jsfiddle.net/), CodePen (at https://codepen.io/), and JSBin (at http://jsbin.com/)

- testing 

Jasmine (https://jasmine.github.io/), though we could also opt for Mocha (http://mochajs.org/).

- classes are first-class objects

const makeSaluteClass = term =>
 class {
    constructor(x) {
      this.x = x;
    }

    salute(y) {
      console.log(`${this.x} says "${term}" to ${y}`);
    }
  };

const Spanish = makeSaluteClass("HOLA");
new Spanish("ALFA").salute("BETA");
// ALFA says "HOLA" to BETA

- thinking functionally - a first example. You have developed an e-commerce site; the user can fill their shopping cart, and in the end, they must click on a Bill me button so their credit card will be charged. However, the user shouldn't click twice (or more) or they will be billed several times

    + hoping for the best, add hint and wish the user will not click twice 
    
    + using a global flag 
let clicked = false;
.
.
.
function billTheUser(some, sales, data) {
  if (!clicked) {
    clicked = true;
    window.alert("Billing the user...");
    // actually bill the user
  }
}
    
    + removing the handler. avoid repeated clicks, we might just remove the possibility of clicking altogether. The following code does just that; the first thing that billTheUser() does is remove the onclick handler from the button

function billTheUser(some, sales, data) {
 document.getElementById("billButton").onclick = null;
  window.alert("Billing the user...");
  // actually bill the user
}

solution bind to button hard to reuse 

    + remove the click function, but rather assign a new one instead. We are using functions as first-class objects here when we assign the alreadyBilled() function to the click event. The function warning the user that they have already clicked

    code coupled to the button, needing to reset the handler, and harder testing
    
    + disabling the button
    
    + The first time you call the function, it will do its thing, but it will also change itself out of existence, by giving its name to a new function
    
    + but instead of making it global (which was our main objection), we can use an Immediately Invoked Function Expression (IIFE),
    
var billTheUser = (clicked => {
  return (some, sales, data) => {
    if (!clicked) {
      clicked = true;
      window.alert("Billing the user...");
      // actually bill the user
    }
  };
})(false);

- a functional solution to our problem some principles:

    + The original function (the one that may be called only once) should do whatever it is expected to do and nothing else.
    + We don't want to modify the original function in any way.
    + We need to have a new function that will call the original one only once.
    + We want a general solution that we can apply to any number of original functions.

Uncle Bob (Robert C. Martin, who wrote the five principles) at http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod.

- functional solution - a higher order solution 

Underscore and Lodash already have a similar function, invoked as _.once(). Ramda also provides R.once(), and most FP libraries include similar functionality

```
const once = fn => {
  let done = false;
  return (...args) => {
    if (!done) {
      done = true;
      fn(...args);
    }
  };
};
```

```
<button id="billButton" onclick="once(billTheUser)(some, sales, data)">
  Bill me
</button>;
```

- an even bettter solution 

