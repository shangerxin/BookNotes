Programming Rust,2nd Edition=Jim;Note=Erxin

# Why rust?
- In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.

- Rust, a safe, concurrent language with the performance of C and C++.

- tool, exodus, Exodus is a tool that makes it easy to successfully relocate Linux ELF binaries from one system to another. This is useful in situations where you don't have root access on a machine or where a package simply isn't available for a given Linux distribution. 

https://github.com/intoli/exodus

- basic types 

types                   description                 values 
i8, i16, i32, i64, i128 signed and unsigned integers 
u8, u16, u32, u64, u128

isize, usize            signed and unsigned integers same size as an anddress on the machine(32b or 64b)

f32, f64,               IEEE floating-point numbers

bool                    boolean 

char                    unicode character, 32 bits wide 

(char, u8, i32)         tuple, mixed type allowed 

()                      "unit" (empty tuple)

struct S {x: f32, y:f32} named-field struct        

struct T {i32, char}    tuple like struct 

struct E,               unit-like struct has no fields 

enum Attend {O nTime, Late(u32)}    Enumeration, algebraic data type

Box<Attend>             Box: owning pointer to value in heap 

&i32, &mut i32          shared and mutable references 

String                  UTF-8 string 

&str                    Reference to str 

[f64; 4], [u8; 256]     Array fixed length, all of same type 

Vec<f64>                Vector, varying length all same type 

&[u8], &mut [u8]        Reference to slice

Result<u64, Error>      Result of operation that may fail 

&dyn Any, &mut dyn Read Trait object 

fn(&str) -> bool        Pointer to function 

(Closure type have no written form)    Closure          |a, b|{a*b + b*b}

- machine types 
size(bits)      unsigned integer        signed integer          floating-point
8               u8                      i8                      
16              u16                     i16 
32              u32                     i32                     f32     
64              u64                     i64                     f64 
128             u128                    i128 
machine word    usize                   isize 

- type casts 

assert_eq!(   10_i8  as u16,    10_u16); // in range
assert_eq!( 2525_u16 as i16,  2525_i16); // in range

assert_eq!(   -1_i16 as i32,    -1_i32); // sign-extended
assert_eq!(65535_u16 as i32, 65535_i32); // zero-extended

// Conversions that are out of range for the destination
// produce values that are equivalent to the original modulo 2^N,
// where N is the width of the destination in bits. This
// is sometimes called "truncation".
assert_eq!( 1000_i16 as  u8,   232_u8);
assert_eq!(65535_u32 as i16,    -1_i16);

assert_eq!(   -1_i8  as u8,    255_u8);
assert_eq!(  255_u8  as i8,     -1_i8);

println!("{}", (-4).abs());

- Checked, Wrapping, and Saturating Arithmetic, customize dealing with arithmetic overflow aren’t what you need. 

// The sum of 10 and 20 can be represented as a u8.
assert_eq!(10_u8.checked_add(20), Some(30));

// Unfortunately, the sum of 100 and 200 cannot.
assert_eq!(100_u8.checked_add(200), None);

// Do the addition; panic if it overflows.
let sum = x.checked_add(y).unwrap();

// Oddly, signed division can overflow too, in one particular case.
// A signed n-bit type can represent -2ⁿ⁻¹, but not 2ⁿ⁻¹.
assert_eq!((-128_i8).checked_div(-1), None);

    + prefix 
    operation           suffix      example 
addition 	            add 	100_i8.checked_add(27) == Some(127)
Subtraction 	        sub 	10_u8.checked_sub(11) == None
Multiplication      	mul 	128_u8.saturating_mul(3) == 255
Division 	            div 	64_u16.wrapping_div(8) == 8
Remainder 	            rem 	(-32768_i16).wrapping_rem(-1) == 0
Negation 	            neg 	(-128_i8).checked_neg() == None
Absolute value 	        abs 	(-32768_i16).wrapping_abs() == -32768
Exponentiation 	        pow 	3_u8.checked_pow(4) == Some(81)
Bitwise left shift 	    shl 	10_u32.wrapping_shl(34) == 40
Bitwise right shift 	shr 	40_u64.wrapping_shr(66) == 10

- Rust performs almost no numeric conversions implicitly.

- the bool type 
assert_eq!(false as i32, 0);
assert_eq!(true  as i32, 1);

- characters, a single Unicode character, as a 32-bit value.

- tuples, A tuple is a pair, or triple, or quadruple, ... of values of assorted types

let text = "I see the eigenvalue in thine eye";
let (head, tail) = text.split_at(21);
assert_eq!(head, "I see the eigenvalue ");
assert_eq!(tail, "in thine eye");

- Pointer types 

- References, A value of type &String (pronounced “ref String”) is a reference to a String value, a &i32 is a reference to an i32, and so on.


&T, A shared reference.

&mut T, A mutable reference. You can read and modify the value it points to. Rust uses this dichotomy between shared and mutable references to enforce a “single writer or multiple readers” rule

- Boxes, allocate a value in heap 

let t = (12, "eggs");
let b = Box::new(t);  // allocate a tuple in the heap

- Raw pointers, Rust also has the raw pointer types *mut T and *const T. Raw pointers really are just like pointers in C++. 

 only dereference raw pointers within an unsafe block.
 
- Arrays, Vectors and Slices 

[T; N] represents an array of N values,
 
Vec<T>, called a vector of Ts, is a dynamically allocated, growable sequence of values of type T.
 
The types &[T] and &mut [T], called a shared slice of Ts and mutable slice of Ts, are references to a series of elements that are a part of some other value, like an array or vector. 
 
A mutable slice &mut [T] lets you read and modify elements, but can’t be shared; a shared slice &[T] lets you share access among several readers, but doesn’t let you modify elements.
 
- Arrays 

let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];
let taxonomy = ["Animalia", "Arthropoda", "Insecta"];

assert_eq!(lazy_caterer[3], 7);
assert_eq!(taxonomy.len(), 3);


let mut sieve = [true; 10000];
for i in 2..100 {
    if sieve[i] {
        let mut j = i * i;
        while j < 10000 {
            sieve[j] = false;
            j += i;
        }
    }
}

assert!(sieve[211]);
assert!(!sieve[9876]);

If n is a variable, you can’t write [true; n] to get an array of n elements. 

- Vectors, Vec<T> is a resizable array of elements of type T, allocated on the heap

let mut primes = vec![2, 3, 5, 7];
assert_eq!(primes.iter().product::<i32>(), 210);

- you can use slice methods on vectors 

// A palindrome!
let mut palindrome = vec!["a man", "a plan", "a canal", "panama"];
palindrome.reverse();
// Reasonable yet disappointing:
assert_eq!(palindrome, vec!["panama", "a canal", "a plan", "a man"]);


let mut v = Vec::with_capacity(2);
assert_eq!(v.len(), 0);
assert_eq!(v.capacity(), 2);

v.push(1);
v.push(2);
assert_eq!(v.len(), 2);
assert_eq!(v.capacity(), 2);

v.push(3);
assert_eq!(v.len(), 3);
// Typically prints "capacity is now 4":
println!("capacity is now {}", v.capacity());


let languages: Vec<String> = std::env::args().skip(1).collect();
for l in languages {
    println!("{}: {}", l,
             if l.len() % 2 == 0 {
                 "functional"
             } else {
                 "imperative"
             });
}

- Slices, written [T] without specifying the length, is a region of an array or vector. 

let v: Vec<f64> = vec![0.0,  0.707,  1.0,  0.707];
let a: [f64; 4] =     [0.0, -0.707, -1.0, -0.707];

let sv: &[f64] = &v;
let sa: &[f64] = &a;

Rust automatically converts the &Vec<f64> reference and the &[f64; 4] reference to slice references that point directly to the data

```
fn print(n: &[f64]) {
    for elt in n {
        println!("{}", elt);
    }
}

print(&a);  // works on arrays
print(&v);  // works on vectors
```

- string types 

let speech = "\"Ouch!\" said the well.\n";

span multiple lines 
println!("In the room the women come and go,
    Singing of Mount Abora");
    
a string ends with a backslash, then the newline character and the leading whitespace on the next line are dropped
println!("It was a bright, cold day in April, and \
    there were four of us—\
    more or less.");

- byte strings, prefix with a b, is a slice of u8 values 

let method = b"GET";
assert_eq!(method, &[b'G', b'E', b'T']);

- Strings in memory 

let noodles = "noodles".to_string();
let oodles = &noodles[1..];
let poodles = "ಠ_ಠ";

{stack frame| noodles String, oodles &str, poodles}

{heap| "noodles"}

{preallocated read-only memory|  "ಠ_ಠ" }

A String has a resizable buffer holding UTF-8 text. The buffer is allocated on the heap

- String, &str is very much like &[T]: a fat pointer to some data. String is analogous to Vec<T>:

                                                            Vec<T>  String 
Automatically frees buffers 	                            Yes 	Yes
Growable 	                                                Yes 	Yes
::new() and ::with_capacity() static methods 	            Yes 	Yes
.reserve() and .capacity() methods 	                        Yes 	Yes
.push() and .pop() methods 	                                Yes 	Yes
Range syntax v[start..stop] 	                            Yes, returns &[T] 	Yes, returns &str
Automatic conversion 	                                    &Vec<T> to &[T] 	&String to &str
Inherits methods 	                                        From &[T] 	From &str

each String has its own heap-allocated buffer that isn’t shared with any other String. 

    + create a string 
    1. The .to_string() method converts a &str to a String. 
    
    2. The format!() macro works just like println!(), except that it returns a new String instead of writing text to stdout

    3. Arrays, slices, and vectors of strings have two methods, .concat() and .join(sep), that form a new String
    
- using string 

Strings support the == and != operators. Two strings are equal if they contain the same characters in the same order

Unicode, simple char-by-char comparison does not always give the expected answers. For example, the Rust strings "th\u{e9}" and "the\u{301}" are both valid Unicode representations for thé, the French word for tea.

- other string like types 

Stick to String and &str for Unicode text.

When working with filenames, use std::path::PathBuf and &Path instead.

binary data that isn’t character data at all, use Vec<u8> and &[u8].

environment variable names and command-line arguments in the native form presented by the operating system, use OsString and &OsStr.

interoperating with C libraries that use null-terminated strings, use std::ffi::CString and &CStr. 


# Expression 
- Expressions have values. Statements don’t. Rust is what is called an expression language. This means it follows an older tradition, dating back to Lisp, where expressions do all the work.

In Rust, if and match can produce values. 

```

pixels[r * bounds.0 + c] =
    match escapes(Complex { re: point.0, im: point.1 }, 255) {
        None => 0,
        Some(count) => 255 - count as u8
    };
    
println!("Inside the vat, you see {}.",
    match vat.contents {
        Some(brain) => brain.desc(),
        None => "nothing of interest"
    });
```

```
let status =
    if cpu.temperature <= MAX_TEMP {
        HttpStatus::Ok
    } else {
        HttpStatus::ServerError  // server melted
    };
```

- Most of the control flow tools in C are statements. In Rust, they are all expressions

- blocks and semicolons, Blocks, too, are expressions. A block produces a value

let display_name = match post.author() {
    Some(author) => author.name(),
    None => {
        let network_info = post.get_network_metadata()?;
        let ip = network_info.client_address();
        ip.to_string()
    }
};

- declarations

let name: type = expr;

let name;
if user.has_nickname() {
    name = user.nickname();
} else {
    name = generate_unique_name();
    user.register(&name);
}

for line in file.lines() {
    let line = line?;
    ...
}

    + All blocks of an if expression must produce values of the same type

let suggested_pet =
    if with_wings { Pet::Buzzard } else { Pet::Hyena };  // ok

let favorite_number =
    if user.is_hobbit() { "eleventy-one" } else { 9 };  // error

let best_sports_team =
    if is_hockey_season() { "Predators" };  // error

- if let 

if let pattern = expr {
    block1
} else {
    block2
}

if let Some(cookie) = request.session_cookie {
    return restore_session(cookie);
}

if let Err(err) = present_cheesy_anti_robot_task() {
    log_robot_attempt(err);
    politely_accuse_user_of_being_a_robot();
} else {
    session.mark_as_human();
}

- loops, tehre are four looping expressions 

while condition {
    block
}

while let pattern = expr {
    block
}

loop {
    block
}

for pattern in collection {
    block
}

for i in 0..20 {
    println!("{}", i);
}

The .. operator produces a range, a simple struct with two fields: start and end. 0..20 is the same as std::ops::Range {start:0, end:20}


let strings: Vec<String> = error_messages();
for s in strings {                  // each String is moved into s here...
    println!("{}", s);
}                                   // ...and dropped here
println!("{} error(s)", strings.len()); // error: use of moved value


//remedy is to loop over a reference to the collection instead 
for rs in &strings {
    println!("String {:?} is at address {:p}.", *rs, rs);
}


A break expression exits an enclosing loop. (In Rust, break works only in loops. It is not necessary in match expressions
// Each call to `next_line` returns either `Some(line)`, where
// `line` is a line of input, or `None`, if we've reached the end of
// the input. Return the first line that starts with `"answer: "`
// otherwise, return "answer: nothing".
let answer = loop {
    if let Some(line) = next_line() {
        if line.starts_with("answer: ") {
            break line;
        }
    } else {
        break "answer: nothing";
    }
};


labeled a loop with a lifetime. 
```
'search:
for room in apartment {
    for spot in room.hiding_spots() {
        if spot.contains(keys) {
            println!("Your keys are {} in the {}.", spot, room);
            //Thus break 'search exits that loop, not the inner loop.
            break 'search;
        }
    }
}
```

a break can have both a label and a value expression 
```
// Find the square root of the first perfect square
// in the series.
let sqrt = 'outer: loop {
    let n = next_number();
    for i in 1.. {
        let square = i * i;
        if square == n {
            // Found a square root.
            break 'outer i;
        }
        if square > n {
            // `n` isn't a perfect square, try the next
            break;
        }
    }
};
```

- return expressions 

fn f() {     // return type omitted: defaults to ()
    return;  // return value omitted: defaults to ()
}

let output = File::create(filename)?;


let output = match File::create(filename) {
    Ok(f) => f,
    Err(err) => return Err(err)
};


rust to reject some safe programs 
```
fn wait_for_process(process: &mut Process) -> i32 {
    while true {
        if process.wait() {
            return process.exit_code();
        }
    }
}  // error: mismatched types: expected i32, found ()
```

The ! means that exit() never returns. It’s a divergent function.
```
fn exit(code: i32) -> !

fn serve_forever(socket: ServerSocket, handler: ServerHandler) -> ! {
    socket.listen();
    loop {
        let s = socket.accept();
        handler.handle(s);
    }
}
```

- function and method calls 

```
let x = gcd(1302, 462);  // function call

let room = player.location();  // method call
```

Rust usually makes a sharp distinction between references and the values

player.location(), player might be a Player, a reference of type &Player, or a smart pointer of type Box<Player> or Rc<Player>. The .location() method might take the player either by value or by reference. 

```
let mut numbers = Vec::new();  // static method call
```

< is the less-than operator. The Rust compiler helpfully suggests writing ::<T> instead of <T> in this case

```
return Vec::<i32>::with_capacity(1000);  // ok, using ::<

let ramp = (0 .. n).collect::<Vec<i32>>();  // ok, using ::<
```

symbol ::<...> is affectionately known in the Rust community as the turbofish.

```
return Vec::with_capacity(10);  // ok, if the fn return type is Vec<i32>

let ramp: Vec<i32> = (0 .. n).collect();  // ok, variable's type is given
```

- Fields and elements 

```
game.black_pawns   // struct field
coords.1           // tuple element

pieces[i]          // array element
```

extract a slice 
```
let second_half = &game_moves[midpoint .. end];
```

```
The .. operator allows either operand to be omitted;

..      // RangeFull
a ..    // RangeFrom { start: a }
.. b    // RangeTo { end: b }
a .. b  // Range { start: a, end: b }

```
0 .. 3 includes the numbers 0, 1, and 2.


..= operator produces closed ranges
0 ..= 3 includes the numbers 0, 1, 2, and 3
```
..= b    // RangeToInclusive { end: b }
a ..= b  // RangeInclusive::new(a, b)
```

- example quick sort 

```
fn quicksort<T: Ord>(slice: &mut [T]) {
    if slice.len() <= 1 {
        return;  // Nothing to sort.
    }

    // Partition the slice into two parts, front and back.
    let pivot_index = partition(slice);

    // Recursively sort the front half of `slice`.
    quicksort(&mut slice[.. pivot_index]);

    // And the back half.
    quicksort(&mut slice[pivot_index + 1 ..]);
}
```

- reference operators, address-of operators, & and &mut, are covered in XREF HERE

unary * operator is used to access the value pointed to by a reference.

Rust automatically follows references when you use the . operator to access a field or method

type of elem is &u64, so *elem is a u64.
```
let padovan: Vec<u64> = compute_padovan_sequence(n);
for elem in &padovan {
    draw_triangle(turtle, *elem);
}
```

- arithmetic, bitwise, comparison, and logical operators 

arithmetic operators, +, -, *, /, and %. As mentioned 

println!("{}", -100);     // -100
println!("{}", -100u32);  // error: can't apply unary `-` to type `u32`
println!("{}", +100);     // error: expected expression, found `+`

C, a % b computes the remainder, or modulus, of division
let x = 1234.567 % 10.0;  // approximately 4.567

&, |, ^, <<, and >>. However, Rust uses ! instead of ~ for bitwise NOT
let hi: u8 = 0xe0;
let lo = !hi;  // 0x1f

Rust has unsigned integers, it does not need Java’s >>> operator.

Bitwise operations have higher precedence than comparisons, unlike C

comparison operators are ==, !=, <, <=, >, and >=. The two values being compared must have the same type

- assignment, =

XREF HERE, if the value has a non-Copy type, assignment moves it into the destination. 

total += item.price;

can’t write a = b = 3 to assign the value 3 to both a and b

- type casts 

let x = 17; 
let index = x as usize; 

Values of type bool, char, or of a C-like enum type, may be cast to any integer type.

casting a large floating-point value to an integer type that is too small to represent it can lead to undefined behavior. This can cause crashes even in safe Rus

Some casts involving unsafe pointer types are also allowe

    + automatic convert, deref coercions, because they apply to types that implement the Deref built-in trait. The purpose of Deref coercion is to make smart pointer types, like Box,

Values of type &String auto-convert to type &str without a cast.

Values of type &Vec<i32> auto-convert to &[i32].

Values of type &Box<Chessboard> auto-convert to &Chessboard.

- closures, closure usually consists of an argument list, given between vertical bars

let is_even = |x| x % 2 == 0;

let is_even = |x: u64| -> bool x % 2 == 0;  // error

let is_even = |x: u64| -> bool { x % 2 == 0 };  // ok

    + call closure is as same as a function 

assert_eq!(is_even(14), true);

- precedence and associativity   

Expressions type                        Example                                 Related traits  

Array literal 	                        [1, 2, 3]
Repeat array literal 	                [0; 50]
Tuple 	                                (6, "crullers")
Grouping 	                            (2 + 2)
Block 	                                { f(); g() }
Control flow expressions 	            if ok { f() }
                                        if ok { 1 } else { 0 }
                                        if let Some(x) = f() { x } else { 0 }
                                        match x { None => 0, _ => 1 }
                                        for v in e { f(v); } 	                std::iter::IntoIterator
                                        while ok { ok = f(); }
                                        while let Some(x) = it.next() { f(x); }
                                        loop { next_event(); }
                                        break
                                        continue
                                        return 0
Macro invocation 	                    println!("ok")
Path 	                                std::f64::consts::PI
Struct literal 	                        Point {x: 0, y: 0}
Tuple field access 	                    pair.0 	                                Deref, DerefMut
Struct field access 	                point.x 	                            Deref, DerefMut
Method call 	                        point.translate(50, 50) 	            Deref, DerefMut
Function call 	                        stdin() 	                            Fn(Arg0, ...) -> T,
                                                                                FnMut(Arg0, ...) -> T,
                                                                                FnOnce(Arg0, ...) -> T
Index 	                                arr[0] 	                                Index, IndexMut
                                                                                Deref, DerefMut
Error check 	                        create_dir("tmp")?
Logical/bitwise NOT 	                !ok 	                                Not
Negation 	                            -num 	                                Neg
Dereference 	                        *ptr 	                                Deref, DerefMut
Borrow 	                                &val
Type cast 	                            x as u32
Multiplication 	                        n * 2 	                                Mul
Division 	                            n / 2 	                                Div
Remainder (modulus) 	                n % 2 	                                Rem
Addition 	                            n + 1 	                                Add
Subtraction 	                        n - 1 	                                Sub
Left shift 	                            n << 1 	                                Shl
Right shift 	                        n >> 1 	                                Shr
Bitwise AND 	                        n & 1 	                                BitAnd
Bitwise exclusive OR 	                n ^ 1 	                                BitXor
Bitwise OR 	                            n | 1 	                                BitOr
Less than 	                            n < 1 	                                std::cmp::PartialOrd
Less than or equal 	                    n <= 1 	                                std::cmp::PartialOrd
Greater than 	                        n > 1 	                                std::cmp::PartialOrd
Greater than or equal 	                n >= 1 	                                std::cmp::PartialOrd
Equal 	                                n == 1 	                                std::cmp::PartialEq
Not equal 	                            n != 1 	                                std::cmp::PartialEq
Logical AND 	                        x.ok && y.ok
Logical OR 	                            x.ok || backup.ok
Range 	                                start .. stop
Assignment 	                            x = val
Compound assignment 	                x *= 1 	                                MulAssign
                                        x /= 1 	                                DivAssign
                                        x %= 1 	                                RemAssign
                                        x += 1 	                                AddAssign
                                        x -= 1 	                                SubAssign
                                        x <<= 1 	                            ShlAssign
                                        x >>= 1 	                            ShrAssign
                                        x &= 1 	                                BitAndAssign
                                        x ^= 1 	                                BitXorAssign
                                        x |= 1 	                                BitOrAssign
Closure 	                            |x, y| x + y

- Onward, Expressions are what we think of as “running code.” 


# Error handling 
- Panic is for the other kind of error, the kind that should never happen

    Out-of-bounds array access

    Integer division by zero

    Calling .expect() on a Result that happens to be Err

    Assertion failure

    macro panic!(), for cases where your own code discovers that it has gone wrong

- unwinding,  Rust unwinds the stack when panic happened. But the rest of the process can continue running.

Panic is per thread. One thread can be panicking while other threads are going on about their normal business

- aborting, If a .drop() method triggers a second panic while Rust is still trying to clean up after the first, this is considered fatal. Rust stops unwinding and aborts the whole process.

 compile with -C panic=abort, the first panic in your program immediately aborts the process. 

- result,  defines Result and how you can define your own similar types.

- catching errors 

match get_weather(hometown) {
    Ok(report) => {
        display_weather(hometown, &report);
    }
    Err(err) => {
        println!("error querying the weather: {}", err);
        schedule_weather_retry();
    }
}

result.is_ok() and result.is_err() return a bool telling if result is a success result or an error result.

result.ok() returns the success value, if any, as an Option<T>. If result is a success result, this returns Some(success_value); otherwise, it returns None, discarding the error value.

result.err() returns the error value, if any, as an Option<E>.

result.unwrap_or(fallback) returns the success value, if result is a success result

result.unwrap_or_else(fallback_fn) is the same, but instead of passing a fallback value directly

result.unwrap() also returns the success value

result.expect(message) is the same as .unwrap(), but lets you provide a message that it prints in case of panic.

    + borrowing references to the value in a Result 
result.as_ref() converts a Result<T, E> to a Result<&T, &E>, borrowing a reference to the success or error value in the existing result.

result.as_mut() is the same, but borrows a mutable reference. The return type is Result<&mut T, &mut E>.

- result type aliases 

fn remove_file(path: &Path) -> Result<()>

err.to_string() returns an error message as a String.

- propagating errors 

- ignoring error 

 idiom let _ = ... is used to silence this warning:

- handling error in main 
.expect() method panics. Panicking in the main thread prints an error message

- declaring a custom error type 

#[derive(Debug, Clone)]
pub struct JsonError {
    pub message: String,
    pub line: usize,
    pub column: usize,
}


# Crates and modules 
- Rust programs are made of crates. cohesive unit: all the source code for a single library or executable, plus any associated tests, examples, tools, configuration, and other junk.

    + use cargo build with the --verbose flag to build an existing project

$ cd <project>
$ cargo clean 
$ cargo build 

specified in our Cargo.toml file which version of each crate

- build profiles 
cargo build 	            [profile.dev]
cargo build --release 	    [profile.release]
cargo test 	                [profile.test]

- modules, rust's namespace, containers for the functions, types, constants, and so on that make up your Rust program or library

mod spores {
    use crate::cells::{Cell, Gene};

    /// A cell made by an adult fern. It disperses on the wind as part of
    /// the fern life cycle. A spore grows into a prothallus -- a whole
    /// separate organism, up to 5mm across -- which produces the zygote
    /// that grows into a new fern. (Plant sex is complicated.)
    pub struct Spore {
        ...
    }

    /// Simulate the production of a spore by meiosis.
    pub fn produce_spore(factory: &mut Sporangium) -> Spore {
        ...
    }

    /// Extract the genes in a particular spore.
    pub(crate) fn genes(&self) -> Vec<Gene> {
        ...
    }

    /// Mix genes to prepare for meiosis (part of interphase).
    fn recombine(parent: &mut Cell) {
        ...
    }

    ...
}

- modules in separate files 

mod spores;

// spores.rs

/// A cell made by an adult fern...
pub struct Spore {
    ...
}

/// Simulate the production of a spore by meiosis.
pub fn produce_spore(factory: &mut Sporangium) -> Spore {
    ...
}

/// Extract the genes in a particular spore.
pub(crate) fn genes(&self) -> Vec<Gene> {
    ...
}

/// Mix genes to prepare for meiosis (part of interphase).
fn recombine(parent: &mut Cell) {
    ...
}

    + file structures 
fern_sim/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── spores.rs
    └── plant_structures/
        ├── mod.rs
        ├── leaves.rs
        ├── roots.rs
        └── stems.rs

- The standard prelude contains a few dozen commonly used traits and types.

There are no mut constants. Statics can be marked mut, but as discussed in XREF HERE, Rust has no way to enforce its rules about exclusive access on mut statics. They are, therefore, inherently non-thread-safe

    + imports, use use delcarations 
    
// in plant_structures/mod.rs
...
pub use self::leaves::Leaf;
pub use self::roots::Root;

- turning a program into a library 

factor your existing project into two parts: a library crate, which contains all the shared code, and an executable

    1. Rename the file src/main.rs to src/lib.rs.

    2. Add the pub keyword to items in src/lib.rs that will be public features of our library.

    3. Move the main function to a temporary file somewhere. We’ll come back to it in a minute.


$ cargo build --verbose
$ cargo run --bin efern --verbose

- attributes, in a Rust program can be decorated with attributes. Attributes are Rust’s catch-all syntax for writing miscellaneous instructions. 

#[allow(non_camel_case_types)]
pub struct git_revspec {
    ...
}

an attribute, the #[cfg] attribute:
// Only include this module in the project if we're building for Android.
#[cfg(target_os = "android")]
mod mobile;

- tests and documentation 

#[test]
fn math_works() {
    let x: i32 = 1;
    assert!(x.is_positive());
    assert_eq!(x + 1, 2);
}

    + runstest 
$ cargo test

assert! and assert_eq! macros from the Rust standard library. 

- Integration tests are .rs files that live in a tests directory alongside your project’s src directory. 

- Documentation 
$ cargo doc --no-deps --open

    + comments starting with //! are treated as #![doc] attributes, and are attached to the enclosing feature, typically a module or crate.

//! Simulate the growth of ferns, from the level of
//! individual cells on up.

/// A block of code in a doc comment:
///
///     if everything().works() {
///         println!("ok");
///     }

    + doc-test. Create a new project by running cargo new --lib ranges

use std::ops::Range;

/// Return true if two ranges overlap.
///
///     assert_eq!(ranges::overlap(0..7, 3..10), true);
///     assert_eq!(ranges::overlap(1..5, 101..105), false);
///
/// If either range is empty, they don't count as overlapping.
///
///     assert_eq!(ranges::overlap(0..0, 0..10), false);
///
pub fn overlap(r1: Range<usize>, r2: Range<usize>) -> bool {
    r1.start < r1.end && r2.start < r2.end &&
        r1.start < r2.end && r2.start < r1.end
}

/// Let the sun shine in and run the simulation for a given
/// amount of time.
///
///     # use fern_sim::Terrarium;
///     # use std::time::Duration;
///     # let mut tm = Terrarium::new();
///     tm.apply_sunlight(Duration::from_secs(60));
///
pub fn apply_sunlight(&mut self, time: Duration) {
    ...
}

    +  Rust to compile your example, but stop short of actually running it, use a fenced code block with the no_run annotation:
/// Upload all local terrariums to the online gallery.
///
/// ```no_run
/// let mut session = fern_sim::connect();
/// session.upload_all();
/// ```
pub fn upload_all(&mut self) {
    ...
}

- specifying dependencies 

image = { git = "https://github.com/Piston/image.git", rev = "528f19c" }

Cargo.toml file. Your next cargo build will seamlessly use your fork of the crate instead of the official version.

- versions 

http://doc.crates.io/crates-io.html

- cargo.lock, Cargo.toml are deliberately flexible, yet we don’t want Cargo to upgrade us to the latest library versions every time we build

Cargo.lock is automatically generated for you, and you normally won’t edit it by hand. 

- publishing crates to crates.io

$ cargo package

building your library from the .crate file, just as your eventual users will.


Cargo.toml:

[package]
name = "fern_sim"
version = "0.1.0"
edition = "2018"
authors = ["You <you@example.com>"]
license = "MIT"
homepage = "https://fernsim.example.com/"
repository = "https://gitlair.com/sporeador/fern_sim"
documentation = "http://fernsim.example.com/docs"
description = """
Fern simulation, from the cellular level up.
"""

get api key from crates.io and run the login command 

$ cargo login 5j0dV54BjlXBpUUbfIj7G9DvNl1vsWW1
$ cargo publish

- workspace 

fernsoft/
├── .git/...
├── fern_sim/
│   ├── Cargo.toml
│   ├── Cargo.lock
│   ├── src/...
│   └── target/...
├── fern_img/
│   ├── Cargo.toml
│   ├── Cargo.lock
│   ├── src/...
│   └── target/...
└── fern_video/
    ├── Cargo.toml
    ├── Cargo.lock
    ├── src/...
    └── target/...
    
Crago.toml file contain 
[workspace]
members = ["fern_sim", "fern_img", "fern_video"]


# Structs 
- ask Rust to generate implementations of common handy traits for your structs

- named-field structs 

/// A rectangle of eight-bit grayscale pixels.
struct GrayscaleMap {
    pixels: Vec<u8>,
    size: (usize, usize)
}

    + struct expression 
let width = 1024;
let height = 576;
let image = GrayscaleMap {
    pixels: vec![0; width * height],
    size: (width, height)
};

    + access struct's fields 
assert_eq!(image.size, (1024, 576));
assert_eq!(image.pixels.len(), 1024 * 576);

    + make a struct visible outside its module by previxing its defined with pub 
    
/// A rectangle of eight-bit grayscale pixels.
pub struct GrayscaleMap {
    pub pixels: Vec<u8>,
    pub size: (usize, usize)
}

    + define private fields without pub keyword 
/// A rectangle of eight-bit grayscale pixels.
pub struct GrayscaleMap {
    pixels: Vec<u8>,
    size: (usize, usize)
}

    + example to use a struct 
    
// In this game, brooms are monsters. You'll see.
struct Broom {
    name: String,
    height: u32,
    health: u32,
    position: (f32, f32, f32),
    intent: BroomIntent
}

/// Two possible alternatives for what a `Broom` could be working on.
#[derive(Copy, Clone)]
enum BroomIntent { FetchWater, DumpWater }
    
// Receive the input Broom by value, taking ownership.
fn chop(b: Broom) -> (Broom, Broom) {
    // Initialize `broom1` mostly from `b`, changing only `height`. Since
    // `String` is not `Copy`, `broom1` takes ownership of `b`'s name.
    let mut broom1 = Broom { height: b.height / 2, .. b };

    // Initialize `broom2` mostly from `broom1`. Since `String` is not
    // `Copy`, we must clone `name` explicitly.
    let mut broom2 = Broom { name: broom1.name.clone(), .. broom1 };

    // Give each fragment a distinct name.
    broom1.name.push_str(" I");
    broom2.name.push_str(" II");

    (broom1, broom2)
}
    
let hokey = Broom {
    name: "Hokey".to_string(),
    height: 60,
    health: 100,
    position: (100.0, 200.0, 0.0),
    intent: BroomIntent::FetchWater
};

let (hokey1, hokey2) = chop(hokey);
assert_eq!(hokey1.name, "Hokey I");
assert_eq!(hokey1.health, 100);

assert_eq!(hokey2.name, "Hokey II");
assert_eq!(hokey2.health, 100);

- tuple-like structs 

struct Bounds(usize, usize);

let image_bounds = Bounds(1024, 768);

assert_eq!(image_bounds.0 * image_bounds.1, 786432);

pub struct Bounds(pub usize, pub usize);

fn Bounds(elem0: usize, elem1: usize) -> Bounds { ... }

    + tuple like struct are good for define new types 
    
struct Ascii(Vec<u8>);

much better than simply passing around Vec<u8> buffers and explaining what they are in the comments.

- unit-like structs 

struct Onesuch;

You’ve already encountered a unit-like struct when reading about the .. range operator

- struct layout 

struct GrayscaleMap {
    pixels: Vec<u8>,
    size: (usize, usize)
}

Unlike C and C++, Rust doesn’t make specific promises about how it will order a struct’s fields or elements in memory; this diagram shows only one possible arrangement. However, Rust does promise to store fields’ values directly in the struct’s block of memory.

- defining methods with impl 


/// A first-in, first-out queue of characters.
pub struct Queue {
    older: Vec<char>,   // older elements, eldest last.
    younger: Vec<char>  // younger elements, youngest last.
}

impl Queue {
    /// Push a character onto the back of a queue.
    pub fn push(&mut self, c: char) {
        self.younger.push(c);
    }

    /// Pop a character off the front of a queue. Return `Some(c)` if there
    /// was a character to pop, or `None` if the queue was empty.
    pub fn pop(&mut self) -> Option<char> {
        if self.older.is_empty() {
            if self.younger.is_empty() {
                return None;
            }

            // Bring the elements in younger over to older, and put them in
            // the promised order.
            use std::mem::swap;
            swap(&mut self.older, &mut self.younger);
            self.older.reverse();
        }

        // Now older is guaranteed to have something. Vec's pop method
        // already returns an Option, so we're set.
        self.older.pop()
    }
}

An impl block is simply a collection of fn definitions, each of which becomes a method on the struct type named at the top of the block

```
let mut q = Queue { older: Vec::new(), younger: Vec::new() };

q.push('0');
q.push('1');
assert_eq!(q.pop(), Some('0'));

q.push('∞');
assert_eq!(q.pop(), Some('1'));
assert_eq!(q.pop(), Some('∞'));
assert_eq!(q.pop(), None);
```

since split takes its self by value, this moves the Queue out of q, leaving q uninitialized

- passing self as a box, rc or arc. method’s self argument can also be a Box<Self>, Rc<Self>, or Arc<Self>

use std::rc::Rc;

struct Node {
    tag: String,
    children: Vec<Rc<Node>>
}

impl Node {
    fn new(tag: &str) -> Node {
        Node {
            tag: tag.to_string(),
            children: vec![],
        }
    }
}

- static methods, don't take self argument  

impl Queue {
    pub fn new() -> Queue {
        Queue { older: Vec::new(), younger: Vec::new() }
    }
}

let mut q = Queue::new();

q.push('*');
...

- generic structs, Queue is unsatisfying: it is written to store characters, but there’s nothing about its structure or methods that is specific to characters

pub struct Queue<T> {
    older: Vec<T>,
    younger: Vec<T>
}

impl<T> Queue<T> {
    pub fn new() -> Queue<T> {
        Queue { older: Vec::new(), younger: Vec::new() }
    }

    pub fn push(&mut self, t: T) {
        self.younger.push(t);
    }

    pub fn is_empty(&self) -> bool {
        self.older.is_empty() && self.younger.is_empty()
    }

    ...
}

- structs with lifetime parameters, lifetime 'elt, you can make an Extrema<'elt> that holds references with that lifetime.

struct Extrema<'elt> {
    greatest: &'elt i32,
    least: &'elt i32
}

fn find_extrema<'s>(slice: &'s [i32]) -> Extrema<'s> {
    let mut greatest = &slice[0];
    let mut least = &slice[0];

    for i in 1..slice.len() {
        if slice[i] < *least    { least    = &slice[i]; }
        if slice[i] > *greatest { greatest = &slice[i]; }
    }
    Extrema { greatest, least }
}

let a = [0, -3, 0, 15, 48];
let e = find_extrema(&a);
assert_eq!(*e.least, -3);
assert_eq!(*e.greatest, 48);

fn find_extrema(slice: &[i32]) -> Extrema {
    ...
}

- deriving common traits for struct types 
struct Point {
    x: f64,
    y: f64
}


// in Rust—Copy, Clone, Debug, and PartialEq. They are called traits. In XREF HERE, we’ll show how to implement traits by hand for your own structs.

#[derive(Copy, Clone, Debug, PartialEq)]
struct Point {
    x: f64,
    y: f64
}

- interior mutability 

pub struct SpiderRobot {
    species: String,
    web_enabled: bool,
    leg_devices: [fd::FileDesc; 8],
    ...
}


use std::rc::Rc;

pub struct SpiderSenses {
    robot: Rc<SpiderRobot>,  // <-- pointer to settings and I/O
    eyes: [Camera; 32],
    motion: Accelerometer,
    ...
}


impl SpiderRobot {
    /// Increase the error count by 1.
    pub fn add_hardware_error(&self) {
        let n = self.hardware_error_count.get();
        self.hardware_error_count.set(n + 1);
    }

    /// True if any hardware errors have been reported.
    pub fn has_hardware_errors(&self) -> bool {
        self.hardware_error_count.get() > 0
    }
}

let ref_cell: RefCell<String> = RefCell::new("hello".to_string());

let r = ref_cell.borrow();      // ok, returns a Ref<String>
let count = r.len();            // ok, returns "hello".len()
assert_eq!(count, 5);

let mut w = ref_cell.borrow_mut();  // panic: already borrowed
w.push_str(" world");


# Enums and Patterns 



