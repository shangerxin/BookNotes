Mastering Reverse Engineering=Reginald;Note=Erxin

# Introduction
- a good report answers questions 

how a reversed engineered object works 

when specific behavior triggers 

why specific code used in the program 

where it was intended to work on 

what the whole program does 

- tools 

binary analysis tools, 

disassemblers, 

decompilers, 

debuggers, 

monitoring tools.

- binary analysis tools 

Microsoft executable file, an EXE file, begin with the MZ header, first four bytes 

D0 CF 11 E0

- disassemblers, view the low level code of a program 

Application Program Interface (API) functions. The following screenshot shows a code snippet of a program module that uses the GetJob() 
 
.text: 10001010 ; int __cdecl GetPageCount(HANDLE hPrinter, DOWRD JobId)
.text: 10001010                 public GetPageCount
.text: 10001010 GetPageCount    proc near 
.text: 10001010
.text: 10001010 var_C           = dword ptr -0Ch 
.text: 10001010 pcbNeeded       = dword ptr -8
...
.text: 10001035                 push eax        ;hPrinter
.text: 10001036                 mov [ebp+pcbNeeded], 0 
.text: 1000103D                 call ds:GetJob
.text: 10001043                 mov  esi, [ebp+pcbNeeded]
...

- debugger, monitor, decompiler, malware handling    

- basic analysis laptop setup

The sandbox environment here is where we do analysis of a file. MITM, mentioned on the right of the diagram, means the man in the middle 

sandbox ---> MITM ----> Internet 

store images or re-image disks would be the best solution for us here. These programs include Fog, Clonezilla, DeepFreeze, and HDClone

- download windows virtual machine 

https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/

- samples 

Dev C++ (http://www.bloodshed.net/
Visual Studio C++ (https://www.visualstudio.com/downloads/)
MASM32 (http://www.masm32.com/)

    + malware 
    
https://github.com/PacktPublishing/Mastering-Reverse-Engineering
https://github.com/ytisf/theZoo


# Identification and extraction of hidden components 
- discuss 
    1. malware delivery 
    2. malware persistence 
    3. malware playload 
- Persistence is when malware consistently runs in the background

- SysInternals suite (https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)

- Microsoft introduced the registry system, which is actually stored in protected files called registry hives.

- filesystems, different disk filesystems such as FAT, NTFS, ex2, ex3, XFS, and APFS

- MacOS X versions, file information and data are stored in resource forks. Resource forks are actually deprecated but backward compatibility still exists on recent versions of MacOS. A file has two forks stored in the filesystem, the data fork and the resource fork.

simple copy mac application to window and then copy back will not work

- memory 
- registry system will store data like:
    + associated programs that execute expecific files 
    + aossiciate icons 
    + software settings 
    + user and group profiles 
    + printer setup 
    + designated drivers for specific services 
    
- typical malware behavior
    + directly change the system 
    + persistence 
    Any entries made under the registry key HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\
Windows\CurrentVersion\Run are expected to run every time Windows starts.

    + run keys when window starts 
    
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\N\RunServicesOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Windows\CurrentVersion\Run

    + run keys when current user login 
    
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnceEx
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows\Run

    + other run keys, The malware may still persist if it keeps on placing its own file path under the RunOnce, RunOnceEx or RunServicesOnce keys. 

    + load run values 
    boot execute value 
    winlogon key 
    policy scripts keys 
    AppInit_Dlls values 
    Servies keys 
    File associations, HKEY_CLASSES_ROOT or in HKEY_LOCAL_MACHINE\SOFTWARE\Classes\[File type or extension name]\shell\open\command . For example, the (Default) value is set to malware.exe "%1" %*.  As a result, malware.exe runs and uses %1

    + start up values,  %APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup
    ...
        
    + image file execution options keys 
    HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\[Process Name]
    ...

- malware delivery 
    + instant message apps 
    + computer network 
    LAN (Local Area Network) or WAN (Wide Area Network), file sharing protocols are also open for attackers to abuse. 
    + media storage 

    it generates an autorun.inf file that points to the dropped executable file, as can be seen in the following example
    
    + exploits and compromised websites 
    
    download malware that can give the attacker more access. This concept was used to develop exploit kits
    
    User -[access sites with malicious] -> compromised sites can be a series of redirected landing pages -[exploit kit gate scans for vulnerabilities of the Users] -> User  
    
    
- malware usually create drop files at 

The Windows System folder: C:\Windows\System32
The Windows folder:  C:\Windows
The user profile folder:   C:\Users\[username]
The Appdata folder:  C:\Users\[username]\AppData\Roaming
The recycle bin folder:  C:\$Recycle.Bin
The desktop folder: C:\Users\[username]\Desktop
The temporary folder:  C:\Users\[username]\AppData\Local\Temp

- malware payloads

encrypting files for ransom 

deleting all files 
..
    
- tools 
regedit/regedit32 to search registry 

taskmgr to list process 

explorer or cmd to traverse directory 

Autoruns

Process explorer to check process information 
    
- further reading 

https://medium.com/@johnpaticklita/cryptomalware-spreads-on-facebook-79a299590116
    
https://msdn.microsoft.com/en-us/library/windows/desktop/ms724871(v=vs.85).aspx
    

# The low level language 
- turn assembly language back to source, this is called versing 

binary numbers, bases, ascii table 

x86 architecture 

assembly language instructions 

tools used to edit and compile an assembly language source code 

debugging 

exceptions and error handling 

window APIs 

high level constructs 
    
- binary editors, HxD Editor or HIEW (Hacker's View)
    
https://mh-nexus.de/en/hxd/

- binary numbers, 

- bases, base-10, base-2, etc

- printable characters 

Lists of printable characters that can be typed on the keyboard and some of the extended characters with keyboard format can be found at https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3.
    
- binary operation, add, subtraction, multiplication, division 

- signed numbers 

a negative binary number, the most significant bit is set to 1. However, the value set from 0 to the 7th bit is then calculated for a two's complement value
    
01011011b = +91
11011011b = -37
10100101b = -91
00100101b = +37
    
- x86, registers 
    
General purpose registers
Segment registers
Flag registers
Instruction pointers
    
    + General purpose 
Accumulator (AX)
Counter (CX)
Data (DX)
Base (BX)
Stack pointer (SP)
Base pointer (BP)
Source index (SI)
Destination index (DI)

    + flags, Every bit of the FLAGS register has its own purpose
    
0	CF	Carry flag. This flag is set when an addition operation requires a bit to be carried. It is also set when a bit needs to be borrowed in a subtraction operation.
1		Reserved
2	PF	Parity flag. This flag indicates if the number of set bits is odd or even from the last instruction operation.
3		Reserved
4	AF	Adjust flag. This is used in Binary-Coded Decimals (BCD). This flag is set when a carry happens from the low to high nibble or when a borrow happens from the high to low nibble of a byte.
6	ZF	Zero flag. This flag is set when the result of the last instruction operation is zero.
7	SF	Sign flag. This flag is set when the result of the last instruction operation is a negative number.
8	TF	Trap flag. This is used when debugging. This flag is set when breakpoints are encountered. Setting the trap flag can cause an exception on every instruction, enabling debugging tools to control step-by-step debugging.
9	IF	Interrupt flag. If this flag is set, the processor responds to interrupts. Interrupts are instances where errors, external events, or exceptions are triggered from hardware or software. 
10	DF	Direction flag. When set, data is read from memory backwards.
11	OF	Overflow flag. It is set if an arithmetic operation results in a value larger than what the register can contain.
12 to 13	IOPL	Input/output privilege level. The IOPL shows the ability of the program to access IO ports.
14	NT	Nested task flag. This controls the chaining of interrupt tasks or processes. If set, then it is linked to the chain.
15		Reserved
16	RF	Resume flag. It temporarily disables debug exceptions so the next instruction being debugged can be interrupted without a debug exception.
17	VM	Virtual mode. Sets the program to run in compatibility with 8086 processors.
18	AC	Alignment check. This flag is set when data written on a memory reference, such as the stack, is a non-word (for 4 byte boundaries) or non-doubleword (for 8 byte boundaries). However, this flag was more useful before the 486-architecture days.
19	VIF	Virtual interrupt flag. Similar to the interrupt flag, but works when in virtual mode.
20	VIP	Virtual interrupt pending flag. Indicates that triggered interrupts are waiting to be processed. Works in Virtual mode.
21	ID	Identification flag. Indicates if the CPUID instruction can be used. The CPUID can determine the type of processor and other processor info.
22		Reserved
23 to 31		Reserved
32 to 63		Reserved
    
    + The segment registers are used to identify the starting location of these sections, as follows:

Stack segment (SS)
Code segment (CS)
Data segment (DS)
Extra segment (ES)
F segment (FS)
G segment (GS)

RAX, EAX, AX, AH, AL 

- memory addressing
    + Endianness
    
        BYTE, WORD, DWORD, or even QWORD. Depending on the platform or program, data is read in little-endian or big-endian form.

    
        * In little-endian ahead to write into memory, a chunk of data read into a DWORD is reversed. Let's take the following piece of data as an example, read as DDCCBBAAh
        
        32 bit data:
        AA BB CC DD
        
        to memory little-endian:
        DDCCBBAA
        
        read sequence in little-endian:
        DDCCBBAAh 
        
        When read as BYTE, it will be AAh. When read as a WORD, it will be AAh. When read as a DWORD, it will be AAh.

        * in big endian, when read as a BYTE
        
        to memory big-endian:
        AA BB CC DD
        
        read sequence:
        AABBCCDDh
        
    + In x86 assembly, the little-endian format is the standard.    
        
- basic instructions, assembly language is made up of direct lines of code that follow syntax:

label/address mnemonic operands                 ;comments 
00A92DF9      move     eax, dword ptr[0AD4194]  ;moves the dword value at 0AD4194 to EAX 

A mnemonic is a human readable instruction, such as MOV, ADD and SUB.
        
- opcode bytes, operation code byte 

Address     Opcode          Instructions
00A92D7C    B8 00000080     MOV EAX,80000000h
00A92D81    B9 02000000     MOV ECX,2
00A92D86    F7E1            MUL ECX
        
MOV instruction is equivalent to the B8 opcode byte        

MOV EAX, 80000000h. It consists of the opcode byte, B8, and the operand value, 80000000h. The same number of bytes is also used in MOV ECX, 2, and MUL ECX uses 2 bytes        
        
The MOV instruction at the 00A92D81 address is equivalent to B9. The difference between the two MOV instructions is the register into which the DWORD value is moved. There are a total of 5 bytes consumed in MOV EAX, 80000000h.
        
- assembly language instructions can be categorized as follows 

Copying and accessing data instructions (for example, MOV, LEA, and MOVB)

Arithmetic instructions (for example, ADD, SUB, MUL, and DIV)

Binary logic instructions (for example, XOR, NOT, SHR, and ROL)

Flow control (for example, JMP, CALL, CMP, and INT)
        
- MOV is used to read the value at a given address, while LEA (Load Effective Address) is used to get the address instead

; using MUL and ADD to set address to eax 
mov ecx, 1111h
mov ebx, 2222h
mov eax, 2              ; eax = 2
mul ecx                 ; eax = 2222h
add eax, ebx            ; eax = 4444h
add eax, 1              ; eax = 4445h

; using LEA to set address to eax 
mov ecx, 1111h
mov ebx, 2222h
lea eax, [ecx*2+ebx+1]  ; eax = 4445h
        
- addition and subtraction 
        
mov ecx, 0x80000000
mov ebx, 0x80000000
add ecx, ebx
        
mov ecx, 0x7fffffff
mov edx, 0x80000000
sub ecx, edx
    
- increment and decrement 

inc eax 
dec eax 
        
- multiplication and division, Hence the product is stored in AX, DX:AX or EDX:EAX (long or QWORD)

mov eax, 0x80000000
mov ecx, 2
mul ecx
        
product stored in eax is zero (0), and edx now contains 0x00000001. SF =0; CF = 1; and OF = 1.
        
dividend is placed in AX, DX:AX, or EDX:EAX, and after the division operation, the quotient is placed in AL, AX, or EAX. The remainder is stored in AH, DX, or EDX.
        
- other signed operations 

NEG EAX or NEG dword ptr [00403000]. If EAX were 01h, it becomes FFFFFFFFh (-1).
        
MOVSX, moves a BYTE to WORD or WORD to DWORD, including the sign. It is a more flexible instruction than CBW, CWDE, CWD

CBW, Similar to MOVSX, it converts a BYTE into WORD, including the sign. The affected register is AL and AX. 

CWDE, converts a WORD into DWORD. It affects AX->EAX.

CWD, converts a WORD into DWORD. It affects AX-> DX:AX.

IMUL/IDIV, performs MUL and DIV, but accepts operands from other registers or memory.

- bitwise algebra

NOT AL 

AND, AL, AH  

OR AL, AH 

XOR AH, AL

SHL/SAL AL, 3 ; shifts bits to the left.

SHR/SAR AL, 3 ; shifts bits to the right.

ROL AL, 3 ; rotates bits to left 

ROR AL, 3 ; rotates bits to the right 

- control flow, The affected register in this is the index pointer IP/EIP, which holds the current address where the next instruction to execute is located.

JMP, direct jump to a given address 

jmp   eax
jmp   dword ptr [00403000]
jmp   dword ptr [eax+edx]
jmp   dowrd ptr [eax]
jmp   dword ptr [ebx*4+eax]















    
    
    