C# 14 what's news=Erxin


# New features 
- Extension members 

eclare extension properties in addition to extension methods. You can also declare extension members that extend the type, rather than an instance of the type.
   
```
public static class Enumerable
{
    // Extension block
    extension<TSource>(IEnumerable<TSource> source) // extension members for IEnumerable<TSource>
    {
        // Extension property:
        public bool IsEmpty => !source.Any();
        // Extension indexer:
        public TSource this[int index] => source.Skip(index).First();

        // Extension method:
        public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }
    }

    // extension block, with a receiver type only
    extension<TSource>(IEnumerable<TSource>) // static extension members for IEnumerable<Source>
    {
        // static extension method:
        public static IEnumerable<TSource> Combine(IEnumerable<TSource> first, IEnumerable<TSource> second) { ... }

        // static extension property:
        public static IEnumerable<TSource> Identity => Enumerable.Empty<TSource>();
    }
}
```

- field keyword, The token field enables you to write a property accessor body without declaring an explicit backing field.

```
//before 
private string _msg;
public string Message
{
    get => _msg;
    set => _msg = value ?? throw new ArgumentNullException(nameof(value));
}

//after 
public string Message
{
    get;
    set => field = value ?? throw new ArgumentNullException(nameof(value));
}
```

- implicit span conversions, C# 14 introduces first-class support for System.Span<T> and System.ReadOnlySpan<T> in the language. This support involves new implicit conversions

the argument to nameof can be an unbound generic type. For example, nameof(List<>) evaluates to List.

- Simple lambda parameters with modifiers,  can add parameter modifiers, such as scoped, ref, in, out, or ref readonly to lambda expression parameters without specifying the parameter type


TryParse<int> parse2 = (string text, out int result) => Int32.TryParse(text, out result);

- more partial memebers, You can now declare instance constructors and events as partial members.

a partial constructor can include a constructor initializer: this() or base(). Only one partial type declaration can include the primary constructor syntax.

- null conditional assignment 

null-conditional member access operators, ?. and ?[], can now be used on the left hand side of an assignment 

customer?.Order = GetCurrentOrder();