C++ 20 for programmer, 3rd edition=Harvey Deitel;Note=Erxin

# Preface 
- Compilers

We tested every program in the book on three popular free compilers:

• Visual C++ in Microsoft Visual Studio Community edition on Windows,

• Clang in Xcode on macOS, and

• GNU C++ on Linux and in the GNU Compiler Collection (GCC) Docker container.

-  source code is available at

https://www.deitel.com/c-plus-plus-20-for-programmers

- C++20 compiler support for many more compilers is tracked at

https://en.cppreference.com/w/cpp/compiler_support


# Fundamental quick start 
- visual studio 
- xcode 
- gnu on linux 

- first cpp program 

1  // fig02_04.cpp
2  // Addition program that displays the sum of two integers.
3  #include <iostream> // enables program to perform input and output
4
5  // function main begins program execution
6  int main() {
7     // declaring and initializing variables
8     int number1{0}; // first integer to add (initialized to 0)  
9     int number2{0}; // second integer to add (initialized to 0) 
10     int sum{0}; // sum of number1 and number2 (initialized to 0)
11
12     std::cout << "Enter first integer: "; // prompt user for data
13     std::cin >> number1; // read first integer from user into number1
14
15     std::cout << "Enter second integer: "; // prompt user for data
16     std::cin >> number2; // read second integer from user into number2
17
18     sum = number1 + number2; // add the numbers; store result in sum
19
20     std::cout << "Sum is " << sum << std::endl; // display sum; end line
21   } // end function main



# Control statements 
- if, else 
- for, while, 


# Functions 
- factory 

int factorial{1};

for (int counter{number}; counter >= 1; --counter) {
   factorial *= counter;
}

- a cube function declared with [[nodiscard]], which you place before the return type— typically on a line by itself


# Arrays, vectors, c++ 20 ranges and functional style programming 
- define 

array<int, 5> n; // n is an array of 5 int values

7   int main() {
 8      constexpr size_t arraySize{4};
 9      array<int, arraySize> integers{10, 20, 30, 40};
10      int total{0};
11
12      // sum contents of array a
13      for (const int item : integers) {
14         total += item;
15      }
16      
17      cout << "Total of array elements: " << total << endl;
18   }

[](const auto& x, const auto& y){return x * y;}



# Pointers in modern c++ 
- null 

int* yPtr{nullptr}; // declare pointer variable yPtr

- pass by value 

*nPtr = (*nPtr) * (*nPtr) * (*nPtr); // cube *nPtr

- built in arrays 


# string 
- string bar{8, '*'}; // string of 8 '*' characters

- regex 

your own regular expressions for common items like these. The following free websites

https://regex101.com
https://regexr.com/
http://www.regexlib.com
https://www.regular-expressions.info



# Custom classes 
```
 1   // Fig. 9.3: Account.h
 2   // Account class with a constructor that initializes the account name.
 3   #include <string>
 4   #include <string_view>
 5
 6   class Account {
 7   public:
 8      // constructor initializes data member m_name with the parameter name
 9      explicit Account(std::string_view name)
10         : m_name{name} { // member initializer
11        // empty body
12      }
13
14      // function to set the account name
15      void setName(std::string_view name) {
16         m_name = name; // replace m_name's value with name
17      }
18
19      // function to retrieve the account name
20      const std::string& getName() const {
21         return m_name;
22      }
23   private:
24      std::string m_name; // account name data member
25   }; // end class Account
```


# Aggregate type 
- struct

12   struct Record {
13      int account{};
14      string first{};
15      string last{};
16      double balance{};
17   };
18


# Opeator overloading
- special member function 

define in class MyArray:

a copy constructor,

a copy assignment operator,

a move constructor,

a move assignment operator, and

a destructor.

- example 

Chapter 11. Operator Overloading, Copy/Move Semantics and Smart Pointers
Images

Objectives

In this chapter, you’ll:

■ Use built-in string class overloaded operators.

■ Use operator overloading to help you craft valuable classes.

■ Understand the special member functions and when to implement them for custom types.

■ Understand when objects should be moved vs. copied.

■ Use rvalue references and move semantics to eliminate unnecessary copies of temporary objects that are going out of scope, improving program performance.

■ Understand why you should avoid dynamic memory management with operators new and delete.

■ Manage dynamic memory automatically with smart pointers.

■ Craft a polished MyArray class that defines the five special member functions to support copy and move semantics, and overloads many unary and binary operators.

■ Use C++20’s three-way comparison operator (<=>).

■ Convert objects to other types.

■ Use keyword explicit to prevent constructors and conversion operators from being used for implicit conversions.

■ Experience a “light-bulb moment” when you’ll truly appreciate the elegance and beauty of the class concept.

Outline

11.1 Introduction

11.2 Using the Overloaded Operators of Standard Library Class string

11.3 Operator Overloading Fundamentals

11.3.1 Operator Overloading Is Not Automatic

11.3.2 Operators That Cannot Be Overloaded

11.3.3 Operators That You Do Not Have to Overload

11.3.4 Rules and Restrictions on Operator Overloading

11.4 (Downplaying) Dynamic Memory Management with new and delete

11.5 Modern C++ Dynamic Memory Management—RAII and Smart Pointers

11.5.1 Smart Pointers

11.5.2 Demonstrating unique_ptr

11.5.3 unique_ptr Ownership

11.5.4 unique_ptr to a Built-In Array

11.6 MyArray Case Study: Crafting a Valuable Class with Operator Overloading

11.6.1 Special Member Functions

11.6.2 Using Class MyArray

11.6.3 MyArray Class Definition

11.6.4 Constructor That Specifies a MyArray’s Size

11.6.5 C++11 Passing a Braced Initializer to a Constructor

11.6.6 Copy Constructor and Copy Assignment Operator

11.6.7 Move Constructor and Move Assignment Operator

11.6.8 Destructor

11.6.9 toString and size Functions

11.6.10 Overloading the Equality (==) and Inequality (!=) Operators

11.6.11 Overloading the Subscript ([]) Operator

11.6.12 Overloading the Unary bool Conversion Operator

11.6.13 Overloading the Preincrement Operator

11.6.14 Overloading the Postincrement Operator

11.6.15 Overloading the Addition Assignment Operator (+=)

11.6.16 Overloading the Binary Stream Extraction (>>) and Stream Insertion (<<) Operators

11.6.17 friend Function swap

11.7 C++20 Three-Way Comparison Operator (<=>)

11.8 Converting Between Types

11.9 explicit Constructors and Conversion Operators

11.10 Overloading the Function Call Operator ()

11.11 Wrap-Up
11.1 Introduction

This chapter shows how to enable C++’s existing operators to work with class objects—a process called operator overloading. One example of an overloaded operator in standard C++ is <<, which is used both as

• the stream insertion operator and

• the bitwise left-shift operator (which is discussed in Appendix E).

Similarly, >> also is overloaded; it’s used both as

• the stream extraction operator and

• the bitwise right-shift operator (which is discussed in Appendix E).

You’ve actually been using overloaded operators since early in the book. Various overloads are built into the core C++ language itself. For example, C++ overloads the addition operator (+) to perform differently, based on its context in integer, floating-point and pointer arithmetic with data of fundamental types.

You can overload most operators to be used with class objects. The compiler generates the appropriate code based on the operand types. The jobs performed by overloaded operators also can be performed by explicit function calls, but operator notation is often more natural.
string Class Overloaded Operators Demonstration

In Section 2.7’s objects-natural case study, we introduced the standard library’s string class and demonstrated a few of its features, such as string concatenation with the + operator. Here, we demonstrate many additional string-class overloaded operators, so you can appreciate how valuable operator overloading is in a key standard library class before implementing it in your own custom classes. Next, we’ll present operator-overloading fundamentals.
Dynamic Memory Management and Smart Pointers

We introduce dynamic memory management, which enables a program to acquire additional memory it needs for objects at runtime rather than at compile-time and release that memory when it’s no longer needed so it can be used for other purposes. We discuss the potential problems with dynamically allocated memory, such as forgetting to release memory that’s no longer needed—known as a memory leak. Then, we introduce smart pointers, which can automatically release dynamically allocated memory for you. As you’ll see, smart pointers, when coupled with the RAII (Resource Acquisition Is Initialization) strategy, enable you to eliminate subtle memory leak issues.
MyArray Case Study

Next, we present one of the book’s capstone case studies. We build a custom MyArray class that uses overloaded operators and other capabilities to solve various problems with C++’s native pointer-based arrays. We introduce and implement the five special member functions you can define in each class—the copy constructor, copy assignment operator, move constructor, move assignment operator and destructor. Sometimes the default constructor also is included as a special member function. We introduce copy semantics and move semantics, which help tell a compiler when it can move resources from one object to another to avoid costly unnecessary copies.

MyArray uses smart pointers and RAII, and overloads many unary and binary operators, including

• = (assignment),

• == (equality),

• != (inequality),

• [] (subscript),

• ++ (increment),

• += (addition assignment),

• >> (stream extraction) and

• << (stream insertion).

We also show how to define a conversion operator that converts a MyArray to a true or false bool value, indicating whether a MyArray contains elements or is empty.

Many of our readers have said that working through the MyArray case study is a “light bulb moment,” helping them truly appreciate what classes and object technology are all about. Once you master this MyArray class, you’ll indeed understand the essence of object technology—crafting, using and reusing valuable classes—and sharing them with colleagues and perhaps the entire C++ open-source community.
C++20’s Three-Way Comparison Operator (<=>)

20 We introduce C++20’s new three-way comparison operator (<=>), which is also referred to as the “spaceship operator.”1

1. “Spaceship operator” was coined by Randal L. Schwartz when he was teaching the same operator in a Perl programming course—the operator reminded him of a spaceship in an early video game. https://groups.google.com/a/dartlang.org/g/misc/c/WS5xftItpl4/m/jcIttrMq8agJ?pli=1.
Conversion Operators

We discuss overloaded conversion operators and conversion constructors in more depth. In particular, we demonstrate how implicit conversions can cause subtle problems. Then, we use explicit to prevent those problems.
11.2 Using the Overloaded Operators of Standard Library Class string

Chapter 8 presented class string in detail. Figure 11.1 demonstrates many of class string’s overloaded operators and several other useful member functions, including empty, substr and at:

• empty determines whether a string is empty,

• substr (for “substring”) returns a string that’s a portion of an existing string, and

• at returns the character at a specific index in a string (after checking that the index is in range).

For discussion purposes, we split this example into small chunks of code, each followed by its output.

Click here to view code image

 1   // fig11_01.cpp
 2   // Standard library string class test program.
 3   #include <iostream>
 4   #include <string>
 5   #include <string_view>
 6   #include "fmt/format.h" // in C++20, this will be #include <format>
 7   using namespace std;
 8
 9   int main() {

Fig. 11.1 | Standard library string class test program.
Creating string and string_view Objects and Displaying Them with cout and Operator <<

Lines 10–13 create three strings and a string_view:

• the string s1 is initialized with the literal "happy",

• the string s2 is initialized with the literal " birthday",

• the string s3 uses string’s default constructor to create an empty string, and

• the string_view v is initialized to reference the characters in the literal "hello".

Lines 16–17 output these three objects, using cout and operator <<, which the string and string_view class designers overloaded to handle string objects.

Click here to view code image

10   string s1{"happy"}; // initialize string from char*
11   string s2{" birthday"}; // initialize string from char*
12   string s3; // creates an empty string
13   string_view v{"hello"}; // initialize string_view from char*
14
15   // output strings and string_view
16   cout << fmt::format("s1: \"{}\"; s2: \"{}\"; s3: \"{}\"; v: \"{}\"\n\n",
17              s1, s2, s3, v);
18

s1: "happy"; s2: " birthday"; s3: ""; v: "hello"

Comparing string Objects with the Equality and Relational Operators

20 Lines 20–26 show the results of comparing s2 to s1 by using class string’s overloaded equality and relational operators. These perform lexicographical comparisons (that is, like a dictionary ordering) using the numerical values of the characters in each string (see Appendix B, ASCII Character Set). When you use C++20’s format function to convert a bool to a string, format produces the string "true" or the string "false".

Click here to view code image

19   // test overloaded equality and relational operators
20   cout << "The results of comparing s2 and s1:\n"
21      << fmt::format("s2 == s1: {}\n", s2 == s1)
22      << fmt::format("s2 != s1: {}\n", s2 != s1)
23      << fmt::format("s2 > s1: {}\n", s2 > s1)
24      << fmt::format("s2 < s1: {}\n", s2 < s1)
25      << fmt::format("s2 >= s1: {}\n", s2 >= s1)
26      << fmt::format("s2 <= s1: {}\n\n", s2 <= s1);
27

The results of comparing s2 and s1:
s2 == s1: false
s2 != s1: true
s2 > s1: false
s2 < s1: true
s2 >= s1: false
s2 <= s1: true

string Member Function empty

Line 31 uses string member function empty, which returns true if the string is empty; otherwise, it returns false. The object s3 was initialized with the default constructor, so it is indeed empty.

Click here to view code image

28   // test string member function empty
29   cout << "Testing s3.empty():\n";
30
31   if (s3.empty()) {
32      cout << "s3 is empty; assigning s1 to s3;\n";
33      s3 = s1; // assign s1 to s3
34      cout << fmt::format("s3 is \"{}\"\n\n", s3);
35   }
36

Testing s3.empty():
s3 is empty; assigning s1 to s3;
s3 is "happy"

string Copy Assignment Operator

Line 33 demonstrates class string’s overloaded copy assignment operator by assigning s1 to s3. Line 34 outputs s3 to demonstrate that the assignment worked correctly.
string Concatenation and C++14 string-object Literals

Line 38 demonstrates class string’s overloaded += operator for string concatenation assignment. In this case, the contents of s2 are appended to s1, thus modifying its value. Then line 39 outputs the resulting string that’s stored in s1. Line 42 demonstrates that you also may append a C-string literal to a string object by using operator +=. Line 43 displays the result.

Click here to view code image

37   // test overloaded string concatenation assignment operator
38   s1 += s2; // test overloaded concatenation
39   cout << fmt::format("s1 += s2 yields s1 = {}\n\n", s1);
40
41   // test string concatenation with a C string
42   s1 += " to you";
43   cout << fmt::format("s1 += \" to you\" yields s1 = {}\n\n", s1);
44
45   // test string concatenation with a C++14 string-object literal
46   s1 += ", have a great day!"s; // s after " for string-object literal
47   cout << fmt::format(
48              "s1 += \", have a great day!\"s yields\ns1 = {}\n\n", s1);
49

s1 += s2 yields s1 = happy birthday

s1 += " to you" yields s1 = happy birthday to you

s1 += ", have a great day!"s yields
s1 = happy birthday to you, have a great day!

14 Similarly, line 46 concatenates s1 with a C++14 string-object literal, which is indicated by placing the letter s immediately following the closing " of a string literal, as in

", have a great day!"s

The preceding literal actually results in a call to a C++ standard library function that returns a string object containing the literal’s characters. Lines 47–48 display the new value of s1.
string Member Function substr

Class string provides member function substr (lines 53 and 58) to return a string containing a portion of the string object on which the function is called. The call to substr in line 53 obtains a 14-character substring of s1 starting at position 0. The call in line 58 obtains a substring starting from position 15 of s1. When the second argument is not specified, substr returns the remainder of the string on which it’s called.

Click here to view code image

50   // test string member function substr
51   cout << fmt::format("{} {}\n{}\n\n",
52              "The substring of s1 starting at location 0 for",
53              "14 characters, s1.substr(0, 14), is:", s1.substr(0, 14));
54
55   // test substr "to-end-of-string" option
56   cout << fmt::format("{} {}\n{}\n\n",
57              "The substring of s1 starting at",
58              "location 15, s1.substr(15), is:", s1.substr(15));
59

The substring of s1 starting at location 0 for 14 characters, s1.substr(0,
14), is:
happy birthday

The substring of s1 starting at location 15, s1.substr(15), is:
to you, have a great day!

string Copy Constructor

Line 61 creates string object s4, initializing it with a copy of s1. This calls class string’s copy constructor, which copies the contents of s1 into the new object s4. You’ll see how to define a custom copy constructor for your own class in Section 11.6.

Click here to view code image

60   // test copy constructor
61   string s4{s1};
62   cout << fmt::format("s4 = {}\n\n", s4);
63

s4 = happy birthday to you, have a great day!

Testing Self-Assignment with the string Copy Assignment Operator

Line 66 uses class string’s overloaded copy assignment (=) operator to demonstrate that it handles self-assignment properly, so s4 still has the same value after the self-assignment. We’ll see when we build class MyArray later in the chapter that self-assignment must be handled carefully for objects that manage their own memory, and we’ll show how to deal with the issues.

Click here to view code image

64   // test overloaded copy assignment (=) operator with self-assignment
65   cout << "assigning s4 to s4\n";
66   s4 = s4;
67   cout << fmt::format("s4 = {}\n\n", s4);
68

assigning s4 to s4
s4 = happy birthday to you, have a great day!

Initializing a string with a string_view

Line 71 demonstrates class string’s constructor that receives a string_view, in this case, copying the character data represented by the string_view v (line 13) into the new string s5.

Click here to view code image

69   // test string's string_view constructor
70   cout << "initializing s5 with string_view v\n";
71   string s5{v};
72   cout << fmt::format("s5 is {}\n\n", s5);
73

initializing s5 with string_view v
s5 is hello

string’s [] Operator

Lines 75–76 use string’s overloaded [] operator in assignments to create lvalues for replacing characters in s1. Lines 77–78 output s1’s new value. The [] operator returns the character at the specified location as a modifiable lvalue or a nonmodifiable lvalue (e.g., a

const reference), depending on the context in which the expression appears. For example:

• If [] is used on a non-const string, the function returns a modifiable lvalue, which can be used on the left of an assignment (=) operator to assign a new value to that location in the string, as line lines 76–76.

• If [] is used on a const string, the function returns a nonmodifiable lvalue that can be used to obtain, but not modify, the value at that location in the string.

The overloaded [] operator does not perform bounds checking. So, you must ensure that operations using this operator do not accidentally manipulate elements outside the string’s bounds.

Click here to view code image

74   // test using overloaded subscript operator to create lvalue
75   s1[0] = 'H';
76   s1[6] = 'B';
77   cout << fmt::format("{}:\n{}\n\n",
78              "after s1[0] = 'H' and s1[6] = 'B', s1 is", s1);
79

after s1[0] = 'H' and s1[6] = 'B', s1 is:
Happy Birthday to you, have a great day!

string’s at Member Function

Class string provides bounds checking in its member function at, which throws an exception if its argument is an invalid index. If the index is valid, function at returns the character at the specified location as a modifiable lvalue or a nonmodifiable lvalue (e.g., a const reference), depending on the context in which the call appears. Line 83 demonstrates a call to function at with an invalid index causing an out_of_range exception. The error message in this case was produced by GNU C++.

Click here to view code image

80      // test index out of range with string member function "at"
81      try {
82         cout << "Attempt to assign 'd' to s1.at(100) yields:\n";
83         s1.at(100) = 'd'; // ERROR: subscript out of range
84      }
85      catch (const out_of_range& ex) {
86         cout << fmt::format("An exception occurred: {}\n", ex.what());
87      }
88   }

Attempt to assign 'd' to s1.at(100) yields:
An exception occurred: basic_string::at: __n (which is 100) >= this->size()
(which is 40)

11.3 Operator Overloading Fundamentals

SEImages As you saw in Fig. 11.1, standard library class string’s overloaded operators provide a concise notation for manipulating string objects. You can use operators with your own user-defined types as well. C++ allows most existing operators to be overloaded by defining operator functions. Once you define an operator function for a given operator and your custom class, that operator has meaning appropriate for objects of your class.
11.3.1 Operator Overloading Is Not Automatic

SEImages You must write operator functions that perform the desired operations. An operator is overloaded by writing a non-static member function definition or a non-member function definition. An operator function’s name is the keyword operator, followed by the symbol of the operator being overloaded. For example, the function name operator+ would overload the addition operator (+). When operators are overloaded as member functions, they must be non-static. They are called on an object of the class and operate on that object.
11.3.2 Operators That Cannot Be Overloaded

Most of C++’s operators can be overloaded—the following operators cannot:2

2. Although it’s possible to overload the address (&), comma (,), && and || operators, you should avoid doing so to avoid subtle errors. See https://isocpp.org/wiki/faq/operator-overloading. Accessed February 25, 2021.

• . (dot) member-selection operator

• .* pointer-to-member operator (discussed in Section 19.6)

• :: scope-resolution operator

• ?: conditional operator
11.3.3 Operators That You Do Not Have to Overload

Three operators work with objects of each new class by default:

• ErrImages 11 The assignment operator (=) may be used with most classes to perform member-wise assignment of the data members. The default assignment operator assigns each data member from the “source” object (on the right) to the “target” object (on the left). As you’ll see Section 11.6.6, this can be dangerous for classes that have pointer members. So, you’ll either explicitly overload the assignment operator or explicitly disallow the compiler from defining the default assignment operator. This is also true for the C++11 move assignment operator, which we discuss in Section 11.6.

• The address (&) operator returns a pointer to the object.

• The comma operator evaluates the expression to its left then the expression to its right, and returns the latter expression’s value. Though this operator can be overloaded, generally, it is not.3

3. “Operator Overloading.” Accessed February 24, 2021. https://isocpp.org/wiki/faq/operator-overloading.
11.3.4 Rules and Restrictions on Operator Overloading

As you prepare to overload operators for your own classes, there are several rules and restrictions you should keep in mind:

• An operator’s precedence cannot be changed by overloading. Parentheses can be used to force the order of evaluation of overloaded operators in an expression.

• An operator’s grouping cannot be changed by overloading. If an operator normally groups left-to-right, then so do its overloaded versions.

• An operator’s “arity” (the number of operands an operator takes) cannot be changed by overloading. Overloaded unary operators remain unary operators and overloaded binary operators remain binary operators. The only ternary operator (?:) cannot be overloaded. Operators &, *, + and - each have unary and binary versions that can be overloaded separately.

• Only existing operators can be overloaded. You cannot create new ones.

• You cannot overload operators to change how an operator works on only fundamental-type values. For example, you cannot make the + operator subtract two ints.

• Operator overloading works only with objects of user-defined types or with a mixture of an object of a user-defined type and an object of a fundamental type.

• 20 Related operators, like + and +=, generally must be overloaded separately. In C++20, if you define == for your class, C++ provides != for you—it simply returns the opposite of ==.

• When overloading (), [], -> or =, the operator overloading function must be declared as a class member. You’ll see later that this is required when the left operand must be an object of your custom class type. Operator functions for all other overloadable operators may be member functions or non-member functions.

SEImages SEImages You should overload operators for class types to work as closely as possible to how they work with fundamental types. Avoid excessive or inconsistent use of operator overloading, as this can make a program cryptic and difficult to read.
11.4 (Downplaying) Dynamic Memory Management with new and delete

CGImages You can allocate and deallocate memory in a program for objects and for arrays of any built-in or user-defined type. This is known as dynamic memory management. In Chapter 7, we introduced pointers and showed various old-style techniques you’re likely to see in legacy code, then we showed improved Modern C++ techniques. We do the same here. For decades, C++ dynamic memory management was performed with operators new and delete. The C++ Core Guidelines recommend against using these operatorsdirectly.4,5 You’ll likely see them in legacy C++ code, so we discuss them here. Section 11.5 discusses Modern C++ dynamic memory management techniques, which we’ll use in Section 11.6’s MyArray case study.

4. “R.11: Avoid calling new and delete explicitly.” Accessed February 26, 2021. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete.

5. Operators new and delete can be overloaded, but this is beyond the scope of the book. If you do overload new, then you should overload delete in the same scope to avoid subtle dynamic memory management errors. Overloading new and delete is typically done for precise control over how memory is allocated and deallocated, often for performance. This might be used, for example, to preallocate a pool of memory, then create new objects within that pool to reduce runtime memory-allocation overhead. For an overview of the so-called placement new and delete operators, see https://en.wikipedia.org/wiki/Placement_syntax.
The Old Way—Operators new and delete

You can use the new operator to dynamically reserve (that is, allocate) the exact amount of memory required to hold an object or built-in array. The object or built-in array is created on the free store—a region of memory assigned to each program for storing dynamically allocated objects. Once memory is allocated, you can access it via the pointer returned by operator new. When you no longer need the memory, you can return it to the free store by using the delete operator to deallocate (i.e., release) the memory, which can then be reused by future new operations.
Obtaining Dynamic Memory with new

Consider the following statement:

Click here to view code image

Time* timePtr{new Time{}};

ErrImages The new operator allocates storage of the proper size for a Time object, calls a default constructor to initialize the object (in this case, Time’s default constructor) and returns a pointer of the type specified to the right of the new operator (in this case, a Time*). In the preceding statement, class Time’s default constructor is called, because we did not supply arguments to initialize the Time object. If new is unable to find sufficient space in memory for the object, it throws a bad_alloc exception. Chapter 12 shows how to deal with new failures.
Releasing Dynamic Memory with delete

To destroy a dynamically allocated object and free the space for the object, use the delete operator as follows:

delete timePtr;

ErrImages This statement calls the destructor for the object to which timePtr points, then deallocates the object’s memory, returning it to the free store. Not releasing dynamically allocated memory when it’s no longer needed can cause memory leaks that eventually lead to a system running out of memory prematurely. The problem might be even worse. If the leaked memory contains objects that manage other resources, those objects’ destructors will not be called to release the resources, causing additional leaks.

ErrImages Do not delete memory that was not allocated by new. Doing so results in undefined behavior. After you delete a block of dynamically allocated memory, be sure not to delete the same block again, which typically causes a program to crash. One way to guard against this is to immediately set the pointer to nullptr—deleting such a pointer has no effect.
Initializing Dynamically Allocated Objects

You can initialize a newly allocated object with constructor arguments to the right of the type, as in:

Click here to view code image

Time* timePtr{new Time{12, 45, 0}};

which initializes a new Time object to 12:45:00 PM and assigns its pointer to timePtr.
Dynamically Allocating Built-In Arrays with new[]

You also can use the new operator to dynamically allocate built-in arrays. The following statement dynamically allocates a 10-element integer array:

Click here to view code image

int* gradesArray{new int[10]{}};

This statement aims the int pointer gradesArray at the first element of the dynamically allocated array. The empty braced initializer following new int[10] value initialize the array’s elements, which sets fundamental-type elements to 0, bools to false and pointers to nullptr. The braced initializer may also contain a comma-separated list of initializers for the array’s elements. Value initializing an object calls its default constructor, if available. The rules become more complicated for objects that do not have default constructors. For more details, see the value-initialization rules at:

Click here to view code image

https://en.cppreference.com/w/cpp/language/value_initialization

The size of a built-in array created at compile time must be specified using an integral constant expression. However, a dynamically allocated array’s size can be specified using any nonnegative integral expression that can be evaluated at execution time.
Releasing Dynamically Allocated Built-In Arrays with delete[]

To deallocate the memory to which gradesArray points, use the statement

delete[] gradesArray;

If the pointer points to a built-in array of objects, this statement first calls the destructor for each object in the array, then deallocates the memory for the entire array. As with delete, delete[] on a nullptr has no effect.

ErrImages If the preceding statement did not include the square brackets ([]) and gradesArray pointed to a built-in array of objects, the result is undefined. Some compilers call the destructor only for the first object in the array. Using delete instead of delete[] for built-in arrays of objects results in undefined behavior. To ensure that every object in the array receives a destructor call, always use operator delete[] to delete memory allocated by new[]. We’ll show better techniques for managing dynamically allocated memory that enable you to avoid using new and delete.

ErrImages If there is only one pointer to a block of dynamically allocated memory and the pointer goes out of scope or you assign it nullptr or a different memory address, a memory leak occurs. After deleting dynamically allocated memory, set the pointer’s value to nullptr to indicate that it no longer points to memory in the free store. This ensures that your code cannot inadvertently access the previously allocated memory—doing so could cause subtle logic errors.
Range-Based for Does Not Work with Dynamically Allocated Built-In Arrays

ErrImages You might be tempted to use C++11’s range-based for statement to iterate over dynamically allocated arrays. Unfortunately, this will not compile. The compiler must know the number of elements at compile-time to iterate over an array with range-based for. As a workaround, you can create a C++20 span object that represents the dynamically allocated array and its number of elements, then iterate over the span object with range-based for.
11.5 Modern C++ Dynamic Memory Management—RAII and Smart Pointers

ErrImagesA common design pattern is to allocate dynamic memory, assign the address of that memory to a pointer, use the pointer to manipulate the memory and deallocate the memory when it’s no longer needed. If an exception occurs after successful memory allocation but before the delete or delete[] statement executes, a memory leak could occur.

CGImages For this reason, the C++ Core Guidelines recommend that you manage resources like dynamic memory using RAII—Resource Acquisition Is Initialization.6,7 The concept is straightforward. For any resource that must be returned to the system when the program is done using it, the program should:

6. “R: Resource Management.” Accessed February 26, 2021. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource.

7. “R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization).” Accessed February 26, 2021. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii.

• create the object as a local variable in a function—the object’s constructor should allocate the resource,

• use that object as necessary in your program, then

• when the function call terminates, the object goes out of scope, which automatically calls the object’s destructor to release the resource.
11.5.1 Smart Pointers

SEImages C++11 smart pointers use RAII to manage dynamically allocated memory for you. The standard library header <memory> defines three smart pointer types:

• unique_ptr

• shared_ptr

• weak_ptr

A unique_ptr maintains a pointer to dynamically allocated memory. The class name contains “unique” because a dynamically allocated object can belong to only one unique_ptr at a time. When a unique_ptr object goes out of scope, its destructor uses delete (or delete[] for an array) to deallocate the memory that the unique_ptr manages. The rest of Section 11.5 demonstrates unique_ptr, which we’ll also use in our MyArray case study. We introduce shared_ptr and weak_ptr in Chapter 19, Other Topics and a Look Toward the Future of C++.
11.5.2 Demonstrating unique_ptr

Figure 11.2 demonstrates a unique_ptr object that points to a dynamically allocated object of a custom class Integer (lines 7–22). For pedagogic purposes, the class’s constructor and destructor both display when they are called. Line 29 creates unique_ptr object ptr and initializes it with a pointer to a dynamically allocated Integer object that contains the value 14 7. To initialize the unique_ptr, line 29 calls C++14’s make_unique function template, which allocates dynamic memory with operator new, then returns a unique_ptr to that memory.8 In this example, make_unique<Integer> returns a unique_ptr<Integer>—line 29 uses the auto keyword to infer ptr’s type from its initializer.

8. Prior to C++14, you’d pass the result of a new expression directly to unique_ptr’s constructor.

Click here to view code image

 1   // fig11_02.cpp
 2   // Demonstrating unique_ptr.
 3   #include <iostream>
 4   #include <memory>
 5   using namespace std;
 6
 7   class Integer {
 8   public:
 9      // constructor
10      Integer(int i) : value{i} { 
11         cout << "Constructor for Integer " << value << "\n";
12      }
13
14      // destructor
15      ~Integer() {
16         cout << "Destructor for Integer " << value << "\n";
17      }
18
19      int getValue() const {return value;} // return Integer value
20   private:
21      int value{0};
22   };
23
24   // use unique_ptr to manipulate Integer object
25   int main() {
26      cout << "Creating a unique_ptr object that points to an Integer\n";
27
28      // create a unique_ptr object and "aim" it at a new Integer object
29      auto ptr{make_unique<Integer>(7)};
30
31      // use unique_ptr to call an Integer member function
32      cout << "Integer value: " << ptr->getValue()
33         << "\n\nMain ends\n";
34   }

Creating a unique_ptr object that points to an Integer
Constructor for Integer 7
Integer value: 7

Main ends
Destructor for Integer 7

Fig. 11.2 | Demonstrating unique_ptr.

Line 32 uses unique_ptr’s overloaded -> operator to invoke function getValue on the Integer object that ptr manages. The expression ptr->getValue() also could have been written as:

(*ptr).getValue()

which uses unique_ptr’s overloaded * operator to dereference ptr, then uses the dot (.) operator to invoke function getValue on the Integer object.

Because ptr is a local variable in main, it’s destroyed when main terminates. The unique_ptr destructor deletes the dynamically allocated Integer object, which calls the object’s destructor. The program releases the Integer object’s memory, whether program control leaves the block normally via a return statement or reaching the end of the block—or as the result of an exception.

SEImages Most importantly, using unique_ptr as shown here prevents resource leaks. For example, suppose a function returns a pointer aimed at some dynamically allocated object. Unfortunately, the function caller that receives this pointer might not delete the object, thus resulting in a memory leak. However, if the function returns a unique_ptr to the object, the object will be deleted automatically when the unique_ptr object’s destructor gets called.
11.5.3 unique_ptr Ownership

SEImages Only one unique_ptr at a time can own a dynamically allocated object, so assigning one unique_ptr to another transfers ownership to the target unique_ptr on the assignment’s left. The same is true when one unique_ptr is passed as an argument to another unique_ptr’s constructor. These operations use unique_ptr’s move assignment operator and move constructor, which we discuss in Section 11.6. The last unique_ptr object that owns the dynamic memory will delete the memory. This makes unique_ptr an ideal mechanism for returning ownership of dynamically allocated objects to client code. When the unique_ptr goes out of scope in the client code, the unique_ptr’s destructor deletes the dynamically allocated object. If that object has a destructor, it is called before the memory is returned to the system.
11.5.4 unique_ptr to a Built-In Array

You can also use a unique_ptr to manage a dynamically allocated built-in array, as we’ll do in Section 11.6’s MyArray case study. For example, in the statement

Click here to view code image

auto ptr{make_unique<int[]>(10)};

14 make_unique’s type argument is specified as int[]. So make_unique dynamically allocates a built-in array with the number of elements specified by its argument (10). By default, the int elements are value initialized to 0. The preceding statement uses auto to infer ptr’s type (unique_ptr<int[]>), based on its initializer.

A unique_ptr that manages an array provides an overloaded subscript operator ([]) to access its elements. For example, the statement

ptr[2] = 7;

assigns 7 to the int at ptr[2], and the following statement displays that int:

cout << ptr[2] << "\n";

11.6 MyArray Case Study: Crafting a Valuable Class with Operator Overloading

Class development is an interesting, creative and intellectually challenging activity— always with the goal of crafting valuable classes. When we refer to “arrays” in this case study, we mean the built-in arrays we discussed in Chapter 7. These pointer-based arrays have many problems, including:

• C++ does not check whether an array index is out-of-bounds. A program can easily “walk off” either end of an array, likely causing a fatal runtime error if you forget to test for this possibility in your code.

• Arrays of size n must use index values in the range 0 to n – 1. Alternate index ranges are not allowed.

• You cannot input an entire array with the stream extraction operator (>>) or output one with the stream insertion operator (<<). You must read or write every element.9

9. In Chapter 13, Standard Library Containers and Iterators, you’ll use C++ standard library functions to input and output entire containers of elements, such as vectors and arrays.

• Two arrays cannot be meaningfully compared with equality or relational operators. Array names are simply pointers to where the arrays begin in memory. Two arrays will always be at different memory locations.

• When you pass an array to a general-purpose function that handles arrays of any size, you must pass the array’s size as an additional argument. As you saw in Section 7.10, C++20’s spans help solve this problem.

• 20 You cannot assign one array to another with the assignment operator(s).

With C++, you can implement more robust array capabilities via classes and operator overloading, as has been done with C++ standard library class templates array and vector. In this section, we’ll develop our own custom MyArray class that’s preferable to arrays. Internally, class MyArray will use a unique_ptr smart pointer to manage a dynamically allocated built-in array of int values.10

20 10. In this section, we’ll use operator overloading to craft a valuable class. In Chapter 15, we’ll make it more valuable by converting it to a class template, and we’ll use C++20’s new concepts feature to add even more value.

We’ll create a powerful MyArray class with the following capabilities:

• MyArrays perform range checking when you access them via the subscript ([]) operator to ensure indices remain within their bounds. Otherwise, the MyArray object will throw a standard library out_of_bounds exception.

• Entire MyArrays can be input or output with the overloaded stream extraction (>>) and stream insertion (<<) operators, without the client-code programmer having to write iteration statements.

• MyArrays may be compared to one another with the equality operators == and !=. The class could easily be enhanced to include the relational operators.

• MyArrays know their own size, making it easier to pass them to functions.

• MyArray objects may be assigned to one another with the assignment operator.

• MyArrays may be converted to bool false or true values to determine whether they are empty or contain elements.

• MyArray provides prefix and postfix increment (++) operators that add 1 to every element. We can easily add prefix and postfix decrement (--) operators.

• MyArray provides an addition assignment operator (+=) that adds a specified value to every element. The class could easily be enhanced to support the -=, *=, /= and %= assignment operators.

Class MyArray will demonstrate the five special member functions and the unique_ptr smart pointer for managing dynamically allocated memory. We’ll use RAII (Resource Acquisition Is Initialization) throughout this example to manage the dynamically allocated memory resources. All dynamically allocated memory will be allocated by the class’s constructors as MyArray objects are initialized and deallocated automatically by the class’s destructor when MyArray objects go out of scope, preventing memory leaks. Our MyArray class is not meant to replace standard library class templates array and vector, nor is it meant to mimic their capabilities. It demonstrates key C++ language and library features that you’ll find useful when you build your own classes.
11.6.1 Special Member Functions

Every class you define can have five special member functions, each of which we define in class MyArray:

• a copy constructor,

• a copy assignment operator,

• a move constructor,

• a move assignment operator, and

• a destructor.

The copy constructor and copy assignment operator implement the class’s copy semantics—that is, how to copy a MyArray when it is passed by value to a function, returned by value from a function or assigned to another MyArray. The move constructor and move assignment operator implement the class’s move semantics, which eliminate costly unnecessary copies of objects that are about to be destroyed. We discuss the details of these special member functions as we encounter the need for them throughout this case study.
11.6.2 Using Class MyArray

The program of Figs. 11.3–11.5 demonstrates class MyArray and its rich selection of overloaded operators. The code in Fig. 11.3 tests the various MyArray capabilities. We present the class definition in Fig. 11.4 and each of its member-function definitions in Fig. 11.5. We’ve broken the code and outputs into small segments for discussion purposes. For pedagogic purposes, many of class MyArray’s member functions, including all of special member functions, display output to show when they’re called.
Function getArrayByValue

Later in this program, we’ll call the getArrayByValue function (Fig. 11.3, lines 10–13) to create a local MyArray object by calling MyArray’s constructor that receives an initializer list. Function getArrayByValue returns that local object by value.

Click here to view code image

 1   // fig11_03.cpp
 2   // MyArray class test program.
 3   #include <iostream>
 4   #include <stdexcept>
 5   #include <utility> // for std::move
 6   #include "MyArray.h"
 7   using namespace std;
 8
 9   // function to return a MyArray by value
10   MyArray getArrayByValue() {
11      MyArray localInts{10, 20, 30}; // create three-element MyArray
12      return localInts; // return by value creates an rvalue
13   }
14

Fig. 11.3 | MyArray class test program.
Creating MyArray Objects and Displaying Their Size and Contents

Lines 16–17 create objects ints1 with seven elements and ints2 with 10 elements. Each calls the MyArray constructor that receives the number of elements and initializes the elements to zeros. Lines 20–21 display ints1’s size then output its contents using MyArray’s overloaded stream insertion operator (<<). Lines 24–25 do the same for ints2. Each statement uses << to output two string literals, a size_t and a MyArray object.

Click here to view code image

15   int main() {
16      MyArray ints1(7); // 7-element MyArray; note () rather than {}
17      MyArray ints2(10); // 10-element MyArray; note () rather than {}
18
19      // print ints1 size and contents
20      cout << "\nints1 size: " << ints1.size()
21         << "\ncontents: " << ints1; // uses overloaded <<
22
23      // print ints2 size and contents
24      cout << "\n\nints2 size: " << ints2.size()
25         << "\ncontents: " << ints2; // uses overloaded <<
26

MyArray(size_t) constructor
MyArray(size_t) constructor

ints1 size: 7
contents: {0, 0, 0, 0, 0, 0, 0}

ints2 size: 10
contents: {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

Using Parentheses Rather Than Braces to Call the Constructor

So far, we’ve used braced initializers, {}, to pass arguments to constructors. Lines 16–17 use parentheses, (), to call the MyArray constructor that receives a size. We do this because our class—like the standard library’s array and vector classes—also supports constructing a MyArray from a braced initializer list containing the MyArray’s element values. When the compiler sees a statement like:

MyArray ints1{7};

it invokes the constructor that accepts the braced-initializer list of integers, not the single-argument constructor that receives the size.
Using the Overloaded Stream Extraction Operator to Fill a MyArray

Next, line 28 prompts the user to enter 17 integers. Line 29 uses the MyArray overloaded stream extraction operator (>>) to read the first seven values into ints1 and the remaining 10 values into ints2 (recall that each MyArray knows its own size). Line 31 displays each MyArray’s updated contents using the overloaded stream insertion operator (<<).

Click here to view code image

27   // input and print ints1 and ints2
28   cout << "\n\nEnter 17 integers: ";
29   cin >> ints1 >> ints2; // uses overloaded >>
30
31   cout << "\nints1: " << ints1 << "\nints2: " << ints2;
32

Enter 17 integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17

ints1: {1, 2, 3, 4, 5, 6, 7}
ints2: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}

Using the Overloaded Inequality Operator (!=)

Line 36 tests MyArray’s overloaded inequality operator (!=) by evaluating the condition

ints1 != ints2

20 The program output shows that the MyArray objects are not equal. Two MyArray objects will be equal if they have the same number of elements and their corresponding element values are identical. As you’ll see, we define only MyArray’s overloaded == operator. In C++20, the compiler autogenerates != if you provide an == operator for your type—!= simply returns the opposite of ==.

Click here to view code image

33   // use overloaded inequality (!=) operator
34   cout << "\n\nEvaluating: ints1 != ints2\n";
35
36   if (ints1 != ints2) {
37      cout << "ints1 and ints2 are not equal\n\n";
38   }
39

Evaluating: ints1 != ints2
ints1 and ints2 are not equal

Initializing a New MyArray with a Copy of an Existing MyArray

Line 41 instantiates the MyArray object ints3 and initializes it with a copy of ints1’s data. This invokes the MyArray copy constructor to copy ints1’s elements into ints3. A copy constructor is invoked whenever a copy of an object is needed, such as:

• passing an object by value to a function,

• returning an object by value from a function, or

• initializing an object with a copy of another object of the same class.

Line 44 displays ints3’s size and contents to confirm that ints3’s elements were set correctly by the copy constructor.

Click here to view code image

40   // create MyArray ints3 by copying ints1
41   MyArray ints3{ints1}; // invokes copy constructor
42
43   // print ints3 size and contents
44   cout << "\nints3 size: " << ints3.size() << "\ncontents: " << ints3;
45

MyArray copy constructor

ints3 size: 7
contents: {1, 2, 3, 4, 5, 6, 7}

SEImages 11 When a class such as MyArray contains both a copy constructor and a move constructor, the compiler chooses the correct one to use based on the context. In line 41, the compiler chose MyArray’s copy constructor because variable names, like ints1, are lvalues. As you’ll soon see, a move constructor receives an rvalue reference, which is part of C++11’s move semantics. An rvalue reference may not refer to an lvalue.

The copy constructor can also be invoked by writing line 41 as:

MyArray ints3 = ints1;

In an object’s definition, the equal sign does not indicate assignment. It invokes the single-argument copy constructor, passing as the argument the value to the = symbol’s right.
Using the Overloaded Copy Assignment Operator (=)

SEImages Line 48 assigns ints2 to ints1 to test the overloaded copy assignment operator (=). Builtin arrays cannot handle this assignment. An array’s name is not a modifiable lvalue, so you cannot assign one array’s name to another—such an assignment causes a compilation error. Line 50 displays both objects’ contents to confirm that they’re now identical. MyArray ints1 initially held seven integers, but the overloaded operator resizes the dynamically allocated built-in array to hold a copy of ints2’s 10 elements. As with copy constructors and move constructors, if a class contains both a copy assignment operator and a move assignment operator, the compiler chooses which one to call based on the arguments. In this case, ints2 is a variable and thus an lvalue, so the copy assignment operator is called. Note in the output that line 48 also resulted in calls to the MyArray copy constructor and destructor—you’ll see why when we present the assignment operator’s implementation in Section 11.6.6.

Click here to view code image

46   // use overloaded copy assignment (=) operator
47   cout << "\n\nAssigning ints2 to ints1:\n";
48   ints1 = ints2; // note target MyArray is smaller
49
50   cout << "\nints1: " << ints1 << "\nints2: " << ints2;
51

Assigning ints2 to ints1:
MyArray copy assignment operator
MyArray copy constructor
MyArray destructor

ints1: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}
ints2: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}

Using the Overloaded Equality Operator (==)

Line 55 compares ints1 and ints2 with the overloaded equality operator (==) to confirm they are indeed identical after the assignment in line 48.

Click here to view code image

52   // use overloaded equality (==) operator
53   cout << "\n\nEvaluating: ints1 == ints2\n";
54
55   if (ints1 == ints2) {
56      cout << "ints1 and ints2 are equal\n\n";
57   }
58

Evaluating: ints1 == ints2
ints1 and ints2 are equal

Using the Overloaded Subscript Operator ([])

Line 60 uses the overloaded subscript operator ([]) to refer to ints1[5]—an in-range element of ints1. This indexed (subscripted) name is used to get the value stored in ints1[5]. Line 64 uses ints1[5] on an assignment’s left side as a modifiable lvalue11 to assign a new value, 1000, to element 5 of ints1. We’ll see that operator[] returns a reference to use as the modifiable lvalue after confirming 5 is a valid index. Line 70 attempts to assign 1000 to ints1[15]. This index is outside int1’s bounds, so the overloaded operator[] throws an out_of_range exception. Lines 72–74 catch the exception and display its error message by calling the exception’s what member function.

11. Recall that an lvalue can be declared const, in which case it would not be modifiable.

Click here to view code image

59   // use overloaded subscript operator to create an rvalue
60   cout << "ints1[5] is " << ints1[5];
61
62   // use overloaded subscript operator to create an lvalue
63   cout << "\n\nAssigning 1000 to ints1[5]\n";
64   ints1[5] = 1000;
65   cout << "ints1: " << ints1;
66
67   // attempt to use out-of-range subscript
68   try {
69      cout << "\n\nAttempt to assign 1000 to ints1[15]\n";
70      ints1[15] = 1000; // ERROR: subscript out of range
71   }
72   catch (const out_of_range& ex) {
73      cout << "An exception occurred: " << ex.what() << "\n";
74   }
75

ints1[5] is 13

Assigning 1000 to ints1[5]
ints1: {8, 9, 10, 11, 12, 1000, 14, 15, 16, 17}

Attempt to assign 1000 to ints1[15]
An exception occurred: Index out of range

The array subscript operator [] is not restricted for use only with arrays. It also can be used, for example, to select elements from other kinds of container classes that maintain collections of items, such as strings (collections of characters) and maps (collections of key-value pairs, which we’ll discuss in Chapter 13, Standard Library Containers and Iterators). Also, when overloaded operator[] functions are defined, indices are not required to be integers. In Chapter 13, we discuss the standard library map class that allows indices of other types, such as strings.
Creating MyArray ints4 and Initializing It With the MyArray Returned By Function getArrayByValue

Line 79 initializes MyArray ints4 with the result of calling function getArrayByValue (lines 10–13), which creates a local MyArray containing 10, 20 and 30, then returns it by value. Then, line 81 displays the new MyArray’s size and contents.

Click here to view code image

76   // initialize ints4 with contents of the MyArray returned by
77   // getArrayByValue; print size and contents
78   cout << "\nInitialize ints4 with temporary MyArray object\n";
79   MyArray ints4{getArrayByValue()};
80
81   cout << "\nints4 size: " << ints4.size() << "\ncontents: " << ints4;
82

Initialize ints4 with temporary MyArray object
MyArray(initializer_list) constructor

ints4 size: 3
contents: {10, 20, 30}

Named Return Value Optimization (NRVO)

Recall from function getArrayByValue’s definition (lines 10–13) that it creates and initializes a local MyArray using the constructor that receives an initializer_list of int values (line 11). This constructor displays

Click here to view code image

MyArray(initializer_list) constructor

each time it’s called. Next, getArrayByValue returns that local array by value (line 12). You might expect that returning an object by value would make a temporary copy of the object for use in the caller. If it did this would call MyArray’s copy constructor to copy the local MyArray. You also might expect the local MyArray object to go out of scope and have its destructor called as getArrayByValue returns to its caller. However, neither the copy constructor nor the destructor displayed lines of output here.

PerfImages 17 This is due to a compiler performance optimization called named return value optimization (NRVO). When the compiler sees that a local object is constructed, returned from a function by value then used to initialize an object in the caller, the compiler instead constructs the object directly in the caller where it will be used, eliminating the temporary object and extra constructor and destructor calls mentioned above. Prior to C++17 this was an optional optimization, but this optimization is required as of C++17.12,13

12. Sy Brand. “Guaranteed Copy Elision Does Not Elide Copies.” C++ Team Blog, February 18, 2019. Accessed February, 24, 2021. https://devblogs.microsoft.com/cppblog/guaranteed-copy-elision-does-not-elide-copies/.

13. Richard Smith, “Guaranteed copy elision through simplified value categories,” September 27, 2015. Accessed February 24, 2021. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html.
Creating MyArray ints5 and Initializing It With the rvalue Returned By Function std::move

A copy constructor is called when you initialize one MyArray with another that’s represented by an lvalue. A copy constructor copies its arguments contents. This is similar to a copy-and-paste operation in a text editor—after the operation, you have two copies of the data.

PerfImages C++ also supports move semantics,14 which help the compiler eliminate the overhead of unnecessarily copying objects. A move is similar to a cut-and-paste operation in a text editor—the data gets moved from the cut location to the paste location. A move constructor moves into a new object the resources of an object that’s no longer needed. Such a constructor receives a C++11 rvalue reference, which you’ll see is declared with TypeName&&. Rvalue references may refer only to rvalues. Typically, these are temporary objects or objects that are about to be destroyed—called expiring values or xvalues.

14. Klaus Iglberger, “Back to Basics: Move Semantics,” YouTube Video, June 16, 2019, https://www.youtube.com/watch?v=St0MNEU5b0o.

11 Line 86 uses class MyArray’s move constructor to initialize MyArray ints5, then line 88 displays the size and contents of the new MyArray. The object ints4 is an lvalue—so it cannot be passed directly to MyArray’s move constructor. If you no longer need an object’s resources, you can convert it from an lvalue to an rvalue reference by passing the object to the C++11 standard library function std::move (from header <utility>). This function casts its argument to an rvalue reference,15 telling the compiler that ints4’s contents are no longer needed. So, line 86 forces MyArray’s move constructor to be called and ints4’s contents are moved into ints5.

15. More specifically, this is called xvalue (for expiring value).

Click here to view code image

83   // convert ints4 to an rvalue reference with std::move and
84   // use the result to initialize MyArray ints5
85   cout << "\n\nInitialize ints5 with the result of std::move(ints4)\n";
86   MyArray ints5{std::move(ints4)}; // invokes move constructor
87
88   cout << "\nints5 size: " << ints5.size() << "\ncontents: " << ints5;
89   cout << "\n\nSize of ints4 is now: " << ints4.size();
90

Initialize ints5 with the result of std::move(ints4)
MyArray move constructor

ints5 size: 3
contents: {10, 20, 30}

Size of ints4 is now: 0

It’s recommended that you use std::move as shown here only if you know the source object passed to std::move will never be used again. Once an object has been moved, two valid operations can be performed with it:

• destroying it, and

• using it on the left side of an assignment to give it a new value.

In general, you should not call member functions on a moved-from object. We do so in line 89 only to prove that the move constructor indeed moved ints4’s resources—the output shows that ints4’s size is now 0.
Assigning MyArray ints5 to ints4 with the Move Assignment Operator

Lines 93 and 95 use class MyArray’s move assignment operator to move ints5’s contents (10, 20 and 30) back into ints4 then display the size and contents of ints4. Line 93 explicitly converts the lvalue ints5 to an rvalue reference using std::move. This indicates that ints5 no longer needs its resources, so the compiler can move them into ints4. In this case, the compiler calls MyArray’s move assignment operator. For demo purposes only, we output ints5’s size to show that the move assignment operator indeed moved its resources. Again, you should not call member functions on a moved-from object.

Click here to view code image

91   // move contents of ints5 into ints4
92   cout << "\n\nMove ints5 into ints4 via move assignment\n";
93   ints4 = std::move(ints5); // invokes move assignment
94
95   cout << "\nints4 size: " << ints4.size() << "\ncontents: " << ints4;
96   cout << "\n\nSize of ints5 is now: " << ints5.size();
97

Move ints5 into ints4 via move assignment
MyArray move assignment operator

ints4 size: 3
contents: {10, 20, 30}

Size of ints5 is now: 0

Converting MyArray ints5 to a bool to Test Whether It’s Empty

Many programming languages allow you to use a container-class object like a MyArray as a condition to determine whether the container has elements. For class MyArray, we defined a bool conversion operator that returns true if the MyArray object contains elements (i.e., its size is greater than 0) and false otherwise. In contexts that require bool values, such as control statement conditions, C++ can invoke an object’s bool conversion operator implicitly. This is known as a contextual conversion. Line 99 uses the MyArray ints5 as a condition, which calls MyArray’s bool conversion operator. Since we just moved ints5’s resources into ints4, ints5 is now empty, and the operator returns false. Once again, you should not call member functions on moved-from objects—we do so here only to prove that ints5’s resources have been moved.

Click here to view code image

98   // check if ints5 is empty by contextually converting it to a bool
99   if (ints5) {
100      cout << "\n\nints5 contains elements\n";
101  }
102  else {
103     cout << "\n\nints5 is empty\n";
104  }
105

ints5 is empty

Preincrementing Every ints4 Element with the Overloaded ++ Operator

Some libraries support “broadcast” operations that apply the same operation to every element of a data structure. For example, consider the popular high-performance Python programming language library NumPy. This library’s ndarray (n-dimensional array) data structure overloads many arithmetic operators. They conveniently perform mathematical operations on every element of an ndarray. In NumPy, the following Python code adds one to every element of the ndarray named numbers (no iteration statement is required):

Click here to view code image

numbers += 1 # Python does not have a ++ operator

To demonstrate preincrement and postincrement, we’ve added a similar capability to class MyArray. Line 107 displays ints4’s current contents, then line 108 uses the expression ++ints4 to preincrement the entire MyArray, by adding one to every element. This expression’s result is the updated MyArray. We then use MyArray’s overloaded stream insertion operator (<<) to display the contents.

Click here to view code image

106   // add one to every element of ints4 using preincrement
107   cout << "\nints4: " << ints4;
108   cout << "\npreincrementing ints4: " << ++ints4;
109

ints4: {10, 20, 30}
preincrementing ints4: {11, 21, 31}

Postincrementing Every ints4 Element with the Overloaded ++ Operator

Line 111 postincrements the entire MyArray with the expression ints4++. Recall that a postincrement returns its operand’s previous value, as confirmed by the program’s output. The outputs showing that MyArray’s copy constructor and destructor were called are from the postincrement operator’s implementation, which we’ll discuss in Section 11.6.14.

Click here to view code image

110   // add one to every element of ints4 using postincrement
111   cout << "\n\npostincrementing ints4: " << ints4++ << "\n";
112   cout << "\nints4 now contains: " << ints4;
113

postincrementing ints4: MyArray copy constructor
{11, 21, 31}
MyArray destructor

ints4 now contains: {12, 22, 32}

Adding a Value to Every ints4 Element with the Overloaded += Operator

Class MyArray also provides a broadcast-based overloaded addition assignment operator (+=) for adding an int value to every MyArray element. Line 115 adds 7 to every ints4 element then displays its new contents. Note that the non-overloaded versions of ++ and += still work on individual MyArray elements too—those are simply int values.

Click here to view code image

114      // add a value to every element of ints4 using +=
115      cout << "\n\nAdd 7 to every ints4 element: " << (ints4 += 7) << "\n\n";
116   }

Add 7 to every ints4 element: {19, 29, 39}

Destroying the MyArray Objects That Remain

When function main terminates, the destructors are called for the five MyArray objects created in main, producing the last five lines of the program’s output.

MyArray destructor
MyArray destructor
MyArray destructor
MyArray destructor
MyArray destructor

11.6.3 MyArray Class Definition

Now, let’s walk through MyArray’s header (Fig. 11.4). As we refer to each member function in the header, we discuss that function’s implementation in Fig. 11.5. We’ve broken the member-function implementation file into small segments for discussion purposes.

In Fig. 11.4, lines 53–54 declare MyArray’s private data members:

• m_size stores its number of elements, and

• m_ptr is a unique_ptr that manages a dynamically allocated pointer-based int array containing the MyArray object’s elements. When a MyArray goes out of scope, its destructor will call the unique_ptr’s destructor which will automatically delete the dynamically allocated memory.

Throughout this class’s member-function implementations, we use some of C++’s declarative, functional-style programming capabilities discussed in Chapters 6 and 7. We also introduce three additional standard library algorithms—copy, for_each and equal.

Click here to view code image

 1   // Fig. 11.4: MyArray.h
 2   // MyArray class definition with overloaded operators.
 3   #pragma once
 4   #include <initializer_list>
 5   #include <iostream>
 6   #include <memory>
 7
 8   class MyArray final {
 9      // overloaded stream extraction operator
10      friend std::istream& operator>>(std::istream& in, MyArray& a);
11
12      // used by copy assignment operator to implement copy-and-swap idiom
13      friend void swap(MyArray& a, MyArray& b) noexcept;
14
15   public:
16      explicit MyArray(size_t size); // construct a MyArray of size elements
17
18      // construct a MyArray with a braced-initializer list of ints
19      explicit MyArray(std::initializer_list<int> list);
20
21      MyArray(const MyArray& original); // copy constructor
22      MyArray& operator=(const MyArray& right); // copy assignment operator
23
24      MyArray(MyArray&& original) noexcept; // move constructor
25      MyArray& operator=(MyArray&& right) noexcept; // move assignment
26
27      ~MyArray(); // destructor
28
29      size_t size() const noexcept {return m_size;}; // return size
30      std::string toString() const; // create string representation
31
32      // equality operator
33      bool operator==(const MyArray& right) const noexcept;
34
35      // subscript operator for non-const objects returns modifiable lvalue
36      int& operator[](size_t index);
37
38      // subscript operator for const objects returns non-modifiable lvalue
39      const int& operator[](size_t index) const;
40
41      // convert MyArray to a bool value: true if non-empty; false if empty
42      explicit operator bool() const noexcept {return size() != 0;}
43
44      // preincrement every element, then return updated MyArray
45      MyArray& operator++();
46
47      // postincrement every element, and return copy of original MyArray
48      MyArray operator++(int);
49
50      // add value to every element, then return updated MyArray
51      MyArray& operator+=(int value);
52   private:
53      size_t m_size{0}; // pointer-based array size
54      std::unique_ptr<int[]> m_ptr; // smart pointer to integer array
55   };
56
57   // overloaded operator<< is not a friend--does not access private data
58   std::ostream& operator<<(std::ostream& out, const MyArray& a);

- Move Operations Should Be noexcept
- Implementing the Stream Insertion Operator
158   // overloaded output operator for class MyArray
159   ostream& operator<<(ostream& out, const MyArray& a) {
160      out << a.toString();
161      return out; // enables cout << x << y;
162   }
163

- C++20 Three-Way Comparison Operator (<=>)

The default compiler-generated operator<=> works for any class containing data members that all support the equality and relational operators.

 1   // fig11_06.cpp
 2   // C++20 three-way comparison (spaceship) operator.
 3   #include <compare>
 4   #include <iostream>
 5   #include <string>
 6   #include "fmt/format.h"
 7   using namespace std;
 8
 9   class Time {
10   public:
11      Time(int hr, int min, int sec) noexcept
12         : m_hr{hr}, m_min{min}, m_sec{sec} {}
13
14      string toString() const {
15         return fmt::format("hr={}, min={}, sec={}", m_hr, m_min, m_sec);
16   }
17
18      // <=> operator automatically supports equality/relational operators
19      auto operator<=>(const Time& t) const noexcept = default;
20   private:
21      int m_hr{0};
22      int m_min{0};
23      int m_sec{0};
24   };
25
26   int main() {
27      const Time t1(12, 15, 30);
28      const Time t2(12, 15, 30);
29      const Time t3(6, 30, 0);
30
31      cout << fmt::format("t1: {}\nt2: {}\nt3: {}\n\n",
32                 t1.toString(), t2.toString(), t3.toString());
33



# Exceptions and a look forward to constracts 
- exception handling 

30        try {
31           double result{quotient(number1, number2)};
32           std::cout << fmt::format("The quotient is: {}\n", result);
33        }
34        catch (const DivideByZeroException& divideByZeroException) {
35           std::cout << fmt::format("Exception occurred: {}\n",
36              divideByZeroException.what());
37        }




















