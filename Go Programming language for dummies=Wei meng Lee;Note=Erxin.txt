Go Programming language for dummies=Wei meng Lee;Note=Erxin


# Hello go 
- os environment 

$ go env

- first program 

```
package main
 
import (
    "fmt"
    "time"
)

func displayTime() {
    fmt.Println(time.Now())
}
```



# Works with different data type 
- define type 

var num1 = 5            // type inferred

- comment 
 double-slash (//) is a comment. 
 
- Explicitly typed variables

var num1 = 5            // type inferred
var num2 int            // explicitly typed

var num3 float32     // floating point variable
var name string      // string variable
var raining bool     // boolean variable
 
fmt.Println(num3)    // 0
fmt.Println(name)    // "" (empty string)
fmt.Println(raining) // false

- short variable declaration operator 

firstName := "Wei-Meng"

firstName, lastName, age := "Wei-Meng", "Lee", 25

var firstName, lastName string = "Wei-Meng", "Lee"


var (
    firstName string = "Wei-Meng"
    lastName  string = "Lee"
    age       int    = 25
)

- const 
 
const publisher = "Wiley"

- unused variable to a blank identifier (_), like this: 

var num1 = 5
_ = num1  // The compiler is now happy!

- string escape 

such as \n or \t), as shown in the following example:
```

address := "The White House\n1600 Pennsylvania Avenue
NW\nWashington, DC 20500"
```

- length 

fmt.Println(len(str1))  // 15 = 5 chars * 3 bytes

count the number of characters (runes) in a string, use the RuneCountInString() function:

fmt.Println(utf8.RuneCountInString(str1)) // 5

- tools 

Chinese characters to their Unicode representations at www.chineseconverter.com/en/convert/unicode.

- Use the %T printing verb in the Printf() function. It looks like this:

fmt.Printf("%T\n", start)        // time.Time

- Use the reflect package. The reflect package allows you to find out the data type of a variable

fmt.Println(reflect.TypeOf(start))         // time.Time
fmt.Println(reflect.ValueOf(start).Kind()) // struct

- convert a variable's type 

var age int
fmt.Print("Please enter your age: ")
fmt.Scanf("%d", &age)
fmt.Println("You entered:", age)

- run  program works as expected:

$ go run main.go

- strconv package's Atoi() function to try to convert the string into an integer value:

age, err := strconv.Atoi(input) // convert string to
                                // int
								
- check if the err variable contains a nil value								

if err != nil {        // an error occurred
    fmt.Println(err)
} else {
    fmt.Println("Your age is:", age)
}

b, err := strconv.ParseBool("t")
fmt.Println(b)        // true
fmt.Println(err)      // <nil>
fmt.Printf("%T\n", b) // bool

- Interpolating strings

onvert the integer variable value to string and then concatenate them:

s := name + ", your queue number is:" +
    strconv.Itoa(queue)

Sprintf() function from the fmt package:

s := fmt.Sprintf("%s, your queue number is %d",
    name, queue)


# Making decisions with if/else 
- example 
num := 6
condition := num % 2 == 0

logical expression:

num % 2 == 0

- comparison operators in go 

```
Operator		Description			Example

==				Equal to			num == 0

!=				Not equal to		num != 0

<				Less than			num < 0

<=				Less than or equal to 	num <= 0

>				Greater than		num > 0

>=				Greater than or equal to	num >= 0

&&	Logical AND operator. Both operands must be true in order for the condition to evaluate to true.	x && y
||
! 
```

- if 

if num % 2 == 1 {
    fmt.Println("Number is odd")
} else {
    fmt.Println("Number is even")
}

- functions 

func raining() bool {
    fmt.Println("Check if it is raining now…")
    return true
}
 
func snowing() bool {
    fmt.Println("Check if it is snowing now…")
    return true
}

if raining() || snowing() {
    fmt.Println("Stay indoors!")
}
/*
Check if it is raining now…
Stay indoors!
*/


- switch 

	+ default switch statement:

num := 5
dayOfWeek := ""
switch num {
case 1:
dayOfWeek = "Monday"
case 2:
    dayOfWeek = "Tuesday"
case 3:
    dayOfWeek = "Wednesday"
case 4:
    dayOfWeek = "Thursday"
case 5:
    dayOfWeek = "Friday"
case 6:
    dayOfWeek = "Saturday"
case 7:
    dayOfWeek = "Sunday"
default:
    dayOfWeek = "--error--"
}
 
fmt.Println(dayOfWeek) // Friday

When a block of statements is executed, control is immediately transferred out of the switch statement.

	+ multiple cases 
switch num {
    case 1:
        dayOfWeek = "Monday"
        fmt.Println("Monday blues…")
 
    case 2: dayOfWeek = "Tuesday"
    case 3: dayOfWeek = "Wednesday"
    case 4: dayOfWeek = "Thursday"
    case 5:
        dayOfWeek = "Friday"
        fmt.Println("TGIF!!!")
 
    case 6: dayOfWeek = "Saturday"
    case 7: dayOfWeek = "Sunday"
    default:
}


	+ switch statement with the fallthrough keyword, don't want to out of switch after execute a block 
	
// grade scores A, B, C, or D, you print Passed. If he scores F, you print Failed.
grade := "C"
switch grade {
    case "A":
        fallthrough
    case "B":
        fallthrough
    case "C":
        fallthrough
    case "D":
        fmt.Println("Passed")
    case "F":
        fmt.Println("Failed")
    default:
        fmt.Println("Absent")
}
	
	+ mutiple cases
grade := "C"
switch grade {
    case "A", "B", "C", "D":
        fmt.Println("Passed")
    case "F":
        fmt.Println("Failed")
    default:
        fmt.Println("Undefined")
}
	
score := 79
grade := ""
switch {
    case score < 50: grade = "F"
    case score < 60: grade = "D"
    case score < 70: grade = "C"
    case score < 80: grade = "B"
    default: grade = "A"
}
fmt.Println(grade)    // B	
	
	
	
# Using loops 
-  looping — while, do…while, and for — Go has only one looping construct

for (init; condition; post) {
}

func main() {
    for i:=0; i<5; i++ {
        fmt.Println(i)
    }
}


num++  // post-increment operator
++num  // pre-increment operator
num--  // post-decrement operator
--num  // pre-decrement operator

- fibonacci numbers 

max := 100
a, b := 0, 1
for ;b <= max; {
    println(b)
    a, b = b, a+b
}


- repeatedly waits for the user to input a string, until the user enters the string QUIT:

package main
 
import (
    "fmt"
    "strings"
)
 
func main() {
    for {
        fmt.Println("Enter QUIT to exit")
        var input string
        fmt.Print("Please enter a string:")
        fmt.Scanln(&input)
        if strings.ToUpper(input) == "QUIT" {
            break
        }
    }
}

$ go run main.go

- an array of three elements:

var OS [3]string
OS[0] = "iOS"
OS[1] = "Android"
OS[2] = "Windows"

for i, v := range OS {
    fmt.Println(i, v)
}

i: The index of the value you're accessing — in this case, the value is the OS array.
v: Each of the values in the OS array.

- the continue or the break statement only affects the current for loop

- define function 

func displayDate() {
    fmt.Println(time.Now().Date())
}

func displayDate(format string) {
    fmt.Println(time.Now().Format(format))
}

func swap(a, b int) {
    a, b = b, a
}

	+ passing value by pointer You can modify the parameters in the swap() function to take in pointers to int instead, like this: 

func swap(a, b *int) {
    *a, *b = *b, *a
}

x := 5
y := 6
swap(&x, &y)
fmt.Println(x, y) // 6 5

- return 

func addNum(num1, num2 int) int {  // returns int
    return num1 + num2
}

	+ returning results with a pair of parentheses, like this:

func countOddEven(s string) (int,int) {
    odds, evens := 0,0
    for _, c := range s {
        if int(c) % 2 == 0 {
            evens++
        } else {
            odds++
        }
    }
    return odds,evens
}


	+ naming return, the returning variable is named sum. This variable is used within the function and at the end of the function. The return statement without any argument will return the value of this variable. 

func addNum(num1 int, num2 int) (sum int) {
    sum = num1 + num2
    return  // you can still use "return sum"
}

- define a function that accepts a variable number of arguments, you use ellipses (…), like this:

func addNums(nums … int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

a fixed parameter together with a variadic parameter:

func addNums(total int, nums …int) int {
    fmt.Printf("%T", nums)
    for _, n := range nums {
        total += n
    }
    return total
}

- an anonymous function

```
package main
 
import "fmt"
 
func main() {
    var i func() int
}2
```

```
func doSomething() int {
    return 5
}
 
func main() {
    var i func() int
    i = doSomething
}

//assign it an anonymous function, like this:

var i func() int
i = func() int {
    return 5
}
```

- implement closure with anonymous functions 

func fib() func() int {
    f1 := 0
    f2 := 1
    return func() int {
        f1, f2 = f2, (f1 + f2)
        return f1
    }
}

- example 

func filter(arr []int, cond func(int) bool) []int {
    result := []int{}
    for _, v := range arr {
        if cond(v) {
            result = append(result, v)
        }
    }
    return result
}

// change the condition in the anonymous function:

func main() {
    a := []int{1, 2, 3, 4, 5}
    evens := filter(a,
        func(val int) bool {
            return val > 3
        })
    fmt.Println(evens)
}


# Working with data structures 
- array 

var array_name [size_of_array]data_type

var nums [5]int   // an array of int (5 elements)
fmt.Println(nums) // [0 0 0 0 0]

	+ initializing array 
	
nums := [5]int{1, 2, 3, 4, 5}
fmt.Println(nums)

	+ omit the length of the size by using the … notation:

nums := […]int{1, 2, 3, 4, 5}

- multi dimensional array 

```
var table [5][6]string
for row := 0; row < 5; row++ {
    for column := 0; column < 6; column++ {
        table[row][column] =
            strconv.Itoa(row) + "," +
                strconv.Itoa(column)
    }
}
fmt.Println(table)
```

- A slice is represented by a slice header, which contains three fields:

ptr: A pointer that points to the address of the underlying array
len: The length of the slice
cap: The capacity, or maximum number of allowed elements in the array

slice s, you use the len() and cap() functions, respectively

- append item to array 

append an item to a slice, you use the append() function:

t = append(t, 6, 7, 8)

- slice 

// slice from 1:3, then your capacity will change (see Figure 6-15).

t = t[1:3]
fmt.Println(t)       // [2 3]
fmt.Println(len(t))  // 2
fmt.Println(cap(t))  // 4

// can make a copy of this slice, you need to create a slice of the same size:
v := make([]int, len(t))

// create copy of slices, use the copy() function. The copy() function has the following syntax:
copy(destination, source)

- inserting an item 

func insert(orig []int, index int, value int)
    ([]int, error) {
    if index < 0 {
        return nil, errors.New(
            "Index cannot be less than 0")
    }
 
    if index >= len(orig) {
        return append(orig, value), nil
    }
 
    orig = append(orig[:index+1], orig[index:]…)
    orig[index] = value
    return orig, nil
}


func delete(orig []int, index int) ([]int, error) {
    if index < 0 || index >= len(orig) {
        return nil, errors.New("Index out of range")
    }
    orig = append(orig[:index], orig[index+1:]…)
    return orig, nil
}


- define a structure 

package main
 
import "fmt"
 
type point struct {
    x float32
    y float32
    z float32
}
 
func main() {
    var pt1 point
    pt1.x = 3.1
    pt1.y = 5.7
    pt1.z = 4.2
}

pt2 := point{x: 5.6, y: 3.8, z: 6.9}

- constructure 

func newPoint(x, y, z float32) *point {
    p := point{x: x, y: y, z: z}
    return &p
}

- make a copy of structure 

The result from the newPoint() function (pt4 in the preceding example) is a pointer to a struct. If you try to assign pt4 to another variable — say, pt

create an independent copy of pt4, you need to use the * character, like this: 
pt6 := *pt4

create a reference to a struct — say, pt7 — you use the & prefix
pt8 := &pt7

- define function for structure 

```
import (
    "fmt"
    "math"
)
 
type point struct {
    x float32
    y float32
    z float32
}
 
func (p point) length() float64 {
    return math.Sqrt(
        (math.Pow(float64(p.x), 2) +
            math.Pow(float64(p.y), 2) +
            math.Pow(float64(p.z), 2)))
}
 
func newPoint(x, y, z float32) *point {
    p := point{x: x, y: y, z: z}
    return &p
}


func (p *point) move(deltax, deltay, deltaz float32) {
    p.x += deltax
    p.y += deltay
    p.z += deltaz
}
```

- comparing structure 

pt1 := point{x: 5.6, y: 3.8, z: 6.9}
pt2 := point{x: 5.6, y: 3.8, z: 6.9}
pt3 := point{x: 6.5, y: 3.8, z: 6.9}
 
fmt.Println(pt1 == pt2) // true
fmt.Println(pt2 == pt3) // false

You can't directly compare structs that contain fields that aren’t comparable, but you can use the cmp package (https://pkg.go.dev/github.com/google/go-cmp/cmp) to do that2

```
package main
 
import (
    "fmt"
    "github.com/google/go-cmp/cmp"
)
 
type Point struct {
    X    float32
    Y    float32
    Z    float32
    Name []string
}
 
func main() {
    pt1 := Point{X: 5.6, Y: 3.8, Z: 6.9,
             Name: []string{"pt1"}}
    pt2 := Point{X: 5.6, Y: 3.8, Z: 6.9,
             Name: []string{"pt"}}
    pt3 := Point{X: 5.6, Y: 3.8, Z: 6.9,
             Name: []string{"pt"}}
 
    fmt.Println(cmp.Equal(pt1, pt2)) // false
    fmt.Println(cmp.Equal(pt2, pt3)) // true
}
```

- establishing relationships suing maps 

map[keyType] valueType

heights = make(map[string]int)
heights["Peter"] = 170

- initializing a map with a map literal 

make() function to initialize a map variable

heights := map[string]int{
    "Peter": 170,
    "Joan":  168,
    "Jan":   175,   // <-- note the comma here
}

if v, ok := heights["Jim"]; ok {
    fmt.Println(v)
} else {
    fmt.Println("Key does not exist")
}

delete(map, key)2

getting the number of items in a map 

fmt.Println(len(heights))

- get all the keys in a map 

// get all the keys in map
var keys []string
for k := range heights {
    keys = append(keys, k)
}
fmt.Println(keys) // [Jan Peter Joan]

- define map functions 

```
package main
 
import (
    "fmt"
    "sort"
)
 
type kv struct {
    key   string
    value int
}
 
type kvPairs []kv
 
var heights map[string]int
 
func (p kvPairs) Len() int {
    // returns the length of the collection
    return len(p)
}
 
func (p kvPairs) Less(i, j int) bool {
    // indicates the first value (height) must be smaller
    // than the second value
    return p[i].value < p[j].value
}
 
func (p kvPairs) Swap(i, j int) {
    // swaps the items in the collection
    p[i], p[j] = p[j], p[i]
}
```

- creating a map of structs

```
type dob struct {
    day   int
    month int
    year  int
}
 
type people struct {
    name  string
    email string
    dob   dob
}

package main
 
import "fmt"
 
type dob struct {
    day   int
    month int
    year  int
}
 
type people struct {
    name  string
    email string
    dob   dob
}
 
var members map[int]people
 
func main() {
    members = make(map[int]people)
 
    members[1] = people{
        name:  "Mary Smith",
        email: "marysmith@example.com",
        dob: dob{
            day:   17,
            month: 3,
            year:  1990,
        },
    }
    members[2] = people{
        name:  "John Smith",
        email: "johnsmith@example.com",
        dob: dob{
            day:   9,
            month: 12,
            year:  1988,
        },
    }
    members[3] = people{
        name:  "Janet Doe",
        email: "janetdoe@example.com",
        dob: dob{
            day:   1,
            month: 12,
            year:  1988,
        },
    }
    members[4] = people{
        name:  "Adam Jones",
        email: "adamjones@example.com",
        dob: dob{
            day:   19,
            month: 8,
            year:  2001,
        },
    }
}

for k, v := range members {
    fmt.Println(k, v.name, v.email, v.dob)
}
```


- sort a slice use the SliceStable() function from the sort package. The SliceStable() function has the following signature:

func SliceStable(slice interface{},
                 less func(i, j int) bool)



- Encoding and decoding data using JSON 

JSON supports the following data types:

Object
String
Boolean
Number
Array
null

- using json package 

package main
 
import (
    "encoding/json"
    "fmt"
)

type People struct {
    Firstname string
    Lastname  string
}

func main() {
    var person People
 
    jsonString := `{"firstname":"Wei-Meng",
                    "lastname":"Lee"}`
 
    err := json.Unmarshal([]byte(jsonString), &person)
    if err == nil {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
    } else {
        fmt.Println(err)
    }
}

- decoding json to arrays 

[
    {
        "firstname":"Wei-Meng",
        "lastname":"Lee"
    },
    {
        "firstname":"Mickey",
        "lastname":"Mouse"
    }
]

func main() {
    var persons []People
    jsonString :=
        `[
            {
                "firstname":"Wei-Meng",
                "lastname":"Lee"
            },
            {
                "firstname":"Mickey",
                "lastname":"Mouse"
            }
        ]`
 
    json.Unmarshal([]byte(jsonString), &persons)
 
    for _, person := range persons {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
    }
}

type Rates struct {
    Base   string `json:"base currency"`
    Symbol string `json:"destination currency"`
}

- decoding json to struct 

```
package main
 
import (
    "encoding/json"
    "fmt"
)

func main() {
    var person People
 
    jsonString := `{"firstname":"Wei-Meng",
                    "lastname":"Lee"}`
 
    err := json.Unmarshal([]byte(jsonString), &person)
    if err == nil {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
    } else {
        fmt.Println(err)
    }
}
```

- decoding objects 

```
package main
 
import (
    "encoding/json"
    "fmt"
)
 
type People struct {
    Firstname string
    Lastname  string
    Details   struct {
        Height int
        Weight float32
    }
}
 
func main() {
    var persons []People
    jsonString :=
        `[
            {
                "firstname":"Wei-Meng",
                "lastname":"Lee",
                "details": {
                    "height":175,
                    "weight":70.0
                }
            },
            {
                "firstname":"Mickey",
                "lastname":"Mouse",
                "details": {
                    "height":105,
                    "weight":85.5
                }
            }
        ]`
 
    json.Unmarshal([]byte(jsonString), &persons)
 
    for _, person := range persons {
        fmt.Println(person.Firstname)
        fmt.Println(person.Lastname)
        fmt.Println(person.Details.Height)
        fmt.Println(person.Details.Weight)
    }
}
```

- mapping unstructured data 
```
package main
 
import (
    "encoding/json"
    "fmt"
)
 
func main() {
    jsonString :=
        `{
            "success": true,
            "timestamp": 1588779306,
            "base": "EUR",
            "date": "2020-05-06",
            "rates": {
                "AUD": 1.683349,
                "CAD": 1.528643,
                "GBP": 0.874757,
                "SGD": 1.534513,
                "USD": 1.080054
            }
        }`
 
    var result map[string]interface{}
 
    json.Unmarshal([]byte(jsonString), &result)
    fmt.Println(result["success"]) // true
 
    rates := result["rates"]
    fmt.Println(rates)
    // map[USD:1.080054 AUD:1.683349 CAD:1.528643
    //     GBP:0.874757 SGD:1.534513]
 
    currencies := rates.(map[string]interface{})
    SGD := currencies["SGD"]
    fmt.Println(SGD)
    // 1.534513
}
```

The following statement indicates that result is a variable of type map, with key of type string, and value of type interface (which can be of any type)

- encoding to json 
```
package main
 
import (
    "encoding/json"
    "fmt"
    "time"
)
 
type Name struct {
    FirstName string
    LastName  string
}
 
type Address struct {
    Line1 string
    Line2 string
    Line3 string
}
 
type Customer struct {
    Name    Name
    Email   string
    Address Address
    DOB     time.Time
}
 
func main() {
 
    layoutISO := "2006-01-02"
    dob, _ := time.Parse(layoutISO, "2010-01-18")
 
    john := Customer{
                Name: Name{ FirstName: "John",
                            LastName: "Smith",
                          },
                Email: "johnsmith@example.com",
                Address: Address{
                     Line1: "The White House",
                     Line2: "1600 Pennsylvania Avenue NW",
                     Line3: "Washington, DC 20500",
                },
                DOB: dob,
    }
 
    johnJSON, err := json.Marshal(john)
    if err == nil {
        fmt.Println(string(johnJSON))
    } else {
        fmt.Println(err)
    }
}

```

- encoding interfaces to json 
```
package main
 
import (
    "encoding/json"
    "fmt"
    "time"
)
 
type Customer map[string]interface{}
type Name map[string]interface{}
type Address map[string]interface{}
 
func main() {
    layoutISO := "2006-01-02"
    dob, _ := time.Parse(layoutISO, "2010-01-18")
 
    john := Customer{
                "Name": Name{
                     "FirstName": "John",
                     "LastName": "Smith",
                },
                "Email": "johnsmith@example.com",
                "Address": Address{
                   "Line1": "The White House",
                   "Line2": "1600 Pennsylvania Avenue NW",
                   "Line3": "Washington, DC 20500",
                },
                "DOB":     dob,
            }
 
    johnJSON, err := json.MarshalIndent(john, "", "    ")
    if err == nil {
        fmt.Println(string(johnJSON))
    } else {
        fmt.Println(err)
    }
}
```

- defining method signatures using interfaces 

```
package main
 
import (
    "fmt"
)
 
type DigitsCounter interface {
}
 
func main() {
 
}
```

	+ implementing an interface 
```	
package main
 
import (
    "fmt"
)
 
type DigitsCounter interface {
    CountOddEven() (int, int)
}
 
type DigitString string

// DigitString implements DigitsCounter
func (ds DigitString) CountOddEven() (int, int) {
    odds, evens := 0, 0
    for _, digit := range ds {
        if digit%2 == 0 {
            evens++
        } else {
            odds++
        }
    }
    return odds, evens
}

s := DigitString("123456789")
var d DigitsCounter
d = s
fmt.Println(d.CountOddEven())  // 5 4
```

- how use interface 

```
type Circle struct {
    radius float64
    name   string
}
 
type Square struct {
    length float64
    name   string
}

type Shape interface {
    Area() float64
}

// Circle implements Shape
func (c Circle) Area() float64 {
    return math.Pi * math.Pow(c.radius, 2)
}

// Square implements Shape
func (s Square) Area() float64 {
    return math.Pow(s.length, 2)
}

func main() {
    c1 := Circle{radius: 5, name: "c1"}
    s1 := Square{length: 6, name: "s1"}
}

func calculateArea(listOfShapes []Shape) {
    for _, shape := range listOfShapes {
        fmt.Println("Area of shape is ", shape.Area())
    }
}
 
func main() {
    c1 := Circle{radius: 5, name: "c1"}
    s1 := Square{length: 6, name: "s1"}
 
    shapes := []Shape{c1, s1}
    calculateArea(shapes)
}
```

- empty interface 

interface{}

c1 := Circle{radius: 5, name: "c1"}

var v interface{} = c1



# multitask in go 

If the main() function is terminated, all the goroutines currently running will also be terminated.

- A Mutex is a mutual exclusion lock. A mutual exclusion lock is a technique to ensure exclusive access to shared data between threads of execution.

```
package main
 
import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)
 
var balance int
var mutex = &sync.Mutex{}
 
func credit() {
    for i := 0; i < 5; i++ {
        mutex.Lock()
        balance += 100
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
        fmt.Println("After crediting, balance is", balance)
        mutex.Unlock()
    }
}
 
func debit() {
    for i := 0; i < 5; i++ {
        mutex.Lock()
        balance -= 100
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
        fmt.Println("After debiting, balance is", balance)
        mutex.Unlock()
    }
}
 
func main() {
    balance = 200
    fmt.Println("Initial balance is", balance)
    go credit()
    go debit()
    fmt.Scanln()
}
```

- Using atomic counters for modifying shared resources

```
package main
 
import (
    "fmt"
    "math/rand"
    "sync"
    "sync/atomic"
    "time"
)
 
var balance int64
 
func credit() {
    for i := 0; i < 10; i++ {
        // adds 100 to balance atomically
        atomic.AddInt64(&balance, 100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
}
 
func debit() {
    for i := 0; i < 5; i++ {
        // deducts -100 from balance atomically
        atomic.AddInt64(&balance, -100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
}
 
func main() {
    balance = 200
    fmt.Println("Initial balance is", balance)
    go credit()
    go debit()
    fmt.Scanln()
    fmt.Println(balance)
}
```

- Synchronizing Goroutines, use sync.WaitGroup to wait goroutines 

```
package main
 
import (
    "fmt"
    "math/rand"
    "sync"
    "sync/atomic"
    "time"
)
 
var balance int64
 
func credit(wg *sync.WaitGroup) {
    // notify the WaitGroup when we are done
    defer wg.Done()
    for i := 0; i < 10; i++ {
        // adds 100 to balance atomically
        atomic.AddInt64(&balance, 100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
 
}
 
func debit(wg *sync.WaitGroup) {
    // notify the WaitGroup when we are done
    defer wg.Done()
    for i := 0; i < 5; i++ {
        // deducts -100 from balance atomically
        atomic.AddInt64(&balance, -100)
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    }
}
 
func main() {
    var wg sync.WaitGroup
 
    balance = 200
    fmt.Println("Initial balance is", balance)
 
    wg.Add(1) // add 1 to the WaitGroup counter
    go credit(&wg)
 
    wg.Add(1) // add 1 to the WaitGroup counter
    go debit(&wg)
 
    wg.Wait() // blocks until WaitGroup counter is 0
    fmt.Println("Final balance is", balance)
}
```

- Communicating between Goroutines Using Channels1










































	
	
	
# Reference 
- online playground https://go.dev/play/

- go at google, language design in the service of software engineering 

https://go.dev/talks/2012/splash.article	
	
	
	
	
	