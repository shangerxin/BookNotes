The Linux command line, 2nd Edition=William;Note=Erxin


# Preface 
- He is also the creator of LinuxCommand.org

- simple command 


$ df
disk free space 

$ date 

$ ls 

absolute /

relative path    ./

Filenames that begin with a period character are hidden. This only means that ls will not list them unless you say ls -a. 

Filenames and commands in Linux, like Unix, are case sensitive.

Though Linux supports long filenames that may contain embedded spaces and punctuation characters, limit the punctuation characters in the names of files you create to period, dash, and underscore. 

Linux has no concept of a “file extension” like some other operating systems.


cd -  Changes the working directory to the previous working directory.
cd ~user_name  Changes the working directory to the home directory of user_name.



# exploring the system 
- ls options 

```
-a 
-A 

-d directory 
-F classify 
-h human readable 
-l long format 
-r reverse 
-s file size 
-t modification time 
```

- determine file type with 

$ file filename

- file content 
less filename

- root subfolders. 

/ root 
/bin contains binaries programs that mast be present for the system to boot and run 
/boot contains the linux kernel /boot/grub/grub.conf or menu.lst is sued to configure the boot loader 
/dev special directory contains device nodes, everything is file
/etc contains all the system wide configuration, scripts that start at boot time, everything in should read aas text, /etc/crontab a file defines automated jobs, etc/fstab a talbe of storage devices and their mount points, /etc/passwd, a list of user accounts 
/home 
/lib contains shared library files 
/lost+found ext3 file system corruption event will contain files 
/mnt older linux systems the contains mount points for removable devices that have been mount manually 
/opt install optional software, mainly used to hold comercial software 
/proc not a real file system, it is a virutal system maintained by linux kernel. it contains peepholes to the kernel.
/root home directory of root 
/sbin the directory contaisn system binaries 
/tmp tempoarary files, the directory to be emptied each time the system is rebooted 
/usr all the programs support files used by regular users 
/usr/bin contains executables 
/usr/lib shared libraries used in /usr/bin 
/usr/local programs that are not included with your distribution 
/usr/sbin more system administration program 
/usr/share all the shared data 
/usr/share/doc installed package documents 
/var data likely to changed to store, various database and spool file 
/var/log log files records of various system, /var/log/messages and /var/log/syslog are most used 

- less file name 

PAGE UP or b    Scroll back one page

PAGE DOWN or space   Scroll forward one page

Up arrow             Scroll up one line

Down arrow           Scroll down one line

G                    Move to the end of the text file

1G or g              Move to the beginning of the text file

/characters          Search forward to the next occurrence of characters

n                    Search for the next occurrence of the previous search

h                    Display help screen

q                    Quit less

- special kind of a file called a symbolic link (also known as a soft link or symlink). hard links. 


# Manipulate files and directories 
- cmds 
cp 
mv mkdir 
rm 
ln 
mv

- hard links 

A hard link cannot reference a file outside its own file system. This means a link cannot reference a file that is not on the same disk partition as the link itself.
A hard link may not reference a directory.

A hard link is indistinguishable from the file itself. Unlike a symbolic link, when you list a directory containing a hard link, you will see no special indication of the link. When a hard link is deleted, the link is removed, but the contents of the file itself continue to exist (that is, its space is not deallocated) until all links to the file are deleted.

- Symbolic links were created to overcome the limitations of hard links. They work by creating a special type of file that contains a text pointer to the referenced file or directory. 


# Working with commands 
- cmds 

type Indicate how a command name is interpreted

which Display which executable program will be executed

help Get help for shell builtins

man Display a command’s manual page

apropos Display a list of appropriate commands

info Display a command’s info entry

whatis Display one-line manual page descriptions

alias Create an alias for a command

- alias 

$ alias foo='cd /usr; ls; cd -'


# Redirection 
- I/O redirection 

cat Concatenate files

sort Sort lines of text

uniq Report or omit repeated lines

grep Print lines matching a pattern

wc Print newline, word, and byte counts for each file

head Output the first part of a file

tail Output the last part of a file

tee Read from standard input and write to standard output and files

- redirect standard output 
$ ls -l /usr/bin > ls-output.txt

append use the >> redirection operator, like

- redirect standard error 

$ ls -l /bin/usr 2> ls-error.txt

- redirect standard output and errors into one file 

$ ls -l /bin/usr > ls-output.txt 2>&1

&> to redirect both standard output and standard error to the file ls-output.txt.

- combined redirection, standard error is directed to the screen:

$ 2>&1 >ls-output.txt

- disposing unwanted output 

The system provides a way to do this by redirecting output to a special file called /dev/null

ls -l /bin/usr 2> /dev/null

cat accepts standard input, in addition to filename arguments
$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.

- send to standard output is utilized by a shell feature called pipelines.

ls -l /usr/bin | less

Pipelines are often used to perform complex operations on data. It is possible to put several commands together into a pipeline

ls /bin /usr/bin | sort | less


The uniq command is often used in conjunction with sort. uniq accepts a sorted list of data from either standard input or a single filename argument
$ ls /bin /usr/bin | sort | uniq | less

- head/tail: Print First/Last Part of Files

- tee: Read from Stdin and Output to Stdout and Files

$  ls /usr/bin | tee ls.txt | grep zip

The tee program reads standard input and copies it to both standard output (allowing the data to continue down the pipeline) and to one or more files. 


# Seeing the world as the shell sees it
- echo Display a line of text

PATHNAME EXPANSION OF HIDDEN FILES
$ echo .*

character (~) has a special meaning. When used at the beginning of a word, it expands into the name of the home directory

Arithmetic Expansion
$ echo $((2 + 2))
$((expression))

Description
Addition +
Subtraction -
Multiplication *
Division (but remember, since expansion supports only integer arithmetic, results are integers) /
Modulo, which simply means “remainder” %
Exponentiation **
$ echo $(($((5**2)) * 3))

- Brace Expansion

$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back

cho Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5

echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

echo {001..15}
001 002 003 004 005 006 007 008 009 010 011 012 013 014 015

- parameter expansion 

reveal the contents of USER, you would do this
$ echo $USER

- command substitution 

allows us to use the output of a command as an expansion.

[me@linuxbox ~]$ echo $(ls)

 $ ls -l $(which cp)
 
- double quote 

The first type of quoting we will look at is double quotes. If we place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters. 

$ ls -l "two words.txt"

Remember, parameter expansion, arithmetic expansion, and command substitution still take place within double quotes

echo "$USER $((2+2)) $(cal)"
me 4    February 2020

command line contains a command followed by four distinct arguments. If we add double quotes:

[me@linuxbox ~]$ echo "this is a     test"

- single quotes, If we need to suppress all expansions, we use single quotes. 

echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER

escape it by typing \\.

Adding the -e option to echo will enable interpretation of escape sequences. You can also place them inside $’ ’. Here, using the sleep command

we can create a primitive countdown timer:

$ sleep 10; echo -e "Time's up\a"
We could also do this:
$ sleep 10; echo "Time's up" $'\a'


# ADVANCED KEYBOARD TRICKS
- commandline editing
CTRL-A

Move cursor to the beginning of the line.

CTRL-E

Move cursor to the end of the line.

CTRL-F

Move cursor forward one character; same as the right arrow key.

CTRL-B

Move cursor backward one character; same as the left arrow key.

ALT-F

Move cursor forward one word.

ALT-B

Move cursor backward one word.

CTRL-L

Clear the screen and move the cursor to the top-left corner. The clear command does the same thing.

- Searching History
$ history | less

 We could use this immediately using another type of expansion called history expansion

$ !88


CTRL-P

Move to the previous history entry. This is the same action as the up arrow.

CTRL-N

Move to the next history entry. This is the same action as the down arrow.

ALT-<

Move to the beginning (top) of the history list.

ALT->

Move to the end (bottom) of the history list, i.e., the current command line.

CTRL-R

Reverse incremental search. This searches incrementally from the current command line up the history list.

ALT-P

Reverse search, nonincremental. With this key, type in the search string and press ENTER before the search is performed.

ALT-N

Forward search, nonincremental.

CTRL-O

Execute the current item in the history list and advance to the next one. This is handy if you are trying to re-execute a sequence of commands in the history list.


!! Repeat the last command. It is probably easier to press the up arrow and ENTER.

!number Repeat history list item number.

!string Repeat last history list item starting with string.

!?string Repeat last history list item containing string.


# Permission 
- following commands:

id Display user identity

chmod Change a file’s mode

umask Set the default file permissions

su Run a shell as another user

sudo Execute a command as another user

chown Change a file’s owner

chgrp Change a file’s group ownership

passwd Change a user’s password

- file attribute 

$ ls -l foo.txt
-rw-rw-r-- 1 me    me   0 2018-03-06 14:52 foo.txt

The first 10 characters of the listing are the file attributes. 
A regular file. -
A directory. d
A symbolic link. l
A character special file. c
A block special file. This file type refers to a device that handles data in blocks. b

A regular file that is readable, writable, and executable by the file’s owner. -rwxr-xr-x
A symbolic link. All symbolic links have “dummy” permissions.lrwxrwxrwx


# Processes 
- introduce the following commands:

ps Report a snapshot of current processes

top Display tasks

jobs List active jobs

bg Place a job in the background

fg Place a job in the foreground

kill Send a signal to a process

killall Kill processes by name

shutdown Shut down or reboot the system

- view processing 
$ ps 

get a bigger picture of what the system is doing.
$ ps x

meaning     state 
running     R 
sleeping    S 
Uninterruptible D 
Stopped     T 
zombie process   Z 
high priority    < 
low priority     N 

$ ps aux
USER    PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1  0.0  0.0   2136   644 ?        Ss   Mar05   0:31 init
root      2  0.0  0.0      0     0 ?        S<   Mar05   0:00 [kt]

ps column meaning 
User ID. USER 
CPU usage in percent. %cpu 
memory usage. %mem 
virutal memory size. VSZ 
resident set size. RSS 
TIME when the process started. START

- TOP display 

1.0%sy  1.0 percent of the CPU is being used for system (kernel) processes.
0.0%ni  0.0 percent of the CPU is being used by “nice” (low-priority) processes.
98.3%id  98.3 percent of the CPU is idle.
up 6:30  This is called uptime. 

- controlling processes 

X logo. First, we’ll get to know our test subject.
$ xlogo 

- put process in background 
follow the command with an ampersand (&) character.
$ executable &

- Returning a Process to the Foreground

[me@linuxbox ~]$ jobs
[1]+  Running                 xlogo &
[me@linuxbox ~]$ fg %1
xlogo

The fg command followed by a percent sign and the job number (called a jobspec) does the trick. 

- Stopping (Pausing) a Process

type xlogo, press ENTER, and then press CTRL-Z.
$ xlog 

resume the program’s execution in the background with the bg command.
$ bg %1

- other ps relative commands 

pstree, Outputs a process list arranged in a tree-like pattern  

vmstat, Outputs a snapshot of system resource usage including memory, swap, and disk I/O

xload, graphical program that draws a graph showing system load over time.

tload, Similar to the xload program but draws the graph in the terminal.


# Configuration the environment 
# The environment 
- commands 
printenv Print part or all of the environment

set Set shell options

export Export environment to subsequently executed programs

alias Create an alias for a command

- printenv command can also list the value of a specific variable

$ printenv USER

- alias command without arguments

```
alias l.=’ls -d .* --color=tty’
alias ll=’ls -l --color=tty’
alias ls=’ls --color=tty’
alias vi=’vim’
alias which=’alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde’
```

- environment variables 
DISPLAY, EDITOR, SHELL, HOME, LANG, OLDPWD the previous working directory, PAGER, PATH, PS1 prompt string 1, PWD current working directory, TERM the name of your terminal type. 

- shell session types 

A login shell session This is one in which we are prompted for our username and password

A non-login shell session This typically occurs when we launch a terminal session in the GUI.

/etc/profile A global configuration script that applies to all users.

~/.bash_profile  A user’s personal startup file. It can be used to extend or override settings in the global configuration script.

~/.bash_login    If ~/.bash_profile is not found, bash attempts to read this script.

~/.profile       If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based distributions, such as Ubuntu.

/etc/bash.bashrc   global configuration script that applies to all users.

~/.bashrc    user’s personal startup file. It can be used to extend or override settings in the global configuration script.

-  a Startup File .bash_profile (taken from a CentOS 6 system), it looks something like this

```
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin
export PATH
```

umask 0002   Sets the umask to solve the problem with the shared directories we discussed in

export HISTCONTROL=ignoredups    Causes the shell’s history recording feature to ignore a command

export HISTSIZE=1000     Increases the size of the command history

alias l.=’ls -d .* --color=auto’    Creates a new command called l., which displays all directory

alias ll=’ls -l --color=auto’    Creates a new command called ll



# introduction to vi 
- 