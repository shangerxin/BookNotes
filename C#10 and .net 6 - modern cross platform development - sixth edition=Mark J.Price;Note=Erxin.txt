C#10 and .net 6 - modern cross platform development - sixth edition=Mark J.Price;Note=Erxin

# Reference 
- link 
https://learning.oreilly.com/library/view/c-10-and/9781801077361/Text/Chapter_1.xhtml#_idParaDest-25


# Deploying cross-platform 
- vs 2022 
- vs code + .net sdk 

https://www.microsoft.com/net/download

- supported platform 

Windows: Windows 7 SP1, or later. Windows 10 version 1607, or later, including Windows 11. Windows Server 2012 R2 SP1, or later. Nano Server version 1809, or later.

Mac: macOS Mojave (version 10.14), or later.

Linux: Alpine Linux 3.13, or later. CentOS 7, or later. Debian 10, or later. Fedora 32, or later. openSUSE 15, or later. Red Hat Enterprise Linux (RHEL) 7, or later. SUSE Enterprise Linux 12 SP2, or later. Ubuntu 16.04, 18.04, 20.04, or later.

Android: API 21, or later.

iOS: 10, or later.

- vscode extension 

c# for vs code, ms-dotnettools.csharp 

.net interactive notebooks, ms-dotnettools.dotnet-interactive-vscode 

msbuild project tools, tinytoy.msbuild-project-tools 

humao.rest-client

ILSply.net decompiler icsharpcode.ilspy-vscode 

azure functions for visual studio code ms-azuretools.vscode-azurefunctions 

github repositories

sql server for visual studio code, ms-mssql.mssql 

protobuf3 support for visual stuido code, zxh404.vscode-proto3 

- Third parties developed a .NET Framework implementation named the Mono project. it is behind official 

- .net core, .NET Core is fast-moving, and because it can be deployed side by side with an app,SDKs and runtimes are currently installed using the following commands:

dotnet --list-sdks
dotnet --list-runtimes

- theme of .net 

https://themesof.net/

- using Visual Studio 2022 and .NET MAUI (Multi-platform App UI). You can find it at https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf.

- c# 10 new features 

// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;

-  solution code:

Visual Studio 2022 solutions: https://github.com/markjprice/cs10dotnet6/tree/main/vs4win
Visual Studio Code solutions: https://github.com/markjprice/cs10dotnet6/tree/main/vscode
.NET Interactive Notebook solutions: https://github.com/markjprice/cs10dotnet6/tree/main/notebooks

- sdks 

	+ Microsoft.NET.Sdk

System

System.Collections.Generic

System.IO

System.Linq

System.Net.Http

System.Threading

System.Threading.Tasks

	+ Microsoft.NET.Sdk.Web

Same as Microsoft.NET.Sdk and:

System.Net.Http.Json

Microsoft.AspNetCore.Builder

Microsoft.AspNetCore.Hosting

Microsoft.AspNetCore.Http

Microsoft.AspNetCore.Routing

Microsoft.Extensions.Configuration

Microsoft.Extensions.DependencyInjection

Microsoft.Extensions.Hosting

Microsoft.Extensions.Logging

	+ Microsoft.NET.Sdk.Worker

Same as Microsoft.NET.Sdk and:

Microsoft.Extensions.Configuration

Microsoft.Extensions.DependencyInjection

Microsoft.Extensions.Hosting

Microsoft.Extensions.Logging

- instrumenting with debug and trace 

The Debug class is used to add logging that gets written only during development.
The Trace class is used to add logging that gets written during both development and runtime.

- Visual Studio, navigate to View | Output and make sure Show output from: Debug is selected.

- types of testing 

unit 

integration 

system, whole system environment 

performance 

load 

user acceptance 

- You can take the concept further by using records. These are defined by using the record keyword instead of the class keyword. That can make the whole object immutable

public record ImmutableVehicle
{
  public int Wheels { get; init; }
  public string? Color { get; init; }
  public string? Brand { get; init; }
}

- setting up a class library and console application 

- delegate, function pointers, then think of a delegate as being a type-safe method pointer.

delegate int DelegateWithMatchingSignature(string s);

// delegate field
public EventHandler? Shout;
// data field
public int AngerLevel;
// method
public void Poke()
{
  AngerLevel++;
  if (AngerLevel >= 3)
  {
    // if something is listening...
    if (Shout != null)
    {
      // ...then call the delegate
      Shout(this, EventArgs.Empty);
    }
  }
}

- release unmanaged resource 

public class Animal : IDisposable
{
  public Animal()
  {
    // allocate unmanaged resource
  }
  ~Animal() // Finalizer
  {
    Dispose(false);
  }
  bool disposed = false; // have resources been released?
  public void Dispose()
  {
    Dispose(true);
    // tell garbage collector it does not need to call the finalizer
    GC.SuppressFinalize(this); 
  }
  protected virtual void Dispose(bool disposing)
  {
    if (disposed) return;
    // deallocate the *unmanaged* resource
    // ...
    if (disposing)
    {
      // deallocate any other *managed* resources
      // ...
    }
    disposed = true;
  }
}

using (Animal a = new())
{
  // code that uses the Animal instance
}

Animal a = new(); 
try
{
  // code that uses the Animal instance
}
finally
{
  if (a != null) a.Dispose();
}

- declaring non-nullable variables and parameters 

class Address
{
  public string? Building; 
  public string Street; 
  public string City; 
  public string Region;
}

- check null 

if (thisCouldBeNull is not null)

// check that the variable is not null before using it
if (thisCouldBeNull != null)
{
  // access a member of thisCouldBeNull
  int length = thisCouldBeNull.Length; // could throw exception
  ...
}

- hiding members 

using static System.Console; 
namespace Packt.Shared;
public class Employee : Person
{
  public string? EmployeeCode { get; set; }
  public DateTime HireDate { get; set; }
  public void WriteToConsole()
  {
    WriteLine(format:
      "{0} was born on {1:dd/MM/yy} and hired on {2:dd/MM/yy}",
      arg0: Name,
      arg1: DateOfBirth,
      arg2: HireDate);
  }
}

- casting 

Employee explicitAlice = aliceInPerson;

Employee explicitAlice = (Employee)aliceInPerson;

Employee? aliceAsEmployee = aliceInPerson as Employee; // could be null
if (aliceAsEmployee != null)
{
  WriteLine($"{nameof(aliceInPerson)} AS an Employee");
  // safely do something with aliceAsEmployee
}

- suppressing warnings 

[assembly:SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1200:UsingDirectivesMustBePlacedWithinNamespace", Justification = "Reviewed.")]


#pragma warning disable SA1200 // UsingDirectivesMustBePlacedWithinNamespace
using System;

	+ modify the stylecop.json 
	
{
  "$schema": "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json",
  "settings": {
    "orderingRules": {
      "usingDirectivesPlacement": "outsideNamespace"
    }
  }
}


# Packaging and distributing .net types 
- .net framework versions 

.NET Core 1.x: much smaller API compared to .NET Framework 4.6.1, which was the current version in March 2016.
.NET Core 2.x: reached API parity with .NET Framework 4.7.1 for modern APIs because they both implement .NET Standard 2.0.
.NET Core 3.x: larger API compared to .NET Framework for modern APIs because.NET Framework 4.8 does not implement .NET Standard 2.1.
.NET 5: even larger API compared to .NET Framework 4.8 for modern APIs, with much-improved performance.
.NET 6: final unification with the support for mobile apps in .NET MAUI, expected by May 2022.

- update sdk 

dotnet sdk check

- controlling the .net sdk 

dotnet new classlib -f netstandard2.0

- dotnet new globaljson --sdk-version 3.1.412

Framework-dependent deployment (FDD).
Framework-dependent executables (FDEs).
Self-contained.

- manage projects 

dotnet restore: This downloads dependencies for the project.
dotnet build: This builds, aka compiles, the project.
dotnet test: This builds and then runs unit tests for the project.
dotnet run: This builds and then runs the project.
dotnet pack: This creates a NuGet package for the project.
dotnet publish: This builds and then publishes the project, either with dependencies or as a self-contained application.
dotnet add: This adds a reference to a package or class library to the project.
dotnet remove: This removes a reference to a package or class library from the project.
dotnet list: This lists the package or class library references for the project.

- decompiling .net assemblies 

Decompiling using the ILSpy extension for Visual Studio 2022
For learning purposes, you can decompile any .NET assembly with a tool like ILSpy.

In Visual Studio 2022 for Windows, navigate to Extensions | Manage Extensions.
In the search box, enter ilspy.
For the ILSpy extension, click Download.

- obfuscation tools like Dotfuscator, but ultimately you cannot completely prevent it.

- package the SharedLibrary project that you created earlier:

In the SharedLibrary project, rename the Class1.cs file to StringExtensions.cs.

- exploring nuget packages with a tool 
Start your favorite browser and navigate to the following link: https://nuget.info.
In the search box, enter Packt.CSdotnet.SharedLibrary.


# Working with common .net types 
- Using immutable collections
Sometimes you need to make a collection immutable, meaning that its members cannot change; that is, you cannot add or remove them.

- input parameter to be IEnumerable<T> and make the method generic, as shown in the following code:

- improve performance 

A key .NET feature that enables this is the Span<T> type.

a subset of an array, use a span because it is like a window into the original array. This is more efficient in terms of memory usage and improves performance. 

// two ways to define the same index, 3 in from the start 
Index i1 = new(value: 3); // counts from the start 
Index i2 = 3; // using implicit int conversion operator
// two ways to define the same index, 5 in from the end
Index i3 = new(value: 5, fromEnd: true); 
Index i4 = ^5; // using the caret operator

- doing more reflection 

Dynamically load assemblies that are not currently referenced: https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability
Dynamically execute code: https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke
Dynamically generate new code and assemblies: https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder



# Working with files, streams and serialization 
- A stream is a sequence of bytes that can be read from and written to. Although files can be processed rather like arrays

- serliazation with xml 

In Person, import the System.Xml.Serialization namespace so that you can decorate some properties with the [XmlAttribute] attribute.

[XmlAttribute("fname")]
public string FirstName { get; set; }
[XmlAttribute("lname")]
public string LastName { get; set; }
[XmlAttribute("dob")]
public DateTime DateOfBirth { get; set; }

- serialize with JSON

using NewJson = System.Text.Json.JsonSerializer;



# Entity framework core 
- sql server 

SQL Server editions from the following link:

https://www.microsoft.com/en-us/sql-server/sql-server-downloads

- Visual Studio, choose View | Server Explorer.
In the Server Explorer window, right-click Data Connections and choose Add Connection....
If you see the Choose Data Source dialog, as shown in Figure 10.3, select Microsoft SQL Server and then click Continue:

- sqlite 

Start your favorite browser and navigate to the following link: https://www.sqlite.org/download.html.


nter the command to execute the SQL script using SQLite and create the Northwind.db database, as shown in the following command:
sqlite3 Northwind.db -init Northwind4SQLite.sql

- sqlite studio 

Navigate to the following link, https://sqlitestudio.pl, and download and extract the application to your preferred location.

- Logging EF Core using a custom logging provider
To monitor the interaction between EF Core and the database, we can enable logging. This requires the following two tasks:

The registering of a logging provider.

```
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Logging;
```


# Using linq 
- query from collection 

var query2 = from name in names where name.EndsWith("m") select name;

- linq to xml 

var query = names
  .Where(name => name.Length > 4)
  .OrderBy(name => name.Length);
  
static void ProcessSettings()
{
  XDocument doc = XDocument.Load("settings.xml");
  var appSettings = doc.Descendants("appSettings")
    .Descendants("add")
    .Select(node => new
    {
      Key = node.Attribute("key")?.Value,
      Value = node.Attribute("value")?.Value
    }).ToArray();
  foreach (var item in appSettings)
  {
    WriteLine($"{item.Key}: {item.Value}");
  }
}
  
- Filtering and sorting sequences
Now let's write statements to filter and sort sequences of rows from the tables:

In Program.cs, statically import the Console type and namespaces for working with EF Core and your entity model using LINQ, as shown in the following code:
using Packt.Shared; // Northwind, Category, Product
using Microsoft.EntityFrameworkCore; // DbSet<T>
using static System.Console;
  
- create your linq extension methods 

namespace System.Linq; // extend Microsoft's namespace
public static class MyLinqExtensions
{
  // this is a chainable LINQ extension method
  public static IEnumerable<T> ProcessSequence<T>(
    this IEnumerable<T> sequence)
  {
    // you could do some processing here
    return sequence;
  }
  public static IQueryable<T> ProcessSequence<T>(
    this IQueryable<T> sequence)
  {
    // you could do some processing here
    return sequence;
  }
...
}
  
  
  
# ASP.NET, as shown in the following URL:
- reference 
https://dotnet.microsoft.com/learn/aspnet

- ASP.NET SignalR was released in 2013 and enables real-time communication in websites by abstracting underlying technologies and techniques,

- asp.net core 

