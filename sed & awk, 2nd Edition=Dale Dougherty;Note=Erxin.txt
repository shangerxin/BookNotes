sed & awk, 2nd Edition=Dale Dougherty;Note=Erxin

# Sample code 
- ftp 
$ ftp ftp.oreilly.com
Connected to ftp.oreilly.com.
220 FTP server (Version 6.21 Tue Mar 10 22:09:55 EST 1992) ready.
Name (ftp.oreilly.com:yourname): anonymous
331 Guest login ok, send domain style e-mail address as password.
Password: yourname@domain.name   (Use your user name and host here)
230 Guest login ok, access restrictions apply.
ftp> cd /published/oreilly/nutshell/sedawk_2
250 CWD command successful.
ftp> binary   (Very important! You must specify binary transfer for compressed files.)
200 Type set to I.
ftp> get progs.tar.gz
200 PORT command successful.
150 Opening BINARY mode data connection for progs.tar.gz.
226 Transfer complete.
ftp> quit
221 Goodbye.

- ftp mail 

$ mail ftpmail@online.oreilly.com
Subject:
reply-to yourname@domain.name     (Where you want files mailed)
open
cd /published/oreilly/nutshell/sedawk_2
dir
mode binary
uuencode
get progs.tar.gz
quit

- bitftp 

FTP  ftp.oreilly.com  NETDATA
USER  anonymous
PASS  yourname@yourhost.edu   Put your Internet email address here (not your BITNET address)
CD /published/oreilly/nutshell/sedawk_2
DIR
BINARY
GET  progs.tar.gz
QUIT

- uucp 

UUCP is standard on virtually all UNIX systems and is available for IBM-compatible PCs and Apple Macintoshes

uucp uunet\!~/published/oreilly/nutshell/sedawk_2/progs.tar.gz yourhost\!~/yourname/

The backslashes can be omitted if you use a Bourne-style shell (sh, ksh, bash, zsh, pdksh) instead of csh or tcsh. 



# a pattern matching programming language 
- awk allows you to do are:

View a text file as a textual database made up of records and fields.

Use variables to manipulate the database.

Use arithmetic and string operators.

Use common programming constructs such as loops and conditionals.

Generate formatted reports.

Define functions.

Execute UNIX commands from a script.

Process the result of UNIX commands.

Process command-line arguments more gracefully.

Work more easily with multiple input streams.

- four hurdles to mastering sed and awk 

How to use sed and awk. This is a relatively low hurdle to clear because, fortunately, sed and awk work in a very similar manner

To apply UNIX regular expression syntax

interact with the shell.

The knack of script writing. 


# Understand basic operation 
- When you open a file using  ed, the original UNIX line editor.

open a file using ed, it displays the number of characters in the file and positions you at the last line.

$ ed test
339

enter the print command, p, to display the current line.

> p
label on the first box.

To move to a line, you specify its address. An address might consist of a line number
> #<line number>

delete a line with d 

> 1
You might think of a regular expression
d

letter g for global.

g/regular/d

substitution command, s, in ed is:
> [address]s/pattern/replacement/flag

An address must be specified to direct this command to act upon more than the current line. 
> /regular/s/regular/complex/g

On any line that contains the string “regular expression,” replace “regular” with “complex.” If the address and the pattern are the same, you can tell ed by specifying two consecutive delimiters (//).
g/regular/s//complex/g

a file named ed-script, the following command executes the script:
$ ed test < ed-script 

The print statement replaces the p command, for example. The concept of addressing is carried over
/regular/{print}


# Using sed 
- specify the simple instructions 

$ sed [-e] 'instruction' file 

the -e option is necessary only when you supply more than one instruction on the command line.

- help 

```
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...

  -n, --quiet, --silent
                 suppress automatic printing of pattern space
      --debug
                 annotate program execution
  -e script, --expression=script
                 add the script to the commands to be executed
  -f script-file, --file=script-file
                 add the contents of script-file to the commands to be executed
  --follow-symlinks
                 follow symlinks when processing in place
  -i[SUFFIX], --in-place[=SUFFIX]
                 edit files in place (makes backup if SUFFIX supplied)
  -l N, --line-length=N
                 specify the desired line-wrap length for the `l' command
  --posix
                 disable all GNU extensions.
  -E, -r, --regexp-extended
                 use extended regular expressions in the script
                 (for portability use POSIX -E).
  -s, --separate
                 consider files as separate rather than as a single,
                 continuous long stream.
      --sandbox
                 operate in sandbox mode (disable e/r/w commands).
  -u, --unbuffered
                 load minimal amounts of data from the input files and flush
                 the output buffers more often
  -z, --null-data
                 separate lines by NUL characters
      --help     display this help and exit
      --version  output version information and exit

If no -e, --expression, -f, or --file option is given, then the first
non-option argument is taken as the sed script to interpret.  All
remaining arguments are names of input files; if no input files are
specified, then the standard input is read.

GNU sed home page: <https://www.gnu.org/software/sed/>.
General help using GNU software: <https://www.gnu.org/gethelp/>.
E-mail bug reports to: <bug-sed@gnu.org>.
```

- three ways to specify multiple instructions on the command line
    + with a semicolon.

sed 's/ MA/, Massachusetts/; s/ PA/, Pennsylvania/' list

    +  each instruction by -e.

sed -e 's/ MA/, Massachusetts/' -e 's/ PA/, Pennsylvania/' list

    + Use the multiline entry capability of the Bourne shell
$ sed ' 
> s/ MA/, Massachusetts/
> s/ PA/, Pennsylvania/
> s/ CA/, California/' list 

- incomplete syntax is entered:

$ sed -e 's/MA/Massachusetts' list

GNU sed is more helpful:

$ gsed -e 's/MA/Massachusetts' list
gsed: Unterminated `s' command

- script files using the -f option, requires that you specify the name of the script file on the command line. 

$ sed -f scriptfile file

- save to output file 

$ sed -f sedscr list > newlist

- suppressing automatic display of input lines,  The -n option suppresses the automatic output. When specifying this option, each instruction intended to produce output must contain a print command

$ sed -n -e 's/MA/Massachusetts/p' list


# Using awk 
- running awk 

$ awk 'instructions' files

- Awk, in the usual case, interprets each input line as a record and each word on that line, delimited by spaces or tabs, as a field. (These defaults can be changed.) One or more consecutive spaces or tabs count as a single delimiter. Awk allows you to reference these fields, in either patterns or procedures.

$ awk '{ print $1 }' list
John
Alice
Orville
Terry
Eric
Hubert
Amy
Sal

- a pattern “/MA/” is specified but there is no procedure. The default action is to print each line that matches the pattern.

$ awk '/MA/' list
John Daggett, 341 King Road, Plymouth MA


next example uses a print statement to limit the output to the first field of each record.
$ awk '/MA/ { print $1 }' list

the -F option to change the field separator to a comma.
$ awk -F, '/MA/ { print $1 }' list

Multiple commands are separated by semicolons.
$ awk -F, '{ print $1; print $2; print $3 }' list

Messages can be caused by any of the following:
Not enclosing a procedure within braces ({})

- options 
```
-f	
Filename of script follows.

-F	
Change field separator.

-v	
var=value follows.
```


# Using sed and awk together 
- example sed script file 

$ cat nameState
s/ CA/, California/
s/ MA/, Massachusetts/
s/ OK/, Oklahoma/
s/ PA/, Pennsylvania/
s/ VA/, Virginia/

- extracts the name of the state from each record. list is the example text file 

$ sed -f nameState list | awk -F, '{ print $4 }'

- sort | uniq -c, which would sort the states into an alphabetical list with a count of the number of occurrences of each state.

- awk script shows the byState program.
```
#! /bin/sh
awk -F, '{ 
	print $4 ", " $0 
	}' $* | 
sort |
awk -F, '
$1 == LastState { 
      print "\t" $2
}
$1 != LastState { 
      LastState = $1
      print $1
      print "\t" $2
}'
```

- change the example to sh script 
 $ sed -f nameState list | byState
 


# Understanding regular expression by syntax 
- expression, even in computer terminology, is not something to be interpreted literally. It is something that needs to be evaluated. An expression describes a result.

- grep, sed, and awk all use regular expressions. However, not all of the metacharacters used in regular expression syntax are available for all three programs.

- regular syntax 
. Matches any single character except newline
* Matches any number (including zero) of the single character
[...] Matches any one of the class of characters enclosed between the brackets.
^ First character of regular expression
$ As last character of regular expression
{n,m} Matches a range of occurrences of the single character
\ Escapes the special character 
extended 
followed + Matches one or more occurrences


- POSIX character class additions
The POSIX standard formalizes the meaning of regular expression characters and operators. The standard defines two classes of regular expressions: Basic Regular Expressions (BREs), which are the kind used by grep and sed, and Extended Regular Expressions, which are the kind used by egrep and awk.

the French è is an alphabetic character, but the typical character class [a-z] would not match it.

“bracket expression” in the POSIX standard. Within bracket expressions, beside literal characters such as a, !, and so on, you can have additional components.

    + components 
    
    1. Character classes. A POSIX character class consists of keywords bracketed by [: and :]. The keywords describe different classes of characters such as alphabetic characters, control characters,
    
    2. Collating symbols. A collating symbol is a multicharacter sequence that should be treated as a unit. It consists of the characters bracketed by [. and .].
    
    3. Equivalence classes. An equivalence class lists a set of characters that should be considered equivalent, such as e and è. It consists of a named element from the locale, bracketed by [= and =]
    
    + For example [[:alpha:]!] matches any single alphabetic character or the exclamation point, [[.ch.]] matches the collating element ch, but does not match just the letter c or the letter h. In a French locale, [[=e=]] might match any of e, è, or é.
    
    + POSIX character classes 
    
Class	Matching Characters
[:alnum:]	Printable characters (includes whitespace)
[:alpha:]	Alphabetic characters
[:blank:]	Space and tab characters
[:cntrl:]	Control characters
[:digit:]	Numeric characters
[:graph:]	Printable and visible (non-space) characters
[:lower:]	Lowercase characters
[:print:]	Printable characters (includes whitespace)
[:punct:]	Punctuation characters
[:space:]	Whitespace characters
[:upper:]	Uppercase characters
[:xdigit:]	Hexadecimal digits

- example 

$ grep "can[□no']*t" sample
I cannot do it
I can not do it
I can't do it
I cant do it

□ stand for space 

North American local phone number could be described with the following regular expression:
[0-9]\{3\}-[0-9]\{4\}

- alternative operations 
The vertical bar (|) metacharacter, part of the extended set of metacharacters UNIX|LINUX|NETBSD

- Grouping Operations

BigOne(□Computer)?

compan(y|ies)

- gres replacement, Then we’ll use a program that works like grep but also allows you to specify a replacement

$ gres "A*Z" "00" test
All of us, including 00ippy, our dog

It can be created using a simple shell script that invokes sed to do the work.

$ cat gres
```
if [ $# -lt "3" ] 
then 
	echo Usage: gres pattern replacement file
	exit 1
fi
pattern=$1
replacement=$2
if [ -f $3 ] 
then 
	file=$3
else
	echo $3 is not a file.
	exit 1
fi
A="`echo | tr '\012' '\001' `" # See footnote[11]
sed -e "s$A$pattern$A$replacement$A" $file
```

$ gres "A.*Z" "00" sample
00ippy, our dog


# Writing sed scripts 
- three basic principles of how sed works:

All editing commands in a script are applied in order to each line of input.

Commands are applied to all lines (globally) unless line addressing restricts the lines affected by editing commands.

The original input file is unchanged; the editing commands modify a copy of original input line and the copy is sent to standard output.

- applying commands in a script following script to change “pig” to “cow” and “cow” to “horse”:

s/pig/cow/g
s/cow/horse/g

- the N command reads another line into the pattern space without removing the current line, so you can test for patterns across multiple lines. 

- add location limitation for the lines, just lines containing “Sebastopol.”
/Sebastopol/s/CA/California/g

- the following example deletes only the first line:
1d

- input stream has only one last line. It can be specified using the addressing symbol $. The following example deletes the last line
$d

The following command deletes from line 50 to the last line in the file
50,$d

- Braces ({}) are used in sed to nest one address inside another or to apply multiple commands at the same address

/^\.TS/,/^\.TE/{
      /^$/d
}

/^\.TS/,/^\.TE/{
	/^$/d
  	s/^\.ps 10/.ps 8/
  	s/^\.vs 12/.vs 10/
}

- testing and saving output 

has a built-in safeguard so that you don’t make changes to the original file. Thus, the following command line:

$ sed -f sedscr testfile

to capture this output in a new file if you want to save it.

$ sed -f sedscr testfile > newfile

use the diff program to point out the differences between the two files.

$ diff testfile newfile

- shell script testsed automates the process of saving the output of sed in a temporary file.
```
for x
do
	sed -f sedscr $x > tmp.$x
done
```

- runsed The shell script runsed was developed to make changes to an input file permanently. In other words, it is used in cases when you would want the input file and the output file to be the same

```
#! /bin/sh

for x
do
   echo "editing $x: \c"
   if test "$x" = sedscr; then
      echo "not editing sedscript!" 
   elif test -s $x; then 
      sed -f sedscr $x > /tmp/$x$$
      if test -s /tmp/$x$$
      then 
         if cmp -s $x /tmp/$x$$
         then
            echo "file not changed: \c"
         else
            mv $x $x.bak  # save original, just in case
            cp /tmp/$x$$ $x
         fi
         echo "done"
      else 
         echo "Sed produced an empty file\c"
         echo " - check your sedscript."
      fi
      rm -f /tmp/$x$$
   else
      echo "original file is empty."
   fi
done
echo "all done"
```

- Shell metacharacters can be used to specify a set of files.

$ runsed ch0?

- four type of scripts 
    + Multiple Edits to the Same File
    + Making Changes Across a Set of Files
    + Extracting Contents of a File
    + Extracting a macro definition
    + Generating an outline
 the -n option to keep it from printing out the entire file. With this option, sed will print only the lines it is explicitly told to print via the print command. 
 
 
# Basic sed commands 
- new editing commands: d (delete), a (append), i (insert), and c (change). We also look at ways to change the flow control 
- syntax 

these commands, our convention is to specify:

[address]command

address { 
		command1
		command2
		command3
}

commands can be placed on the same line if each one is separated by a semicolon.
```
n;d
```
putting a space after the n command causes a syntax error. Putting a space before the d command is okay

- comment 

(#) must be the first character on the line. The syntax of a comment line is:
```
#[n]
```

- Substitution, s

[address]s/pattern/replacement/flags
where the flags that modify the substitution are:

n  A number (1 to 512) indicating that a replacement should be made for only the nth occurrence of the pattern.

g  Make changes globally on all occurrences in the pattern space. Normally only the first occurrence is replaced.

p  Print the contents of the pattern space.

w file Write the contents of the pattern space to file.

- use other character to seperate the regular expression 

Unlike addresses, which require a slash (/) as a delimiter, the regular expression can be delimited by any character except a newline. Thus, if the pattern contained slashes, you could choose another character, such as an exclamation mark

- special meaning replacement section, only the following characters have special meaning:

&  Replaced by the string matched by the regular expression.

\n Matches the nth substring (n is a single digit) previously specified in the pattern using “\(” and “\)”.

\  Used to escape the ampersand (&), the backslash (\), and the substitution command’s delimiter when they are used literally in the replacement section.

- example 

s/•/>/2
“•” represents an actual tab character, which is otherwise invisible on the screen.

the input is a one-line file such as the following:
Column1•Column2•Column3•Column4

the output produced by running the script on this file will be:
Column1•Column2>Column3•Column4

- As a metacharacter, the ampersand (&) represents the extent of the pattern match, not the line that was matched.

s/UNIX/\\s-2&\\s0/g

Because backslashes are also replacement metacharacters, two backslashes are necessary to output a single backslash. The “&” in the replacement string refers to “UNIX.” If the input line is:

on the UNIX Operating System.

the substitute command produces:

on the \s-2UNIX\s0 Operating System.

    + another example 
    
A regular expression can match the different combination of numbers, so we use “&” in the replacement string and surround whatever was matched.

s/See Section [1-9][0-9]*\.[1-9][0-9]*/(&)/

The replacement string recalls the first saved substring as “\1” and the second as “\2,” which is surrounded by bold-font requests

s/\(See Section \)\([1-9][0-9]*\.[1-9][0-9]*\)/\1\\fB\2\\fP/

    + example 
$ cat test1
first:second
one:two
$ sed  's/\(.*\):\(.*\)/\2:\1/' test1
second:first
two:one

-  as a series of sed substitute commands.
```
#! /bin/sh
# index.edit -- compile list of index entries for editing.
grep "^\.XX" $* | sort -u |
sed '
s/^\.XX \(.*\)$/\/^\\.XX \/s\/\1\/\1\//'
```

- Delete 

showed a command to delete blank lines:

/^$/d

- Append, insert and change 

The syntax follows:

append	[line-address]a\
	text
insert	[line-address]i\
	text
change	[address]c\
	text
    
    + example 
    
inserts two lines of text at a line matching “<Larry’s Address>”:

/<Larry's Address>/i\
4700 Cross Court\
French Lick, IN

 run on a file containing a mail message:

/^From /,/^$/c\
<Mail Header Removed>

, enclosed in braces, that act on a range of lines. For instance, the following script, two location expressions 
```
/^From /,/^$/{
	s/^From //p
	c\
<Mail Header Removed>
}
```

inserts two new lines of text before the first line of a file:
```
1i\
.so macros\
.ds CH First Draft
```

shows the append command adding a line to the end of a file:
```
$a\
End of file
```


- transform command is peculiar, not only because it is the least mnemonic of all sed commands. This command transforms each character by position in string abc to its equivalent in string xyz

- The print command (p) causes the contents of the pattern space to be output

// sed.debug
/^\.Ah/{
p
s/"//g
s/^\.Ah //p
}
```
$ sed -f sed.debug ch05
.Ah "Comment"
Comment
.Ah "Substitution"
Substitution
.Ah "Delete"
Delete
.Ah "Append, Insert and Change"
Append, Insert and Change
.Ah "List"
List
```

    + sign (=) following an address prints the line number
    
#n print line number and line with if statement
/       if/{
=
p
}

- next command (n) outputs the contents of the pattern space and then reads the next line of input without returning to the top of the script

[address]n


```
.H1 "On Egypt"

Napoleon, pointing to the Pyramids, said to his troops: 
"Soldiers, forty centuries have their eyes upon you."
```

following script removes that blank line after .H1:

/^\.H1/{
n
/^$/d
}

-  reading and writing files 

[line-address]r file
[address]w file

-  quit command (q) causes sed to stop reading new input lines


[line-address]q                                        


sed -n "
/^\.de *$mac/,/^\.\.$/{
p
/^\.\.$/q
}" $file


# Advance sed commands 
- three groupings 

Working with a multiline pattern space (N,D,P).

Using the hold space to preserve the contents of the pattern space and make it available for subsequent commands (H,h,G,g,x).

Writing scripts that use branching and conditional instructions to change the flow of control (:,b,t).

- example 

The following script looks for “Operator” at the end of a line, reads the next line of input and then makes the replacement.

/Operator$/{
N
s/Owner and Operator\nGuide/Installation Guide/
}
-  multiline delete 

The delete command (d) deletes the contents of the pattern space and causes a new line of input to be read with editing resuming at the top of the script.
```
# reduce multiple blank lines to one; version using d command
/^$/{
	N
	/^\n$/d
}
```

- multiline print, The multiline Print command differs slightly from its lowercase cousin

/UNIX$/{
        N
        /\nSystem/{
        s// Operating &/
        P
        D
        }
}


The Next command appends a new input line to the current line in the pattern space. After the substitute command is applied to the multiline pattern space, the first part of the pattern space is output by the Print command and then removed by the Delete command. That means the current line is output and the new line becomes the current line. The Delete command prevents the script from reaching bottom, which would output both lines and clear the contents of the pattern space. The Delete command lets us preserve the second portion of the pattern space and pass control to the top of the script where all the editing commands can now be applied to that line. One of those commands is the Next command which reads another new line into the pattern space

- hold that line, The pattern space is a buffer that contains the current input line

There is also a set-aside buffer called the hold space. The contents of the pattern space can be copied to the hold space and the contents of the hold space can be copied to the pattern space. A group of commands allows you to move data between the hold space and the pattern space. 


Hold	h or H	
Copy or append contents of pattern space to hold space.

Get	g or G	
Copy or append contents of hold space to pattern space.

Exchange	x	
Swap contents of hold space and pattern space.


    + example 
    
we have a file contains 
```
1
2
11
22
111
222
```
    
```    
# Reverse flip
/1/{
h
d
}
/2/{
G
}
```

$ sed -f sed.flip test.flip
2
1
22
11
222
111


Without the delete command, control would reach the bottom of the script and the contents of the pattern space would be output. If the script used the next (n) command instead of the delete command, the contents of the pattern space would also be output. could also see what happens if you use g instead of G.

- advanced flow control commands 

The branch (b) and test (t) commands transfer control in a script to a line containing a specified label. 

A label is put on a line by itself that begins with a colon:

:mylabel

you specify the label in a branch or test command, a space is permitted between the command and the label itself:

b mylabel

    + branch command allows you to transfer control to another line in the script.

[address]b[label]


        * example 
        
which means command1 then command2 will be executed again.

:top
command1
command2
/pattern/b top
command3

- test command, it implies a conditional branch. Its syntax follows:

The test command branches to a label (or the end of the script) if a successful substitution has been made

[address]t[label]

If no label is supplied, control falls through to the end of the script. If the label is supplied, then execution resumes at the line following the label.


# Writing scripts for awk 
- pattern matching 

/^$/ { print "This is a blank line." }

$ awk -f awkscr test
This is a blank line.

- comments 
```
#  blank.awk -- Print message for each blank line.
/^$/ { print "This is a blank line." }
```

- escape 

Escape Sequences
Sequence	Description
\a	Alert character, usually ASCII BEL character
\b	Backspace
\f	Formfeed
\n	Newline
\r	Carriage return
\t	Horizontal tab
\v	Vertical tab
\ddd	Character represented as 1 to 3 digit octal value
\xhex	Character represented as hexadecimal value[4]
\c	Any literal character c (e.g., \” for ")[5]

- Arithmetic Operators
Operator	Description
+	Addition
-	Subtraction
*	Multiplication
/	Division
%	Modulo
^	Exponentiation
**	Exponentiation[6]

- system variables 

The system variable FS defines the field separator. 

output equivalent of FS is OFS, which is a space by default. We’ll see an example of redefining OFS

Awk also defines RS, the record separator, as a newline. RS is a bit unusual; it’s the only variable where awk only pays attention to the first character of the value.


```
# phonelist.awk -- print name and phone number. 
# input file -- name, company, street, city, state and zip, phone
BEGIN { FS = ", *" }  # comma-delimited fields
{ print $1 ", " $6 } 
END { 	print ""
	print NR, "records processed." }32.0.101.8425
```

-  set the record separator to the empty string, which stands for a blank line.

BEGIN { FS = "\n"; RS = "" }

- Relational Operators
Operator	Description
<	Less than
>	Greater than
<=	Less than or equal to
>=	Greater than or equal to
==	Equal to
!=	Not equal to
~	Matches
!~	Does not match

-  Boolean Operators
Operator	Description
||	Logical OR
&&	Logical AND
!	Logical NOT

- example write an action that is controlled by the END rule.

END { print "Total: ", sum, "bytes (" filenum " files)" }
We can also use the BEGIN rule to add column headings to the report.

BEGIN { print "BYTES", "\t", "FILE" }

- format print 

The printf statement can output a simple string just like the print statement.

awk 'BEGIN { printf ("Hello, world\n") }'

    + Format Specifiers Used in printf
Character	Description
c	ASCII character
d	Decimal integer
i	Decimal integer. (Added in POSIX)
e	Floating-point format ([-]d.precisione[+-]dd)
E	Floating-point format ([-]d.precisionE[+-]dd)
f	Floating-point format ([-]ddd.precision)
g	e or f conversion, whichever is shortest, with trailing zeros removed
G	E or f conversion, whichever is shortest, with trailing zeros removed
o	Unsigned octal value
s	String
x	Unsigned hexadecimal number. Uses a-f for 10 to 15
X	Unsigned hexadecimal number. Uses A-F for 10 to 15
%	Literal %

- information retrieval 

    + example a simple database.  A tab is used as the field separator.

$ cat acronyms
BASIC	Beginner's All-Purpose Symbolic Instruction Code
CICS	Customer Information Control System
COBOL	Common Business Oriented Language
DBMS	Data Base Management System
GIGO	Garbage In, Garbage Out
GIRL 	Generalized Information Retrieval Language

    + The shell script that we develop is named acro. It takes the first argument from the command line
    
```
$ cat acro
#! /bin/sh
# assign shell's $1 to awk search variable
awk '$1 == search' search=$1 acronyms
```

- awk’s multiline record capability and requires that you be able to pass the search string as a command-line parameter.


```
awk 'BEGIN { FS = "\n"; RS = "" } $0 ~ search { print $0 }' search=$1 $2
```

- condition statements 

if and evaluates an expression placed in parentheses. The syntax is:

if ( expression )
   action1
[else
   action2]
   
    + example 
    
```
if ( x == y ) print x
```
    + a pair of braces.

if ( expression ) { 
    statement1
    statement2
}


if (avg >= 90)  grade = "A"
else if (avg >= 80) grade = "B"
else if (avg >= 70) grade = "C"
else if (avg >= 60) grade = "D"
else grade = "F"

- condition operator 

expr ? action1 : action2


- looping 

while (condition) 
	action
    
do
	action
while (condition)


BEGIN {
	do {
		++x
		print x
	} while ( x <= 4 )
}

$ awk -f do.awk

remember that the do loop always executes the body of the loop at least once.


for ( set_counter ; test_counter ; increment_counter ) 
    action
    
    
for ( i = 1; i <= NF; i++ )
	print $i
    
total = $2 + $3 + $4 + $5 + $6
avg = total / 5


- Deriving Factorials, example 
The factorial of a number is the product of successively multiplying that number by one less than that number. The factorial of 4 is 4 x 3 x 2 x 1, or 24. The factorial of 5 is 5 times 

can be expressed using a loop as follows:

fact = number
for (x = number - 1 ; x > 1; x--)
	fact *= x
    

```
awk '# factorial: return factorial of user-supplied number
BEGIN {
	# prompt user; use printf, not print, to avoid the newline
	printf("Enter number: ")
}

# check that user enters a number
$1 ~ /^[0-9]+$/ { 
	# assign value of $1 to number & fact
	number = $1
	if (number == 0)
		fact = 1
	else
		fact = number
	# loop to multiply fact*x until x = 1
	for (x = number - 1; x > 1; x--)
		fact *= x
	printf("The factorial of %d is %g\n", number, fact)
	# exit -- saves user from typing CRTL-D.
	exit
}

# if not a number, prompt again.
{ printf("\nInvalid entry. Enter a number: ") 
}' -
```

- other statements that affect flow control 

There are two statements that affect the flow control of a loop, break and continue. 

next and exit. The next statement causes the next line of input to be read and then resumes execution at the top of the script


```
FILENAME == "acronyms" {
	action
	next
}
{ print }
```


The exit statement exits the main input loop and passes control to the END rule, if there is one. If the END rule is not defined, or the exit statement is used in the END rule, then the script terminates


```
awk '{
	...
	exit 5
}
END { exit }'
```

- Arrays 

array[subscript] = value


flavor[1] = "cherry"

flavor_count = 5
for (x = 1; x <= flavor_count; ++x)
	print flavor[x]
    
    
    + example 
    
END {
	for ( x = 1; x <= NR; x++ ) 
		class_avg_total += student_avg[x]
	
	class_average = class_avg_total / NR
	
	for ( x = 1; x <= NR; x++ )
		if (student_avg[x] >= class_average)
			++above_average
		else
			++below_average
	
	print "Class Average: ", class_average
	print "At or Above Average: ", above_average
	print "Below Average: ", below_average
}

    + Awk provides a statement for deleting an element of an array. The syntax is:

delete array[subscript]

- An Acronym Processor

instead used the split( ) function to create the array entry. This array is then used in creating an array named acro.


```
# process any input line containing caps 
/[A-Z][A-Z]+/ {
	# see if any field is an acronym
	for (i = 1; i <= NF; i++)
		if ( $i in acro ) {
			acronym =$i 
			# if it matches, add description 
			$i = acro[$i] " (" $i ")"
		}
}

{
	# print all lines
	print $0
}
```

- Multidimensional Arrays

file_array[NR, i] = $i


```
BEGIN { FS = ","   # comma-separated fields
	# assign width and height of bitmap
	WIDTH = 12
	HEIGHT = 12
	# loop to load entire array with "O"
	for (i = 1; i <= WIDTH; ++i)
		for (j = 1; j <= HEIGHT; ++j)
			bitmap[i, j] = "O"
}
# read input of the form x,y. 
{
	# assign "X" to that element of array 
	bitmap[$1, $2] = "X"
}
# at end output multidimensional array
END {
	for (i = 1; i <= WIDTH; ++i){
		for (j = 1; j <= HEIGHT; ++j)
			printf("%s", bitmap[i, j] )
		# after each row, print newline
		printf("\n")	
	}
}
```

The multidimensional array syntax is also supported in testing for array membership. The subscripts must be placed inside parentheses.

if ((i, j) in array)

- use the split( ) function to access individual subscript components. Thus:

split(item, subscr, SUBSEP)

- system values that are arrays

    + ARGV
An array of command-line arguments, excluding the script itself and any options specified with the invocation of awk. The number of elements in this array is available in ARGC. The index of the first element of the array is 0 

    + ENVIRON
An array of environment variables. 

    + example 
    
# argv.awk - print command-line parameters
BEGIN { for (x = 0; x < ARGC; ++x)
	    print ARGV[x]
	print ARGC
}
$ awk -f argv.awk 1234 "John Wayne" Westerns n=44 -
awk
1234
John Wayne
Westerns
n=44
- 
6

reference any element, using the variable name as the index of the array:

ENVIRON["LOGNAME"]

invoked from awk via the getline or system( ) functions, which are described

- functions 

    + Built-In Arithmetic Functions
Awk Function	Description
cos(x)	Returns cosine of x (x is in radians).
exp(x)	Returns e to the power x.
int(x)	Returns truncated value of x.
log(x)	Returns natural logarithm (base-e) of x.
sin(x)	Returns sine of x (x is in radians).
sqrt(x)	Returns square root of x.
atan2(y,x)	Returns arctangent of y/x in the range -π to π.
rand( )	Returns pseudo-random number r, where 0 <= r < 1.
srand(x) Establishes new seed for rand( ). If no seed is specified, uses time of day. Returns the old seed.

    + string function 
    
Awk Function	Description
gsub(r,s,t)	    Globally substitutes s for each match of the regular expression r in the string t. Returns the number of substitutions. If t is not supplied, defaults to $0.

index(s,t)	    Returns position of substring t in string s or zero if not present.

length(s)	    Returns length of string s or length of $0 if no string is supplied.

match(s,r)	    Returns either the position in s where the regular expression r begins, or 0 if no occurrences are found. Sets the values of RSTART and RLENGTH.

split(s,a,sep)	Parses string s into elements of array a using field separator sep; returns number of elements. If sep is not supplied, FS is used. Array splitting works the same way as field splitting.

sprintf(”fmt“,expr)  Uses printf format specification for expr.

sub(r,s,t)	    Substitutes s for first match of the regular expression r in the string t. Returns 1 if successful; 0 otherwise. If t is not supplied, defaults to $0.

substr(s,p,n)	Returns substring of string s at beginning position p up to a maximum length of n. If n is not supplied, the rest of the string from p is used.

tolower(s)	    Translates all uppercase characters in string s to lowercase and returns the new string.

toupper(s)	    Translates all lowercase characters in string s to uppercase and returns the new string.

    + example 
    
if (gsub(/UNIX/, "POSIX"))
	print
    
awk '# do.outline -- number headings in chapter.
{
gsub(/"/, "")
}
/^\.Se/ {
	sub(/^\.Se /, "Chapter ") 
	ch = $2
	ah = 0
	bh = 0
	print
	next
}
/^\.Ah/ {
	sub(/^\.Ah /, "\t " ch "." ++ah " ") 
	bh = 0
	print
	next
}
/^\.Bh/ {
	sub(/^\.Bh /, "\t\t " ch "."  ah "." ++bh " ")
	print
}' $*


    + define your own function 
    
function name (parameter-list) {
	statements
    
    return expression
}

    + function library 
    
    You might want to put a useful function in its own file and store it in a central directory. Awk permits multiple uses of the -f option to specify more than one program file.
    
    $ awk -f grade.awk -f /usr/local/share/awk/sort.awk grades.test
    
    ```
# grade.sort.awk -- script for sorting student grades
# input: student name followed by a series of grades

# sort function -- sort numbers in ascending order
function sort(ARRAY, ELEMENTS, 	temp, i, j) {
	for (i = 2; i <= ELEMENTS; ++i) 
		for (j = i; ARRAY[j-1] > ARRAY[j]; --j) { 
			temp = ARRAY[j]
			ARRAY[j] = ARRAY[j-1]
			ARRAY[j-1] = temp
	}
	return 
}

# main routine
{ 
# loop through fields 2 through NF and assign values to
# array named grades
for (i = 2; i <= NF; ++i)
	grades[i-1] = $i 

# call sort function to sort elements

sort(grades, NF-1)

# print student name
printf("%s: ", $1)

# output loop
for (j = 1; j <= NF-1; ++j)
	printf("%d ", grades[j])
printf("\n")
}
    ```
    
- the bottom drawer 

cover a number of topics, including the following:

The getline function, The getline function is used to read another line of input. Not only can getline read from the regular input data stream, it can also handle input from files and pipes.

The system( ) function

Directing output to files and pipes

Debugging awk scripts

    + example 
```   
# getline.awk -- test getline function
/^\.SH "?Name"?/ { 
	getline # get next line
	print $1 # print $1 of new line.
}
```
$ awk -f getline.awk test

getline to read all the lines after the heading “Related Commands.” We can test the return value of getline in a while loop to read a number of lines from the input. 

```
# Match "Related Commands" and collect them
/^\.SH "?Related Commands"?/ {
	print
	while (getline > 0)
		commandList = commandList $0
}
```

read from  file data:

getline < "data"

    +  getline following a prompt for the user to enter information:

BEGIN { printf "Enter your name: "
	getline < "-"
	print  
}

    + The getline function allows you to assign the input record to a variable. input into the variable input
    
    getline input
    
    + reading from a pipe 
    
    "who am i" | getline
    
    + example 
 who am i command to get the user’s name. It then looks up the name in /etc/passwd, printing out the fifth field of that file, the user’s full name:
```
awk '# getname - print users fullname from /etc/passwd
BEGIN { "who am i" | getline 
	name = $1
	FS = ":"
}
name ~ $1 { print $5 }
' /etc/passwd
```

- The close function allows you to close open files and pipes. There are a number of reasons you should use it.

close may be necessary in order to get an output pipe to finish its work. For example:

{ some processing of $0 | "sort > tmpfile" }
END {
	close("sort > tmpfile")
	while ((getline < "tmpfile") > 0) {
		do more work
	}
}

- The system( ) function executes a command supplied as an expression.

BEGIN { if (system("mkdir dale") != 0) 
		print "Command Failed" }

- Menu-Based Command Generator

$ cat uucp_commands
UUCP Status Menu
Look at files in PUBDIR:find /var/spool/uucppublic -print
Look at recent status in LOGFILE:tail /var/spool/uucp/LOGFILE
Look for lock files:ls /var/spool/uucp/*.LCK


```
BEGIN { FS = ":"
if ((getline < CMDFILE) > 0)
	title = $1
else
	exit 1
while ((getline < CMDFILE) > 0) {
	# load array
	++sizeOfArray
	# array of menu items
	menu[sizeOfArray] = $1
	# array of commands associated with items
	command[sizeOfArray] = $2
	} 
...
}
```

read the first line of this file and assign it to a variable named title. The rest of the lines contain two fields and are read into two arrays, one for the menu items and one for the commands to be executed. 

The variable CMDFILE is the name of the menu-command file, which is passed as a command-line parameter.
$ awk script CMDFILE="uucp_commands" -

your version of awk doesn’t have the -v option, you can pass the value of CMDFILE as a shell variable. Create a shell script to execute awk. and chane the line to 
while ((getline < '"$CMDFILE"') > 0 ) ...

function to display the menu 
```
function display_menu( ) {
	# clear screen -- comment out if clear does not work
	system("clear")
	# print title, list of items, exit item, and prompt
	print "\t" title
	for (i = 1; i <= sizeOfArray; ++i)
		printf "\t%d. %s\n", i, menu[i]
	printf "\t%d. Exit\n", i
	printf("Choose one: ")
}
```

the full script invoke program in full:
```
awk -v CMDFILE="uucp_commands"  '# invoke -- menu-based
                                  # command generator
# first line in CMDFILE is the title of the menu
# subsequent lines contain: $1 - Description;
# $2 Command to execute
BEGIN { FS = ":" 
# process CMDFILE, reading items into menu array 
  if ((getline < CMDFILE) > 0)
	title = $1
  else
	exit 1
  while ((getline < CMDFILE) > 0) {
	# load array
	++sizeOfArray
	# array of menu items
	menu[sizeOfArray] = $1
	# array of commands associated with items
	command[sizeOfArray] = $2
  } 
  # call function to display menu items and prompt
  display_menu( )
}
# Applies the user response to prompt
{
   # test value of user response
   if ($1 > 0 && $1 <= sizeOfArray) {
	# print command that is executed
	printf("Executing ... %s\n", command[$1]) 
	# then execute it. 
	system(command[$1])
	printf("<Press RETURN to continue>")
 	# wait for input before displaying menu again
	getline
   }
   else 
	exit	
   # re-display menu 
   display_menu( )
}

function display_menu( ) {
	# clear screen -- if clear does not work, try "cls"
	system("clear")
	# print title, list of items, exit item, and prompt
	print "\t" title
	for (i = 1; i <= sizeOfArray; ++i)
		printf "\t%d. %s\n", i, menu[i]
	printf "\t%d. Exit\n", i
	printf("Choose one: ")
}' -
```

output is displayed:

UUCP Status Menu
        1. Look at files in PUBDIR
        2. Look at recent status in LOGFILE
        3. Look for lock files
        4. Exit
Choose one:


- directin output to files and pipes 

operators “>” or “>>”. For example, the following statement writes the current record to the file data.out:

print > "data.out"

direct output to a pipe. The command

print | command

- generating columnar reports 

two sample customer records from the customer order file:

Charlotte Webb 
P.O  N61331 97 Y 045 	Date: 03/14/97
#1 3  7.50
#2 3  7.50
#3 1  7.50
#4 1  7.50
#7 1  7.50 

Martin S. Rossi 
P.O  NONE 	Date: 03/14/97
#1 2  7.50
#2 5  6.75

awk '/^#/ {
		amount = $2 * $3
		printf "%s %6.2f\n", $0, amount
		next
	 }
{ print }' $*


- Debugging 

Before you begin debugging a program, make a copy of it. This is extremely important.

use the print statement to print the value of the variable 

est that the input reaches part of a program. For instance, when debugging the masterindex program, described in

Commenting Out Loud
Another technique is simply commenting out a series of lines that may be causing problems to see whether they really are. 

- limitations 

most systems.

Table 10.1. Limitations
Item	Limit
Number of fields per record	100
Characters per input record	3000
Characters per output record	3000
Characters per field	1024
Characters per printf string	3000
Characters in literal string	400
Characters in character class	400
Files open	15
Pipes open	1

- invoke awk using the #! syntax 

 “#!” syntax is an alternative syntax for invoking awk from a shell script. 

 #!/bin/awk -f

```
 #!/bin/awk
{ print $1 }
```

```
#!/bin/sh
/bin/awk '{ print $1 }'
```

- flock of awks, different version may have slightly different sytnax  

- free available awk 

common extensions 

 free awks extend the delete statement, making it possible to delete all the elements of an array at one time. The syntax is:

delete array

flusing buffered output,  fflush( ). Like close( ), the argument to fflush( ) is the name of an open file or pipe. Unlike close( ), the fflush( ) function only works on output files and pipes.

 output of the program is directed to a file:

printf "Enter your name:" >"/dev/tty"

The nextfile statement is similar to next, but it operates at a higher level. When nextfile is executed, the current data file is abandoned, and processing starts over at the top of the script, using the first record of the following file. 

- bell labs awk 

- gnu awk (gawk)

- Michael’s awk (mawk)

- commercial awks 

MKS awk

Thompson Automation awk (tawk)

- full featured applications 

 first program, spellcheck, provides an interactive interface to the UNIX spell program. The second application, masterindex, is a batch program for generating an index for a book