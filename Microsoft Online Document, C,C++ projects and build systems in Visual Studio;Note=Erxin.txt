Microsoft Online Document, C,C++ projects and build systems in Visual Studio;Note=Erxin

# Introduction 
- build simple programs by invoking the MSVC compiler (cl.exe) directly from the command line.
- build systems and projects 



# Visual Studio projects c++ 
- Set compiler and build properties 

Project > project-name Properties from the main menu

- The Property Pages dialog box shows only the property pages that are relevant to the current project. For example, if the project doesn't have an .idl file, the MIDL property page isn't displayed. 

- Macros look like $(macro-name) or %(item-macro-name). They're exposed in the property pages

Global macros apply to all items in a project configuration. 

Item macros have the syntax %(name). 

A user-defined macro is a name/value pair.

- The MSVC compiler (cl.exe) recognizes certain environment variables, specifically LIB, LIBPATH, PATH, and INCLUDE

- project's Property Pages dialog box, expand Configuration Properties and then select Debugging.

- View > Property Manager or View > Other Windows > Property Manager, depending on your settings.

- convention has a .props file name extension. You can apply the sheet (or sheets) to new projects so you don't have to set those properties from scratch.

- evaluation in the .vcxproj file, the .props and .targets files, environment variables, and the command line, see Project property inheritance.

- Add New Project Property Sheet and then select, for example, the MyProps.props property sheet, a property page dialog box appears.

- create a property sheet 

    + View > Property Manager or View > Other Windows > Property Manager. The Property Manager opens.

    + define the scope of the property sheet, select the item to which it applies. This item can be a particular configuration, or another property sheet

    + in Property Manager, open the new property sheet and then set the properties you want to include.

    + Others come from other .targets or .props files that the project file imports and which supply default values. You'll find the Visual Studio project files in a locale-specific folder under the base directory, %VSINSTALLDIR%MSBuild\Microsoft\VC\<version>

    + set a property to "X" in a .props file, but the property is set to "Y" in the project file, then the project will build with the property set to "Y". If the same property is set to "Z" on a project item, such as a .cpp file, then the MSBuild engine will use the "Z" value.
    
- project property inheritance 

    1. Default settings from the MSBuild CPP Toolset (the Microsoft.Cpp.Default.props file in the base directory, which is imported by the .vcxproj file.)

    2. Property sheets

    3. .vcxproj file. (This file can override the default and property sheet settings.)

    4. Items metadata

- view and expanded project file with all imported values 

$ msbuild /pp:temp.txt myapp.vcxproj

- build configuration 

You can use the Configuration Manager to define custom configurations.

- modify properties and targets without changing the project file 


    + override project properties 
    Create a .props file that specifies the properties you want to override.

    From the command prompt: set ForceImportBeforeCppTargets="C:\sources\my_props.props"

    + override project targets 
    Create a .targets file with their implementation or a particular target

    From the command prompt: set ForceImportAfterCppTargets ="C:\sources\my_target.targets"

    + msbuild command line 

> msbuild myproject.sln /p:ForceImportBeforeCppTargets="C:\sources\my_props.props"
> msbuild myproject.sln /p:ForceImportAfterCppTargets="C:\sources\my_target.targets"

    + add into project file
<Import Project=="C:\sources\my_props.props" />
<Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
<Import Project==" C:\sources\my_target.targets"" />

- Clang/LLVM support in Visual Studio projects 

choosing C++ Clang tools for Windows under Desktop development with C++ optional components. You may prefer to use an existing Clang installation

Solution Explorer choose all configurations > General > Platform Toolset, choose LLVM (clang-cl) and then OK.

Visual Studio by default invokes Clang in clang-cl mode

- reference libraries and components at build time 
    + using the vcpkg package manager, you can ignore the instructions below. For more information, see vcpkg.io
    
    + consuming static libraries 
    
    #include the header file(s) for the static library using quotation marks. In a typical solution, the path starts with ../<library project name>

    Add a reference to the static library project. Right-click on References under the application project node in Solution Explorer and choose Add Reference

    + consuming third party static libraries 
    
    Right-click on the application project node in Solution Explorer and then choose Properties.
    
    In the VC++ Directories property page, add the path to the directory that contains the LIB file to Library Paths. 

    add the path to the library header file(s) to Include Directories.

    In the Linker > Input property page, add the name of the LIB file to Additional Dependencies.
    
    + dynamic libraries 
    
    Copy the DLL to the output folder of your project, or to another folder in the standard Windows search path for DLLs

    1-3 for static libraries to provide the paths to the headers and LIB file.

    + COM objects 
    
    If your native C++ application needs to consume a COM object, and that object is registered, then all you have to do is call CoCreateInstance and pass in the CLSID of the object
    
    A C++/CLI project can consume a COM object in the same way. Or, it can consume it by adding a reference to it from the Add References > COM list

    + .net assemblies and windows runtime components 
    
    In UWP or C++/CLI projects, you consume .NET assemblies or Windows Runtime Components by adding a reference to the assembly or component.
    
    Choose the Browse button to navigate to any folder that contains a custom component. view their methods and classes by right-clicking and choosing View in Object Browser.

    + reference properties 
    
    ActiveX reference properties are available only for references to COM components. 
    
    + build properties 
    
    Copy Local, Specifies whether to automatically copy the referenced assembly to the target location during a build.

    Copy Local Satellite Assemblies (C++/CLI), Specifies whether to automatically copy the satellite assemblies of the referenced assembly to the target location

    Reference Assembly Output, Specifies that this assembly gets used in the build process. If true, the assembly gets used on the compiler command line 
    
    + project to project reference properties 
    
    project-to-project reference from the project that's selected in the References pane to another project in the same solution. 
    
    Project Identifier, Uniquely identifies the independent project.

    + Read-only reference properties (COM & .NET)
    
- organize project output files for builds 
    + referencing CLR assemblies 
    using directive, such as #using <System.Data.dll>. For more information, see #using Directive.

    + Instead of referencing an assembly directly from a code file as described above, you can use the /FU compiler option
    
    + This is the easiest way to use CLR assemblies. First, make sure the project is compiled with the /clr compiler option

    + Property Pages dialog, select Add New Reference. A dialog will appear listing all .NET, COM, and other assemblies available in the current project.
    
    + reference native dlls or static libraries 
    
    Setting project dependencies guarantees two things. it ensures that projects are built in the right order. implicitly adds the dependent project's output directory to the path so that files can be found easily at link-time.
    
    + working with multiple projects 
    
    sibling projects to refer to each other, each project must explicitly add the other project output directories to their path in order for linking to succeed
    
    when a project has Debug and Release configurations, and it includes an external library from a sibling project, it should use a different library file depending on which configuration is being built.
    
    avoid using relative paths in #include statements in your code. 
    
    + specify the output files 
    
    output settings can be found in the project's Property Pages. Expand the node next to Configuration Properties and select General
    
    Output Directory. For more information, see General Property Page (Project).
    
- customize build steps and build events 

A custom build step can specify a command line to execute, any additional input or output files

A custom build step can pass input files to a custom build tool
    
There are three build events: pre-build, pre-link, and post-build. A build event lets you specify an action 
    
- build steps:

Pre-Build event

Custom build tools on individual files

MIDL

Resource compiler

The C/C++ compiler

Pre-Link event

Linker or Librarian (as appropriate)

Manifest Tool

BSCMake

Custom build step on the project

Post-Build event

- specify a custom build tool 

Configuration Properties to enable the Configuration box. In the Configuration box, select the configuration for which you want to specify

Additional Dependencies, specify any additional files beyond the one for which the custom build tool is being defined. an Additional Dependencies file's date is later than the input file, then the custom build tool is run

Command Line, specify a command as if you were specifying it at the command prompt. Specify a valid command or batch file

In Outputs, specify the name of the output file. This is a required entry

    + example 
Create a custom build tool for parser.l and enter the following in the Commands property:

    lexer %(FullPath) .%(Filename).c

In the Outputs property, enter the following:

    .%(Filename).c

- specify a build event 
Solution Explorer > Build Events folder, select a build event property page.

Because the '%' character is reserved by MSBuild, if you specify an environment variable replace each % escape character with the %25 hexadecimal escape sequence. For example, replace %WINDIR% with %25WINDIR%25. 

- troubleshooting build customizations 

build log is represented by the MSBuild macro expression, $(IntDir)\$(MSBuildProjectName).log.

- Create a c++ project from existing code 

a C++ project using the Create New Project From Existing Code Files wizard.



# Open folder projects for c++ 
- You can also use CMake to build Qt projects, or you can use the Qt Visual Studio Extension

File | Open | Folder or press Ctrl + Shift + Alt + O. Navigate to the folder that contains your source code files

CppProperties.json 	Specify custom configuration information for browsing. 

tasks.vs.json 	Specify custom build commands. Accessed via the Solution Explorer context menu item Configure Tasks.

launch.vs.json 	Specify command line arguments for the debugger. 

- CppProperties.json 
    + x64-Debug 
    
{
  "configurations": [
    {
      "inheritEnvironments": [
        "msvc_x64"
      ],
      "name": "x64-Debug",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "defines": [
        "WIN32",
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "intelliSenseMode": "windows-msvc-x64"
    }
  ]
}

    + MinGW-w64
{
  "configurations": [
    {
      "inheritEnvironments": [
        "mingw_64"
      ],
      "name": "Mingw64",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "intelliSenseMode": "linux-gcc-x64",
      "environments": [
        {
          "MINGW64_ROOT": "C:\\msys64\\mingw64",
          "BIN_ROOT": "${env.MINGW64_ROOT}\\bin",
          "FLAVOR": "x86_64-w64-mingw32",
          "TOOLSET_VERSION": "9.1.0",
          "PATH": "${env.BIN_ROOT};${env.MINGW64_ROOT}\\..\\usr\\local\\bin;${env.MINGW64_ROOT}\\..\\usr\\bin;${env.MINGW64_ROOT}\\..\\bin;${env.PATH}",
          "INCLUDE": "${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION};${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\tr1;${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\${env.FLAVOR}",
          "environment": "mingw_64"
        }
      ]
    }
  ]
}

- enable intellisense diagnostics

Tools > Options > Text Editor > C/C++ > Advanced and setting Enable Logging to true.

a complete tasks.vs.json file with as single task that invokes g++.exe to build a project

{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "build hello",
      "appliesTo": "/",
      "type": "default",
      "command": "g++",
      "args": [
        "-g",
        "-o",
        "hello",
        "hello.cpp"
      ]
    }
  ]
}



# CMake projects 
- CMake documentation. The CMake tutorial is a good starting point to learn more.

- open a folder containing a CMakeLists.txt file, the following things happen.

Edit and Continue for CMake projects

Incredibuild integration for CMake projects

AddressSanitizer support for CMake projects

Clang/LLVM support

- CMakePresets.json, see Configure and build with CMake Presets. CMakeSettings.json

- Project > Configure Cache from the toolbar. You can also change your configuration preferences in Tools > Options > CMake > General.

Tools > Options > CMake > Enable verbose CMake diagnostic output.

CMake cache generation won't start and CMake configurations (from CMakeSettings.json or CMakePresets.json) 

reach CMakeWorkspaceSettings.json through the Project > CMake Workspace Settings menu

- set a breakpoint build and run on linux 

- Visual Studio 2022 introduces a native C++ toolset for Windows Subsystem for Linux version 2 (WSL 2) development

- You can use Visual Studio with Clang to edit and debug C++ CMake projects that target Windows or Linux.

- C++ Clang compiler for Windows under Desktop development with C++ optional components. When using a custom Clang installation, check the C++ Clang-cl for v143 build tools 

Right-click on CMakeLists.txt in Solution Explorer and choose CMake settings for project.


(Windows) The internally installed copy of Clang/LLVM that comes with the Visual Studio installer.
(Windows and Linux) The PATH environment variable.

- make present 

CMakePresets.json is for saving project-wide builds. CMakeUserPresets.json is for developers to save their own local builds




# Get started with C++ build insights 
- C++ Build Insights is a collection of tools that provides increased visibility into the Microsoft Visual C++ (MSVC) tool chain. 

- main components 

vcperf.exe, a command-line utility that you can use to collect traces for your builds,

a Windows Performance Analyzer (WPA) extension that allows you to view build traces in WPA, and

the C++ Build Insights SDK, a software development kit for creating your own tools

A useful one is the CPU (Sampled) view, which shows CPU utilization throughout your build.

- c++ build insights sdk 

Open an elevated x64 Native Tools Command Prompt for VS 2019.

Run the following command: vcperf /start MySessionName

Build your project.

Run the following command: vcperf /stopnoanalyze MySessionName outputTraceFile.etl




# Build and import header units 
- A header unit is a binary representation of a header file. A header unit ends with an .ifc extension. 

- difference between a header unit and a header file is that a header unit isn't affected by macro definitions outside of the header unit

you can't #define a symbol that causes the header unit to behave differently

Header units can be imported in any order. 

- ways to compile a header unit 

    + choose individual files to translate into header units 
    https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170#approach1
    
    + build a shared header unit project 
    + automatically scan for and build header units 
    + build and import STL header files as header units 

- steps 

    1. project properties, set the C++ Language Standard to /std:c++20 Configuration Properties > General.

    2. In Solution Explorer, select the file you want to compile as a header unit 

    3. Set the Configuration properties > General > Item Type dropdown to C/C++ compiler and choose Ok.

    4. From the source file change #include "Pythagorean.h" to import "Pythagorean.h";

    5. it's a header file in a directory local to the project, we used quotes with the import statement, that is: import "file"; In your own projects, to compile a header unit from a system header use angle brackets: import <file>;

    6. Build the solution by selecting Build > Build Solution on the main menu. Run it to see that it produces the expected

- second approach avoid set header file one by one in the Solution Explorer and choose Properties. Then choose Configuration Properties > C/C++ > General.

    1. Scan Sources for Module Dependencies causes the build system to call the compiler to ensure that all imported modules and header units are built before compiling

    2. Translate Includes to Imports treats a header file as an import if the #include refers to a header file that can be compiled as a header unit 


The header-units.json file is used to automatically build header units for each #include without symbol duplication.

- import stl libraries as header unit 

A header unit is a binary representation of a header file. It has an .ifc extension.

To create a static library that contains the STL libraries <iostream> and <vector>, follow these steps

If you're using Visual Studio 2019 version 16.10, use /std:c++latest. you need the /std:c++20 or later option.

- reuse header units,  Solution explorer VC++ Directories, Public C++ module directories, All modules are public 

    + Public Include Directories specifies project directories for header units

- use a prebuilt module file 

Project > Properties > C/C++ > General 

In the Additional Module Dependencies list, add the modules to reference. Here's an example of the format to use for Additional Module Dependencies: ModuleName1=Path\To\ModuleName1.ifc; ModuleName2=Path\To\ModuleName2.ifc

Additional Header Unit Dependencies: 

Path\To\Header1.h= Path\To\HeaderUnit1.ifc;
Path\To\Header2.h= Path\To\ HeaderUnit2.ifc;

- The header-units.json file serves two purposes:

    + Specify which header files can be translated into header units when /translateInclude is specified.
    + Minimize duplicated symbols to increase build throughput.


a header-units.json file for the STL headers that the compiler uses when /translateInclude is specified. It determines which STL headers can be compiled into header units. The header-units.json file is under the installation directory for Visual Studio. For example, %ProgramFiles%\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.30.30705\include\header-units.json

- precompiled header files 

a precompiled header file named pch.h is added to the project. (In Visual Studio 2017 and earlier, the file was called stdafx.h.) The purpose of the file is to speed up the build process. 

Any stable header files, for example Standard Library headers such as <vector>, should be included here

The precompiled header is compiled only when it, or any files it includes, are modified.

the options are located under Configuration Properties > C/C++ > Precompiled Headers. 



# C++ release build 
-  create a release build, the compiler will not produce symbolic debugging information. code is not generated for TRACE and ASSERT calls

- release from the Solution Configuration drop-down list, which is on the Standard toolbar.

- heap layout 

all memory allocations have guard bytes placed around them. heap layout isdifferent between release and debug versions. release build may have problems

- compilation 

MFC macros and much of the MFC implementation changes when you build for release. In particular, the ASSERT macro evaluates to nothing in a release build,

- pointer support 
The lack of debugging information removes the padding from your application. stray pointers have a greater chance of pointing to uninitialized memory instead of pointing to debug information.

- optimizations 

Depending on the nature of certain segments of code, the optimizing compiler might generate unexpected code. 

- fixing release build problems 

If you are using ASSERT to confirm that a function call succeeded, consider using VERIFY instead. The VERIFY macro evaluates its own arguments in both debug and release builds 

    + problem code 
enum {
    sizeOfBuffer = 20
};
char *buf;
ASSERT(buf = (char *) calloc(sizeOfBuffer, sizeof(char) ));
strcpy_s( buf, sizeOfBuffer, "Hello, World" );
free( buf );

    + correct 
    
enum {
    sizeOfBuffer = 20
};
char *buf;
buf = (char *) calloc(sizeOfBuffer, sizeof(char) );
ASSERT( buf != NULL );
strcpy_s( buf, sizeOfBuffer, "Hello, World" );
free( buf );

- using debug build to check for memory overwrite

    + beginning of your application's InitInstance function and add the following line

afxMemDF |= checkAlwaysMemDF;

By turning on the checkAlwaysMemDF, you will force MFC to make a call to the AfxCheckMemory function every time a call to new or delete is made. 

    + explicit calls to AfxCheckMemory
    
ASSERT(AfxCheckMemory());
    DoABunchOfStuff();
    ASSERT(AfxCheckMemory());

- debug your release build 

Property Pages dialog box for the project. For details, see Set C++ compiler and build properties in Visual Studio.

Click the C/C++ node. Set Debug Information Format to C7 compatible (/Z7) or Program Database (/Zi).

Expand Linker and click the General node. Set Enable Incremental Linking to No (/INCREMENTAL:NO).

Select the Debugging node. Set Generate Debug Info to Yes (/DEBUG).

Select the Optimization node. Set References to /OPT:REF and Enable COMDAT Folding to /OPT:ICF.

You can now debug your release build application. To find a problem, step through the code 

- checking for memory overwrites 

The _heapchk function is available in both debug and release builds

if(_heapchk()!=_HEAPOK)
   DebugBreak();
   
   
   
# Optimizing your code 
- optimize pragma 

#pragma optimize("", off)
// some code here
#pragma optimize("", on)

- optimization prgmas and keywords 

 C or C++ code affect optimization:
```
__asm

__assume

inline, __inline, or __forceinline

#pragma auto_inline

#pragma check_stack

#pragma function

#pragma inline_depth

#pragma inline_recursion

#pragma intrinsic

#pragma optimize

register Keyword
```

- improving compiler throughput 

This is important if you are using ATL, MFC, or the Windows SDK header files.

- floating point numbers may lose precision 

Floating-point decimal values generally do not have an exact binary representation. This is a side effect of how the CPU represents floating point data.

The binary representation of the decimal number may not be exact.

There is a type mismatch between the numbers used (for example, mixing float and double).

    + workaround 
        * limit the range 
        * they get and use a Binary Coded Decimal (BCD) library that will maintain the precision.
    
```
// Floating-point_number_precision.c
// Compile options needed: none. Value of c is printed with a decimal
// point precision of 10 and 6 (printf rounded value by default) to
// show the difference
#include <stdio.h>

#define EPSILON 0.0001   // Define your own tolerance
#define FLOAT_EQ(x,v) (((v - EPSILON) < x) && (x <( v + EPSILON)))

int main() {
   float a, b, c;

   a = 1.345f;
   b = 1.123f;
   c = a + b;
   // if (FLOAT_EQ(c, 2.468)) // Remove comment for correct result
   if (c == 2.468)            // Comment this line for correct result
      printf_s("They are equal.\n");
   else
      printf_s("They are not equal! The value of c is %13.10f "
                "or %f",c,c);
}
```

- FLT_EPSILON, which is defined for float as 1.192092896e-07F, or DBL_EPSILON, which is defined for double as 2.2204460492503131e-016. You need to include float.h for these constants

- IEEE floating point representation 

The IEEE-754 standard describes floating-point formats, a way to represent real numbers in hardware.

The single-precision (4-byte) and double-precision (8-byte) formats are used in MSVC. Single-precision is declared using the keyword float. Double-precision is declared using the keyword double.

half-precision (2-byte) and quadruple-precision (16-byte) formats, and a double-extended-precision (10-byte) format, which some C and C++ compilers implement as the long double data type.

    + In single-precision and double-precision formats, there's an assumed leading 1 in the fractional part. The fractional part is called the significand (sometimes known as the mantissa). This leading 1 isn't stored in memory, so the significands are actually 24 or 53 bits, even though one less bit gets stored. The double-extended-precision format actually stores this bit.

- Zero can't be normalized, which makes it unrepresentable in the normalized form of a single-precision or double-precision value. 

NaN - Not a Number

- Tips for improving time-critical code 

A CPU cache hit can cost your program 10-20 clock cycles. An external cache hit can cost 20-40 clock cycles. A page fault can cost one million clock cycles 

    + Cache Misses and Page Faults
    
    Dynamically allocated linked lists can reduce program performance

    Hash tables that use dynamically allocated linked lists can degrade performance.
    
    + Sorting and searching 
    
    Defer sorting until a non-performance-critical time.

    Sort the data at an earlier, non-performance-critical time.

    Sort only the part of the data that truly needs sorting.
    
    earch is time-critical, a binary search or hash table lookup is almost always best, but as with sorting, you must keep locality in mind. A linear search through a small array can be faster than a binary search 
    
    + MFC and class libraries 
    
    CString MFC calls the C run-time library to allocate memory for a CString dynamically. Generally speaking, CString is as efficient as any other dynamically-allocated string.
    
    CArray A CArray provides flexibility that a regular array doesn't, but your program may not need that. If you know the specific limits for the array, you can use a global fixed array instead. 
    
    CList CList is a doubly linked list, so element insertion is fast at the head, tail, and at a known position (POSITION) in the list.
    
    IsKindOf This function can generate many calls and access a lot of memory in different data areas, leading to bad locality of reference.
    
    PreTranslateMessage Use PreTranslateMessage when a particular tree of windows needs different keyboard accelerators or when you must insert message handling into the message pump. 
    
    OnIdle Idle events can occur at times you do not expect, such as between WM_KEYDOWN and WM_KEYUP events.
    
    + Use multiple heaps with discretion. Additional heaps created with HeapCreate and HeapAlloc let you manage and then dispose of a related set of allocations.
    
    Measure your heaps so you can account for every allocation on the heap. Use the C run-time debug heap routines to checkpoint and dump your heap

    + Threads also present communication problems. You must manage the communication link between your threads, with a list of messages or by allocating and using shared memory. 
    
    + Smaller working sets mean better locality of reference, fewer page faults, and more cache hits. 
    
    
- Using function name without () produces no code 

the function call operator "()" is not present, no call is made. This result is similar to the following. Visual C++, even using warning level 4 generates no diagnostic output. No warning is issued; no code is produced.

```
#include <stdio.h>
void funcn();

int main() {
   funcn;      /* missing function call operator;
                  call will fail.  Use funcn() */
   }

void funcn() {
   printf("\nHello World\n");
}
```

- optimiztion best practices 




    
# Building c/c++ isolated application and side by side assemblies 
- building c/c++ side-by-side assemblies 

A side-by-side assembly is a collection of resources—a group of DLLs, windows classes, COM servers, type libraries, or interfaces—available for an application to use at runtime. 

- DLLs can be repackaged into a side-by-side assembly with a corresponding assembly manifest, which describes which files form the assembly as well as the dependence of the assembly

- an MFC ActiveX Controls project creates an .ocx library

- build registration free com components 

Open the project property pages for the COM component.

Expand the Configuration Properties node, and then expand the Manifest Tool node.

Select the Input and Output property page, and then set the Embed Manifest property equal to Yes.

Click OK.

build the solution 





# Dynamic link libraries 
- search order 

    + factor that affect searching 
    
    If a DLL with the same module name is already loaded in memory, the system checks only for redirection and a manifest before resolving to the loaded DLL, no matter which directory it is in. The system does not search for the DLL.
    
    If the DLL is on the list of known DLLs for the version of Windows on which the application is running, the system uses its copy of the known DLL. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs.

    + uwp apps 
    
    a UWP app for Windows 10 (or a Store app for Windows 8.x) loads a packaged module by calling the LoadPackagedLibrary function

    The package dependency graph of the process. This is the application's package plus any dependencies specified as <PackageDependency> in the <Dependencies> section of the application's package manifest.

    The directory the calling process was loaded from.

    The system directory (%SystemRoot%\system32).

    + alternate search order for uwp apps 
    
    calling the LoadLibraryEx function with LOAD_WITH_ALTERED_SEARCH_PATH, the system searches the directory the specified module was loaded from instead of the directory of the calling process.

    + standard search order for desktop applications 
    
    Safe DLL search mode is enabled by default. To disable this feature, create the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode registry value and set it to 0.
    
        * The directory from which the application loaded.
        
        * The system directory. Use the GetSystemDirectory function to get the path of this directory.

        * The 16-bit system directory. 

        * The Windows directory. Use the GetWindowsDirectory
        
        * The current directory.
        
        * The directories that are listed in the PATH environment variable. 
        
    If SafeDllSearchMode is disabled, the search order is as follows:
        
        * The directory from which the application loaded.
        
        * The current directory.

        * The system directory. Use the GetSystemDirectory

        * The 16-bit system directory

        * The Windows directory. Use the GetWindowsDirectory

        * The directories that are listed in the PATH environment variable.

    + alternate search order 
    
    LoadLibraryEx function with LOAD_WITH_ALTERED_SEARCH_PATH. The standard search order can also be changed by calling the SetDllDirectory
     
    + search order using load library search flags 
    
    An application can specify a search order by using one or more LOAD_LIBRARY_SEARCH flags with the LoadLibraryEx function. An application can also use LOAD_LIBRARY_SEARCH flags with the SetDefaultDllDirectories function to establish a DLL search order for a process. 
    
    process DLL search order by using the AddDllDirectory or SetDllDirectory functions.
    
    
    
     

