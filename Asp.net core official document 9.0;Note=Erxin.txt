Asp.net core official document 9.0;Note=Erxin


# Overview 
- ASP.NET Core, you can:

Build web apps and services, Azure IoT (Internet of Things) apps, and mobile backends.
Use your favorite development tools on Windows, macOS, and Linux.
Deploy to the cloud or on-premises.
Run on .NET.

- ASP.NET 4.x to create web apps. ASP.NET Core is a redesign of ASP.NET 4.x, including architectural changes 

benefits:

A unified story for building web UI and web APIs.
Architected for testability.
Blazor lets you use C# in the browser alongside JavaScript. Share server-side and client-side app logic all written with .NET.
Razor Pages makes coding page-focused scenarios easier and more productive.
Ability to develop and run on Windows, macOS, and Linux.
Open-source and community-focused.
Integration of modern, client-side frameworks and development workflows.
Support for hosting Remote Procedure Call (RPC) services using gRPC.
A cloud-ready, environment-based configuration system.
Built-in dependency injection.
A lightweight, high-performance, and modular HTTP request pipeline.
Ability to host on the following:
Kestrel
IIS
HTTP.sys
Nginx
Docker
Side-by-side versioning.
Tooling that simplifies modern web development.

- ASP.NET Core MVC provides features to build web APIs 

mvc
https://learn.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-9.0

blazor
https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-9.0

razor 
https://learn.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-9.0

razor mvc
https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-9.0

Built-in support for multiple data formats and content negotiation 

Model binding automatically maps data from HTTP requests to action method parameters.

Model validation automatically performs client-side and server-side validation.

- ASP.NET Core includes Blazor for building richly interactive web UI, and also integrates with other popular frontend JavaScript frameworks like Angular, React, Vue, and Bootstrap.

https://getbootstrap.com/

- advantages of .NET over .NET Framework include:

Cross-platform. Runs on Windows, macOS, and Linux.
Improved performance
Side-by-side versioning
New APIs
Open source

- learning path 
https://dotnet.microsoft.com/learn/aspnet/blazor-tutorial/intro

https://learn.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/razor-pages-start?view=aspnetcore-9.0

https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc?view=aspnetcore-9.0

https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-9.0

https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-9.0

realtime app 
https://learn.microsoft.com/en-us/aspnet/core/tutorials/signalr?view=aspnetcore-9.0

- basic data access 

New development	Blazor with Entity Framework Core
https://learn.microsoft.com/en-us/aspnet/core/blazor/tutorials/movie-database-app/?view=aspnetcore-9.0

New development	Razor Pages with Entity Framework Core
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-9.0

Maintaining an MVC app	MVC with Entity Framework Core
https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/intro?view=aspnetcore-9.0

- sample 

https://codeload.github.com/dotnet/AspNetCore.Docs/zip/main

To demonstrate multiple scenarios, sample apps use the #define and #if-#else/#elif-#endif preprocessor directives to selectively compile and run different sections of sample code. 

runs the TemplateCode scenario:

Copy
#define TemplateCode // or LogFromMain or ExpandDefault or FilterInCode


sample to run the ExpandDefault scenario, define the ExpandDefault symbol
#define ExpandDefault // TemplateCode or LogFromMain or FilterInCode



# asp.net core ui 
- core Blazor  a full-stack web UI framework
- core Razor Pages Razor Pages is a page-based model for building server rendered web UI. Razor pages UI are dynamically rendered on the server to generate the page's HTML and CSS
- ASP.NET Core MVC renders UI on the server and uses a Model-View-Controller (MVC) architectural pattern.
- Core Single Page Applications

client-side logic for ASP.NET Core apps using popular JavaScript frameworks, like Angular, React, and Vue.

Asp.ne Core provides project templates

- Combine multiple web UI solutions



# SignalR
- SignalR is an open-source library that simplifies adding real-time web functionality to apps. Real-time web functionality enables server-side code to push content to clients instantly.

SignalR provides an API for creating server-to-client remote procedure calls (RPC). The RPCs invoke functions on clients from server-side .NET Core code. 

-  real-time communication (in order of graceful fallback):

WebSockets
Server-Sent Events
Long Polling


- SignalR uses hubs to communicate between clients and servers.

A hub is a high-level pipeline that allows a client and server to call methods on each other.

- SignalR provides two built-in hub protocols: a text protocol based on JSON and a binary protocol based on MessagePack. MessagePack generally creates smaller messages compared to JSON. Older browsers must support XHR level 2


- WebHooks is a lightweight HTTP pattern providing a simple pub/sub model for wiring together Web APIs and SaaS services

https://learn.microsoft.com/en-us/aspnet/webhooks/

- Create a controller-based web API with ASP.NET Core

web API that uses a database. Another approach to creating APIs in ASP.NET Core is to create minimal APIs. For help with choosing between minimal APIs and controller-based APIs, see APIs overview.
 
- Create a minimal API with ASP.NET Core 

https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-9.0


GET /api/todoitems	            Get all to-do items	None	Array of to-do items
GET /api/todoitems/{id}	        Get an item by ID	None	To-do item
POST /api/todoitems	            Add a new item	To-do item	To-do item
PUT /api/todoitems/{id}	        Update an existing item  	To-do item	None
DELETE /api/todoitems/{id}    	Delete an item    	None	None

- Choose between controller-based APIs and minimal APIs

    + minimal APIs hides the host class by default and focuses on configuration and extensibility via extension methods that take functions as lambda expressions
    
```
namespace MinimalAPI;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        var app = builder.Build();

        app.UseHttpsRedirection();

        var summaries = new[]
        {
            "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
        };

        app.MapGet("/weatherforecast", (HttpContext httpContext) =>
        {
            var forecast = Enumerable.Range(1, 5).Select(index =>
                new WeatherForecast
                {
                    Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                    TemperatureC = Random.Shared.Next(-20, 55),
                    Summary = summaries[Random.Shared.Next(summaries.Length)]
                })
                .ToArray();
            return forecast;
        });

        app.Run();
    }
}

namespace APIWithControllers;

public class WeatherForecast
{
    public DateOnly Date { get; set; }

    public int TemperatureC { get; set; }

    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);

    public string? Summary { get; set; }
}
```



    + Controllers in an API project are classes that derive from ControllerBase. Minimal APIs define endpoints with logical handlers in lambdas or methods.  Controllers are classes that can take dependencies via constructor injection or property injection, and generally follow object-oriented patterns.
    
```
namespace APIWithControllers;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        builder.Services.AddControllers();
        var app = builder.Build();

        app.UseHttpsRedirection();

        app.MapControllers();

        app.Run();
    }
}

using Microsoft.AspNetCore.Mvc;

namespace APIWithControllers.Controllers;
[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
    private static readonly string[] Summaries = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };

    private readonly ILogger<WeatherForecastController> _logger;

    public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
        _logger = logger;
    }

    [HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable<WeatherForecast> Get()
    {
        return Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    }
}
```