Microsoft online document, Microsoft interface definition language (MIDL);Note=Erxin

# Reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-start-page



# Purpose 
- MIDL can be used in all client/server applications based on Windows operating systems.
- network environments that include such operating systems as Unix and Apple. Microsoft supports the Open Group (formerly known as the Open Software Foundation) DCE standard for RPC interoperability.

- MIDL compiler generates C-language files from IDL files.

- Application Configuration (ACF) files for MIDL


# Using MIDL compiler 
- invoking the compiler 

command line using the following command:

$ midl <options> filename.idl

MIDL compiler /help and /? switches

    + remarks 

The new global flag $(MIDL_OPTIMIZATION) exists in win32.mak. When an .idl file is compiled using this flag, the generated stub can utilize the latest RPC features available

- response files. A response file is a text file containing one or more MIDL compiler command-line options. 

You can specify a MIDL response file as, include one or more response files, with commandline parameters 

$ midl -Oicf @midl1.rsp -envwin32 @midl2.rsp itf.idl

- Using C/C++ preprocessor with MIDL 

By default, MIDL uses the preprocessor for the Microsoft C/C++ compiler from the same building environment

MIDL spawns separate preprocessor runs for top-level IDL and ACF files

included with the #include directive are handled by the preprocessor directly.

- C-preprocessor requirements for MIDL 

The MIDL switches /cpp_cmd, /cpp_opt, and /no_cpp are used to override the default behavior of the compiler.

the MIDL compiler switch /cpp_cmd enables an override of the default C/C++-preprocessor 

$ midl /cpp_cmd preprocessor_name idl-filename 

In the output stream of the preprocessor, the #line directives are present to enable better diagnostic messages.

The preprocessor must redirect output to the standard output device, stdout.

for the Microsoft C/C++ preprocessor the /E option would have to be used

$ midl /cpp_cmd cl.exe /cpp_opt "/E" file.idl

the #line directive in MIDL 
```
#line digit-sequence "filename" new-line
 
# digit-sequence "filename" new-line
```

if the /no_cpp switch is used, the input file must not have other preprocessor directives

- dealing with #defines in IDL files 

explanation applies to any files processed by MIDL, such as *.idl, *.acf, *.h files.

when MIDL replicates type definitions from an input file to the generated H file, the #defines are not replicated, do not use #defines directly in IDL files if they are to be used later from the generated H file

    + workarounds 
    
    Use the const declaration specification.
    
    ```
    const short ARRSIZE = 10
    ```
    
    will be compiled to 
    
    ```
    #define ARRSIZE 10
    ```

    Use separate header files that are imported or included in the IDL file, and later included in the C-source code.
    
    Use enumeration constants in the IDL file.

    Use cpp_quote to reproduce #define in the generated header file.
    
    handle **#**define statements is to package them in a separate header file, either into a file devoted to **#**define statements or into a file that contains only type definitions

    Importing a header or IDL file to another IDL file prevents the typedef statements from being replicated to the H file generated by MIDL 
    
    ```
    typedef enum midlworkaround { MAXSTRINGCOUNT = 300 };
    ```
    
    cpp_quote directive of MIDL can be used to write out an arbitrary string directly into the generated H file.
    ```
    cpp_quote ("#define ARRSIZE 10")
    ```
    
- verifying preprocessor options 

MIDL /cpp_opt switch, the preprocessor command line is composed of all the /I, /D and /U switches used in the MIDL command line, as well as /E and /nologo switches

To see the switches passed on to the preprocessor, use the compiler's /confirm switch.

- saving preprocessor output 

easiest and the least obtrusive way to obtain the preprocessed files from a MIDL compile run is to use the -savePP switch. The -savePP switch simply prevents MIDL from deleting the temporary files

$ midl -savePP -Id:\nt\public\sdk\inc -DNTENV=1 -Oicf -env win32 stub.idl


/E /nologo are the switches that MIDL adds when invoking the preprocessor
```
$ cl /E /nologo -Id:\nt\public\sdk\inc -DNTENV=1 stub.idl > stub.pp
$ cl /E /P -Id:\nt\public\sdk\inc -DNTENV=1 stub.idl
```


The /cpp_opt switch can also be used to obtain a preprocessed file
```
$ Midl -Oicf -win32 -cpp_opt "/E /P -Id:\nt\public\sdk\inc -DNTENV=1" stub.idl
```

- C/C++ compiler considerations 

    + natural alignment 

    A base type, such as short, float and __int64, and a pointer is aligned naturally
    
    base types have sizes of 1, 2, 4 or 8. Pointers have a size of 4 in 32-bit environments and 8 in 64-bit environments
    
    + A compound type is aligned naturally if each of its components is aligned naturally relative to the beginning of the type
    
    + connection between alignment and memory size of a type in languages like C or C++ and IDL as expressed by the operator sizeof(). The size is a multiple of the alignment
    
    Natural alignment is important because accessing misaligned data may cause an exception on some systems
    
    Data can be marked for a safe manipulation when misaligned, but typically that involves a speed penalty that may be substantial on some platforms
    
    + simple rule, new alignment of a packed type is the smaller of the packing level and its natural alignment. 
    
    a multiple of the new alignment. The sizeof() operator returns the reduced size for packed types.
    
    + 1 byte character 
    
```
struct mystructtype 
{    
    char c1;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
    long l2;  /* requires 4 bytes */
    char c3;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
 } mystruct;
```

This structure is naturally aligned at 4 and has the natural size of 12. will be misaligned if located in memory at an address that is not a multiple of 4

packing level 2, the structure is aligned at 2 and its size is 8. will be misaligned if located in memory at an address that is not a multiple of 2.

packing level 1, the structure is aligned at 1 and its size is 6, The structure packed with level 1 can be placed anywhere without causing a misalignment fault.

- C-Compiler definitions for proxy/stubs 

macros are invoked with the /D (or -D) preprocessor switch at the C-compile time
    
REGISTER_PROXY_DLL, 	Generates DllMain, DllRegisterServer, and DllUnregisterServer, self-register your proxy DLL in the system registry.

PROXY_CLSID=<clsid>, 	Specifies a class identifier for the server. I

PROXY_CLSID_IS={0x8hexdigits, ... {0x2hexdigits,0x2hexdigits,...}}      specify server's class id in binary hex format 

PROXY_CLSID=<clsid> macro when you want to explicitly specify the proxy/stub server's CLSID 

default DllRegisterServer function runs, it registers the server with ThreadingModel=Both.

makefile example 
```
example.h example.tlb example_p.c example_i.c dlldata.c : example.idl
    midl example.idl
dlldata.obj : dlldata.c
    CL /c /DWIN32 /DREGISTER_PROXY_DLL dlldata.c
example.obj : example_p.c
    CL /c /DWIN32 /DREGISTER_PROXY_DLL \
    /DPROXY_CLSID=7a98c250-6808-11cf-b73b-00aa00b677a7
example_p.c
iids.obj : example_i.c
PROXYSTUBOBJS = dlldata.obj example.obj iids.obj
PROXYSTUBLIBS = kernel32.lib rpcns4.lib rpcrt4.lib uuid.lib
proxy.dll : $(PROXYSTUBOBJX) example.def
    link /dll /out:proxy.dll /def:example.def
        $(PROXYSTUBOBJS) $(PROXYSTUBLIBS)
    regsvr32 /s proxy.dll
```

- using the __midl predefined constant 

MIDL compiler processes the input IDL and ACF files, __midl is defined by default and is used for conditional compilation to attain consistency throughout the build

example MIDL ver. 6.0.x has the __midl defined as 600.

/U switch removes any previous definition of a name by passing the name to the C preprocessor 

$ midl /U name 

- MIDL and RPC 

The MIDL compiler generates the C-language stub and header files necessary to create the interface between the client application and the server application

    + client stub 
    
    MIDL compiler switches /client, /cstub, and /out affect the client stub file.
    
    + server stub 
    
    MIDL compiler switches /server, /sstub, and /out affect the server stub file.
    
    + the header file 
    
    the generated header file contains an include line to the H file generated from the imported file. the files included with the #include directive. 
    
    MIDL compiler switches /header and /out affect the header file.
    
    + targeting stubs for specific 32 bit or 64 bit platforms
    
    Microsoft RPC and the MIDL 3.0 
    
    MIDL generates two types of guards: a platform-dependent guard (32-bit versus 64-bit) and a release-dependent guard (feature set dependency).
    ```
    #if !defined(__RPC_WIN32__)
    #error  Invalid build platform for this stub.
    #endif
    ```
    
    if the interface uses features supported only on Windows√Ç 2000 or later, MIDL generates a guard with the TARGET_IS_NT50_OR_LATER macro.
    
    The guard macros, defined in Rpcndr.h, depend on the setting of WINVER and _WIN32_WINNT and are evaluated by the C/C++ compiler.
    
    ```
    CFLAGS = $(CFLAGS) -D_WIN32_WINNT=0x500
    ```

- MIDL and COM 

the MIDL compiler combines all client and object server auxiliary routines and data into a single interface proxy file

the MIDL compiler generates an interface header file, an interface UUID file and an interface registration file. You will use all these files when creating a proxy DLL
    
    + the interface proxy file 
 
interface proxy file (U_p.c) is a C file that contains routines equivalent to those in the client stub and server stub files of an object (COM) interface

The interface proxy file includes the supporting routines and data only for methods of the interfaces defined in the current IDL file

proxy file contains the following two surrogate methods when compiled in the mixed mode (/Os), and equivalent interpreter data when compiled in the interpreter mode (/Oi).

        * The client-side surrogate, such as IFaceB_Method_Proxy 
    
        * The server-side surrogate, for example, IFaceB_Method_Stub

name for a proxy file generated from a file.idl is file_p.c.Use the /proxy MIDL compiler switch to override the default name

    + header file

    The default name for a header file generated from a file.idl is File.h, The /header MIDL compiler switch overrides the default name 

    + interface uuid file 
    
    IID file generated from a file.idl is File_i.c. The /iid MIDL compiler switch overrides the default name of the interface UUID file.
    
    + the interface registration file 
    
    interface registration file collects information that helps in the registration of COM interfaces packaged into a DLL or EXE file.
    
    the MIDL compiler implements a timeout approach to waiting on a file it cannot open,

    an input file is dlldata.c. The /dlldata MIDL compiler switch can be used to override the default name of the file
    
    + marshaling OLE data types 
    
    To use the BSTR data type in remote procedure calls, import the wtypes.idl file into your interface definition (IDL) file and link to Oleaut32.lib, your stubs use the ready-made helper functions BSTR_UserSize, BSTR_UserMarshal, BSTR_UserUnmarshal, and BSTR_UserFree.
    
    To use other Automation data types, such as VARIANT and SAFEARRAY, or types that use those types (for example, DISPPARAMS and EXCEPINFO), import the objidl.idl file into your IDL file and link to the oleaut32.lib at build time.
    
    To use OLE data types (such as CLIPFORMAT, SNB, STGMEDIUM, ASYNC_STGMEDIUM), or system handles (such as HMETAFILE_PICT, HENHMETAFILE, HMETAFILE, HBITMAP, HPALETTE, and HGLOBAL), import the objidl.idl file into your interface definition file and link to the ole32.lib
    
    The following OLE handles are also defined with the [wire_marshal] attribute, but only as handles within a computer since they cannot be used in remote procedure calls to other computers at this time: HWND, HMENU, HACCEL, HDC, HFONT, HICON, HBRUSH. Import the objidl.idl file into your IDL file and link to ole32.lib at build time to use these handles in interprocess communication on a single computer.
    
    more info, see The wire_marshal Attribute, The type_UserSize Function, The type_UserMarshal Function, The type_UserUnmarshal Function, The type_UserFree Function, and Targeting Stubs for Specific 32-bit or 64-bit Platforms.
    
- MIDL and ODL 


Microsoft Interface Definition Language (MIDL) now includes the complete Object Definition Language (ODL) syntax. generate a type library and optional header files for a COM application.


the documentation refers to an ODL file, it is referring to a file that Mktyplib.exe can parse. When it refers to an IDL file, it is referring to a file that the MIDL compiler can parse. 

    + reference 
    https://docs.microsoft.com/en-us/windows/win32/midl/midl-and-odl
    
- MIDLRT and windows runtime components 

    + reference 
    https://docs.microsoft.com/en-us/windows/win32/midl/midlrt-and-windows-runtime-components
    
- interface definitions and type libraries 

interface definition language (IDL) files and application configuration files (ACF) for MIDL, how to import files, type libraries, and system header files.

    + interfaces in distributed objects 

Applications based on remote procedure calls (RPC), Component Object Model (COM), and Distributed Component Object Model (DCOM) specify their interfaces using MIDL.

    + COM, DCOM, type libraries 
    
    type library, A type library (.tlb) is a binary file that stores information about a COM or DCOM object's properties and methods in a form that is accessible to other applications at runtime.
 
    The COM/DCOM run-time environment can also use a type library to provide automatic cross-apartment, cross-process, and cross-machine marshaling for interfaces described in type libraries.
    
    + characteristics of an interface 
    
    The IDL file specifies the characteristics of the application's interfaces on the wire 
    
    The ACF file specifies interface characteristics, such as binding handles, that pertain only to the local operating environment. The ACF file can also specify how to marshal and transmit a complex data 
    
    + interface definition file (IDL)
    
        * data types in the body 
        
        The interface body, which is enclosed in braces ({ }), contains the data types be used in RPC 
        
        OSF-DCE specification for RPC interfaces does not allow multiple interfaces in a single IDL file. Therefore, if you are compiling in MIDL's OSF-compatibility mode ( /osf), your IDL file can contain only one interface
        
    ```
    interface ITwo; //forward declaration
    interface IOne 
    {
    ...uses ITwo...
    }
    interface ITwo 
    {
    ...uses IOne...
    }    
    ```
        
    + type definition construct declarations and imports 
    
    multiple interfaces are not permitted when you use the /osf switch
    
    The import keyword specifies the names of one or more IDL files to import
    
        * constant declaration specifies Boolean, integer, character, wide-character, string, and void * constants. For more information, see const
        
        * A general declaration is similar to the C typedef statement with the addition of IDL type attributes
        
        * function 
    ```
[ 
    uuid(12345678-1234-1234-1234-123456789ABC), 
    version(3.1), 
    pointer_default(unique) 
] 
interface IdlGrammarExample 
{ 
    import "windows.idl", "other.idl"; 
    const wchar_t * NAME = L"Example Program"; 
    typedef char * PCHAR; 
 
    HRESULT DictCheckSpelling( 
        [in, string] PCHAR   word,     // word to look up 
        [out]        short * isPresent // 0 if not present 
    ); 
}
    ```
        
- IDL attributes 

    + Field Attributes
    + Aliasing and Marshaling Attributes
    
    This format, the Network Data Representation (NDR) format, is often called the wire format of the data
    
    marshaling the data, stubs must convert data from its native format in the program's memory space to NDR
    
    unmarshaling the data, t convert the data from NDR to the native format for that program.
    
call_as 	    Maps a nonremotable function to a remote procedure call.
iid_is 	        Provides the interface identifier of the COM interface that is the object of the pointer.
transmit_as 	Converts a data type to a simpler type for transmission over a network.
wire_marshal 	Similar to transmit_as but you implement the routines to size, marshal, unmarshal, and free the data.
    
    + Asynchronous Attributes
    
    An asynchronous procedure returns immediately without waiting for results
    
async 	    When applied to a function parameter, defines a handle that allows the caller to make an asynchronous call
    
async_uuid 	Directs the MIDL compiler to define both synchronous and asynchronous versions of a COM interface.

maybe 	    The client making this remote procedure call does not expect any response indicating delivery or completion of the call, and delivery is not guaranteed. 

message 	The remote procedure call is to be treated as an asynchronous message from the client to the server. The client makes the call and returns immediately
    
    + Array and Sized-Pointer Attributes
TODO:
    + Data Type Attributes
    + Directional Attributes
    + Function Call Attributes
    + Interface Header Attributes
    + Performance Attributes
    + Pointer Type Attributes
    + Structure and Union Attributes
    + Type Library Attributes

- application configuration file, ACF 

- ACF attributes 

- MIDL data types 

- importing files and type libraries 

- importing system header files 






    

# MIDL commandline reference 



# MIDL language reference 



# reference microsoft learn 
https://docs.microsoft.com/en-us/



# MIDL language reference 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-language-reference





# Compiler warning and errors 
https://docs.microsoft.com/en-us/windows/win32/midl/midl-compiler-errors-and-warnings