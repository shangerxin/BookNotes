C# 13 what's news=Erxin

# New features 
- params collections

The params modifier isn't limited to array types. You can now use params with any recognized collection type, including System.Span<T>, System.ReadOnlySpan<T>, and types that implement System.Collections.Generic.IEnumerable<T> and have an Add method.


```
public void Concat<T>(params ReadOnlySpan<T> items)
{
    for (int i = 0; i < items.Length; i++)
    {
        Console.Write(items[i]);
        Console.Write(" ");
    }
    Console.WriteLine();
}
```




- New lock object System.Threading.Lock type support LockEnterScope(). The ref struct returned from that supports the Dispose() pattern.

The C# lock statement recognizes if the target of the lock is a Lock object. If so, it uses the updated API, rather than the traditional API using System.Threading.Monitor.

- New escape sequence

You can use \e as a character literal escape sequence for the ESCAPE character, Unicode U+001B. Previously, you used \u001b or \x1b. Using \x1b wasn't recommended because if the next characters following 1b were valid hexadecimal digits


- Method group natural type

    + implicit "from the end" index operator, ^, is now allowed in an object initializer expression for single-dimension collections.
    
    
```
public class TimerRemaining
{
    public int[] buffer { get; set; } = new int[10];
}

var countdown = new TimerRemaining()
{
    buffer =
    {
        [^1] = 0,
        [^2] = 1,
        [^3] = 2,
        [^4] = 3,
        [^5] = 4,
        [^6] = 5,
        [^7] = 6,
        [^8] = 7,
        [^9] = 8,
        [^10] = 9
    }
};
```

    + ref and unsafe in iterators and async methods
This feature and the following two features enable ref struct types to use new constructs.
- Show 8 more

- allow ref struct, . The compiler enforces ref safety rules on all instances of that type parameter.

public class C<T> where T : allows ref struct
{
    // Use T as a ref struct:
    public void M(scoped T p)
    {
        // The parameter p must follow ref safety rules
    }
}

- ref struct interfaces. You can declare that a ref struct type implements an interface. 

- more partial members 

You can declare partial properties and partial indexers in C# 13. Partial properties and indexers generally follow the same rules as partial methods

public partial class C
{
    // Declaring declaration
    public partial string Name { get; set; }
}

public partial class C
{
    // implementation declaration:
    private string _name;
    public partial string Name
    {
        get => _name;
        set => _name = value;
    }
}

- overload resolution priorit is improved

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/general#overloadresolutionpriority-attribute

- the field keyword 

The field contextual keyword is in C# 13 as a preview feature. The token field accesses the compiler synthesized backing field in a property accessor.

a field named field. You can use @field or this.field to disambiguate between the field keyword and the identifier.