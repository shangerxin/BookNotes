Pro Apach JMeter=Sai;Note=Erxin

# Performance testing 
- matrix 

    + response time 

    absolute reponse time 
    
    perceived response time 
    
    server processing time 
    
    rendering time 
    
    network latency 
    
    + throughput 
    
    + utilization 
    
    Utilization is the ratio of the throughput of the application relative to its maximum capacity. 
    
    + robustness 
    
    + scalability 
    
    + user perception 
    
    + cost 
    
- type of performance tests 

    + stress tests tests the application beyond the normal limits. The application is subjected to excess load and after that its stability and performance are noted. 
    
    + load test is a kind of performance test that’s performed at the specified load level. So ideally, we would like to perform load tests at varying load levels to note the behavior of the application.
    
    + peak load test is performed at the load that the application is expected to handle.
    
    + soak test (also called an endurance test ), the application is subjected to a specified load that is within the specified limit but for a long duration. It is performed for many hours at a time. This test determines if the application is properly reusing its resources.
    
    + scalability tests 
    
    + capacity tests 
    
    + spike tests and burst capacity 
    
    + performance smoke tests 
    
    + high availability tests/fail over tests 
    
    + chaos monkey, It randomly disables the production instances to make sure that the system can survive this common type of failur 
    
    + chaos gorilla, simulates an outage of an entire Amazon availability zone. It verifies that the services automatically rebalance to the functional availability zones without user-visible impact or manual intervention. 
    
- test environment 

separate performance environment 

like production environment 

performance environment should be isolated 

testing tools 

+ performance goals 

+ performance test suite 

+ reporting and analysis 

+ performance tuning 




# First JMeter tests 
- Components of jmeter test 

test plan

thread group 

controller Each thread group has one or more controller elements. Logical controllers decide the flow of execution. They determine the next Sampler to execute

sampler Sampler is a child element of a thread group or a controller. It sends requests to the server. For every protocol, we need a separate sampler.

Listeners listen to the responses from the server and assemble and aggregate the performance metrics.

timer introduces a delay in the flow. Delay is needed between sampler requests for the following reasons

Assertions are used to verify that the server responses are as expected. Assertions test various status codes, and then pause, alert, or log bad request/responses. 

Configuration elements are placeholders for properties, including user-defined properties and variables. 

Pre-processors take the request and modify it (substitution, enhancement, dereferencing variables, etc.) 

Post-processors process the response from the server. 

- order of the component execution 

thread group {
    config elements 
    pre-processor 
    timer 
    logic controller / sample 
    post-processor 
    assertions 
    listeners 
}

- For the given test plan, the execution order will be:

BeanShell Pre-processor

Constant Timer

Constant Throughput Timer

Transaction Controller

CSV Data Set Config

HTTP Request

BeanShell PostProcessor

Aggregate Report

-  start jmeter gui 

Edit ➤ Add ➤ Threads (Users) and add Thread Group. Configure the Number of Threads (Users)

Edit ➤ Add ➤ Sampler and add HTTP Request. Configure Server Name or IP as localhost, Port Number as 8080, and Path as /dt. Uncheck Follow Redirects

HTTP Request and go to Edit ➤ Add ➤ Assertions and add Response Assertion. Configure Response Field to Test as Response Code

Edit ➤ Add ➤ Listener and add View Results Tree

Run ➤ Start to run the test (on Mac OSX, type CMD+R).

JMeter GUI mode provides several options to start/stop test(s)

- non-gui mode 

$ jmeter --help 

all command line options, open a command prompt and type:

jmeter.bat(Windows)/jmeter.sh(Linux) -?

proxy append the following options.

$ jmeter -H <proxy host server name>, -P <port number>

- Start JMeter in Server Mode master-slave formation

C:\>jmeter-server

stop/shutdown jmeter 
C:\apache-jmeter-3.0\bin>stoptest.cmd

C:\apache-jmeter-3.0\bin>shutdown.cmd



# Jmeter test script recorder 
- JMeter understands browser actions. You need to configure the browser and use JMeter as a proxy server.
- workbench

JMeter’s WorkBench provides a temporary workspace to store test elements

it is pre-populated with an empty test plan and an empty WorkBench.

JMeter Port setting in Global Settings and the browser proxy port to the same value: --7070

- Proxy Settings

Preferences ➤ Advanced ➤ Network ➤ Connection Settings ➤ Manual Proxy Configuration. Configure HTTP Proxy as localhost and Port as 7070.

Select Use This Proxy Server for All Protocols.

Clear the No proxy For text area

- Record example 

Detail ➤ Add To Cart ➤ Checkout ➤ Add Billing/Shipping Address ➤ Add Credit Card ➤ Place Order ➤ Sign Out

JMeter will show a Root CA Certificate dialog box. Click OK.

Click on Add Suggested Excludes, and this action will add a sample expression. Modify this expression

- Click on Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add a thread group.

Select all recorded browser actions from WorkBench and then drag and add them as child elements of the thread group.

Thread Group and go to Edit ➤ Add ➤ Listener. Add View Results Tree.

Save the test plan .

Test plan > Edit ➤ Add ➤ Config Element. Add HTTP Cookie Manager.



# Test plan components 
- Test plan 

JMeter components like the thread group, logic controller, sampler, listener, timer, assertion, and config element.

- Configuration 

User Defined Variables: These are defined by using name/value pair(s). 

Run Thread Groups Consecutively (i.e. Run Groups One at a Time): A test plan can have more than one thread group.

Run tearDown Thread Groups After Shutdown of Main Threads: If this checkbox is selected, then tearDown thread groups executes after the test has finished executing its regular thread group

Functional Test Mode (i.e. Save Response Data and Sampler Data): If this checkbox is selected, then sampler requests and response data are saved in the listeners.

Add Directory or JAR to Classpath: You can add a folder or a JAR file to the classpath and JMeter can load these classes.

- Serial execution of thread group 

    + Create a test plan and give it a meaningful name
    
    + Click on Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add Thread Group. Loop count 4 
    
    + Click on Thread Group A and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Name as Alpha, Server Name or IP as localhost, Port Number as 8080, and Path as /jmeter/alpha.
    
    + Click on Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure the Name as Thread Group B and Loop Count as 4.
    
    + Click on Simple Controller and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Name as Bravo, Path as /jmeter/bravo, and Method as GET.
    
    + Click on Test Plan and go to Edit ➤ Add ➤ Listener. Add View Results Tree.
    
    + Run check the result form the view result tree
    
    + test plan and uncheck the Run Thread Groups Consecutively checkbox 
    
- User defined variables have a scope across the entire test plan. These are copied to the variables in each of the thread groups before the test starts executing.
    
- thread group 

The thread group is simulating the load generated by users performing a use-case.

- Thread Properties option (see Figure 5-9) gives you the flexibility to simulate a realistic load.

Number of Threads (Users): This is the number of users we want to use for load testing a web application.

Ramp-Up Period (in Seconds): This is the time after which all threads will be active.

Thread Group and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Server Name or IP as localhost, Port Number as 8080, and Path as /dt.
 
- Scheduler

Create a test plan and give it a meaningful name, such as Scheduled Thread Group Test.

Click on Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure Number of Threads (users) as 1, Ramp-Up Period (in seconds) as 1, and then click the Forever checkbox

test to run 5 minutes from now. Configure the Start Time to 07:23:10 and End Time to 07:23:11. Here, you are telling JMeter to run the test 5 minutes from now and to run it for .01 seconds

Thread Group and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Server Name or IP as localhost, Port Number as 8080, and Path as /dt.

Start the test 

- Action After Sampler Error
When a sampler fails , the thread group execution behavior is configurable.

Continue: If selected, the execution will continue irrespective of the error.

- Pre-processors take the request and modify (substitution, enhancement, dereferencing variables etc.) it before the sampler sends it to the server.

- The HTTP URL Re-Writing Modifier (see Figure 5-31) is used to store session ID. It is added as a child to the thread group. It will automatically determine the session ID of the web application being tested based on the session variable name

Session Argument Name: Variable used to store the session ID in the web application.

Path Extension (Use ";" as Separator): Should be selected only when the URL parameters are separated by semicolons (;).

Do not use equals in path extension: Should be selected if you do not want name/value pair separated by equals signs (=).

Do not use question mark in path extension: Should be selected if you do not want name/value pair separated by question marks (?).

Cache Session Id?: Should be selected if you want to use the Caching feature of JMeter.

URL Encode: Should be selected if your URL is using any encoding Let’s illustrate this with the following example.

- Controllers determine the sequence in which the samplers are processed. 

    + Logical controllers can be categorized as follows:

Controllers for grouping

Simple Controller

Transaction Controller

    + Controllers for looping

Loop Controller

While Controller

ForEach Controller

    + Controllers for decision making

If Controller

Switch Controller

Once Only Controller

Interleave Controller

Random Controller

Random Order Controller

    + Controllers for modularity

Module Controller

Include Controller

Controllers for recording

Recording Controller

    + Other controllers

Critical Section Controller

Throughput Controller

Runtime Controller

- Transaction Controller

The Transaction Controller provides the functionality of grouping elements together, similar to Simple Controller. 

    + Test plan example 
    
Edit ➤ Add ➤ Threads (Users). Add Thread Group.

Thread Group and go to Edit ➤ Add ➤ Config Element. Add HTTP Request Defaults. Configure Server Name or IP as localhost and Port Number as 8080.

Thread Group and go to Edit ➤ Add ➤ Logic Controller and add Transaction Controller.

Transaction Controller and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Name as Alpha, Path as /jmeter/alpha, and Method as GET.

Edit ➤ Add ➤ Listener. Add View Results Tree.

Run 

By default, Transaction Controller does not include the time taken by timers and pre-processors. However, it can be configured to include the timers by enabling a checkbox,

- The Loop Controller provides a looping mechanism. It can repeat the execution of its nested elements a specified number of times. 

- The Runtime Controller controls the duration for which its child elements are run.

A Runtime Controller executes its child elements in its hierarchy for the specified duration. At the end of the nested elements, it loops through again

- The Throughput Controller controls the number of executions of its child elements.

Number of Executions: The child elements are executed until the specified count

Percentage of Executions: The concept is the same except that the number of executions of the child elements is restricted by the percentage configured.

- Once Only Controller executes its child elements only once per thread. This is typically used to perform logins or another use-case that’s needed only once for a user session.

- The Interleave Controller executes only one of its child elements per loop iteration. Each time it iterates, it picks the next child element in sequence.

- The Random Controller is similar to the Interleave Controller except that the order of interleaving is random instead of sequential.

- The Random Order Controller executes all its child elements but in random order.

- The Switch Controller is analogous to the switch/case programming construct. The Switch Controller executes only one of its child elements after matching the element’s name with the configured Switch value. 

- The ForEach Controller has one or more child elements over which it iterates. It can be configured with the following parameters. 

- If Controller is useful for decision/branching logic. The configuration is simple, with only two checkboxes.

"$(myUservar)" == "alpha"

- Timers are used to introduce a delay or pause before a sampler is run. In a test plan, even if a timer is placed after the samplers, it will run before the sampler

even if a timer is placed after the samplers, it will run before the sampler. If the timer is a child element of a sampler, it will apply only to that sampler.

- The Constant Timer introduces a specified delay before the samplers in its scope are executed.

- The Gaussian Random Timer introduces a delay according to the Gaussian Distribution (also called the bell curve). The delay varies around a central mean

- The delay introduced by the Uniform Random Timer has two parts:

Constant Delay: Fixed and equal to the configured value.

Random Delay: Varies between zero and the configured value.

- Constant Throughput Timer calculates and introduces delays between samplers so as to keep the throughput at the configured value.

- Synchronizing Timer blocks threads and releases them all at once, thus creating a large load at the same instant. 

- Sampler is a component that’s used to send requests to the application being tested. If the test plan has more than one sampler, they will be executed in the order they are defined in the test plan tree

Access Log Sampler

AJP/1.3 Sampler

BeanShell Sampler

BSF Sampler

Debug Sampler

FTP Request

HTTP Request

Java Request

JDBC Request

JMS Point-to-Point

JMS Publisher

JMS Subscriber

JSR233 Sampler

JUnit Request

LDAP Extended Request

LDAP Request

Mail Reader Sampler

OS Process Sampler

SMTP Sampler

SOAP/XML-RPC Request

TCP Sampler

Test Action

- The HTTP Request sampler is used when you want to use POST, GET, DELETE, PUT, etc., methods over HTTP(S) 

HttpClient4: This uses Apache HttpClient version 4 component.

HttpClient3.1: This uses Apache HttpClient version 3.1 component.

Java: This uses the HTTP implementation provided by the JVM.

Blank value: This uses a value defined in the HTTP Request Defaults configuration element.

JMeter provides http, https, and file protocols.

The Use KeepAlive checkbox is enabled by default. This allows the same connection to be re-used by including KeepAlive in the Connection header.

Browser-Compatible Headers
This property is used in combination with multipart/form-data for POST. Using this suppresses the Content-Type and Content-Transfer-Encoding Headers. 

Proxy Server
JMeter provides a simple way to specify the proxy server details for the HTTP Request sampler.

    + Assertions
The primary purpose of assertions is to validate the server response and decide if the test passed or failed.

    + Apply to Property
This option specifies where to apply the assertions: Main sample and sub-samples, main sample only, Sub-samples only, and JMeter variable. Sometimes a sampler may generate a redirected URL

    + response:

Text Response

Document (Text)

URL Sampled

Response Code

Response Message

Response Headers

Ignore Status

- Listeners capture and process the response from the server.

only a few are used frequently:

Aggregate Graph

Aggregate Report

Assertion Results

Backend Listener

BeanShell Listener

BSF Listener

Comparison Assertion Analyzer

Generate Summary Results

Graph Results

JSR233 Listener

Mailer Visualizer

Monitor Results

Response Time Graph

Save Responses to a File

Simple Data Writer

Summary Report

View Results in Table

View Results in Tree

GUI Mode The View Results Tree listener shows responses in a tree-like structure, thereby allowing users to see response data (content)

Non-GUI Mode  When you are running tests in non-GUI mode and want to see results in this listener

- Aggregate Report listener also shows the responses in a table-like structure for each differently named sampler. Similar to View Results in Table, it does not have a panel and does not show any headers or response contents. Generated results can be saved as .csv files with the use of the Save Table Data button at the bottom of this listener.

- post-processor to extract useful information from the response and store the value in a variable to make it available to the next sampler. 

- Regular Expression Extractor is used to extract useful information (mostly values of variables to be used in successive requests) from the response of a sampler.

- JMeter, like any programming language, has the concept of defining and using name/value pairs. JMeter utilizes this concept for both properties and variables.

properties define in jmeter.properties file, JSR 223 script or passed on the command line, shared across the thread groups, use  __P() to get the value.

variables defined using jsr223 script or csv data config component in a thead group, local to the thread group. use ${ } to get the value.

user defined variables, defined using variable section in the test plan, each UDV gets copied as a variable into each of the thread groups at the start of the test execution. Use ${ } to get the value.

    + example 
    
Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure the name as Thread Group A and the Loop Count as 1.

Click on Thread Group A and go to Edit ➤ Add ➤ Pre Processor. Add JSR223 Pre Processor. Configure Script Language as Java

```
vars.put("zeta_variable", "variable value");
props.put("Alpha_variable", "property value");. 
```'

    + example user define variable 
    
Thread Groups Consecutively checkbox. Under User Defined Variables, add two Name:Value pairs as UDV_Alpha/alpha and UDV_Bravo/bravo

Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure the name as Thread Group A and Loop Count as 1.

Thread Group A and go to Edit ➤ Add ➤ Sampler. Add Debug Sampler. Configure the name as Debug Sampler Thread A.

Thread Group A and go to Edit ➤ Add ➤ Post Processors. Add JSR223 PostProcessor. Configure the language as Java.

```
log.info("The value of UDV_Bravo before: " + vars.get("UDV_Bravo") );
vars.put("UDV_Bravo", "zulu");
log.info("The value of UDV_Bravo after: " + vars.get("UDV_Bravo") );
```

$ jmeter -n -t UDVExecuteThreadGroupConsecutivelyTestPlan.jmx -JSERVER=localhost -l UDV-cmd-line-test.log



# Distribute testing 
- The hostname or IP address of the slave machines are configured in the jmeter.properties file on the master.

slave machines to be a part of the JMeter distributed testing cluster, and they are visible in the master node GUI.

The slave nodes obtain a copy of the test plan from the master. The role of the master node is only to orchestrate the test.

    + example 
    
DistributedTestPlan.jmx 1 file:

Create a test plan and give it a meaningful name, such as Distributed Testing.

Click on Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure Number of Threads (Users) as 1 and Loop Count as 1.

Click on Thread Group and go to Edit ➤ Add ➤ Config Element. Add HTTP Cookie Manager.

Click on Thread Group and go to Edit ➤ Add ➤ Config Element. Add HTTP Request Defaults. Configure Server Name or IP as <your_machine_ip_or_hostname> and Port Name as 8080.

Click on Thread Group and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Path as /user/signIn and Method as POST.

Click on HTTP Request and go to Edit ➤ Add ➤ Config Element. Add CSV Data Set Config value pairs 

Click on HTTP Request and go to Edit ➤ Add ➤ Assertions. Add Response Assertion. Configure Response Field to Test as Response Code, Pattern Matching Rules as Equals, and Patterns To Test as 200 .

Click on Thread Group and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Path as /user/signOut and Method as HEAD.

Click on HTTP Request and go to Edit ➤ Add ➤ Assertions. Add Response Assertion. Configure Response Field to Test as Response Code, Pattern Matching Rules as Equals, and Patterns To Test as 200.

Click on Thread Group and go to Edit ➤ Add ➤ Listener. Add View Results Tree.

Click on Thread Group and go to Edit ➤ Add ➤ Listener. Add View Results in Table.

Save the test plan .

    + start the test with Run > The Remote Start and Remote Start All options will start the test on remote hosts.
    
    From the apache-jmeter-3.0/bin directory on each slave, you need to start jmeterserver using the following command :

    C:\>jmeter-server
    
    Under Thread Group, you can see that you are running 1 thread and selecting Remote Start All; it will trigger this test on both remote hosts
    
    or trigger manual from cli 
    $ jmeter -n -t DistributedTestPlan.jmx -R 192.168.0.7,192.168.0.8
    
- RMI Port
server configuration to change the port 
By default, the server_port is set to 1099. Sometimes it may be that this port is blocked. Open the jmeter.properties file on the slaves and change it to a different port

client cli
$ jmeter -n -t DistributedTestPlan.jmx -R 192.168.0.7:1234, 192.168.0.8:1234

- Sample sender mode 

Standard : Send samples synchronously as soon as they are generated.

Batch Mode : Send saved samples when either the count (num_sample_threshold) or time (time_threshold) exceeds a threshold

Statistical Mode : Send a summary sample when either the count or time exceeds a threshold. The samples are summarized by thread group name and sample label.

Hold Mode : Hold samples in an array until the end of a run

DiskStore Mode : Store samples in a disk file (under java.io.temp) until the end of a run .

StrippedDiskStore Mode : Remove responseData from successful samples and use DiskStore sender to send them.

Stripped Mode : Remove responseData from successful samples.

StrippedBatch Mode : Remove responseData from successful samples and use Batch sender to send them.

Asynch : Samples are temporarily stored in a local queue.

...
- unreachable remote hosts 

when one or more of the remote hosts is not reachable by the client (the master). Perhaps they have not yet booted up or they are shut down.

- By default, client.tries is set to 1 and client.retries_delay is set to 5000 milliseconds. 

- limitations 

It is quite expensive to set up dedicated hardware for performance testing on the premises. 

RMI cannot communicate across subnets without a proxy; therefore, neither can JMeter

Since JMeter sends all the test results to the controlling console, it is easy to saturate the network. It is a good idea to use the Simple Data Writer to save the results

A single JMeter client running on a 2-3 GHz CPU can handle 300-600 threads depending on the type of test.

performance of XML-centric applications is 4-10 times slower than applications using binary protocols.



# JMeter best practices 

- http as default 
- Always enable the Follow Redirects option.
- Always use a cookie manager, as cookies are the most common mechanism for web applications to maintain session state
- The Cache Manager simulates a browser cache. You can make JMeter behave closer to a real browser by including an HTTP Cache Manager.
- Apache Maven is a popular build-management tool. It provides a standard method to build the software executable and various other project artifacts.
- JMeter Property value in one thread group and using its value in the other thread group. passing variables across thread groups 
-  run thread groups in parallel.

Configure Test Plan and uncheck the Run Thread Groups Consecutively (i.e. run groups one at a time) property if it’s checked

Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure the name as Thread Group 1 and the Number of Threads (Users) as 5.

Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Server Name or IP as localhost, Port Number as 8080, Path as /dt, and Name as Sampler 1.

Click on Test Plan and go to Edit ➤ Add ➤ Threads (Users). Add Thread Group. Configure Name as Thread Group 2 and Number of Threads (users) as 5.

Click on Thread Group and go to Edit ➤ Add ➤ Sampler. Add HTTP Request. Configure Server Name or IP as localhost, Port Number as 8080, Path as /dt, and Name as Sampler 2.

Click on Thread Group and go to Edit ➤ Add ➤ Listener. Add View Results Tree.

Save the test plan.

Run the test .

- using external file for parameterizing user login 

This can be done using the parameterization of the login page and providing an external CSV file, which consists of a list of users arranged in columns, such as login-user and login-password. JMeter provides the CSV Data Set Config option to achieve this.

- JMeter can be customized by configuring various properties. By default, these are loaded from the jmeter.properties file. These can be overridden by a custom properties

The custom properties file can be specified by modifying the user.properties property in the jmeter.properties file. By default, this property is set to user.properties.

- monitor jmeter resource usage 




# Troubleshooting JMeter 
- ensure permission on linux 
$ cd <JMeter Installation Folder> cd bin chmod +x jmeter

- You can specify a different log file name or path by:

Specify the -j option on the command line.

Specify the log_file property in the jmeter.properties file.

- log level at the root level, as shown here.

jmeter -LDEBUG

-  log levels are as follows:

File: jmeter.properties

log_level.jmeter=INFO
log_level.jmeter.junit=DEBUG
log_level.jmeter.control=DEBUG
log_level.jmeter.testbeans=DEBUG
log_level.jmeter.engine=DEBUG
log_level.jmeter.threads=DEBUG
log_level.jmeter.gui=WARN
log_level.jmeter.testelement=DEBUG
log_level.jmeter.util=WARN
log_level.jmeter.protocol.http=DEBUG
log_level.jmeter.protocol.http.control=DEBUG
log_level.jmeter.protocol.ftp=WARN
log_level.jmeter.protocol.jdbc=DEBUG
log_level.jmeter.protocol.java=WARN
log_level.jmeter.testelements.property=DEBUG

- HTTP Protocol Logs
HTTPClient is an open source Java library used to start HTTP connections. This is the core of the HTTP Request Sampler

There is another solution. Before starting jmeter-server, execute the following command.

$ export RMI_HOST_DEF=-Djava.rmi.server.hostname=<vm hostname>

- Proxy Server details are set as follows:

Server Name or IP is set to MyCorpProxy

Username is set to myusername

Password is set to mypass

$ jmeter -H proxyserver -P 7000 -u username -a password

- HTTP Basic Authentication
As the title indicates, HTTP Basic Authentication is a very simple authentication mechanism used by the web server and the browser to secure access to URLs and resources. 

- Using HTTP Header Manager
If the web application requires authentication, you can use the HTTP Header Manager to accomplish this.

- Using the HTTP Authorization Manager
If the web application requires authentication, you can also use the HTTP Authorization Manager to accomplish this.

- Debug Test Faster
Prior to JMeter 3.0, we had to configure the thread group before you could run the test.

- avoid out of memory 

monitor the memory and CPU usage of JMeter using JVisualVM. This tool is shipped with the JDK installation, by default.



# JMeter plugins 
- the PerfMon package supports server/cluster monitoring. Using this, you can monitor CPU, memory, swap

- the PerfMon package supports server/cluster monitoring. Using this, you can monitor CPU, memory, swap


# Jmeter recipes 
- JDBC performance testing 

$ mysql -u jmeter_user -p -t < employees.sql

- File Transfer Protocol (FTP) is a standard network protocol used to transfer files between computers. FTP follows a client-server model.

$  sudo -s launchctl load -w /System/Library/LaunchDaemons/ ftp.plist

Thread Group and go to Edit ➤ Add ➤ Config Element ➤ FTP Request Defaults. Add FTP Request Defaults. Configure the Server Name or IP

- REST/JSON Performance Testing
REST stands for REpresentational State Transfer . It is not a specification or a protocol, but rather an architectural style. 

- REST API for Create, Read, Update, and Delete (CRUD) operations. The API uses the HTTP verbs:

POST: Creates the book with a JSON payload

GET: Reads the book given the ID

PUT: Updates the book with a JSON payload

DELETE: Deletes the book given the ID

- Mobile Performance Testing
JMeter can be used to do the performance testing of web applications running on mobile devices.

- Simulating Network Speed
The connection speeds of mobile devices are often slow. It is easy to simulate slow connections.

- JMeter to Record User Actions
Earlier in the book, we explored how to use JMeter to record a test script. 

- Android Proxy Configuration
Go to Settings ➤ Wi-Fi.

Long tap on the connected network and click the Modify Network option.

From the dialog box, check the Advanced Options checkbox.

This will open advanced settings from which you can modify the proxy manually. For this, set the Proxy option to Manual.

Now set the Proxy hostname to your computer’s IP address and set the Proxy port to 8080

- SOAP Performance Testing
SOAP stands for Simple Object Access Protocol . This is a specification for exchanging structured information in the XML message format and relies on application layer protocols

- Install SOAPUI
SoapUI is a free and open source functional testing tool with very good support for SOAP.



# Digital toys 
- Tool selection, Alex searched the Internet and found many performance testing tools. He shortlisted two tools that he felt would solve the problem.


Variable                                                        Result

The count of users who are logged in at one point in time.      100,000

The use-case and the percentage of users.                       Browsing catalog: 10%

                                                                Ordering first time: 60%

                                                                Ordering second time: 10%

                                                                Changing address: 5%

                                                                Changing payment information: 5%

                                                                Continue shopping: 10%

Time of day and duration.                                       Most of the users use the application during early morning and at the end of the day. The duration of load is between 1 to 2 hours.


- Using jmeter 

Test Plan: Every JMeter test script contains a test plan as a root node. It contains a thread group, which contains one or more of the following child nodes:

Sampler, Logical Controller, Listener, Assertions, Timer, Config Element

Thread Group: This is synonymous to a web user.

Samplers: Send requests to the server. JMeter ships with many samplers out of which the HTTP Request Sampler is used most often. It is used to simulate a web request.

Logical Controllers: Provide common programming constructs that provide control flow and are used to structure JMeter test scripts. Using controllers, you can specify the order in which the samplers are processed.

Listeners: Used to display the results of the server responses generated due to sampler requests. They are processed at the end of the scope in which they are found.

Assertions: Used to validate the server responses generated due to sampler requests. For example, to verify that for a HTTP request, the HTTP Response Code is 200.

Timers: Used to insert a delay before the sampler is executed. These are used to simulate the user think time before the next action. They are processed before each sampler in the scope in which they are found. Timers are only processed in conjunction with a sampler.

Config Elements: Used to set up defaults and variables for later use by other components. They are processed at the start of the scope in which they are found.


- validation of test steps 

HTTP Request and go to Edit ➤ Add ➤ Assertions. Add Response Assertion. Configure Apply to as Main Sample Only, Response Field To Test as Response Code, Pattern Matching Rules as Equals, and Patterns To Test as 200.

- combining multiple tests 

Test Plan                                 Thread Group

DTHomePageTestPlan.jmx                    Home Page

DTFirstOrderTestPlan.jmx                  First Order

DTSecondTimeOrderTestPlan.jmx             Second Time Order

DTChangeAddressTestPlan.jmx               Aggregate Report

DTChangePaymentInfoTestPlan.jmx           Change Payment Info

DTContinueShoppingTestPlan.jmx            Continue Shopping



# Performance dashboard 
- APDEX stands for Application Performance Index.1 It calculates a user satisfaction score, taking into account user satisfaction levels .

- Global Graph Properties
The following properties are used to set the granularity of the generated graphs.

- Specific Graph Properties
There are a number of graphs that are generated as a part of the Performance Dashboard 

- Generating Graphs
To generate the dashboard in a single step, execute the following command in the CMD prompt.

jmeter -n -t <TestName.jmx> -l <logFileName>.jtl -e -o <path of the directory which is used to store Performance Dashboard>


# Setup jmeter 
- install jdk 

```
$ java -version
java version "1.8.0_60" Java(TM)
SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed  mode)
```

- Set Up the Environment Variable
```
$ vim ∼/.bash_profile
$ vim ∼/.profile
```

