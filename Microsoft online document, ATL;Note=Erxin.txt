Microsoft online document, ATL;Note=Erxin


# Reference 
- link 
https://docs.microsoft.com/en-us/cpp/atl/atl-com-desktop-components?view=msvc-160


# ATL COM Desktop components 
- Active Template Library (ATL), a set of template-based C++ classes that simplify the programming of Component Object Model (COM) objects

- class overview 

Class factories
Class information
Collection
COM modules
Composite controls
Connection points
Control containment
Controls: General support
Data transfer
Data types
Debugging and exception
Dual interfaces
Enumerators and collections
Error information
File handling
Interface pointers
IUnknown implementation
Memory management
MMC snap-in
Object safety
Persistence
Properties and property pages
Registry support
Running objects
Security
Service provider support
Site information
String and text
Tear-off interfaces
Thread pooling
Threading models and critical sections
UI support
Windows support
Utility

- global variable, provide functionality like CComModule in VC 6.0 (obsolete), atlbase.h

__declspec(selectany) CAtlModule * _pAtlModule

LONG lLocks = _pAtlModule->GetLockCount();



# ATL Concepts 
- learn more about COM and .NET attributes, which is designed to simplify COM programming

https://docs.microsoft.com/en-us/cpp/windows/attributes/cpp-attributes-com-net?view=msvc-160


## Introduction to COM and ATL 
- Fundamental to COM are these concepts:

    Interfaces — the mechanism through which an object exposes its functionality.

    IUnknown — the basic interface on which all others are based. It implements the reference counting and interface querying mechanisms running through COM.

    Reference counting — the technique by which an object (or, strictly, an interface) decides when it is no longer being used and is therefore free to remove itself.

    QueryInterface — the method used to query an object for a given interface.

    Marshaling — the mechanism that enables objects to be used across thread, process, and network boundaries, allowing for location independence.

    Aggregation — a way in which one object can make use of another. 
    
- interfaces 
In COM, an interface is a table of pointers (like a C++ vtable) to functions implemented by the object.

Each interface is based on the fundamental COM interface, IUnknown. The methods of IUnknown

- IUnknown

This interface defines three methods: QueryInterface, AddRef, and Release. QueryInterface allows an interface user to ask the objec

- Reference counting 

Whenever a client receives an interface pointer, AddRef must be called on the interface.

Whenever the client has finished using the interface pointer, it must call Release.

- QueryInterface

IUnknown method called QueryInterface.

QueryInterface. Regardless of implementation, this method queries an object using the IID

QueryInterface retrieves a pointer to the interface, while also calling AddRef. Otherwise, it returns the E_NOINTERFACE error code.

This more readily becomes apparent when _ATL_DEBUG_INTERFACES is defined,  ATL header files to trace all AddRef and Release calls on your components' interfaces to the output window.

```
#define _ATL_DEBUG_INTERFACES
```

QueryInterface to the output window.
```
#define _ATL_DEBUG_QI
```

ATLASSERT(booleanExpression);
ATLENSURE(booleanExpression);
ATLENSURE_THROW(booleanExpression, hr);
ATLTRACENOTIMPL(funcname);
ATLTRACE(exp);    Reports warnings to an output device, such as the debugger window
ATLTRACE2(exp);
- marshaling 

allows interfaces exposed by an object in one process to be used in another process

- Aggregation means that the containing (outer) object creates the contained (inner) object as part of its creation process and the interfaces of the inner object are exposed by the outer. Primarily, all IUnknown method calls on the contained object must delegate to the containing object.

- Introduction to ATL 

special support for key COM features including: 

stock implementations of IUnknown, IClassFactory, IClassFactory2, and IDispatch; 

dual interfaces; 

standard COM enumerator interfaces; 

connection points; 

tear-off interfaces; 

ActiveX controls.

- Using a template library 

Template libraries such as ATL differ from traditional C++ class libraries in that they are typically supplied only as source code (

ATL also makes a DLL available (atl90.dll), which contains code that can be shared across components

- recommendations for choosing between ATL and MFC 

you can choose between two approaches — ATL and MFC (the Microsoft Foundation Class Library).

    + atl 
    
    ATL is a fast, easy way to both create a COM component in C++ and maintain a small footprint. 
    
    + MFC 
    
    MFC allows you to create full applications, ActiveX controls, and active documents.

    + using ATL in an existing MFC project by running a wizard. For details, see Adding ATL Support to Your MFC Project.

- fundamental of ATL COM objects 

{CComObjectRoot} {CComCoClass<>} {IDispatchImpl<>} {ISupportErrorInfoImpl}
A
|
{CYourClass}
A
|
{CComObject<> or CComAggObject<> or CComPolyOjbect<>} 

CComObject is derived from CYourClass whereas CComAggObject and CComPolyObject

three ways to define an ATL COM object
    + use the CComObject class which is derived from CYourClass.
    + create an aggregated object by using the CComAggObject class
    + use the CComPolyObject class. CComPolyObject acts as a hybrid: it can function as a CComObject class or as a CComAggObject class. depending on it is first create 

client does not have to go through the outer object to interact with the inner object, aggregated objects are usually more efficient. Not all component can be aggregated 

ATL implemenets IUnknown in two phases 
    + CComObject, CComAggObject, or CComPolyObject implements the IUnknown methods.
    
    + CComObjectRoot or CComObjectRootEx manages the reference count and outer pointers of IUnknown.
    
CComCoClass defines the object's default class factory and aggregation model.

IDispatchImpl provides a default implementation of the IDispatch Interface portion of any dual interfaces on the object. 

ISupportErrorInfoImpl implements the ISupportErrorInfo interface that ensures error information can be propagated up the call chain correctly.

- Implementing CComObjectRootEx 

CComObjectRootEx is essential; all ATL objects must have one instance of CComObjectRootEx or CComObjectRoot in their inheritance.

The query is performed through CComObjectRootEx::InternalQueryInterface. InternalQueryInterface only handles interfaces in the COM map table

enter interfaces into the COM map table with the COM_INTERFACE_ENTRY macro 

```
BEGIN_COM_MAP(CBeeper)
   COM_INTERFACE_ENTRY(IBeeper)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY_TEAR_OFF(IID_ISupportErrorInfo, CBeeper2)
END_COM_MAP()
```

- Implementing CComAggObject, CComAggObject and CComPolyObject are always the most derived classes in the inheritance chain

    + which one is used depends on the following macro 
    
DECLARE_NOT_AGGREGATABLE 	Always uses CComObject.

DECLARE_AGGREGATABLE 	Uses CComAggObject if the object is aggregated and CComObject if it is not. 

DECLARE_ONLY_AGGREGATABLE 	Always uses CComAggObject. Returns an error if the object is not aggregated.

DECLARE_POLY_AGGREGATABLE 	ATL creates an instance of CComPolyObject<CYourClass> when IClassFactory::CreateInstance is called.

an aggregated object needs both a reference count for the inner unknown and a pointer to the outer unknown.

CComPolyObject is that you avoid having both CComAggObject and CComObject in your module to handle the aggregated and nonaggregated cases. A single CComPolyObject object handles both cases. 

- Supporting IDispatch and IErrorInfo 

the template class IDispatchImpl to provide a default implementation of the IDispatch Interface portion of any dual interfaces on your object.

IErrorInfo interface to report errors back to the client, then your object must support the ISupportErrorInfo Interface interface

- Supporting IDisEventImpl 

The template class IDispEventImpl can be used to provide support for connection point sinks in your ATL class

sink allows your class to handle events fired from external COM objects

mapped with an event sink map, provided by your class.

    + to implement a sink 
    
    Import the type libraries for each external object
    
    Declare the IDispEventImpl interfaces

    Declare an event sink map

    Advise and unadvise the connection points

    all accomplished by modifying only the header file (.h) of your class.

    + importing the type libraries 
    
    The #import directive can be used to accomplish this. Add the necessary #import directive lines for each dispatch interface
    
```
#import "PROGID:MSCAL.Calendar.7" no_namespace, raw_interfaces_only
```

    + declaring the IDisEventImpl interfaces, Modify the declaration of your class by adding an IDispEventImpl interface declaration for each external object.
    
```
template <UINT nID, 
    class T,
    const IID* pdiid = &IID_NULL,
    const GUID* plibid = &GUID_NULL,
    WORD wMajor = 0,
    WORD wMinor = 0,
    class tihclass = CcomTypeInfoHolder>
class ATL_NO_VTABLE IDispEventImpl : public IDispEventSimpleImpl<nID, T, pdiid>
```
    
    
    two connection point sinks, for the DCalendarEvents interface
```
public IDispEventImpl<IDC_CALENDAR1, CMyCompositCtrl2, &__uuidof(DCalendarEvents), &__uuidof(__MSACAL), 7, 0>,
public IDispEventImpl<IDC_CALENDAR2, CMyCompositCtrl2, &__uuidof(DCalendarEvents), &__uuidof(__MSACAL), 7, 0>
```

    + declare an event sink map, ATL provides several macros, BEGIN_SINK_MAP, END_SINK_MAP, and SINK_ENTRY_EX, that make this


```
BEGIN_SINK_MAP(comClass)
  SINK_ENTRY_EX(id, iid, dispid, func)
  . . . //additional external event entries
END_SINK_MAP()

BEGIN_SINK_MAP(CMyCompositCtrl2)
   //Make sure the Event Handlers have __stdcall calling convention
   SINK_ENTRY_EX(IDC_CALENDAR1, __uuidof(DCalendarEvents), DISPID_CLICK, 
      &CMyCompositCtrl2::ClickCalendar1)
   SINK_ENTRY_EX(IDC_CALENDAR2, __uuidof(DCalendarEvents), DISPID_CLICK, 
      &CMyCompositCtrl2::ClickCalendar2)
END_SINK_MAP()
```

    + advising and unadvising the IDisEventImpl interfaces 

A connection is established and a reference to the outgoing interface is used to handle events from the object. This procedure is referred to as "advising."

the outgoing interfaces should be notified that they are no longer used by your class. This process is referred to as "unadvising."

the implementation detail is not unique in each COM object 

- changing the default 

ATL uses CComCoClass to define the default class factory and aggregation model

DECLARE_CLASSFACTORY Declares the class factory to be CComClassFactory.

DECLARE_AGGREGATABLE Declares that your object can be aggregated.

use CComClassFactory2 instead of CComClassFactory, specify the DECLARE_CLASSFACTORY2 

```
class ATL_NO_VTABLE CMyClass2 :
   public CComObjectRootEx<CComSingleThreadModel>,
   public CComCoClass<CMyClass2, &CLSID_MyClass>,
   public IDispatchImpl<IMyClass, &IID_IMyClass, &LIBID_NVC_ATL_COMLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
   public IDispatchImpl<IMyDualInterface, &__uuidof(IMyDualInterface), &LIBID_NVC_ATL_COMLib, /* wMajor = */ 1, /* wMinor = */ 0>
{
public:
   DECLARE_CLASSFACTORY2(CMyLicense)

   // Remainder of class declaration omitted
```

define a class factory are DECLARE_CLASSFACTORY_AUTO_THREAD and DECLARE_CLASSFACTORY_SINGLETON.

DECLARE_AGGREGATABLE macro uses typedef to define a type called _CreatorClass, which is then referenced throughout ATL.

redeclare same typedef will in derive class will make ALT use the override version 

- creating an aggregated object 

Add an IUnknown pointer to your class object and initialize it to NULL

Override FinalConstruct to create the aggregate.

Use the IUnknown pointer, defined in Step 1, as the second parameter for the COM_INTERFACE_ENTRY_AGGREGATE macros.

Override FinalRelease to release the IUnknown pointer.

- Dual interfaces and ATL 

A dual interface allows its methods to be accessed as dispinterface methods or as vtable methods.

implement a dual interface using the IDispatchImpl class, which provides a default implementation of the IDispatch methods 

    + Define your dual interface in a type library.
    
    + Derive your class from a specialization of IDispatchImpl

    + Add an entry (or entries) to the COM map to expose the dual interface through QueryInterface.
    
    + Implement the vtable part of the interface in your class.

    + Ensure that the type library containing the interface definition is available to your objects at run time.
    
using ATL simple object wizard 

    + create a new interface and a new class to implement it, you can use the ATL Add Class dialog box, and then the ATL Simple Object Wizard
    
    + use the Implement Interface Wizard to add the necessary base class, COM map entries, and skeleton method implementations

    The Implement Interface Wizard doesn't check the type library version number for you.
    
implementing IDispatch, IDispatchImpl base class to provide an implementation of a dispinterface just by specifying the appropriate entry in the COM map. using the COM_INTERFACE_ENTRY2 or COM_INTERFACE_ENTRY_IID macro

ATL offers the IDispEventImpl and IDispEventSimpleImpl classes to help you implement dispinterfaces without requiring a type library

- Multiple dual interfaces 










